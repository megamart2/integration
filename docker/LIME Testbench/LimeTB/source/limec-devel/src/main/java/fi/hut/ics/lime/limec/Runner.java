package fi.hut.ics.lime.limec;

import java.io.File;
import java.io.IOException;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import fi.hut.ics.lime.common.utils.FileUtils;
import fi.hut.ics.lime.common.utils.Debug;

import fi.hut.ics.lime.limec.sourceprocessor.DoxygenParser;
import fi.hut.ics.lime.limec.sourceprocessor.DoxygenLexer;

import fi.hut.ics.lime.limec.DoxygenRunner;

import fi.hut.ics.lime.common.aspect.Aspect;
import fi.hut.ics.lime.common.aspect.AspectWriter;
import fi.hut.ics.lime.common.sourcecode.Method;
import fi.hut.ics.lime.common.sourcecode.Source;
import fi.hut.ics.lime.common.specification.Specification;
import fi.hut.ics.lime.common.specification.SpecificationException;
import fi.hut.ics.lime.common.specification.SpecificationFactory;
import fi.hut.ics.lime.limec.aspect.ACCAspectFactory;
import fi.hut.ics.lime.limec.ast.Annotation;
import fi.hut.ics.lime.limec.ast.AnnotationType;
import fi.hut.ics.lime.limec.ast.AnnotationField;

import fi.hut.ics.lime.limec.sourcecode.CMethod;
import fi.hut.ics.lime.limec.sourcecode.CSource;
import fi.hut.ics.lime.limec.staticaccessor.StaticAccessor;
import fi.hut.ics.lime.limec.xmlreaders.XMLMainReader;
import fi.hut.ics.lime.limec.xmlreaders.XMLSourceReader;

public class Runner {
	
	// this doesn't make any sense at all. should either make the "singletons"
	// in common either proper singletons or remove the behavior altogether 
	// to make the program more modular
	
	// name of the file generated by doxygen, shouldn't maybe be hardcoded here
	private static final String XMLFILENAME = "docs"+
		File.separator+"xml"+File.separator+"index.xml";
	
	private SpecificationFactory specificationFactory;
	private ACCAspectFactory aspectFactory;
	private File sourcedir;
	private File tmpdir;
	
	public Runner(File sourcedir, File tmpdir) {
		this.specificationFactory = SpecificationFactory.instance();
		this.aspectFactory = ACCAspectFactory.getInstance();
		this.sourcedir = sourcedir;
		this.tmpdir = tmpdir;
	}
	
	public void run() throws Exception {
		
		// doing this properly this time:
		
		// copy the sources to the tmp directory
		
		if (this.tmpdir.exists() && this.tmpdir.isDirectory()) {
			Debug.println("tmp dir '"+this.tmpdir.getAbsolutePath()+"' already exists, emptying it");
			FileUtils.deleteDirectory(this.tmpdir);
		}
		
		Debug.println("copying sources from '"+this.sourcedir.getAbsolutePath()+
				"' to '"+this.tmpdir.getAbsolutePath()+"'...");
		
		FileUtils.copyByExtension(this.sourcedir, this.tmpdir, "c");
		FileUtils.copyByExtension(this.sourcedir, this.tmpdir, "h");
		
		// strip doxygen comments (just in case there are any originally)
		
		Debug.println("removing original doxygen comments...");
		
		// only parse the files in the root directory
		// TODO: if required, change this behavior here
		
		for (File file : this.tmpdir.listFiles())
			if (!file.isDirectory() && 
					(file.getName().endsWith(".c") || file.getName().endsWith(".h")))
				stripDoxygenComments(file);
		
		// run doxygen to parse the sources
		
		Debug.println("running doxygen...");
		
		DoxygenRunner.getInstance().run(this.tmpdir);
		
		// find the main XML file inside the directory
		
		File mainXML = new File(this.tmpdir.getAbsolutePath() +
				File.separator + XMLFILENAME);
		
		if (!mainXML.exists()) {
			throw new IOException("ERROR: main XML file '" +
								  mainXML.getAbsolutePath() +
								  "' not found");
		}
		
		// deal with the specifications and create aspects
		
		// ...continue later
		
		XMLMainReader reader = new XMLMainReader(mainXML);
		
		ArrayList<File> xmlFilesToRead = reader.getXMLFilesToRead(); 
		
		// Parse the XML files that represents the C source files. The ISL 
		// embedded in the XML is further parsed by the 
		// fi.hut.ics.lime.limec.islparser during the same process.
		for (File xmlFileToRead : xmlFilesToRead) {
		
			CSource cSource = null;
			
			XMLSourceReader sourceReader = new XMLSourceReader(xmlFileToRead);

			cSource = sourceReader.getParsedSource();
			
			// Did we correctly read all functions and variables from xmlFileToRead? 
			//System.out.println("PARSING INFO");
			//DebugPrinter.printXMLParsingDebugInfo(cSource);
				
			// This can be used to check that the parsing of the ISL went OK
			//System.out.println("CHECKER INFO");
			//DebugPrinter.printAllCheckerDebugInfo(cSource);
		
			PropositionGenerator.createAllPropositions(cSource);
			SpecificationGenerator.createAllSpecifications(cSource);
		
			// Check for Observes and if found, link them to correct
		   	// interface/library specifications
			associateObserves(cSource, specificationFactory);
		
			// This can be used to check that the creation of specifications and
			// the association of Observes with the specifications went OK
			//System.out.println("SPEC INFO");
			//DebugPrinter.printSpecificationDebugInfo(specificationFactory, cSource);
			
			StaticAccessor.addOriginalSourceAccessors(cSource, tmpdir);
			this.createAspects();
			this.writeAspectsToDisk(tmpdir);
					
		}
		
		// clean up
		
		Debug.println("cleaning up...");
		
		
	}
	
	private static void stripDoxygenComments(File file) throws Exception {
		Debug.println("  stripping comments in '"+file.getName()+"'...");
		// TODO: learn how to actually use these parsers
		DoxygenParser parser = new DoxygenParser(
				new DoxygenLexer(new StringReader(FileUtils.readFile(file))));
		StringBuilder result = (StringBuilder)parser.parse().value;
		FileUtils.writeFile(file, result.toString());
	}
	
	/**
	 * Observes may be used to specify that a certain function is
	 * associated with a CallSpecification or a ReturnSpecification. This method
	 * goes through all functions of the C source file sourceFile and checks
	 * if they have Observes associated with them.
	 * 
	 * If they do, it finds the correct CallSpecification/ReturnSpecification and
	 * associates the function with it. Observes may also be used
	 * to set the exception that is thrown when the specification is broken;
	 * this method is supposed to handle that as well.
	 * 
	 * @param sourceFile the C source file to grab functions from and determine
	 * 		  if they are associated with Observes
	 * @param specificationFactory the specification factory
	 */
	public void associateObserves(CSource sourceFile, SpecificationFactory specificationFactory) {
		
		for (Method meth : sourceFile.getAllMethods()) {
			
			// Need to explicitly cast to use getAssociatedCheckers
			CMethod func = (CMethod)meth;
			
			for (Annotation annotation : func.getAssociatedAnnotations()) {
				
				if (annotation.getType() != AnnotationType.OBSERVE) {
					continue; // We are only interested in Observes
				}
					
				for (AnnotationField field : annotation.getAnnotationFields()) {
					
					try {
						
						// This function is associated with an Observe. Now,
						// find the checker this Observe 'points to' and
						// add this function to the list of functions observed by
						// that checker.
						
						for (String fieldContent : field.getFieldContents()) {
							
							// A Observe may associate the function with multiple
							// checkers, so we need to iterate through the Observe contents
							
							Specification spec = specificationFactory.getSpecification(sourceFile, 
												fieldContent);
							spec.addEnforcedMethod(func);
						
						}
						
					} catch (SpecificationException spe) {
						System.out.println(spe.getMessage());
					}
					
				}

			}
			
		}
		
	}
	
	private void createAspects() {
		
		// Put all specs into a common map
		HashMap<Source, Map<String,? extends Specification>> allSpecs =
			new HashMap<Source, Map<String,? extends Specification>>();
		allSpecs.putAll(this.specificationFactory.getRegExpSpecifications());
		allSpecs.putAll(this.specificationFactory.getPltlSpecifications());
		allSpecs.putAll(this.specificationFactory.getNfaSpecifications());

		// Check that all specifications are associated to at least something.
		// Create aspects from the specifications.
		for(Source sourceType : allSpecs.keySet()) {
			for (String name : allSpecs.get(sourceType).keySet()) {
				Specification specification = allSpecs.get(sourceType).get(name);
				if(specification.getEnforcedMethods().size() == 0) {
					System.err.println("WARNING: " + specification.toString() + 
										"never gets triggered.");
				}
				else {
					try {
						this.aspectFactory.createAspect(specification);
					} catch (Exception e) { //AspectException
						System.err.println("ERROR: Failed to create aspect from " +
								           specification.toString() + ".");
						System.err.println(e);
					}
				}
			}
		}
		
	}
	
	private void writeAspectsToDisk(File targetDir) {
		
		// Just print out a note that we're writing to the disk and not hung
		Debug.println("writing aspects to disk...");
		
		// Should now have AspeCt-oriented C aspects, let's write them to the disk.
		// We write to the same directory we read the aspect from.
		try {
			for (Aspect a : aspectFactory.getAllAspects()) {
				String filename = targetDir.getCanonicalPath() + File.separator + 
					a.getName() + "." + "acc";
				FileUtils.writeFile(new File(filename), a.toString());
			}
		} catch (IOException e) {
			System.err.println("ERROR: Failed to write aspect(s) to disk.");
			System.err.println(e);
		}
	
		Debug.println("done writing aspects to disk");
		
	}
	
}
