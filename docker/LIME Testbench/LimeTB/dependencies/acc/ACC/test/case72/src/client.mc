# 1 "client.c"
# 1 "/home/czhang/Desktop/ORBit2-2.14.3/test/everything//"
# 1 "<built-in>"
# 1 "<command line>"
# 1 "client.c"
# 21 "client.c"
# 1 "/usr/include/glib-2.0/glib.h" 1
# 30 "/usr/include/glib-2.0/glib.h"
# 1 "/usr/include/glib-2.0/glib/galloca.h" 1
# 30 "/usr/include/glib-2.0/glib/galloca.h"
# 1 "/usr/include/glib-2.0/glib/gtypes.h" 1
# 30 "/usr/include/glib-2.0/glib/gtypes.h"
# 1 "/usr/lib/glib-2.0/include/glibconfig.h" 1
# 9 "/usr/lib/glib-2.0/include/glibconfig.h"
# 1 "/usr/include/glib-2.0/glib/gmacros.h" 1
# 36 "/usr/include/glib-2.0/glib/gmacros.h"
# 1 "/usr/lib/gcc/i386-redhat-linux/4.1.0/include/stddef.h" 1 3 4
# 152 "/usr/lib/gcc/i386-redhat-linux/4.1.0/include/stddef.h" 3 4
typedef int ptrdiff_t;
# 214 "/usr/lib/gcc/i386-redhat-linux/4.1.0/include/stddef.h" 3 4
typedef unsigned int size_t;
# 326 "/usr/lib/gcc/i386-redhat-linux/4.1.0/include/stddef.h" 3 4
typedef long int wchar_t;
# 37 "/usr/include/glib-2.0/glib/gmacros.h" 2
# 10 "/usr/lib/glib-2.0/include/glibconfig.h" 2

# 1 "/usr/lib/gcc/i386-redhat-linux/4.1.0/include/limits.h" 1 3 4
# 11 "/usr/lib/gcc/i386-redhat-linux/4.1.0/include/limits.h" 3 4
# 1 "/usr/lib/gcc/i386-redhat-linux/4.1.0/include/syslimits.h" 1 3 4






# 1 "/usr/lib/gcc/i386-redhat-linux/4.1.0/include/limits.h" 1 3 4
# 122 "/usr/lib/gcc/i386-redhat-linux/4.1.0/include/limits.h" 3 4
# 1 "/usr/include/limits.h" 1 3 4
# 27 "/usr/include/limits.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 329 "/usr/include/features.h" 3 4
# 1 "/usr/include/sys/cdefs.h" 1 3 4
# 313 "/usr/include/sys/cdefs.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 314 "/usr/include/sys/cdefs.h" 2 3 4
# 330 "/usr/include/features.h" 2 3 4
# 352 "/usr/include/features.h" 3 4
# 1 "/usr/include/gnu/stubs.h" 1 3 4



# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 5 "/usr/include/gnu/stubs.h" 2 3 4


# 1 "/usr/include/gnu/stubs-32.h" 1 3 4
# 8 "/usr/include/gnu/stubs.h" 2 3 4
# 353 "/usr/include/features.h" 2 3 4
# 28 "/usr/include/limits.h" 2 3 4
# 145 "/usr/include/limits.h" 3 4
# 1 "/usr/include/bits/posix1_lim.h" 1 3 4
# 153 "/usr/include/bits/posix1_lim.h" 3 4
# 1 "/usr/include/bits/local_lim.h" 1 3 4
# 36 "/usr/include/bits/local_lim.h" 3 4
# 1 "/usr/include/linux/limits.h" 1 3 4
# 37 "/usr/include/bits/local_lim.h" 2 3 4
# 154 "/usr/include/bits/posix1_lim.h" 2 3 4
# 146 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/bits/posix2_lim.h" 1 3 4
# 150 "/usr/include/limits.h" 2 3 4
# 123 "/usr/lib/gcc/i386-redhat-linux/4.1.0/include/limits.h" 2 3 4
# 8 "/usr/lib/gcc/i386-redhat-linux/4.1.0/include/syslimits.h" 2 3 4
# 12 "/usr/lib/gcc/i386-redhat-linux/4.1.0/include/limits.h" 2 3 4
# 12 "/usr/lib/glib-2.0/include/glibconfig.h" 2
# 1 "/usr/lib/gcc/i386-redhat-linux/4.1.0/include/float.h" 1 3 4
# 13 "/usr/lib/glib-2.0/include/glibconfig.h" 2




# 32 "/usr/lib/glib-2.0/include/glibconfig.h"
typedef signed char gint8;
typedef unsigned char guint8;
typedef signed short gint16;
typedef unsigned short guint16;



typedef signed int gint32;
typedef unsigned int guint32;





__extension__ typedef signed long long gint64;
__extension__ typedef unsigned long long guint64;
# 59 "/usr/lib/glib-2.0/include/glibconfig.h"
typedef signed int gssize;
typedef unsigned int gsize;
# 126 "/usr/lib/glib-2.0/include/glibconfig.h"
typedef struct _GStaticMutex GStaticMutex;
struct _GStaticMutex
{
  struct _GMutex *runtime_mutex;
  union {
    char pad[24];
    double dummy_double;
    void *dummy_pointer;
    long dummy_long;
  } static_mutex;
};
# 145 "/usr/lib/glib-2.0/include/glibconfig.h"
typedef union _GSystemThread GSystemThread;
union _GSystemThread
{
  char data[4];
  double dummy_double;
  void *dummy_pointer;
  long dummy_long;
};
# 185 "/usr/lib/glib-2.0/include/glibconfig.h"
typedef int GPid;


# 31 "/usr/include/glib-2.0/glib/gtypes.h" 2


# 41 "/usr/include/glib-2.0/glib/gtypes.h"
typedef char gchar;
typedef short gshort;
typedef long glong;
typedef int gint;
typedef gint gboolean;

typedef unsigned char guchar;
typedef unsigned short gushort;
typedef unsigned long gulong;
typedef unsigned int guint;

typedef float gfloat;
typedef double gdouble;
# 72 "/usr/include/glib-2.0/glib/gtypes.h"
typedef void* gpointer;
typedef const void *gconstpointer;

typedef gint (*GCompareFunc) (gconstpointer a,
                                                 gconstpointer b);
typedef gint (*GCompareDataFunc) (gconstpointer a,
                                                 gconstpointer b,
       gpointer user_data);
typedef gboolean (*GEqualFunc) (gconstpointer a,
                                                 gconstpointer b);
typedef void (*GDestroyNotify) (gpointer data);
typedef void (*GFunc) (gpointer data,
                                                 gpointer user_data);
typedef guint (*GHashFunc) (gconstpointer key);
typedef void (*GHFunc) (gpointer key,
                                                 gpointer value,
                                                 gpointer user_data);
typedef void (*GFreeFunc) (gpointer data);
typedef const gchar * (*GTranslateFunc) (const gchar *str,
       gpointer data);
# 338 "/usr/include/glib-2.0/glib/gtypes.h"
typedef union _GDoubleIEEE754 GDoubleIEEE754;
typedef union _GFloatIEEE754 GFloatIEEE754;





union _GFloatIEEE754
{
  gfloat v_float;
  struct {
    guint mantissa : 23;
    guint biased_exponent : 8;
    guint sign : 1;
  } mpn;
};
union _GDoubleIEEE754
{
  gdouble v_double;
  struct {
    guint mantissa_low : 32;
    guint mantissa_high : 20;
    guint biased_exponent : 11;
    guint sign : 1;
  } mpn;
};
# 388 "/usr/include/glib-2.0/glib/gtypes.h"
typedef struct _GTimeVal GTimeVal;

struct _GTimeVal
{
  glong tv_sec;
  glong tv_usec;
};


# 31 "/usr/include/glib-2.0/glib/galloca.h" 2
# 31 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/garray.h" 1
# 32 "/usr/include/glib-2.0/glib/garray.h"


typedef struct _GArray GArray;
typedef struct _GByteArray GByteArray;
typedef struct _GPtrArray GPtrArray;

struct _GArray
{
  gchar *data;
  guint len;
};

struct _GByteArray
{
  guint8 *data;
  guint len;
};

struct _GPtrArray
{
  gpointer *pdata;
  guint len;
};
# 66 "/usr/include/glib-2.0/glib/garray.h"
GArray* g_array_new (gboolean zero_terminated,
       gboolean clear_,
       guint element_size);
GArray* g_array_sized_new (gboolean zero_terminated,
       gboolean clear_,
       guint element_size,
       guint reserved_size);
gchar* g_array_free (GArray *array,
       gboolean free_segment);
GArray* g_array_append_vals (GArray *array,
       gconstpointer data,
       guint len);
GArray* g_array_prepend_vals (GArray *array,
       gconstpointer data,
       guint len);
GArray* g_array_insert_vals (GArray *array,
       guint index_,
       gconstpointer data,
       guint len);
GArray* g_array_set_size (GArray *array,
       guint length);
GArray* g_array_remove_index (GArray *array,
       guint index_);
GArray* g_array_remove_index_fast (GArray *array,
       guint index_);
GArray* g_array_remove_range (GArray *array,
       guint index_,
       guint length);
void g_array_sort (GArray *array,
       GCompareFunc compare_func);
void g_array_sort_with_data (GArray *array,
       GCompareDataFunc compare_func,
       gpointer user_data);






GPtrArray* g_ptr_array_new (void);
GPtrArray* g_ptr_array_sized_new (guint reserved_size);
gpointer* g_ptr_array_free (GPtrArray *array,
        gboolean free_seg);
void g_ptr_array_set_size (GPtrArray *array,
        gint length);
gpointer g_ptr_array_remove_index (GPtrArray *array,
        guint index_);
gpointer g_ptr_array_remove_index_fast (GPtrArray *array,
        guint index_);
gboolean g_ptr_array_remove (GPtrArray *array,
        gpointer data);
gboolean g_ptr_array_remove_fast (GPtrArray *array,
        gpointer data);
void g_ptr_array_remove_range (GPtrArray *array,
        guint index_,
        guint length);
void g_ptr_array_add (GPtrArray *array,
        gpointer data);
void g_ptr_array_sort (GPtrArray *array,
        GCompareFunc compare_func);
void g_ptr_array_sort_with_data (GPtrArray *array,
        GCompareDataFunc compare_func,
        gpointer user_data);
void g_ptr_array_foreach (GPtrArray *array,
        GFunc func,
        gpointer user_data);






GByteArray* g_byte_array_new (void);
GByteArray* g_byte_array_sized_new (guint reserved_size);
guint8* g_byte_array_free (GByteArray *array,
         gboolean free_segment);
GByteArray* g_byte_array_append (GByteArray *array,
         const guint8 *data,
         guint len);
GByteArray* g_byte_array_prepend (GByteArray *array,
         const guint8 *data,
         guint len);
GByteArray* g_byte_array_set_size (GByteArray *array,
         guint length);
GByteArray* g_byte_array_remove_index (GByteArray *array,
         guint index_);
GByteArray* g_byte_array_remove_index_fast (GByteArray *array,
         guint index_);
GByteArray* g_byte_array_remove_range (GByteArray *array,
         guint index_,
         guint length);
void g_byte_array_sort (GByteArray *array,
         GCompareFunc compare_func);
void g_byte_array_sort_with_data (GByteArray *array,
         GCompareDataFunc compare_func,
         gpointer user_data);



# 32 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/gasyncqueue.h" 1
# 30 "/usr/include/glib-2.0/glib/gasyncqueue.h"
# 1 "/usr/include/glib-2.0/glib/gthread.h" 1
# 30 "/usr/include/glib-2.0/glib/gthread.h"
# 1 "/usr/include/glib-2.0/glib/gerror.h" 1
# 24 "/usr/include/glib-2.0/glib/gerror.h"
# 1 "/usr/include/glib-2.0/glib/gquark.h" 1
# 32 "/usr/include/glib-2.0/glib/gquark.h"


typedef guint32 GQuark;



GQuark g_quark_try_string (const gchar *string);
GQuark g_quark_from_static_string (const gchar *string);
GQuark g_quark_from_string (const gchar *string);
const gchar* g_quark_to_string (GQuark quark) __attribute__((__const__));

const gchar* g_intern_string (const gchar *string);
const gchar* g_intern_static_string (const gchar *string);



# 25 "/usr/include/glib-2.0/glib/gerror.h" 2



typedef struct _GError GError;

struct _GError
{
  GQuark domain;
  gint code;
  gchar *message;
};

GError* g_error_new (GQuark domain,
                                gint code,
                                const gchar *format,
                                ...) __attribute__((__format__ (__printf__, 3, 4)));

GError* g_error_new_literal (GQuark domain,
                                gint code,
                                const gchar *message);

void g_error_free (GError *error);
GError* g_error_copy (const GError *error);

gboolean g_error_matches (const GError *error,
                                GQuark domain,
                                gint code);




void g_set_error (GError **err,
                                GQuark domain,
                                gint code,
                                const gchar *format,
                                ...) __attribute__((__format__ (__printf__, 4, 5)));



void g_propagate_error (GError **dest,
    GError *src);


void g_clear_error (GError **err);



# 31 "/usr/include/glib-2.0/glib/gthread.h" 2

# 1 "/usr/include/glib-2.0/glib/gatomic.h" 1
# 35 "/usr/include/glib-2.0/glib/gatomic.h"


gint g_atomic_int_exchange_and_add (volatile gint *atomic,
      gint val);
void g_atomic_int_add (volatile gint *atomic,
      gint val);
gboolean g_atomic_int_compare_and_exchange (volatile gint *atomic,
      gint oldval,
      gint newval);
gboolean g_atomic_pointer_compare_and_exchange (volatile gpointer *atomic,
      gpointer oldval,
      gpointer newval);

gint g_atomic_int_get (volatile gint *atomic);
void g_atomic_int_set (volatile gint *atomic,
      gint newval);
gpointer g_atomic_pointer_get (volatile gpointer *atomic);
void g_atomic_pointer_set (volatile gpointer *atomic,
      gpointer newval);
# 66 "/usr/include/glib-2.0/glib/gatomic.h"

# 33 "/usr/include/glib-2.0/glib/gthread.h" 2






extern GQuark g_thread_error_quark (void);


typedef enum
{
  G_THREAD_ERROR_AGAIN
} GThreadError;

typedef gpointer (*GThreadFunc) (gpointer data);

typedef enum
{
  G_THREAD_PRIORITY_LOW,
  G_THREAD_PRIORITY_NORMAL,
  G_THREAD_PRIORITY_HIGH,
  G_THREAD_PRIORITY_URGENT
} GThreadPriority;

typedef struct _GThread GThread;
struct _GThread
{

  GThreadFunc func;
  gpointer data;
  gboolean joinable;
  GThreadPriority priority;
};

typedef struct _GMutex GMutex;
typedef struct _GCond GCond;
typedef struct _GPrivate GPrivate;
typedef struct _GStaticPrivate GStaticPrivate;

typedef struct _GThreadFunctions GThreadFunctions;
struct _GThreadFunctions
{
  GMutex* (*mutex_new) (void);
  void (*mutex_lock) (GMutex *mutex);
  gboolean (*mutex_trylock) (GMutex *mutex);
  void (*mutex_unlock) (GMutex *mutex);
  void (*mutex_free) (GMutex *mutex);
  GCond* (*cond_new) (void);
  void (*cond_signal) (GCond *cond);
  void (*cond_broadcast) (GCond *cond);
  void (*cond_wait) (GCond *cond,
                                   GMutex *mutex);
  gboolean (*cond_timed_wait) (GCond *cond,
                                   GMutex *mutex,
                                   GTimeVal *end_time);
  void (*cond_free) (GCond *cond);
  GPrivate* (*private_new) (GDestroyNotify destructor);
  gpointer (*private_get) (GPrivate *private_key);
  void (*private_set) (GPrivate *private_key,
                                   gpointer data);
  void (*thread_create) (GThreadFunc func,
                                   gpointer data,
                                   gulong stack_size,
                                   gboolean joinable,
                                   gboolean bound,
                                   GThreadPriority priority,
                                   gpointer thread,
                                   GError **error);
  void (*thread_yield) (void);
  void (*thread_join) (gpointer thread);
  void (*thread_exit) (void);
  void (*thread_set_priority)(gpointer thread,
                                   GThreadPriority priority);
  void (*thread_self) (gpointer thread);
  gboolean (*thread_equal) (gpointer thread1,
       gpointer thread2);
};

extern GThreadFunctions g_thread_functions_for_glib_use;
extern gboolean g_thread_use_default_impl;
extern gboolean g_threads_got_initialized;





void g_thread_init (GThreadFunctions *vtable);
# 128 "/usr/include/glib-2.0/glib/gthread.h"
void g_thread_init_with_errorcheck_mutexes (GThreadFunctions* vtable);
# 138 "/usr/include/glib-2.0/glib/gthread.h"
GMutex* g_static_mutex_get_mutex_impl (GMutex **mutex);
# 208 "/usr/include/glib-2.0/glib/gthread.h"
GThread* g_thread_create_full (GThreadFunc func,
                                gpointer data,
                                gulong stack_size,
                                gboolean joinable,
                                gboolean bound,
                                GThreadPriority priority,
                                GError **error);
GThread* g_thread_self (void);
void g_thread_exit (gpointer retval);
gpointer g_thread_join (GThread *thread);

void g_thread_set_priority (GThread *thread,
                                GThreadPriority priority);
# 233 "/usr/include/glib-2.0/glib/gthread.h"
void g_static_mutex_init (GStaticMutex *mutex);
void g_static_mutex_free (GStaticMutex *mutex);

struct _GStaticPrivate
{

  guint index;
};

void g_static_private_init (GStaticPrivate *private_key);
gpointer g_static_private_get (GStaticPrivate *private_key);
void g_static_private_set (GStaticPrivate *private_key,
       gpointer data,
       GDestroyNotify notify);
void g_static_private_free (GStaticPrivate *private_key);

typedef struct _GStaticRecMutex GStaticRecMutex;
struct _GStaticRecMutex
{

  GStaticMutex mutex;
  guint depth;
  GSystemThread owner;
};


void g_static_rec_mutex_init (GStaticRecMutex *mutex);
void g_static_rec_mutex_lock (GStaticRecMutex *mutex);
gboolean g_static_rec_mutex_trylock (GStaticRecMutex *mutex);
void g_static_rec_mutex_unlock (GStaticRecMutex *mutex);
void g_static_rec_mutex_lock_full (GStaticRecMutex *mutex,
                                         guint depth);
guint g_static_rec_mutex_unlock_full (GStaticRecMutex *mutex);
void g_static_rec_mutex_free (GStaticRecMutex *mutex);

typedef struct _GStaticRWLock GStaticRWLock;
struct _GStaticRWLock
{

  GStaticMutex mutex;
  GCond *read_cond;
  GCond *write_cond;
  guint read_counter;
  gboolean have_writer;
  guint want_to_read;
  guint want_to_write;
};



void g_static_rw_lock_init (GStaticRWLock* lock);
void g_static_rw_lock_reader_lock (GStaticRWLock* lock);
gboolean g_static_rw_lock_reader_trylock (GStaticRWLock* lock);
void g_static_rw_lock_reader_unlock (GStaticRWLock* lock);
void g_static_rw_lock_writer_lock (GStaticRWLock* lock);
gboolean g_static_rw_lock_writer_trylock (GStaticRWLock* lock);
void g_static_rw_lock_writer_unlock (GStaticRWLock* lock);
void g_static_rw_lock_free (GStaticRWLock* lock);

void g_thread_foreach (GFunc thread_func,
        gpointer user_data);

typedef enum
{
  G_ONCE_STATUS_NOTCALLED,
  G_ONCE_STATUS_PROGRESS,
  G_ONCE_STATUS_READY
} GOnceStatus;

typedef struct _GOnce GOnce;
struct _GOnce
{
  volatile GOnceStatus status;
  volatile gpointer retval;
};



gpointer g_once_impl (GOnce *once, GThreadFunc func, gpointer arg);
# 331 "/usr/include/glib-2.0/glib/gthread.h"
extern void glib_dummy_decl (void);
# 374 "/usr/include/glib-2.0/glib/gthread.h"

# 31 "/usr/include/glib-2.0/glib/gasyncqueue.h" 2



typedef struct _GAsyncQueue GAsyncQueue;





GAsyncQueue* g_async_queue_new (void);





void g_async_queue_lock (GAsyncQueue *queue);
void g_async_queue_unlock (GAsyncQueue *queue);




GAsyncQueue* g_async_queue_ref (GAsyncQueue *queue);
void g_async_queue_unref (GAsyncQueue *queue);




void g_async_queue_ref_unlocked (GAsyncQueue *queue);
void g_async_queue_unref_and_unlock (GAsyncQueue *queue);





void g_async_queue_push (GAsyncQueue *queue,
       gpointer data);
void g_async_queue_push_unlocked (GAsyncQueue *queue,
       gpointer data);

void g_async_queue_push_sorted (GAsyncQueue *queue,
       gpointer data,
       GCompareDataFunc func,
       gpointer user_data);
void g_async_queue_push_sorted_unlocked (GAsyncQueue *queue,
       gpointer data,
       GCompareDataFunc func,
       gpointer user_data);



gpointer g_async_queue_pop (GAsyncQueue *queue);
gpointer g_async_queue_pop_unlocked (GAsyncQueue *queue);




gpointer g_async_queue_try_pop (GAsyncQueue *queue);
gpointer g_async_queue_try_pop_unlocked (GAsyncQueue *queue);





gpointer g_async_queue_timed_pop (GAsyncQueue *queue,
       GTimeVal *end_time);
gpointer g_async_queue_timed_pop_unlocked (GAsyncQueue *queue,
       GTimeVal *end_time);
# 107 "/usr/include/glib-2.0/glib/gasyncqueue.h"
gint g_async_queue_length (GAsyncQueue *queue);
gint g_async_queue_length_unlocked (GAsyncQueue *queue);
void g_async_queue_sort (GAsyncQueue *queue,
       GCompareDataFunc func,
       gpointer user_data);
void g_async_queue_sort_unlocked (GAsyncQueue *queue,
       GCompareDataFunc func,
       gpointer user_data);



# 33 "/usr/include/glib-2.0/glib.h" 2

# 1 "/usr/include/glib-2.0/glib/gbacktrace.h" 1
# 32 "/usr/include/glib-2.0/glib/gbacktrace.h"

# 43 "/usr/include/glib-2.0/glib/gbacktrace.h"
void g_on_error_query (const gchar *prg_name);
void g_on_error_stack_trace (const gchar *prg_name);
# 59 "/usr/include/glib-2.0/glib/gbacktrace.h"

# 35 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/gcache.h" 1
# 30 "/usr/include/glib-2.0/glib/gcache.h"
# 1 "/usr/include/glib-2.0/glib/glist.h" 1
# 30 "/usr/include/glib-2.0/glib/glist.h"
# 1 "/usr/include/glib-2.0/glib/gmem.h" 1
# 30 "/usr/include/glib-2.0/glib/gmem.h"
# 1 "/usr/include/glib-2.0/glib/gslice.h" 1
# 28 "/usr/include/glib-2.0/glib/gslice.h"




gpointer g_slice_alloc (gsize block_size) __attribute__((__malloc__));
gpointer g_slice_alloc0 (gsize block_size) __attribute__((__malloc__));
void g_slice_free1 (gsize block_size,
      gpointer mem_block);
void g_slice_free_chain_with_offset (gsize block_size,
      gpointer mem_chain,
      gsize next_offset);
# 63 "/usr/include/glib-2.0/glib/gslice.h"
typedef enum {
  G_SLICE_CONFIG_ALWAYS_MALLOC = 1,
  G_SLICE_CONFIG_BYPASS_MAGAZINES,
  G_SLICE_CONFIG_WORKING_SET_MSECS,
  G_SLICE_CONFIG_COLOR_INCREMENT,
  G_SLICE_CONFIG_CHUNK_SIZES,
  G_SLICE_CONFIG_CONTENTION_COUNTER
} GSliceConfig;
void g_slice_set_config (GSliceConfig ckey, gint64 value);
gint64 g_slice_get_config (GSliceConfig ckey);
gint64* g_slice_get_config_state (GSliceConfig ckey, gint64 address, guint *n_values);


# 31 "/usr/include/glib-2.0/glib/gmem.h" 2




typedef struct _GMemVTable GMemVTable;
# 47 "/usr/include/glib-2.0/glib/gmem.h"
gpointer g_malloc (gulong n_bytes) __attribute__((__malloc__));
gpointer g_malloc0 (gulong n_bytes) __attribute__((__malloc__));
gpointer g_realloc (gpointer mem,
      gulong n_bytes) __attribute__((warn_unused_result));
void g_free (gpointer mem);
gpointer g_try_malloc (gulong n_bytes) __attribute__((__malloc__));
gpointer g_try_malloc0 (gulong n_bytes) __attribute__((__malloc__));
gpointer g_try_realloc (gpointer mem,
      gulong n_bytes) __attribute__((warn_unused_result));
# 79 "/usr/include/glib-2.0/glib/gmem.h"
struct _GMemVTable
{
  gpointer (*malloc) (gsize n_bytes);
  gpointer (*realloc) (gpointer mem,
      gsize n_bytes);
  void (*free) (gpointer mem);

  gpointer (*calloc) (gsize n_blocks,
      gsize n_block_bytes);
  gpointer (*try_malloc) (gsize n_bytes);
  gpointer (*try_realloc) (gpointer mem,
      gsize n_bytes);
};
void g_mem_set_vtable (GMemVTable *vtable);
gboolean g_mem_is_system_malloc (void);

extern gboolean g_mem_gc_friendly;



extern GMemVTable *glib_mem_profiler_table;
void g_mem_profile (void);




typedef struct _GAllocator GAllocator;
typedef struct _GMemChunk GMemChunk;
# 124 "/usr/include/glib-2.0/glib/gmem.h"
GMemChunk* g_mem_chunk_new (const gchar *name,
    gint atom_size,
    gulong area_size,
    gint type);
void g_mem_chunk_destroy (GMemChunk *mem_chunk);
gpointer g_mem_chunk_alloc (GMemChunk *mem_chunk);
gpointer g_mem_chunk_alloc0 (GMemChunk *mem_chunk);
void g_mem_chunk_free (GMemChunk *mem_chunk,
    gpointer mem);
void g_mem_chunk_clean (GMemChunk *mem_chunk);
void g_mem_chunk_reset (GMemChunk *mem_chunk);
void g_mem_chunk_print (GMemChunk *mem_chunk);
void g_mem_chunk_info (void);
void g_blow_chunks (void);
GAllocator*g_allocator_new (const gchar *name,
    guint n_preallocs);
void g_allocator_free (GAllocator *allocator);






# 31 "/usr/include/glib-2.0/glib/glist.h" 2



typedef struct _GList GList;

struct _GList
{
  gpointer data;
  GList *next;
  GList *prev;
};



GList* g_list_alloc (void) __attribute__((warn_unused_result));
void g_list_free (GList *list);
void g_list_free_1 (GList *list);

GList* g_list_append (GList *list,
      gpointer data) __attribute__((warn_unused_result));
GList* g_list_prepend (GList *list,
      gpointer data) __attribute__((warn_unused_result));
GList* g_list_insert (GList *list,
      gpointer data,
      gint position) __attribute__((warn_unused_result));
GList* g_list_insert_sorted (GList *list,
      gpointer data,
      GCompareFunc func) __attribute__((warn_unused_result));
GList* g_list_insert_sorted_with_data (GList *list,
      gpointer data,
      GCompareDataFunc func,
      gpointer user_data) __attribute__((warn_unused_result));
GList* g_list_insert_before (GList *list,
      GList *sibling,
      gpointer data) __attribute__((warn_unused_result));
GList* g_list_concat (GList *list1,
      GList *list2) __attribute__((warn_unused_result));
GList* g_list_remove (GList *list,
      gconstpointer data) __attribute__((warn_unused_result));
GList* g_list_remove_all (GList *list,
      gconstpointer data) __attribute__((warn_unused_result));
GList* g_list_remove_link (GList *list,
      GList *llink) __attribute__((warn_unused_result));
GList* g_list_delete_link (GList *list,
      GList *link_) __attribute__((warn_unused_result));
GList* g_list_reverse (GList *list) __attribute__((warn_unused_result));
GList* g_list_copy (GList *list) __attribute__((warn_unused_result));
GList* g_list_nth (GList *list,
      guint n);
GList* g_list_nth_prev (GList *list,
      guint n);
GList* g_list_find (GList *list,
      gconstpointer data);
GList* g_list_find_custom (GList *list,
      gconstpointer data,
      GCompareFunc func);
gint g_list_position (GList *list,
      GList *llink);
gint g_list_index (GList *list,
      gconstpointer data);
GList* g_list_last (GList *list);
GList* g_list_first (GList *list);
guint g_list_length (GList *list);
void g_list_foreach (GList *list,
      GFunc func,
      gpointer user_data);
GList* g_list_sort (GList *list,
      GCompareFunc compare_func) __attribute__((warn_unused_result));
GList* g_list_sort_with_data (GList *list,
      GCompareDataFunc compare_func,
      gpointer user_data) __attribute__((warn_unused_result));
gpointer g_list_nth_data (GList *list,
      guint n);






void g_list_push_allocator (gpointer allocator);
void g_list_pop_allocator (void);


# 31 "/usr/include/glib-2.0/glib/gcache.h" 2



typedef struct _GCache GCache;

typedef gpointer (*GCacheNewFunc) (gpointer key);
typedef gpointer (*GCacheDupFunc) (gpointer value);
typedef void (*GCacheDestroyFunc) (gpointer value);



GCache* g_cache_new (GCacheNewFunc value_new_func,
                                GCacheDestroyFunc value_destroy_func,
                                GCacheDupFunc key_dup_func,
                                GCacheDestroyFunc key_destroy_func,
                                GHashFunc hash_key_func,
                                GHashFunc hash_value_func,
                                GEqualFunc key_equal_func);
void g_cache_destroy (GCache *cache);
gpointer g_cache_insert (GCache *cache,
                                gpointer key);
void g_cache_remove (GCache *cache,
                                gconstpointer value);
void g_cache_key_foreach (GCache *cache,
                                GHFunc func,
                                gpointer user_data);

void g_cache_value_foreach (GCache *cache,
                                GHFunc func,
                                gpointer user_data);



# 36 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/gcompletion.h" 1
# 32 "/usr/include/glib-2.0/glib/gcompletion.h"


typedef struct _GCompletion GCompletion;

typedef gchar* (*GCompletionFunc) (gpointer);




typedef gint (*GCompletionStrncmpFunc) (const gchar *s1,
     const gchar *s2,
     gsize n);

struct _GCompletion
{
  GList* items;
  GCompletionFunc func;

  gchar* prefix;
  GList* cache;
  GCompletionStrncmpFunc strncmp_func;
};

GCompletion* g_completion_new (GCompletionFunc func);
void g_completion_add_items (GCompletion* cmp,
                                         GList* items);
void g_completion_remove_items (GCompletion* cmp,
                                         GList* items);
void g_completion_clear_items (GCompletion* cmp);
GList* g_completion_complete (GCompletion* cmp,
                                         const gchar* prefix,
                                         gchar** new_prefix);
GList* g_completion_complete_utf8 (GCompletion *cmp,
                                         const gchar* prefix,
                                         gchar** new_prefix);
void g_completion_set_compare (GCompletion *cmp,
             GCompletionStrncmpFunc strncmp_func);
void g_completion_free (GCompletion* cmp);


# 37 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/gconvert.h" 1
# 30 "/usr/include/glib-2.0/glib/gconvert.h"
# 1 "/usr/lib/gcc/i386-redhat-linux/4.1.0/include/stddef.h" 1 3 4
# 31 "/usr/include/glib-2.0/glib/gconvert.h" 2




typedef enum
{
  G_CONVERT_ERROR_NO_CONVERSION,
  G_CONVERT_ERROR_ILLEGAL_SEQUENCE,
  G_CONVERT_ERROR_FAILED,
  G_CONVERT_ERROR_PARTIAL_INPUT,
  G_CONVERT_ERROR_BAD_URI,
  G_CONVERT_ERROR_NOT_ABSOLUTE_PATH
} GConvertError;


GQuark g_convert_error_quark (void);



typedef struct _GIConv *GIConv;

GIConv g_iconv_open (const gchar *to_codeset,
         const gchar *from_codeset);
size_t g_iconv (GIConv converter,
         gchar **inbuf,
         gsize *inbytes_left,
         gchar **outbuf,
         gsize *outbytes_left);
gint g_iconv_close (GIConv converter);


gchar* g_convert (const gchar *str,
    gssize len,
    const gchar *to_codeset,
    const gchar *from_codeset,
    gsize *bytes_read,
    gsize *bytes_written,
    GError **error) __attribute__((__malloc__));
gchar* g_convert_with_iconv (const gchar *str,
    gssize len,
    GIConv converter,
    gsize *bytes_read,
    gsize *bytes_written,
    GError **error) __attribute__((__malloc__));
gchar* g_convert_with_fallback (const gchar *str,
    gssize len,
    const gchar *to_codeset,
    const gchar *from_codeset,
    gchar *fallback,
    gsize *bytes_read,
    gsize *bytes_written,
    GError **error) __attribute__((__malloc__));




gchar* g_locale_to_utf8 (const gchar *opsysstring,
      gssize len,
      gsize *bytes_read,
      gsize *bytes_written,
      GError **error) __attribute__((__malloc__));
gchar* g_locale_from_utf8 (const gchar *utf8string,
      gssize len,
      gsize *bytes_read,
      gsize *bytes_written,
      GError **error) __attribute__((__malloc__));
# 108 "/usr/include/glib-2.0/glib/gconvert.h"
gchar* g_filename_to_utf8 (const gchar *opsysstring,
        gssize len,
        gsize *bytes_read,
        gsize *bytes_written,
        GError **error) __attribute__((__malloc__));
gchar* g_filename_from_utf8 (const gchar *utf8string,
        gssize len,
        gsize *bytes_read,
        gsize *bytes_written,
        GError **error) __attribute__((__malloc__));

gchar *g_filename_from_uri (const gchar *uri,
       gchar **hostname,
       GError **error) __attribute__((__malloc__));

gchar *g_filename_to_uri (const gchar *filename,
       const gchar *hostname,
       GError **error) __attribute__((__malloc__));
gchar *g_filename_display_name (const gchar *filename) __attribute__((__malloc__));
gboolean g_get_filename_charsets (const gchar ***charsets);

gchar *g_filename_display_basename (const gchar *filename) __attribute__((__malloc__));

gchar **g_uri_list_extract_uris (const gchar *uri_list) __attribute__((__malloc__));


# 38 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/gdataset.h" 1
# 32 "/usr/include/glib-2.0/glib/gdataset.h"


typedef struct _GData GData;

typedef void (*GDataForeachFunc) (GQuark key_id,
                                                 gpointer data,
                                                 gpointer user_data);



void g_datalist_init (GData **datalist);
void g_datalist_clear (GData **datalist);
gpointer g_datalist_id_get_data (GData **datalist,
      GQuark key_id);
void g_datalist_id_set_data_full (GData **datalist,
      GQuark key_id,
      gpointer data,
      GDestroyNotify destroy_func);
gpointer g_datalist_id_remove_no_notify (GData **datalist,
      GQuark key_id);
void g_datalist_foreach (GData **datalist,
      GDataForeachFunc func,
      gpointer user_data);
# 65 "/usr/include/glib-2.0/glib/gdataset.h"
void g_datalist_set_flags (GData **datalist,
      guint flags);
void g_datalist_unset_flags (GData **datalist,
      guint flags);
guint g_datalist_get_flags (GData **datalist);
# 89 "/usr/include/glib-2.0/glib/gdataset.h"
void g_dataset_destroy (gconstpointer dataset_location);
gpointer g_dataset_id_get_data (gconstpointer dataset_location,
                                         GQuark key_id);
void g_dataset_id_set_data_full (gconstpointer dataset_location,
                                         GQuark key_id,
                                         gpointer data,
                                         GDestroyNotify destroy_func);
gpointer g_dataset_id_remove_no_notify (gconstpointer dataset_location,
                                         GQuark key_id);
void g_dataset_foreach (gconstpointer dataset_location,
                                         GDataForeachFunc func,
                                         gpointer user_data);
# 116 "/usr/include/glib-2.0/glib/gdataset.h"

# 39 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/gdate.h" 1
# 30 "/usr/include/glib-2.0/glib/gdate.h"
# 1 "/usr/include/time.h" 1 3 4
# 31 "/usr/include/time.h" 3 4








# 1 "/usr/lib/gcc/i386-redhat-linux/4.1.0/include/stddef.h" 1 3 4
# 40 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/bits/time.h" 1 3 4
# 44 "/usr/include/time.h" 2 3 4
# 57 "/usr/include/time.h" 3 4
# 1 "/usr/include/bits/types.h" 1 3 4
# 28 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 29 "/usr/include/bits/types.h" 2 3 4


# 1 "/usr/lib/gcc/i386-redhat-linux/4.1.0/include/stddef.h" 1 3 4
# 32 "/usr/include/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;




__extension__ typedef signed long long int __int64_t;
__extension__ typedef unsigned long long int __uint64_t;







__extension__ typedef long long int __quad_t;
__extension__ typedef unsigned long long int __u_quad_t;
# 134 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/typesizes.h" 1 3 4
# 135 "/usr/include/bits/types.h" 2 3 4


__extension__ typedef __u_quad_t __dev_t;
__extension__ typedef unsigned int __uid_t;
__extension__ typedef unsigned int __gid_t;
__extension__ typedef unsigned long int __ino_t;
__extension__ typedef __u_quad_t __ino64_t;
__extension__ typedef unsigned int __mode_t;
__extension__ typedef unsigned int __nlink_t;
__extension__ typedef long int __off_t;
__extension__ typedef __quad_t __off64_t;
__extension__ typedef int __pid_t;
__extension__ typedef struct { int __val[2]; } __fsid_t;
__extension__ typedef long int __clock_t;
__extension__ typedef unsigned long int __rlim_t;
__extension__ typedef __u_quad_t __rlim64_t;
__extension__ typedef unsigned int __id_t;
__extension__ typedef long int __time_t;
__extension__ typedef unsigned int __useconds_t;
__extension__ typedef long int __suseconds_t;

__extension__ typedef int __daddr_t;
__extension__ typedef long int __swblk_t;
__extension__ typedef int __key_t;


__extension__ typedef int __clockid_t;


__extension__ typedef void * __timer_t;


__extension__ typedef long int __blksize_t;




__extension__ typedef long int __blkcnt_t;
__extension__ typedef __quad_t __blkcnt64_t;


__extension__ typedef unsigned long int __fsblkcnt_t;
__extension__ typedef __u_quad_t __fsblkcnt64_t;


__extension__ typedef unsigned long int __fsfilcnt_t;
__extension__ typedef __u_quad_t __fsfilcnt64_t;

__extension__ typedef int __ssize_t;



typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;


__extension__ typedef int __intptr_t;


__extension__ typedef unsigned int __socklen_t;
# 58 "/usr/include/time.h" 2 3 4



typedef __clock_t clock_t;



# 75 "/usr/include/time.h" 3 4


typedef __time_t time_t;



# 93 "/usr/include/time.h" 3 4
typedef __clockid_t clockid_t;
# 105 "/usr/include/time.h" 3 4
typedef __timer_t timer_t;
# 121 "/usr/include/time.h" 3 4
struct timespec
  {
    __time_t tv_sec;
    long int tv_nsec;
  };








struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  __const char *tm_zone;




};








struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };


struct sigevent;





typedef __pid_t pid_t;








extern clock_t clock (void) __attribute__ ((__nothrow__));


extern time_t time (time_t *__timer) __attribute__ ((__nothrow__));


extern double difftime (time_t __time1, time_t __time0)
     __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) __attribute__ ((__nothrow__));





extern size_t strftime (char *__restrict __s, size_t __maxsize,
   __const char *__restrict __format,
   __const struct tm *__restrict __tp) __attribute__ ((__nothrow__));

# 229 "/usr/include/time.h" 3 4



extern struct tm *gmtime (__const time_t *__timer) __attribute__ ((__nothrow__));



extern struct tm *localtime (__const time_t *__timer) __attribute__ ((__nothrow__));





extern struct tm *gmtime_r (__const time_t *__restrict __timer,
       struct tm *__restrict __tp) __attribute__ ((__nothrow__));



extern struct tm *localtime_r (__const time_t *__restrict __timer,
          struct tm *__restrict __tp) __attribute__ ((__nothrow__));





extern char *asctime (__const struct tm *__tp) __attribute__ ((__nothrow__));


extern char *ctime (__const time_t *__timer) __attribute__ ((__nothrow__));







extern char *asctime_r (__const struct tm *__restrict __tp,
   char *__restrict __buf) __attribute__ ((__nothrow__));


extern char *ctime_r (__const time_t *__restrict __timer,
        char *__restrict __buf) __attribute__ ((__nothrow__));




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) __attribute__ ((__nothrow__));



extern int daylight;
extern long int timezone;





extern int stime (__const time_t *__when) __attribute__ ((__nothrow__));
# 312 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) __attribute__ ((__nothrow__));


extern time_t timelocal (struct tm *__tp) __attribute__ ((__nothrow__));


extern int dysize (int __year) __attribute__ ((__nothrow__)) __attribute__ ((__const__));
# 327 "/usr/include/time.h" 3 4
extern int nanosleep (__const struct timespec *__requested_time,
        struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) __attribute__ ((__nothrow__));


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) __attribute__ ((__nothrow__));


extern int clock_settime (clockid_t __clock_id, __const struct timespec *__tp)
     __attribute__ ((__nothrow__));






extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       __const struct timespec *__req,
       struct timespec *__rem);


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) __attribute__ ((__nothrow__));




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) __attribute__ ((__nothrow__));


extern int timer_delete (timer_t __timerid) __attribute__ ((__nothrow__));


extern int timer_settime (timer_t __timerid, int __flags,
     __const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) __attribute__ ((__nothrow__));


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     __attribute__ ((__nothrow__));


extern int timer_getoverrun (timer_t __timerid) __attribute__ ((__nothrow__));
# 416 "/usr/include/time.h" 3 4

# 31 "/usr/include/glib-2.0/glib/gdate.h" 2





# 46 "/usr/include/glib-2.0/glib/gdate.h"
typedef gint32 GTime;
typedef guint16 GDateYear;
typedef guint8 GDateDay;
typedef struct _GDate GDate;

struct tm;


typedef enum
{
  G_DATE_DAY = 0,
  G_DATE_MONTH = 1,
  G_DATE_YEAR = 2
} GDateDMY;


typedef enum
{
  G_DATE_BAD_WEEKDAY = 0,
  G_DATE_MONDAY = 1,
  G_DATE_TUESDAY = 2,
  G_DATE_WEDNESDAY = 3,
  G_DATE_THURSDAY = 4,
  G_DATE_FRIDAY = 5,
  G_DATE_SATURDAY = 6,
  G_DATE_SUNDAY = 7
} GDateWeekday;
typedef enum
{
  G_DATE_BAD_MONTH = 0,
  G_DATE_JANUARY = 1,
  G_DATE_FEBRUARY = 2,
  G_DATE_MARCH = 3,
  G_DATE_APRIL = 4,
  G_DATE_MAY = 5,
  G_DATE_JUNE = 6,
  G_DATE_JULY = 7,
  G_DATE_AUGUST = 8,
  G_DATE_SEPTEMBER = 9,
  G_DATE_OCTOBER = 10,
  G_DATE_NOVEMBER = 11,
  G_DATE_DECEMBER = 12
} GDateMonth;
# 99 "/usr/include/glib-2.0/glib/gdate.h"
struct _GDate
{
  guint julian_days : 32;





  guint julian : 1;
  guint dmy : 1;


  guint day : 6;
  guint month : 4;
  guint year : 16;
};





GDate* g_date_new (void);
GDate* g_date_new_dmy (GDateDay day,
                                           GDateMonth month,
                                           GDateYear year);
GDate* g_date_new_julian (guint32 julian_day);
void g_date_free (GDate *date);






gboolean g_date_valid (const GDate *date);
gboolean g_date_valid_day (GDateDay day) __attribute__((__const__));
gboolean g_date_valid_month (GDateMonth month) __attribute__((__const__));
gboolean g_date_valid_year (GDateYear year) __attribute__((__const__));
gboolean g_date_valid_weekday (GDateWeekday weekday) __attribute__((__const__));
gboolean g_date_valid_julian (guint32 julian_date) __attribute__((__const__));
gboolean g_date_valid_dmy (GDateDay day,
                                           GDateMonth month,
                                           GDateYear year) __attribute__((__const__));

GDateWeekday g_date_get_weekday (const GDate *date);
GDateMonth g_date_get_month (const GDate *date);
GDateYear g_date_get_year (const GDate *date);
GDateDay g_date_get_day (const GDate *date);
guint32 g_date_get_julian (const GDate *date);
guint g_date_get_day_of_year (const GDate *date);






guint g_date_get_monday_week_of_year (const GDate *date);
guint g_date_get_sunday_week_of_year (const GDate *date);
guint g_date_get_iso8601_week_of_year (const GDate *date);





void g_date_clear (GDate *date,
                                           guint n_dates);





void g_date_set_parse (GDate *date,
                                           const gchar *str);
void g_date_set_time_t (GDate *date,
        time_t timet);
void g_date_set_time_val (GDate *date,
        GTimeVal *timeval);

void g_date_set_time (GDate *date,
                                           GTime time_);

void g_date_set_month (GDate *date,
                                           GDateMonth month);
void g_date_set_day (GDate *date,
                                           GDateDay day);
void g_date_set_year (GDate *date,
                                           GDateYear year);
void g_date_set_dmy (GDate *date,
                                           GDateDay day,
                                           GDateMonth month,
                                           GDateYear y);
void g_date_set_julian (GDate *date,
                                           guint32 julian_date);
gboolean g_date_is_first_of_month (const GDate *date);
gboolean g_date_is_last_of_month (const GDate *date);


void g_date_add_days (GDate *date,
                                           guint n_days);
void g_date_subtract_days (GDate *date,
                                           guint n_days);


void g_date_add_months (GDate *date,
                                           guint n_months);
void g_date_subtract_months (GDate *date,
                                           guint n_months);


void g_date_add_years (GDate *date,
                                           guint n_years);
void g_date_subtract_years (GDate *date,
                                           guint n_years);
gboolean g_date_is_leap_year (GDateYear year) __attribute__((__const__));
guint8 g_date_get_days_in_month (GDateMonth month,
                                           GDateYear year) __attribute__((__const__));
guint8 g_date_get_monday_weeks_in_year (GDateYear year) __attribute__((__const__));
guint8 g_date_get_sunday_weeks_in_year (GDateYear year) __attribute__((__const__));



gint g_date_days_between (const GDate *date1,
        const GDate *date2);


gint g_date_compare (const GDate *lhs,
                                           const GDate *rhs);
void g_date_to_struct_tm (const GDate *date,
                                           struct tm *tm);

void g_date_clamp (GDate *date,
        const GDate *min_date,
        const GDate *max_date);


void g_date_order (GDate *date1, GDate *date2);




gsize g_date_strftime (gchar *s,
                                           gsize slen,
                                           const gchar *format,
                                           const GDate *date);
# 259 "/usr/include/glib-2.0/glib/gdate.h"

# 40 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/gdir.h" 1
# 28 "/usr/include/glib-2.0/glib/gdir.h"


typedef struct _GDir GDir;







GDir * g_dir_open (const gchar *path,
            guint flags,
            GError **error);
const gchar *g_dir_read_name (GDir *dir);
void g_dir_rewind (GDir *dir);
void g_dir_close (GDir *dir);


# 41 "/usr/include/glib-2.0/glib.h" 2

# 1 "/usr/include/glib-2.0/glib/gfileutils.h" 1
# 26 "/usr/include/glib-2.0/glib/gfileutils.h"




typedef enum
{
  G_FILE_ERROR_EXIST,
  G_FILE_ERROR_ISDIR,
  G_FILE_ERROR_ACCES,
  G_FILE_ERROR_NAMETOOLONG,
  G_FILE_ERROR_NOENT,
  G_FILE_ERROR_NOTDIR,
  G_FILE_ERROR_NXIO,
  G_FILE_ERROR_NODEV,
  G_FILE_ERROR_ROFS,
  G_FILE_ERROR_TXTBSY,
  G_FILE_ERROR_FAULT,
  G_FILE_ERROR_LOOP,
  G_FILE_ERROR_NOSPC,
  G_FILE_ERROR_NOMEM,
  G_FILE_ERROR_MFILE,
  G_FILE_ERROR_NFILE,
  G_FILE_ERROR_BADF,
  G_FILE_ERROR_INVAL,
  G_FILE_ERROR_PIPE,
  G_FILE_ERROR_AGAIN,
  G_FILE_ERROR_INTR,
  G_FILE_ERROR_IO,
  G_FILE_ERROR_PERM,
  G_FILE_ERROR_NOSYS,
  G_FILE_ERROR_FAILED
} GFileError;





typedef enum
{
  G_FILE_TEST_IS_REGULAR = 1 << 0,
  G_FILE_TEST_IS_SYMLINK = 1 << 1,
  G_FILE_TEST_IS_DIR = 1 << 2,
  G_FILE_TEST_IS_EXECUTABLE = 1 << 3,
  G_FILE_TEST_EXISTS = 1 << 4
} GFileTest;

GQuark g_file_error_quark (void);

GFileError g_file_error_from_errno (gint err_no);
# 83 "/usr/include/glib-2.0/glib/gfileutils.h"
gboolean g_file_test (const gchar *filename,
                              GFileTest test);
gboolean g_file_get_contents (const gchar *filename,
                              gchar **contents,
                              gsize *length,
                              GError **error);
gboolean g_file_set_contents (const gchar *filename,
         const gchar *contents,
         gssize length,
         GError **error);
gchar *g_file_read_link (const gchar *filename,
         GError **error);


gint g_mkstemp (gchar *tmpl);


gint g_file_open_tmp (const gchar *tmpl,
         gchar **name_used,
         GError **error);

gchar *g_build_path (const gchar *separator,
    const gchar *first_element,
    ...) __attribute__((__malloc__)) __attribute__((__sentinel__));
gchar *g_build_pathv (const gchar *separator,
    gchar **args) __attribute__((__malloc__));

gchar *g_build_filename (const gchar *first_element,
    ...) __attribute__((__malloc__)) __attribute__((__sentinel__));
gchar *g_build_filenamev (gchar **args) __attribute__((__malloc__));

int g_mkdir_with_parents (const gchar *pathname,
        int mode);


# 43 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/ghash.h" 1
# 32 "/usr/include/glib-2.0/glib/ghash.h"


typedef struct _GHashTable GHashTable;

typedef gboolean (*GHRFunc) (gpointer key,
                               gpointer value,
                               gpointer user_data);



GHashTable* g_hash_table_new (GHashFunc hash_func,
         GEqualFunc key_equal_func);
GHashTable* g_hash_table_new_full (GHashFunc hash_func,
         GEqualFunc key_equal_func,
         GDestroyNotify key_destroy_func,
         GDestroyNotify value_destroy_func);
void g_hash_table_destroy (GHashTable *hash_table);
void g_hash_table_insert (GHashTable *hash_table,
         gpointer key,
         gpointer value);
void g_hash_table_replace (GHashTable *hash_table,
         gpointer key,
         gpointer value);
gboolean g_hash_table_remove (GHashTable *hash_table,
         gconstpointer key);
gboolean g_hash_table_steal (GHashTable *hash_table,
         gconstpointer key);
gpointer g_hash_table_lookup (GHashTable *hash_table,
         gconstpointer key);
gboolean g_hash_table_lookup_extended (GHashTable *hash_table,
         gconstpointer lookup_key,
         gpointer *orig_key,
         gpointer *value);
void g_hash_table_foreach (GHashTable *hash_table,
         GHFunc func,
         gpointer user_data);
gpointer g_hash_table_find (GHashTable *hash_table,
         GHRFunc predicate,
         gpointer user_data);
guint g_hash_table_foreach_remove (GHashTable *hash_table,
         GHRFunc func,
         gpointer user_data);
guint g_hash_table_foreach_steal (GHashTable *hash_table,
         GHRFunc func,
         gpointer user_data);
guint g_hash_table_size (GHashTable *hash_table);


GHashTable* g_hash_table_ref (GHashTable *hash_table);
void g_hash_table_unref (GHashTable *hash_table);
# 94 "/usr/include/glib-2.0/glib/ghash.h"
gboolean g_str_equal (gconstpointer v1,
                      gconstpointer v2);
guint g_str_hash (gconstpointer v);

gboolean g_int_equal (gconstpointer v1,
                      gconstpointer v2);
guint g_int_hash (gconstpointer v);







guint g_direct_hash (gconstpointer v) __attribute__((__const__));
gboolean g_direct_equal (gconstpointer v1,
                         gconstpointer v2) __attribute__((__const__));


# 44 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/ghook.h" 1
# 32 "/usr/include/glib-2.0/glib/ghook.h"




typedef struct _GHook GHook;
typedef struct _GHookList GHookList;

typedef gint (*GHookCompareFunc) (GHook *new_hook,
       GHook *sibling);
typedef gboolean (*GHookFindFunc) (GHook *hook,
       gpointer data);
typedef void (*GHookMarshaller) (GHook *hook,
       gpointer marshal_data);
typedef gboolean (*GHookCheckMarshaller) (GHook *hook,
       gpointer marshal_data);
typedef void (*GHookFunc) (gpointer data);
typedef gboolean (*GHookCheckFunc) (gpointer data);
typedef void (*GHookFinalizeFunc) (GHookList *hook_list,
       GHook *hook);
typedef enum
{
  G_HOOK_FLAG_ACTIVE = 1 << 0,
  G_HOOK_FLAG_IN_CALL = 1 << 1,
  G_HOOK_FLAG_MASK = 0x0f
} GHookFlagMask;




struct _GHookList
{
  gulong seq_id;
  guint hook_size : 16;
  guint is_setup : 1;
  GHook *hooks;
  gpointer dummy3;
  GHookFinalizeFunc finalize_hook;
  gpointer dummy[2];
};
struct _GHook
{
  gpointer data;
  GHook *next;
  GHook *prev;
  guint ref_count;
  gulong hook_id;
  guint flags;
  gpointer func;
  GDestroyNotify destroy;
};
# 102 "/usr/include/glib-2.0/glib/ghook.h"
void g_hook_list_init (GHookList *hook_list,
      guint hook_size);
void g_hook_list_clear (GHookList *hook_list);
GHook* g_hook_alloc (GHookList *hook_list);
void g_hook_free (GHookList *hook_list,
      GHook *hook);
GHook * g_hook_ref (GHookList *hook_list,
      GHook *hook);
void g_hook_unref (GHookList *hook_list,
      GHook *hook);
gboolean g_hook_destroy (GHookList *hook_list,
      gulong hook_id);
void g_hook_destroy_link (GHookList *hook_list,
      GHook *hook);
void g_hook_prepend (GHookList *hook_list,
      GHook *hook);
void g_hook_insert_before (GHookList *hook_list,
      GHook *sibling,
      GHook *hook);
void g_hook_insert_sorted (GHookList *hook_list,
      GHook *hook,
      GHookCompareFunc func);
GHook* g_hook_get (GHookList *hook_list,
      gulong hook_id);
GHook* g_hook_find (GHookList *hook_list,
      gboolean need_valids,
      GHookFindFunc func,
      gpointer data);
GHook* g_hook_find_data (GHookList *hook_list,
      gboolean need_valids,
      gpointer data);
GHook* g_hook_find_func (GHookList *hook_list,
      gboolean need_valids,
      gpointer func);
GHook* g_hook_find_func_data (GHookList *hook_list,
      gboolean need_valids,
      gpointer func,
      gpointer data);

GHook* g_hook_first_valid (GHookList *hook_list,
      gboolean may_be_in_call);



GHook* g_hook_next_valid (GHookList *hook_list,
      GHook *hook,
      gboolean may_be_in_call);

gint g_hook_compare_ids (GHook *new_hook,
      GHook *sibling);





void g_hook_list_invoke (GHookList *hook_list,
      gboolean may_recurse);



void g_hook_list_invoke_check (GHookList *hook_list,
      gboolean may_recurse);


void g_hook_list_marshal (GHookList *hook_list,
      gboolean may_recurse,
      GHookMarshaller marshaller,
      gpointer marshal_data);
void g_hook_list_marshal_check (GHookList *hook_list,
      gboolean may_recurse,
      GHookCheckMarshaller marshaller,
      gpointer marshal_data);


# 45 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/giochannel.h" 1
# 31 "/usr/include/glib-2.0/glib/giochannel.h"
# 1 "/usr/include/glib-2.0/glib/gmain.h" 1
# 23 "/usr/include/glib-2.0/glib/gmain.h"
# 1 "/usr/include/glib-2.0/glib/gslist.h" 1
# 32 "/usr/include/glib-2.0/glib/gslist.h"


typedef struct _GSList GSList;

struct _GSList
{
  gpointer data;
  GSList *next;
};



GSList* g_slist_alloc (void) __attribute__((warn_unused_result));
void g_slist_free (GSList *list);
void g_slist_free_1 (GSList *list);

GSList* g_slist_append (GSList *list,
       gpointer data) __attribute__((warn_unused_result));
GSList* g_slist_prepend (GSList *list,
       gpointer data) __attribute__((warn_unused_result));
GSList* g_slist_insert (GSList *list,
       gpointer data,
       gint position) __attribute__((warn_unused_result));
GSList* g_slist_insert_sorted (GSList *list,
       gpointer data,
       GCompareFunc func) __attribute__((warn_unused_result));
GSList* g_slist_insert_sorted_with_data (GSList *list,
       gpointer data,
       GCompareDataFunc func,
       gpointer user_data) __attribute__((warn_unused_result));
GSList* g_slist_insert_before (GSList *slist,
       GSList *sibling,
       gpointer data) __attribute__((warn_unused_result));
GSList* g_slist_concat (GSList *list1,
       GSList *list2) __attribute__((warn_unused_result));
GSList* g_slist_remove (GSList *list,
       gconstpointer data) __attribute__((warn_unused_result));
GSList* g_slist_remove_all (GSList *list,
       gconstpointer data) __attribute__((warn_unused_result));
GSList* g_slist_remove_link (GSList *list,
       GSList *link_) __attribute__((warn_unused_result));
GSList* g_slist_delete_link (GSList *list,
       GSList *link_) __attribute__((warn_unused_result));
GSList* g_slist_reverse (GSList *list) __attribute__((warn_unused_result));
GSList* g_slist_copy (GSList *list) __attribute__((warn_unused_result));
GSList* g_slist_nth (GSList *list,
       guint n);
GSList* g_slist_find (GSList *list,
       gconstpointer data);
GSList* g_slist_find_custom (GSList *list,
       gconstpointer data,
       GCompareFunc func);
gint g_slist_position (GSList *list,
       GSList *llink);
gint g_slist_index (GSList *list,
       gconstpointer data);
GSList* g_slist_last (GSList *list);
guint g_slist_length (GSList *list);
void g_slist_foreach (GSList *list,
       GFunc func,
       gpointer user_data);
GSList* g_slist_sort (GSList *list,
       GCompareFunc compare_func) __attribute__((warn_unused_result));
GSList* g_slist_sort_with_data (GSList *list,
       GCompareDataFunc compare_func,
       gpointer user_data) __attribute__((warn_unused_result));
gpointer g_slist_nth_data (GSList *list,
       guint n);




void g_slist_push_allocator (gpointer dummy);
void g_slist_pop_allocator (void);


# 24 "/usr/include/glib-2.0/glib/gmain.h" 2




typedef struct _GMainContext GMainContext;
typedef struct _GMainLoop GMainLoop;
typedef struct _GSource GSource;
typedef struct _GSourceCallbackFuncs GSourceCallbackFuncs;
typedef struct _GSourceFuncs GSourceFuncs;

typedef gboolean (*GSourceFunc) (gpointer data);
typedef void (*GChildWatchFunc) (GPid pid,
           gint status,
           gpointer data);
struct _GSource
{

  gpointer callback_data;
  GSourceCallbackFuncs *callback_funcs;

  GSourceFuncs *source_funcs;
  guint ref_count;

  GMainContext *context;

  gint priority;
  guint flags;
  guint source_id;

  GSList *poll_fds;

  GSource *prev;
  GSource *next;

  gpointer reserved1;
  gpointer reserved2;
};

struct _GSourceCallbackFuncs
{
  void (*ref) (gpointer cb_data);
  void (*unref) (gpointer cb_data);
  void (*get) (gpointer cb_data,
   GSource *source,
   GSourceFunc *func,
   gpointer *data);
};

typedef void (*GSourceDummyMarshal) (void);

struct _GSourceFuncs
{
  gboolean (*prepare) (GSource *source,
   gint *timeout_);
  gboolean (*check) (GSource *source);
  gboolean (*dispatch) (GSource *source,
   GSourceFunc callback,
   gpointer user_data);
  void (*finalize) (GSource *source);


  GSourceFunc closure_callback;
  GSourceDummyMarshal closure_marshal;
};
# 116 "/usr/include/glib-2.0/glib/gmain.h"
typedef struct _GPollFD GPollFD;
typedef gint (*GPollFunc) (GPollFD *ufds,
     guint nfsd,
     gint timeout_);

struct _GPollFD
{
  gint fd;
  gushort events;
  gushort revents;
};
# 138 "/usr/include/glib-2.0/glib/gmain.h"
GMainContext *g_main_context_new (void);
GMainContext *g_main_context_ref (GMainContext *context);
void g_main_context_unref (GMainContext *context);
GMainContext *g_main_context_default (void);

gboolean g_main_context_iteration (GMainContext *context,
     gboolean may_block);
gboolean g_main_context_pending (GMainContext *context);



GSource *g_main_context_find_source_by_id (GMainContext *context,
            guint source_id);
GSource *g_main_context_find_source_by_user_data (GMainContext *context,
            gpointer user_data);
GSource *g_main_context_find_source_by_funcs_user_data (GMainContext *context,
             GSourceFuncs *funcs,
            gpointer user_data);



void g_main_context_wakeup (GMainContext *context);
gboolean g_main_context_acquire (GMainContext *context);
void g_main_context_release (GMainContext *context);
gboolean g_main_context_is_owner (GMainContext *context);
gboolean g_main_context_wait (GMainContext *context,
     GCond *cond,
     GMutex *mutex);

gboolean g_main_context_prepare (GMainContext *context,
      gint *priority);
gint g_main_context_query (GMainContext *context,
      gint max_priority,
      gint *timeout_,
      GPollFD *fds,
      gint n_fds);
gint g_main_context_check (GMainContext *context,
      gint max_priority,
      GPollFD *fds,
      gint n_fds);
void g_main_context_dispatch (GMainContext *context);

void g_main_context_set_poll_func (GMainContext *context,
     GPollFunc func);
GPollFunc g_main_context_get_poll_func (GMainContext *context);



void g_main_context_add_poll (GMainContext *context,
       GPollFD *fd,
       gint priority);
void g_main_context_remove_poll (GMainContext *context,
       GPollFD *fd);

int g_main_depth (void);



GMainLoop *g_main_loop_new (GMainContext *context,
           gboolean is_running);
void g_main_loop_run (GMainLoop *loop);
void g_main_loop_quit (GMainLoop *loop);
GMainLoop *g_main_loop_ref (GMainLoop *loop);
void g_main_loop_unref (GMainLoop *loop);
gboolean g_main_loop_is_running (GMainLoop *loop);
GMainContext *g_main_loop_get_context (GMainLoop *loop);



GSource *g_source_new (GSourceFuncs *source_funcs,
       guint struct_size);
GSource *g_source_ref (GSource *source);
void g_source_unref (GSource *source);

guint g_source_attach (GSource *source,
       GMainContext *context);
void g_source_destroy (GSource *source);

void g_source_set_priority (GSource *source,
       gint priority);
gint g_source_get_priority (GSource *source);
void g_source_set_can_recurse (GSource *source,
       gboolean can_recurse);
gboolean g_source_get_can_recurse (GSource *source);
guint g_source_get_id (GSource *source);

GMainContext *g_source_get_context (GSource *source);

void g_source_set_callback (GSource *source,
         GSourceFunc func,
         gpointer data,
         GDestroyNotify notify);



void g_source_set_callback_indirect (GSource *source,
         gpointer callback_data,
         GSourceCallbackFuncs *callback_funcs);

void g_source_add_poll (GSource *source,
        GPollFD *fd);
void g_source_remove_poll (GSource *source,
        GPollFD *fd);

void g_source_get_current_time (GSource *source,
        GTimeVal *timeval);







GSource *g_idle_source_new (void);
GSource *g_child_watch_source_new (GPid pid);
GSource *g_timeout_source_new (guint interval);



void g_get_current_time (GTimeVal *result);
# 282 "/usr/include/glib-2.0/glib/gmain.h"
gboolean g_source_remove (guint tag);
gboolean g_source_remove_by_user_data (gpointer user_data);
gboolean g_source_remove_by_funcs_user_data (GSourceFuncs *funcs,
           gpointer user_data);


guint g_timeout_add_full (gint priority,
     guint interval,
     GSourceFunc function,
     gpointer data,
     GDestroyNotify notify);
guint g_timeout_add (guint interval,
     GSourceFunc function,
     gpointer data);
guint g_child_watch_add_full (gint priority,
     GPid pid,
     GChildWatchFunc function,
     gpointer data,
     GDestroyNotify notify);
guint g_child_watch_add (GPid pid,
     GChildWatchFunc function,
     gpointer data);
guint g_idle_add (GSourceFunc function,
     gpointer data);
guint g_idle_add_full (gint priority,
     GSourceFunc function,
     gpointer data,
     GDestroyNotify notify);
gboolean g_idle_remove_by_data (gpointer data);


extern GSourceFuncs g_timeout_funcs;
extern GSourceFuncs g_child_watch_funcs;
extern GSourceFuncs g_idle_funcs;


# 32 "/usr/include/glib-2.0/glib/giochannel.h" 2
# 1 "/usr/include/glib-2.0/glib/gstring.h" 1
# 31 "/usr/include/glib-2.0/glib/gstring.h"
# 1 "/usr/include/glib-2.0/glib/gunicode.h" 1
# 28 "/usr/include/glib-2.0/glib/gunicode.h"


typedef guint32 gunichar;
typedef guint16 gunichar2;




typedef enum
{
  G_UNICODE_CONTROL,
  G_UNICODE_FORMAT,
  G_UNICODE_UNASSIGNED,
  G_UNICODE_PRIVATE_USE,
  G_UNICODE_SURROGATE,
  G_UNICODE_LOWERCASE_LETTER,
  G_UNICODE_MODIFIER_LETTER,
  G_UNICODE_OTHER_LETTER,
  G_UNICODE_TITLECASE_LETTER,
  G_UNICODE_UPPERCASE_LETTER,
  G_UNICODE_COMBINING_MARK,
  G_UNICODE_ENCLOSING_MARK,
  G_UNICODE_NON_SPACING_MARK,
  G_UNICODE_DECIMAL_NUMBER,
  G_UNICODE_LETTER_NUMBER,
  G_UNICODE_OTHER_NUMBER,
  G_UNICODE_CONNECT_PUNCTUATION,
  G_UNICODE_DASH_PUNCTUATION,
  G_UNICODE_CLOSE_PUNCTUATION,
  G_UNICODE_FINAL_PUNCTUATION,
  G_UNICODE_INITIAL_PUNCTUATION,
  G_UNICODE_OTHER_PUNCTUATION,
  G_UNICODE_OPEN_PUNCTUATION,
  G_UNICODE_CURRENCY_SYMBOL,
  G_UNICODE_MODIFIER_SYMBOL,
  G_UNICODE_MATH_SYMBOL,
  G_UNICODE_OTHER_SYMBOL,
  G_UNICODE_LINE_SEPARATOR,
  G_UNICODE_PARAGRAPH_SEPARATOR,
  G_UNICODE_SPACE_SEPARATOR
} GUnicodeType;






typedef enum
{
  G_UNICODE_BREAK_MANDATORY,
  G_UNICODE_BREAK_CARRIAGE_RETURN,
  G_UNICODE_BREAK_LINE_FEED,
  G_UNICODE_BREAK_COMBINING_MARK,
  G_UNICODE_BREAK_SURROGATE,
  G_UNICODE_BREAK_ZERO_WIDTH_SPACE,
  G_UNICODE_BREAK_INSEPARABLE,
  G_UNICODE_BREAK_NON_BREAKING_GLUE,
  G_UNICODE_BREAK_CONTINGENT,
  G_UNICODE_BREAK_SPACE,
  G_UNICODE_BREAK_AFTER,
  G_UNICODE_BREAK_BEFORE,
  G_UNICODE_BREAK_BEFORE_AND_AFTER,
  G_UNICODE_BREAK_HYPHEN,
  G_UNICODE_BREAK_NON_STARTER,
  G_UNICODE_BREAK_OPEN_PUNCTUATION,
  G_UNICODE_BREAK_CLOSE_PUNCTUATION,
  G_UNICODE_BREAK_QUOTATION,
  G_UNICODE_BREAK_EXCLAMATION,
  G_UNICODE_BREAK_IDEOGRAPHIC,
  G_UNICODE_BREAK_NUMERIC,
  G_UNICODE_BREAK_INFIX_SEPARATOR,
  G_UNICODE_BREAK_SYMBOL,
  G_UNICODE_BREAK_ALPHABETIC,
  G_UNICODE_BREAK_PREFIX,
  G_UNICODE_BREAK_POSTFIX,
  G_UNICODE_BREAK_COMPLEX_CONTEXT,
  G_UNICODE_BREAK_AMBIGUOUS,
  G_UNICODE_BREAK_UNKNOWN,
  G_UNICODE_BREAK_NEXT_LINE,
  G_UNICODE_BREAK_WORD_JOINER,
  G_UNICODE_BREAK_HANGUL_L_JAMO,
  G_UNICODE_BREAK_HANGUL_V_JAMO,
  G_UNICODE_BREAK_HANGUL_T_JAMO,
  G_UNICODE_BREAK_HANGUL_LV_SYLLABLE,
  G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE
} GUnicodeBreakType;







gboolean g_get_charset (const char **charset);



gboolean g_unichar_isalnum (gunichar c) __attribute__((__const__));
gboolean g_unichar_isalpha (gunichar c) __attribute__((__const__));
gboolean g_unichar_iscntrl (gunichar c) __attribute__((__const__));
gboolean g_unichar_isdigit (gunichar c) __attribute__((__const__));
gboolean g_unichar_isgraph (gunichar c) __attribute__((__const__));
gboolean g_unichar_islower (gunichar c) __attribute__((__const__));
gboolean g_unichar_isprint (gunichar c) __attribute__((__const__));
gboolean g_unichar_ispunct (gunichar c) __attribute__((__const__));
gboolean g_unichar_isspace (gunichar c) __attribute__((__const__));
gboolean g_unichar_isupper (gunichar c) __attribute__((__const__));
gboolean g_unichar_isxdigit (gunichar c) __attribute__((__const__));
gboolean g_unichar_istitle (gunichar c) __attribute__((__const__));
gboolean g_unichar_isdefined (gunichar c) __attribute__((__const__));
gboolean g_unichar_iswide (gunichar c) __attribute__((__const__));



gunichar g_unichar_toupper (gunichar c) __attribute__((__const__));
gunichar g_unichar_tolower (gunichar c) __attribute__((__const__));
gunichar g_unichar_totitle (gunichar c) __attribute__((__const__));



gint g_unichar_digit_value (gunichar c) __attribute__((__const__));

gint g_unichar_xdigit_value (gunichar c) __attribute__((__const__));


GUnicodeType g_unichar_type (gunichar c) __attribute__((__const__));


GUnicodeBreakType g_unichar_break_type (gunichar c) __attribute__((__const__));





void g_unicode_canonical_ordering (gunichar *string,
       gsize len);




gunichar *g_unicode_canonical_decomposition (gunichar ch,
          gsize *result_len) __attribute__((__malloc__));



extern const gchar * const g_utf8_skip;



gunichar g_utf8_get_char (const gchar *p);
gunichar g_utf8_get_char_validated (const gchar *p,
        gssize max_len);

gchar* g_utf8_offset_to_pointer (const gchar *str,
                                   glong offset);
glong g_utf8_pointer_to_offset (const gchar *str,
       const gchar *pos);
gchar* g_utf8_prev_char (const gchar *p);
gchar* g_utf8_find_next_char (const gchar *p,
       const gchar *end);
gchar* g_utf8_find_prev_char (const gchar *str,
       const gchar *p);

glong g_utf8_strlen (const gchar *p,
       gssize max);


gchar* g_utf8_strncpy (gchar *dest,
         const gchar *src,
         gsize n);



gchar* g_utf8_strchr (const gchar *p,
         gssize len,
         gunichar c);
gchar* g_utf8_strrchr (const gchar *p,
         gssize len,
         gunichar c);
gchar* g_utf8_strreverse (const gchar *str,
     gssize len);

gunichar2 *g_utf8_to_utf16 (const gchar *str,
    glong len,
    glong *items_read,
    glong *items_written,
    GError **error) __attribute__((__malloc__));
gunichar * g_utf8_to_ucs4 (const gchar *str,
    glong len,
    glong *items_read,
    glong *items_written,
    GError **error) __attribute__((__malloc__));
gunichar * g_utf8_to_ucs4_fast (const gchar *str,
    glong len,
    glong *items_written) __attribute__((__malloc__));
gunichar * g_utf16_to_ucs4 (const gunichar2 *str,
    glong len,
    glong *items_read,
    glong *items_written,
    GError **error) __attribute__((__malloc__));
gchar* g_utf16_to_utf8 (const gunichar2 *str,
    glong len,
    glong *items_read,
    glong *items_written,
    GError **error) __attribute__((__malloc__));
gunichar2 *g_ucs4_to_utf16 (const gunichar *str,
    glong len,
    glong *items_read,
    glong *items_written,
    GError **error) __attribute__((__malloc__));
gchar* g_ucs4_to_utf8 (const gunichar *str,
    glong len,
    glong *items_read,
    glong *items_written,
    GError **error) __attribute__((__malloc__));





gint g_unichar_to_utf8 (gunichar c,
        gchar *outbuf);





gboolean g_utf8_validate (const gchar *str,
                          gssize max_len,
                          const gchar **end);


gboolean g_unichar_validate (gunichar ch);

gchar *g_utf8_strup (const gchar *str,
         gssize len) __attribute__((__malloc__));
gchar *g_utf8_strdown (const gchar *str,
         gssize len) __attribute__((__malloc__));
gchar *g_utf8_casefold (const gchar *str,
   gssize len) __attribute__((__malloc__));

typedef enum {
  G_NORMALIZE_DEFAULT,
  G_NORMALIZE_NFD = G_NORMALIZE_DEFAULT,
  G_NORMALIZE_DEFAULT_COMPOSE,
  G_NORMALIZE_NFC = G_NORMALIZE_DEFAULT_COMPOSE,
  G_NORMALIZE_ALL,
  G_NORMALIZE_NFKD = G_NORMALIZE_ALL,
  G_NORMALIZE_ALL_COMPOSE,
  G_NORMALIZE_NFKC = G_NORMALIZE_ALL_COMPOSE
} GNormalizeMode;

gchar *g_utf8_normalize (const gchar *str,
    gssize len,
    GNormalizeMode mode) __attribute__((__malloc__));

gint g_utf8_collate (const gchar *str1,
      const gchar *str2);
gchar *g_utf8_collate_key (const gchar *str,
      gssize len) __attribute__((__malloc__));
gchar *g_utf8_collate_key_for_filename (const gchar *str,
                   gssize len) __attribute__((__malloc__));

gboolean g_unichar_get_mirror_char (gunichar ch,
                                    gunichar *mirrored_ch);


# 32 "/usr/include/glib-2.0/glib/gstring.h" 2
# 1 "/usr/include/glib-2.0/glib/gutils.h" 1
# 31 "/usr/include/glib-2.0/glib/gutils.h"
# 1 "/usr/lib/gcc/i386-redhat-linux/4.1.0/include/stdarg.h" 1 3 4
# 43 "/usr/lib/gcc/i386-redhat-linux/4.1.0/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 105 "/usr/lib/gcc/i386-redhat-linux/4.1.0/include/stdarg.h" 3 4
typedef __gnuc_va_list va_list;
# 32 "/usr/include/glib-2.0/glib/gutils.h" 2


# 116 "/usr/include/glib-2.0/glib/gutils.h"
const gchar* g_get_user_name (void);
const gchar* g_get_real_name (void);
const gchar* g_get_home_dir (void);
const gchar* g_get_tmp_dir (void);
const gchar* g_get_host_name (void);
gchar* g_get_prgname (void);
void g_set_prgname (const gchar *prgname);
const gchar* g_get_application_name (void);
void g_set_application_name (const gchar *application_name);

const gchar* g_get_user_data_dir (void);
const gchar* g_get_user_config_dir (void);
const gchar* g_get_user_cache_dir (void);
const gchar* const * g_get_system_data_dirs (void);
# 144 "/usr/include/glib-2.0/glib/gutils.h"
const gchar* const * g_get_system_config_dirs (void);

const gchar* const * g_get_language_names (void);

typedef struct _GDebugKey GDebugKey;
struct _GDebugKey
{
  gchar *key;
  guint value;
};



guint g_parse_debug_string (const gchar *string,
         const GDebugKey *keys,
         guint nkeys);

gint g_snprintf (gchar *string,
         gulong n,
         gchar const *format,
         ...) __attribute__((__format__ (__printf__, 3, 4)));
gint g_vsnprintf (gchar *string,
         gulong n,
         gchar const *format,
         va_list args);


gboolean g_path_is_absolute (const gchar *file_name);


const gchar* g_path_skip_root (const gchar *file_name);







const gchar* g_basename (const gchar *file_name);
# 192 "/usr/include/glib-2.0/glib/gutils.h"
gchar* g_get_current_dir (void);
gchar* g_path_get_basename (const gchar *file_name) __attribute__((__malloc__));
gchar* g_path_get_dirname (const gchar *file_name) __attribute__((__malloc__));


void g_nullify_pointer (gpointer *nullify_location);
# 208 "/usr/include/glib-2.0/glib/gutils.h"
const gchar* g_getenv (const gchar *variable);
gboolean g_setenv (const gchar *variable,
         const gchar *value,
         gboolean overwrite);
void g_unsetenv (const gchar *variable);
gchar** g_listenv (void);
const gchar* _g_getenv_nomalloc (const gchar *variable,
         gchar buffer[1024]);





typedef void (*GVoidFunc) (void);
# 232 "/usr/include/glib-2.0/glib/gutils.h"
void g_atexit (GVoidFunc func);
# 246 "/usr/include/glib-2.0/glib/gutils.h"
gchar* g_find_program_in_path (const gchar *program);



extern inline gint g_bit_nth_lsf (gulong mask,
           gint nth_bit);
extern inline gint g_bit_nth_msf (gulong mask,
           gint nth_bit);
extern inline guint g_bit_storage (gulong number);




typedef struct _GTrashStack GTrashStack;
struct _GTrashStack
{
  GTrashStack *next;
};

extern inline void g_trash_stack_push (GTrashStack **stack_p,
       gpointer data_p);
extern inline gpointer g_trash_stack_pop (GTrashStack **stack_p);
extern inline gpointer g_trash_stack_peek (GTrashStack **stack_p);
extern inline guint g_trash_stack_height (GTrashStack **stack_p);




extern inline gint
g_bit_nth_lsf (gulong mask,
        gint nth_bit)
{
  do
    {
      nth_bit++;
      if (mask & (1UL << nth_bit))
 return nth_bit;
    }
  while (nth_bit < ((4 * 8) - 1));
  return -1;
}
extern inline gint
g_bit_nth_msf (gulong mask,
        gint nth_bit)
{
  if (nth_bit < 0)
    nth_bit = 4 * 8;
  do
    {
      nth_bit--;
      if (mask & (1UL << nth_bit))
 return nth_bit;
    }
  while (nth_bit > 0);
  return -1;
}
extern inline guint
g_bit_storage (gulong number)
{
  register guint n_bits = 0;

  do
    {
      n_bits++;
      number >>= 1;
    }
  while (number);
  return n_bits;
}
extern inline void
g_trash_stack_push (GTrashStack **stack_p,
      gpointer data_p)
{
  GTrashStack *data = (GTrashStack *) data_p;

  data->next = *stack_p;
  *stack_p = data;
}
extern inline gpointer
g_trash_stack_pop (GTrashStack **stack_p)
{
  GTrashStack *data;

  data = *stack_p;
  if (data)
    {
      *stack_p = data->next;



      data->next = ((void *)0);
    }

  return data;
}
extern inline gpointer
g_trash_stack_peek (GTrashStack **stack_p)
{
  GTrashStack *data;

  data = *stack_p;

  return data;
}
extern inline guint
g_trash_stack_height (GTrashStack **stack_p)
{
  GTrashStack *data;
  guint i = 0;

  for (data = *stack_p; data; data = data->next)
    i++;

  return i;
}






extern const guint glib_major_version;
extern const guint glib_minor_version;
extern const guint glib_micro_version;
extern const guint glib_interface_age;
extern const guint glib_binary_age;

const gchar * glib_check_version (guint required_major,
                                  guint required_minor,
                                  guint required_micro);








# 33 "/usr/include/glib-2.0/glib/gstring.h" 2



typedef struct _GString GString;
typedef struct _GStringChunk GStringChunk;

struct _GString
{
  gchar *str;
  gsize len;
  gsize allocated_len;
};



GStringChunk* g_string_chunk_new (gsize size);
void g_string_chunk_free (GStringChunk *chunk);
gchar* g_string_chunk_insert (GStringChunk *chunk,
         const gchar *string);
gchar* g_string_chunk_insert_len (GStringChunk *chunk,
         const gchar *string,
         gssize len);
gchar* g_string_chunk_insert_const (GStringChunk *chunk,
         const gchar *string);




GString* g_string_new (const gchar *init);
GString* g_string_new_len (const gchar *init,
                                         gssize len);
GString* g_string_sized_new (gsize dfl_size);
gchar* g_string_free (GString *string,
      gboolean free_segment);
gboolean g_string_equal (const GString *v,
      const GString *v2);
guint g_string_hash (const GString *str);
GString* g_string_assign (GString *string,
      const gchar *rval);
GString* g_string_truncate (GString *string,
      gsize len);
GString* g_string_set_size (GString *string,
      gsize len);
GString* g_string_insert_len (GString *string,
                                         gssize pos,
                                         const gchar *val,
                                         gssize len);
GString* g_string_append (GString *string,
                    const gchar *val);
GString* g_string_append_len (GString *string,
                    const gchar *val,
                                         gssize len);
GString* g_string_append_c (GString *string,
      gchar c);
GString* g_string_append_unichar (GString *string,
      gunichar wc);
GString* g_string_prepend (GString *string,
      const gchar *val);
GString* g_string_prepend_c (GString *string,
      gchar c);
GString* g_string_prepend_unichar (GString *string,
      gunichar wc);
GString* g_string_prepend_len (GString *string,
                    const gchar *val,
                                         gssize len);
GString* g_string_insert (GString *string,
      gssize pos,
      const gchar *val);
GString* g_string_insert_c (GString *string,
      gssize pos,
      gchar c);
GString* g_string_insert_unichar (GString *string,
      gssize pos,
      gunichar wc);
GString* g_string_erase (GString *string,
      gssize pos,
      gssize len);
GString* g_string_ascii_down (GString *string);
GString* g_string_ascii_up (GString *string);
void g_string_printf (GString *string,
      const gchar *format,
      ...) __attribute__((__format__ (__printf__, 2, 3)));
void g_string_append_printf (GString *string,
      const gchar *format,
      ...) __attribute__((__format__ (__printf__, 2, 3)));



static inline GString*
g_string_append_c_inline (GString *gstring,
                          gchar c)
{
  if (gstring->len + 1 < gstring->allocated_len)
    {
      gstring->str[gstring->len++] = c;
      gstring->str[gstring->len] = 0;
    }
  else
    g_string_insert_c (gstring, -1, c);
  return gstring;
}
# 145 "/usr/include/glib-2.0/glib/gstring.h"
GString* g_string_down (GString *string);
GString* g_string_up (GString *string);








# 33 "/usr/include/glib-2.0/glib/giochannel.h" 2






typedef struct _GIOChannel GIOChannel;
typedef struct _GIOFuncs GIOFuncs;

typedef enum
{
  G_IO_ERROR_NONE,
  G_IO_ERROR_AGAIN,
  G_IO_ERROR_INVAL,
  G_IO_ERROR_UNKNOWN
} GIOError;



typedef enum
{

  G_IO_CHANNEL_ERROR_FBIG,
  G_IO_CHANNEL_ERROR_INVAL,
  G_IO_CHANNEL_ERROR_IO,
  G_IO_CHANNEL_ERROR_ISDIR,
  G_IO_CHANNEL_ERROR_NOSPC,
  G_IO_CHANNEL_ERROR_NXIO,
  G_IO_CHANNEL_ERROR_OVERFLOW,
  G_IO_CHANNEL_ERROR_PIPE,

  G_IO_CHANNEL_ERROR_FAILED
} GIOChannelError;

typedef enum
{
  G_IO_STATUS_ERROR,
  G_IO_STATUS_NORMAL,
  G_IO_STATUS_EOF,
  G_IO_STATUS_AGAIN
} GIOStatus;

typedef enum
{
  G_SEEK_CUR,
  G_SEEK_SET,
  G_SEEK_END
} GSeekType;

typedef enum
{
  G_IO_IN =1,
  G_IO_OUT =4,
  G_IO_PRI =2,
  G_IO_ERR =8,
  G_IO_HUP =16,
  G_IO_NVAL =32
} GIOCondition;

typedef enum
{
  G_IO_FLAG_APPEND = 1 << 0,
  G_IO_FLAG_NONBLOCK = 1 << 1,
  G_IO_FLAG_IS_READABLE = 1 << 2,
  G_IO_FLAG_IS_WRITEABLE = 1 << 3,
  G_IO_FLAG_IS_SEEKABLE = 1 << 4,
  G_IO_FLAG_MASK = (1 << 5) - 1,
  G_IO_FLAG_GET_MASK = G_IO_FLAG_MASK,
  G_IO_FLAG_SET_MASK = G_IO_FLAG_APPEND | G_IO_FLAG_NONBLOCK
} GIOFlags;

struct _GIOChannel
{

  guint ref_count;
  GIOFuncs *funcs;

  gchar *encoding;
  GIConv read_cd;
  GIConv write_cd;
  gchar *line_term;
  guint line_term_len;

  gsize buf_size;
  GString *read_buf;
  GString *encoded_read_buf;
  GString *write_buf;
  gchar partial_write_buf[6];



  guint use_buffer : 1;
  guint do_encode : 1;
  guint close_on_unref : 1;
  guint is_readable : 1;
  guint is_writeable : 1;
  guint is_seekable : 1;

  gpointer reserved1;
  gpointer reserved2;
};

typedef gboolean (*GIOFunc) (GIOChannel *source,
        GIOCondition condition,
        gpointer data);
struct _GIOFuncs
{
  GIOStatus (*io_read) (GIOChannel *channel,
             gchar *buf,
      gsize count,
      gsize *bytes_read,
      GError **err);
  GIOStatus (*io_write) (GIOChannel *channel,
      const gchar *buf,
      gsize count,
      gsize *bytes_written,
      GError **err);
  GIOStatus (*io_seek) (GIOChannel *channel,
      gint64 offset,
      GSeekType type,
      GError **err);
  GIOStatus (*io_close) (GIOChannel *channel,
      GError **err);
  GSource* (*io_create_watch) (GIOChannel *channel,
      GIOCondition condition);
  void (*io_free) (GIOChannel *channel);
  GIOStatus (*io_set_flags) (GIOChannel *channel,
                                  GIOFlags flags,
      GError **err);
  GIOFlags (*io_get_flags) (GIOChannel *channel);
};

void g_io_channel_init (GIOChannel *channel);
GIOChannel *g_io_channel_ref (GIOChannel *channel);
void g_io_channel_unref (GIOChannel *channel);


GIOError g_io_channel_read (GIOChannel *channel,
            gchar *buf,
            gsize count,
            gsize *bytes_read);
GIOError g_io_channel_write (GIOChannel *channel,
            const gchar *buf,
            gsize count,
            gsize *bytes_written);
GIOError g_io_channel_seek (GIOChannel *channel,
            gint64 offset,
            GSeekType type);
void g_io_channel_close (GIOChannel *channel);


GIOStatus g_io_channel_shutdown (GIOChannel *channel,
     gboolean flush,
     GError **err);
guint g_io_add_watch_full (GIOChannel *channel,
     gint priority,
     GIOCondition condition,
     GIOFunc func,
     gpointer user_data,
     GDestroyNotify notify);
GSource * g_io_create_watch (GIOChannel *channel,
     GIOCondition condition);
guint g_io_add_watch (GIOChannel *channel,
     GIOCondition condition,
     GIOFunc func,
     gpointer user_data);




void g_io_channel_set_buffer_size (GIOChannel *channel,
        gsize size);
gsize g_io_channel_get_buffer_size (GIOChannel *channel);
GIOCondition g_io_channel_get_buffer_condition (GIOChannel *channel);
GIOStatus g_io_channel_set_flags (GIOChannel *channel,
        GIOFlags flags,
        GError **error);
GIOFlags g_io_channel_get_flags (GIOChannel *channel);
void g_io_channel_set_line_term (GIOChannel *channel,
        const gchar *line_term,
        gint length);
const gchar* g_io_channel_get_line_term (GIOChannel *channel,
        gint *length);
void g_io_channel_set_buffered (GIOChannel *channel,
        gboolean buffered);
gboolean g_io_channel_get_buffered (GIOChannel *channel);
GIOStatus g_io_channel_set_encoding (GIOChannel *channel,
        const gchar *encoding,
        GError **error);
const gchar* g_io_channel_get_encoding (GIOChannel *channel);
void g_io_channel_set_close_on_unref (GIOChannel *channel,
        gboolean do_close);
gboolean g_io_channel_get_close_on_unref (GIOChannel *channel);


GIOStatus g_io_channel_flush (GIOChannel *channel,
        GError **error);
GIOStatus g_io_channel_read_line (GIOChannel *channel,
        gchar **str_return,
        gsize *length,
        gsize *terminator_pos,
        GError **error);
GIOStatus g_io_channel_read_line_string (GIOChannel *channel,
        GString *buffer,
        gsize *terminator_pos,
        GError **error);
GIOStatus g_io_channel_read_to_end (GIOChannel *channel,
        gchar **str_return,
        gsize *length,
        GError **error);
GIOStatus g_io_channel_read_chars (GIOChannel *channel,
        gchar *buf,
        gsize count,
        gsize *bytes_read,
        GError **error);
GIOStatus g_io_channel_read_unichar (GIOChannel *channel,
        gunichar *thechar,
        GError **error);
GIOStatus g_io_channel_write_chars (GIOChannel *channel,
        const gchar *buf,
        gssize count,
        gsize *bytes_written,
        GError **error);
GIOStatus g_io_channel_write_unichar (GIOChannel *channel,
        gunichar thechar,
        GError **error);
GIOStatus g_io_channel_seek_position (GIOChannel *channel,
        gint64 offset,
        GSeekType type,
        GError **error);




GIOChannel* g_io_channel_new_file (const gchar *filename,
        const gchar *mode,
        GError **error);



GQuark g_io_channel_error_quark (void);
GIOChannelError g_io_channel_error_from_errno (gint en);
# 294 "/usr/include/glib-2.0/glib/giochannel.h"
GIOChannel* g_io_channel_unix_new (int fd);
gint g_io_channel_unix_get_fd (GIOChannel *channel);



extern GSourceFuncs g_io_watch_funcs;
# 352 "/usr/include/glib-2.0/glib/giochannel.h"

# 46 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/gkeyfile.h" 1
# 28 "/usr/include/glib-2.0/glib/gkeyfile.h"


typedef enum
{
  G_KEY_FILE_ERROR_UNKNOWN_ENCODING,
  G_KEY_FILE_ERROR_PARSE,
  G_KEY_FILE_ERROR_NOT_FOUND,
  G_KEY_FILE_ERROR_KEY_NOT_FOUND,
  G_KEY_FILE_ERROR_GROUP_NOT_FOUND,
  G_KEY_FILE_ERROR_INVALID_VALUE
} GKeyFileError;



GQuark g_key_file_error_quark (void);

typedef struct _GKeyFile GKeyFile;

typedef enum
{
  G_KEY_FILE_NONE = 0,
  G_KEY_FILE_KEEP_COMMENTS = 1 << 0,
  G_KEY_FILE_KEEP_TRANSLATIONS = 1 << 1
} GKeyFileFlags;

GKeyFile *g_key_file_new (void);
void g_key_file_free (GKeyFile *key_file);
void g_key_file_set_list_separator (GKeyFile *key_file,
          gchar separator);
gboolean g_key_file_load_from_file (GKeyFile *key_file,
          const gchar *file,
          GKeyFileFlags flags,
          GError **error);
gboolean g_key_file_load_from_data (GKeyFile *key_file,
          const gchar *data,
          gsize length,
          GKeyFileFlags flags,
          GError **error);
gboolean g_key_file_load_from_data_dirs (GKeyFile *key_file,
          const gchar *file,
          gchar **full_path,
          GKeyFileFlags flags,
          GError **error);
gchar *g_key_file_to_data (GKeyFile *key_file,
          gsize *length,
          GError **error) __attribute__((__malloc__));
gchar *g_key_file_get_start_group (GKeyFile *key_file) __attribute__((__malloc__));
gchar **g_key_file_get_groups (GKeyFile *key_file,
          gsize *length) __attribute__((__malloc__));
gchar **g_key_file_get_keys (GKeyFile *key_file,
          const gchar *group_name,
          gsize *length,
          GError **error) __attribute__((__malloc__));
gboolean g_key_file_has_group (GKeyFile *key_file,
          const gchar *group_name);
gboolean g_key_file_has_key (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          GError **error);
gchar *g_key_file_get_value (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          GError **error) __attribute__((__malloc__));
void g_key_file_set_value (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          const gchar *value);
gchar *g_key_file_get_string (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          GError **error) __attribute__((__malloc__));
void g_key_file_set_string (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          const gchar *string);
gchar *g_key_file_get_locale_string (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          const gchar *locale,
          GError **error) __attribute__((__malloc__));
void g_key_file_set_locale_string (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          const gchar *locale,
          const gchar *string);
gboolean g_key_file_get_boolean (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          GError **error);
void g_key_file_set_boolean (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          gboolean value);
gint g_key_file_get_integer (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          GError **error);
void g_key_file_set_integer (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          gint value);
gchar **g_key_file_get_string_list (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          gsize *length,
          GError **error) __attribute__((__malloc__));
void g_key_file_set_string_list (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          const gchar * const list[],
          gsize length);
gchar **g_key_file_get_locale_string_list (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          const gchar *locale,
          gsize *length,
          GError **error) __attribute__((__malloc__));
void g_key_file_set_locale_string_list (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          const gchar *locale,
          const gchar * const list[],
          gsize length);
gboolean *g_key_file_get_boolean_list (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          gsize *length,
          GError **error) __attribute__((__malloc__));
void g_key_file_set_boolean_list (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          gboolean list[],
          gsize length);
gint *g_key_file_get_integer_list (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          gsize *length,
          GError **error) __attribute__((__malloc__));
void g_key_file_set_integer_list (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          gint list[],
          gsize length);
void g_key_file_set_comment (GKeyFile *key_file,
                                             const gchar *group_name,
                                             const gchar *key,
                                             const gchar *comment,
                                             GError **error);
gchar *g_key_file_get_comment (GKeyFile *key_file,
                                             const gchar *group_name,
                                             const gchar *key,
                                             GError **error) __attribute__((__malloc__));

void g_key_file_remove_comment (GKeyFile *key_file,
                                             const gchar *group_name,
                                             const gchar *key,
          GError **error);
void g_key_file_remove_key (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          GError **error);
void g_key_file_remove_group (GKeyFile *key_file,
          const gchar *group_name,
          GError **error);


# 47 "/usr/include/glib-2.0/glib.h" 2



# 1 "/usr/include/glib-2.0/glib/gmappedfile.h" 1
# 26 "/usr/include/glib-2.0/glib/gmappedfile.h"


typedef struct _GMappedFile GMappedFile;

GMappedFile *g_mapped_file_new (const gchar *filename,
             gboolean writable,
             GError **error) __attribute__((__malloc__));
gsize g_mapped_file_get_length (GMappedFile *file);
gchar *g_mapped_file_get_contents (GMappedFile *file);
void g_mapped_file_free (GMappedFile *file);


# 51 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/gmarkup.h" 1
# 28 "/usr/include/glib-2.0/glib/gmarkup.h"


typedef enum
{
  G_MARKUP_ERROR_BAD_UTF8,
  G_MARKUP_ERROR_EMPTY,
  G_MARKUP_ERROR_PARSE,



  G_MARKUP_ERROR_UNKNOWN_ELEMENT,
  G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE,
  G_MARKUP_ERROR_INVALID_CONTENT
} GMarkupError;



GQuark g_markup_error_quark (void);

typedef enum
{

  G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG = 1 << 0

} GMarkupParseFlags;

typedef struct _GMarkupParseContext GMarkupParseContext;
typedef struct _GMarkupParser GMarkupParser;

struct _GMarkupParser
{

  void (*start_element) (GMarkupParseContext *context,
                          const gchar *element_name,
                          const gchar **attribute_names,
                          const gchar **attribute_values,
                          gpointer user_data,
                          GError **error);


  void (*end_element) (GMarkupParseContext *context,
                          const gchar *element_name,
                          gpointer user_data,
                          GError **error);



  void (*text) (GMarkupParseContext *context,
                          const gchar *text,
                          gsize text_len,
                          gpointer user_data,
                          GError **error);






  void (*passthrough) (GMarkupParseContext *context,
                          const gchar *passthrough_text,
                          gsize text_len,
                          gpointer user_data,
                          GError **error);




  void (*error) (GMarkupParseContext *context,
                          GError *error,
                          gpointer user_data);
};

GMarkupParseContext *g_markup_parse_context_new (const GMarkupParser *parser,
                                                   GMarkupParseFlags flags,
                                                   gpointer user_data,
                                                   GDestroyNotify user_data_dnotify);
void g_markup_parse_context_free (GMarkupParseContext *context);
gboolean g_markup_parse_context_parse (GMarkupParseContext *context,
                                                   const gchar *text,
                                                   gssize text_len,
                                                   GError **error);

gboolean g_markup_parse_context_end_parse (GMarkupParseContext *context,
                                                       GError **error);
const gchar *g_markup_parse_context_get_element (GMarkupParseContext *context);


void g_markup_parse_context_get_position (GMarkupParseContext *context,
                                                          gint *line_number,
                                                          gint *char_number);


gchar* g_markup_escape_text (const gchar *text,
                             gssize length);

gchar *g_markup_printf_escaped (const char *format,
    ...) __attribute__((__format__ (__printf__, 1, 2)));
gchar *g_markup_vprintf_escaped (const char *format,
     va_list args);


# 52 "/usr/include/glib-2.0/glib.h" 2

# 1 "/usr/include/glib-2.0/glib/gmessages.h" 1
# 37 "/usr/include/glib-2.0/glib/gmessages.h"
       
# 38 "/usr/include/glib-2.0/glib/gmessages.h" 3






gsize g_printf_string_upper_bound (const gchar* format,
         va_list args);
# 54 "/usr/include/glib-2.0/glib/gmessages.h" 3
typedef enum
{

  G_LOG_FLAG_RECURSION = 1 << 0,
  G_LOG_FLAG_FATAL = 1 << 1,


  G_LOG_LEVEL_ERROR = 1 << 2,
  G_LOG_LEVEL_CRITICAL = 1 << 3,
  G_LOG_LEVEL_WARNING = 1 << 4,
  G_LOG_LEVEL_MESSAGE = 1 << 5,
  G_LOG_LEVEL_INFO = 1 << 6,
  G_LOG_LEVEL_DEBUG = 1 << 7,

  G_LOG_LEVEL_MASK = ~(G_LOG_FLAG_RECURSION | G_LOG_FLAG_FATAL)
} GLogLevelFlags;




typedef void (*GLogFunc) (const gchar *log_domain,
                                                 GLogLevelFlags log_level,
                                                 const gchar *message,
                                                 gpointer user_data);



guint g_log_set_handler (const gchar *log_domain,
                                         GLogLevelFlags log_levels,
                                         GLogFunc log_func,
                                         gpointer user_data);
void g_log_remove_handler (const gchar *log_domain,
                                         guint handler_id);
void g_log_default_handler (const gchar *log_domain,
                                         GLogLevelFlags log_level,
                                         const gchar *message,
                                         gpointer unused_data);
GLogFunc g_log_set_default_handler (GLogFunc log_func,
        gpointer user_data);
void g_log (const gchar *log_domain,
                                         GLogLevelFlags log_level,
                                         const gchar *format,
                                         ...) __attribute__((__format__ (__printf__, 3, 4)));
void g_logv (const gchar *log_domain,
                                         GLogLevelFlags log_level,
                                         const gchar *format,
                                         va_list args);
GLogLevelFlags g_log_set_fatal_mask (const gchar *log_domain,
                                         GLogLevelFlags fatal_mask);
GLogLevelFlags g_log_set_always_fatal (GLogLevelFlags fatal_mask);


void _g_log_fallback_handler (const gchar *log_domain,
     GLogLevelFlags log_level,
     const gchar *message,
     gpointer unused_data) __attribute__((visibility("hidden")));


void g_return_if_fail_warning (const char *log_domain,
          const char *pretty_function,
          const char *expression);
void g_assert_warning (const char *log_domain,
          const char *file,
          const int line,
                 const char *pretty_function,
                 const char *expression) __attribute__((__noreturn__));
# 205 "/usr/include/glib-2.0/glib/gmessages.h" 3
typedef void (*GPrintFunc) (const gchar *string);
void g_print (const gchar *format,
                                         ...) __attribute__((__format__ (__printf__, 1, 2)));
GPrintFunc g_set_print_handler (GPrintFunc func);
void g_printerr (const gchar *format,
                                         ...) __attribute__((__format__ (__printf__, 1, 2)));
GPrintFunc g_set_printerr_handler (GPrintFunc func);
# 361 "/usr/include/glib-2.0/glib/gmessages.h" 3

# 54 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/gnode.h" 1
# 32 "/usr/include/glib-2.0/glib/gnode.h"


typedef struct _GNode GNode;


typedef enum
{
  G_TRAVERSE_LEAVES = 1 << 0,
  G_TRAVERSE_NON_LEAVES = 1 << 1,
  G_TRAVERSE_ALL = G_TRAVERSE_LEAVES | G_TRAVERSE_NON_LEAVES,
  G_TRAVERSE_MASK = 0x03,
  G_TRAVERSE_LEAFS = G_TRAVERSE_LEAVES,
  G_TRAVERSE_NON_LEAFS = G_TRAVERSE_NON_LEAVES
} GTraverseFlags;


typedef enum
{
  G_IN_ORDER,
  G_PRE_ORDER,
  G_POST_ORDER,
  G_LEVEL_ORDER
} GTraverseType;

typedef gboolean (*GNodeTraverseFunc) (GNode *node,
       gpointer data);
typedef void (*GNodeForeachFunc) (GNode *node,
       gpointer data);
typedef gpointer (*GCopyFunc) (gconstpointer src,
                                                 gpointer data);



struct _GNode
{
  gpointer data;
  GNode *next;
  GNode *prev;
  GNode *parent;
  GNode *children;
};






GNode* g_node_new (gpointer data);
void g_node_destroy (GNode *root);
void g_node_unlink (GNode *node);
GNode* g_node_copy_deep (GNode *node,
     GCopyFunc copy_func,
     gpointer data);
GNode* g_node_copy (GNode *node);
GNode* g_node_insert (GNode *parent,
     gint position,
     GNode *node);
GNode* g_node_insert_before (GNode *parent,
     GNode *sibling,
     GNode *node);
GNode* g_node_insert_after (GNode *parent,
     GNode *sibling,
     GNode *node);
GNode* g_node_prepend (GNode *parent,
     GNode *node);
guint g_node_n_nodes (GNode *root,
     GTraverseFlags flags);
GNode* g_node_get_root (GNode *node);
gboolean g_node_is_ancestor (GNode *node,
     GNode *descendant);
guint g_node_depth (GNode *node);
GNode* g_node_find (GNode *root,
     GTraverseType order,
     GTraverseFlags flags,
     gpointer data);
# 125 "/usr/include/glib-2.0/glib/gnode.h"
void g_node_traverse (GNode *root,
     GTraverseType order,
     GTraverseFlags flags,
     gint max_depth,
     GNodeTraverseFunc func,
     gpointer data);






guint g_node_max_height (GNode *root);

void g_node_children_foreach (GNode *node,
      GTraverseFlags flags,
      GNodeForeachFunc func,
      gpointer data);
void g_node_reverse_children (GNode *node);
guint g_node_n_children (GNode *node);
GNode* g_node_nth_child (GNode *node,
      guint n);
GNode* g_node_last_child (GNode *node);
GNode* g_node_find_child (GNode *node,
      GTraverseFlags flags,
      gpointer data);
gint g_node_child_position (GNode *node,
      GNode *child);
gint g_node_child_index (GNode *node,
      gpointer data);

GNode* g_node_first_sibling (GNode *node);
GNode* g_node_last_sibling (GNode *node);
# 167 "/usr/include/glib-2.0/glib/gnode.h"
void g_node_push_allocator (gpointer dummy);
void g_node_pop_allocator (void);


# 55 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/goption.h" 1
# 27 "/usr/include/glib-2.0/glib/goption.h"


typedef struct _GOptionContext GOptionContext;
typedef struct _GOptionGroup GOptionGroup;
typedef struct _GOptionEntry GOptionEntry;

typedef enum
{
  G_OPTION_FLAG_HIDDEN = 1 << 0,
  G_OPTION_FLAG_IN_MAIN = 1 << 1,
  G_OPTION_FLAG_REVERSE = 1 << 2,
  G_OPTION_FLAG_NO_ARG = 1 << 3,
  G_OPTION_FLAG_FILENAME = 1 << 4,
  G_OPTION_FLAG_OPTIONAL_ARG = 1 << 5,
  G_OPTION_FLAG_NOALIAS = 1 << 6
} GOptionFlags;

typedef enum
{
  G_OPTION_ARG_NONE,
  G_OPTION_ARG_STRING,
  G_OPTION_ARG_INT,
  G_OPTION_ARG_CALLBACK,
  G_OPTION_ARG_FILENAME,
  G_OPTION_ARG_STRING_ARRAY,
  G_OPTION_ARG_FILENAME_ARRAY
} GOptionArg;

typedef gboolean (*GOptionArgFunc) (const gchar *option_name,
        const gchar *value,
        gpointer data,
        GError **error);

typedef gboolean (*GOptionParseFunc) (GOptionContext *context,
          GOptionGroup *group,
          gpointer data,
          GError **error);

typedef void (*GOptionErrorFunc) (GOptionContext *context,
      GOptionGroup *group,
      gpointer data,
      GError **error);



typedef enum
{
  G_OPTION_ERROR_UNKNOWN_OPTION,
  G_OPTION_ERROR_BAD_VALUE,
  G_OPTION_ERROR_FAILED
} GOptionError;

GQuark g_option_error_quark (void);


struct _GOptionEntry
{
  const gchar *long_name;
  gchar short_name;
  gint flags;

  GOptionArg arg;
  gpointer arg_data;

  const gchar *description;
  const gchar *arg_description;
};



GOptionContext *g_option_context_new (const gchar *parameter_string);
void g_option_context_free (GOptionContext *context);
void g_option_context_set_help_enabled (GOptionContext *context,
         gboolean help_enabled);
gboolean g_option_context_get_help_enabled (GOptionContext *context);
void g_option_context_set_ignore_unknown_options (GOptionContext *context,
            gboolean ignore_unknown);
gboolean g_option_context_get_ignore_unknown_options (GOptionContext *context);

void g_option_context_add_main_entries (GOptionContext *context,
         const GOptionEntry *entries,
         const gchar *translation_domain);
gboolean g_option_context_parse (GOptionContext *context,
         gint *argc,
         gchar ***argv,
         GError **error);

void g_option_context_add_group (GOptionContext *context,
            GOptionGroup *group);
void g_option_context_set_main_group (GOptionContext *context,
            GOptionGroup *group);
GOptionGroup *g_option_context_get_main_group (GOptionContext *context);


GOptionGroup *g_option_group_new (const gchar *name,
           const gchar *description,
           const gchar *help_description,
           gpointer user_data,
           GDestroyNotify destroy);
void g_option_group_set_parse_hooks (GOptionGroup *group,
           GOptionParseFunc pre_parse_func,
           GOptionParseFunc post_parse_func);
void g_option_group_set_error_hook (GOptionGroup *group,
           GOptionErrorFunc error_func);
void g_option_group_free (GOptionGroup *group);
void g_option_group_add_entries (GOptionGroup *group,
           const GOptionEntry *entries);
void g_option_group_set_translate_func (GOptionGroup *group,
           GTranslateFunc func,
           gpointer data,
           GDestroyNotify destroy_notify);
void g_option_group_set_translation_domain (GOptionGroup *group,
           const gchar *domain);



# 56 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/gpattern.h" 1
# 24 "/usr/include/glib-2.0/glib/gpattern.h"



typedef struct _GPatternSpec GPatternSpec;

GPatternSpec* g_pattern_spec_new (const gchar *pattern);
void g_pattern_spec_free (GPatternSpec *pspec);
gboolean g_pattern_spec_equal (GPatternSpec *pspec1,
     GPatternSpec *pspec2);
gboolean g_pattern_match (GPatternSpec *pspec,
     guint string_length,
     const gchar *string,
     const gchar *string_reversed);
gboolean g_pattern_match_string (GPatternSpec *pspec,
     const gchar *string);
gboolean g_pattern_match_simple (const gchar *pattern,
     const gchar *string);


# 57 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/gprimes.h" 1
# 32 "/usr/include/glib-2.0/glib/gprimes.h"

# 43 "/usr/include/glib-2.0/glib/gprimes.h"
guint g_spaced_primes_closest (guint num) __attribute__((__const__));


# 58 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/gqsort.h" 1
# 33 "/usr/include/glib-2.0/glib/gqsort.h"


void g_qsort_with_data (gconstpointer pbase,
   gint total_elems,
   gsize size,
   GCompareDataFunc compare_func,
   gpointer user_data);


# 59 "/usr/include/glib-2.0/glib.h" 2

# 1 "/usr/include/glib-2.0/glib/gqueue.h" 1
# 32 "/usr/include/glib-2.0/glib/gqueue.h"


typedef struct _GQueue GQueue;

struct _GQueue
{
  GList *head;
  GList *tail;
  guint length;
};



GQueue* g_queue_new (void);
void g_queue_free (GQueue *queue);
gboolean g_queue_is_empty (GQueue *queue);
guint g_queue_get_length (GQueue *queue);
void g_queue_reverse (GQueue *queue);
GQueue * g_queue_copy (GQueue *queue);
void g_queue_foreach (GQueue *queue,
     GFunc func,
     gpointer user_data);
GList * g_queue_find (GQueue *queue,
     gconstpointer data);
GList * g_queue_find_custom (GQueue *queue,
     gconstpointer data,
     GCompareFunc func);
void g_queue_sort (GQueue *queue,
     GCompareDataFunc compare_func,
     gpointer user_data);

void g_queue_push_head (GQueue *queue,
     gpointer data);
void g_queue_push_tail (GQueue *queue,
     gpointer data);
void g_queue_push_nth (GQueue *queue,
     gpointer data,
     gint n);
gpointer g_queue_pop_head (GQueue *queue);
gpointer g_queue_pop_tail (GQueue *queue);
gpointer g_queue_pop_nth (GQueue *queue,
     guint n);
gpointer g_queue_peek_head (GQueue *queue);
gpointer g_queue_peek_tail (GQueue *queue);
gpointer g_queue_peek_nth (GQueue *queue,
     guint n);
gint g_queue_index (GQueue *queue,
     gconstpointer data);
void g_queue_remove (GQueue *queue,
     gconstpointer data);
void g_queue_remove_all (GQueue *queue,
     gconstpointer data);
void g_queue_insert_before (GQueue *queue,
     GList *sibling,
     gpointer data);
void g_queue_insert_after (GQueue *queue,
     GList *sibling,
     gpointer data);
void g_queue_insert_sorted (GQueue *queue,
     gpointer data,
     GCompareDataFunc func,
     gpointer user_data);

void g_queue_push_head_link (GQueue *queue,
     GList *link_);
void g_queue_push_tail_link (GQueue *queue,
     GList *link_);
void g_queue_push_nth_link (GQueue *queue,
     gint n,
     GList *link_);
GList* g_queue_pop_head_link (GQueue *queue);
GList* g_queue_pop_tail_link (GQueue *queue);
GList* g_queue_pop_nth_link (GQueue *queue,
     guint n);
GList* g_queue_peek_head_link (GQueue *queue);
GList* g_queue_peek_tail_link (GQueue *queue);
GList* g_queue_peek_nth_link (GQueue *queue,
     guint n);
gint g_queue_link_index (GQueue *queue,
     GList *link_);
void g_queue_unlink (GQueue *queue,
     GList *link_);
void g_queue_delete_link (GQueue *queue,
     GList *link_);


# 61 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/grand.h" 1
# 32 "/usr/include/glib-2.0/glib/grand.h"


typedef struct _GRand GRand;
# 45 "/usr/include/glib-2.0/glib/grand.h"
GRand* g_rand_new_with_seed (guint32 seed);
GRand* g_rand_new_with_seed_array (const guint32 *seed,
        guint seed_length);
GRand* g_rand_new (void);
void g_rand_free (GRand *rand_);
GRand* g_rand_copy (GRand *rand_);
void g_rand_set_seed (GRand *rand_,
          guint32 seed);
void g_rand_set_seed_array (GRand *rand_,
          const guint32 *seed,
          guint seed_length);



guint32 g_rand_int (GRand *rand_);
gint32 g_rand_int_range (GRand *rand_,
          gint32 begin,
          gint32 end);
gdouble g_rand_double (GRand *rand_);
gdouble g_rand_double_range (GRand *rand_,
          gdouble begin,
          gdouble end);
void g_random_set_seed (guint32 seed);



guint32 g_random_int (void);
gint32 g_random_int_range (gint32 begin,
          gint32 end);
gdouble g_random_double (void);
gdouble g_random_double_range (gdouble begin,
          gdouble end);



# 62 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/grel.h" 1
# 32 "/usr/include/glib-2.0/glib/grel.h"


typedef struct _GRelation GRelation;
typedef struct _GTuples GTuples;

struct _GTuples
{
  guint len;
};
# 65 "/usr/include/glib-2.0/glib/grel.h"
GRelation* g_relation_new (gint fields);
void g_relation_destroy (GRelation *relation);
void g_relation_index (GRelation *relation,
                               gint field,
                               GHashFunc hash_func,
                               GEqualFunc key_equal_func);
void g_relation_insert (GRelation *relation,
                               ...);
gint g_relation_delete (GRelation *relation,
                               gconstpointer key,
                               gint field);
GTuples* g_relation_select (GRelation *relation,
                               gconstpointer key,
                               gint field);
gint g_relation_count (GRelation *relation,
                               gconstpointer key,
                               gint field);
gboolean g_relation_exists (GRelation *relation,
                               ...);
void g_relation_print (GRelation *relation);

void g_tuples_destroy (GTuples *tuples);
gpointer g_tuples_index (GTuples *tuples,
                               gint index_,
                               gint field);


# 63 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/gscanner.h" 1
# 33 "/usr/include/glib-2.0/glib/gscanner.h"


typedef struct _GScanner GScanner;
typedef struct _GScannerConfig GScannerConfig;
typedef union _GTokenValue GTokenValue;

typedef void (*GScannerMsgFunc) (GScanner *scanner,
       gchar *message,
       gboolean error);
# 60 "/usr/include/glib-2.0/glib/gscanner.h"
typedef enum
{
  G_ERR_UNKNOWN,
  G_ERR_UNEXP_EOF,
  G_ERR_UNEXP_EOF_IN_STRING,
  G_ERR_UNEXP_EOF_IN_COMMENT,
  G_ERR_NON_DIGIT_IN_CONST,
  G_ERR_DIGIT_RADIX,
  G_ERR_FLOAT_RADIX,
  G_ERR_FLOAT_MALFORMED
} GErrorType;


typedef enum
{
  G_TOKEN_EOF = 0,

  G_TOKEN_LEFT_PAREN = '(',
  G_TOKEN_RIGHT_PAREN = ')',
  G_TOKEN_LEFT_CURLY = '{',
  G_TOKEN_RIGHT_CURLY = '}',
  G_TOKEN_LEFT_BRACE = '[',
  G_TOKEN_RIGHT_BRACE = ']',
  G_TOKEN_EQUAL_SIGN = '=',
  G_TOKEN_COMMA = ',',

  G_TOKEN_NONE = 256,

  G_TOKEN_ERROR,

  G_TOKEN_CHAR,
  G_TOKEN_BINARY,
  G_TOKEN_OCTAL,
  G_TOKEN_INT,
  G_TOKEN_HEX,
  G_TOKEN_FLOAT,
  G_TOKEN_STRING,

  G_TOKEN_SYMBOL,
  G_TOKEN_IDENTIFIER,
  G_TOKEN_IDENTIFIER_NULL,

  G_TOKEN_COMMENT_SINGLE,
  G_TOKEN_COMMENT_MULTI,
  G_TOKEN_LAST
} GTokenType;

union _GTokenValue
{
  gpointer v_symbol;
  gchar *v_identifier;
  gulong v_binary;
  gulong v_octal;
  gulong v_int;
  guint64 v_int64;
  gdouble v_float;
  gulong v_hex;
  gchar *v_string;
  gchar *v_comment;
  guchar v_char;
  guint v_error;
};

struct _GScannerConfig
{


  gchar *cset_skip_characters;
  gchar *cset_identifier_first;
  gchar *cset_identifier_nth;
  gchar *cpair_comment_single;



  guint case_sensitive : 1;




  guint skip_comment_multi : 1;
  guint skip_comment_single : 1;
  guint scan_comment_multi : 1;
  guint scan_identifier : 1;
  guint scan_identifier_1char : 1;
  guint scan_identifier_NULL : 1;
  guint scan_symbols : 1;
  guint scan_binary : 1;
  guint scan_octal : 1;
  guint scan_float : 1;
  guint scan_hex : 1;
  guint scan_hex_dollar : 1;
  guint scan_string_sq : 1;
  guint scan_string_dq : 1;
  guint numbers_2_int : 1;
  guint int_2_float : 1;
  guint identifier_2_string : 1;
  guint char_2_token : 1;
  guint symbol_2_token : 1;
  guint scope_0_fallback : 1;
  guint store_int64 : 1;
  guint padding_dummy;
};

struct _GScanner
{

  gpointer user_data;
  guint max_parse_errors;


  guint parse_errors;


  const gchar *input_name;


  GData *qdata;


  GScannerConfig *config;


  GTokenType token;
  GTokenValue value;
  guint line;
  guint position;


  GTokenType next_token;
  GTokenValue next_value;
  guint next_line;
  guint next_position;


  GHashTable *symbol_table;
  gint input_fd;
  const gchar *text;
  const gchar *text_end;
  gchar *buffer;
  guint scope_id;


  GScannerMsgFunc msg_handler;
};

GScanner* g_scanner_new (const GScannerConfig *config_templ);
void g_scanner_destroy (GScanner *scanner);
void g_scanner_input_file (GScanner *scanner,
       gint input_fd);
void g_scanner_sync_file_offset (GScanner *scanner);
void g_scanner_input_text (GScanner *scanner,
       const gchar *text,
       guint text_len);
GTokenType g_scanner_get_next_token (GScanner *scanner);
GTokenType g_scanner_peek_next_token (GScanner *scanner);
GTokenType g_scanner_cur_token (GScanner *scanner);
GTokenValue g_scanner_cur_value (GScanner *scanner);
guint g_scanner_cur_line (GScanner *scanner);
guint g_scanner_cur_position (GScanner *scanner);
gboolean g_scanner_eof (GScanner *scanner);
guint g_scanner_set_scope (GScanner *scanner,
       guint scope_id);
void g_scanner_scope_add_symbol (GScanner *scanner,
       guint scope_id,
       const gchar *symbol,
       gpointer value);
void g_scanner_scope_remove_symbol (GScanner *scanner,
       guint scope_id,
       const gchar *symbol);
gpointer g_scanner_scope_lookup_symbol (GScanner *scanner,
       guint scope_id,
       const gchar *symbol);
void g_scanner_scope_foreach_symbol (GScanner *scanner,
       guint scope_id,
       GHFunc func,
       gpointer user_data);
gpointer g_scanner_lookup_symbol (GScanner *scanner,
       const gchar *symbol);
void g_scanner_unexp_token (GScanner *scanner,
       GTokenType expected_token,
       const gchar *identifier_spec,
       const gchar *symbol_spec,
       const gchar *symbol_name,
       const gchar *message,
       gint is_error);
void g_scanner_error (GScanner *scanner,
       const gchar *format,
       ...) __attribute__((__format__ (__printf__, 2, 3)));
void g_scanner_warn (GScanner *scanner,
       const gchar *format,
       ...) __attribute__((__format__ (__printf__, 2, 3)));
# 272 "/usr/include/glib-2.0/glib/gscanner.h"

# 64 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/gshell.h" 1
# 26 "/usr/include/glib-2.0/glib/gshell.h"




typedef enum
{

  G_SHELL_ERROR_BAD_QUOTING,

  G_SHELL_ERROR_EMPTY_STRING,
  G_SHELL_ERROR_FAILED
} GShellError;

GQuark g_shell_error_quark (void);

gchar* g_shell_quote (const gchar *unquoted_string);
gchar* g_shell_unquote (const gchar *quoted_string,
                             GError **error);
gboolean g_shell_parse_argv (const gchar *command_line,
                             gint *argcp,
                             gchar ***argvp,
                             GError **error);


# 65 "/usr/include/glib-2.0/glib.h" 2

# 1 "/usr/include/glib-2.0/glib/gspawn.h" 1
# 26 "/usr/include/glib-2.0/glib/gspawn.h"





typedef enum
{
  G_SPAWN_ERROR_FORK,
  G_SPAWN_ERROR_READ,
  G_SPAWN_ERROR_CHDIR,
  G_SPAWN_ERROR_ACCES,
  G_SPAWN_ERROR_PERM,
  G_SPAWN_ERROR_2BIG,
  G_SPAWN_ERROR_NOEXEC,
  G_SPAWN_ERROR_NAMETOOLONG,
  G_SPAWN_ERROR_NOENT,
  G_SPAWN_ERROR_NOMEM,
  G_SPAWN_ERROR_NOTDIR,
  G_SPAWN_ERROR_LOOP,
  G_SPAWN_ERROR_TXTBUSY,
  G_SPAWN_ERROR_IO,
  G_SPAWN_ERROR_NFILE,
  G_SPAWN_ERROR_MFILE,
  G_SPAWN_ERROR_INVAL,
  G_SPAWN_ERROR_ISDIR,
  G_SPAWN_ERROR_LIBBAD,
  G_SPAWN_ERROR_FAILED


} GSpawnError;

typedef void (* GSpawnChildSetupFunc) (gpointer user_data);

typedef enum
{
  G_SPAWN_LEAVE_DESCRIPTORS_OPEN = 1 << 0,
  G_SPAWN_DO_NOT_REAP_CHILD = 1 << 1,

  G_SPAWN_SEARCH_PATH = 1 << 2,

  G_SPAWN_STDOUT_TO_DEV_NULL = 1 << 3,
  G_SPAWN_STDERR_TO_DEV_NULL = 1 << 4,
  G_SPAWN_CHILD_INHERITS_STDIN = 1 << 5,
  G_SPAWN_FILE_AND_ARGV_ZERO = 1 << 6
} GSpawnFlags;

GQuark g_spawn_error_quark (void);
# 82 "/usr/include/glib-2.0/glib/gspawn.h"
gboolean g_spawn_async (const gchar *working_directory,
                        gchar **argv,
                        gchar **envp,
                        GSpawnFlags flags,
                        GSpawnChildSetupFunc child_setup,
                        gpointer user_data,
                        GPid *child_pid,
                        GError **error);





gboolean g_spawn_async_with_pipes (const gchar *working_directory,
                                   gchar **argv,
                                   gchar **envp,
                                   GSpawnFlags flags,
                                   GSpawnChildSetupFunc child_setup,
                                   gpointer user_data,
                                   GPid *child_pid,
                                   gint *standard_input,
                                   gint *standard_output,
                                   gint *standard_error,
                                   GError **error);






gboolean g_spawn_sync (const gchar *working_directory,
                               gchar **argv,
                               gchar **envp,
                               GSpawnFlags flags,
                               GSpawnChildSetupFunc child_setup,
                               gpointer user_data,
                               gchar **standard_output,
                               gchar **standard_error,
                               gint *exit_status,
                               GError **error);

gboolean g_spawn_command_line_sync (const gchar *command_line,
                                     gchar **standard_output,
                                     gchar **standard_error,
                                     gint *exit_status,
                                     GError **error);
gboolean g_spawn_command_line_async (const gchar *command_line,
                                     GError **error);

void g_spawn_close_pid (GPid pid);



# 67 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/gstrfuncs.h" 1
# 33 "/usr/include/glib-2.0/glib/gstrfuncs.h"



typedef enum {
  G_ASCII_ALNUM = 1 << 0,
  G_ASCII_ALPHA = 1 << 1,
  G_ASCII_CNTRL = 1 << 2,
  G_ASCII_DIGIT = 1 << 3,
  G_ASCII_GRAPH = 1 << 4,
  G_ASCII_LOWER = 1 << 5,
  G_ASCII_PRINT = 1 << 6,
  G_ASCII_PUNCT = 1 << 7,
  G_ASCII_SPACE = 1 << 8,
  G_ASCII_UPPER = 1 << 9,
  G_ASCII_XDIGIT = 1 << 10
} GAsciiType;

extern const guint16 * const g_ascii_table;
# 85 "/usr/include/glib-2.0/glib/gstrfuncs.h"
gchar g_ascii_tolower (gchar c) __attribute__((__const__));
gchar g_ascii_toupper (gchar c) __attribute__((__const__));

gint g_ascii_digit_value (gchar c) __attribute__((__const__));
gint g_ascii_xdigit_value (gchar c) __attribute__((__const__));





gchar* g_strdelimit (gchar *string,
     const gchar *delimiters,
     gchar new_delimiter);
gchar* g_strcanon (gchar *string,
     const gchar *valid_chars,
     gchar substitutor);
const gchar* g_strerror (gint errnum) __attribute__((__const__));
const gchar* g_strsignal (gint signum) __attribute__((__const__));
gchar* g_strreverse (gchar *string);
gsize g_strlcpy (gchar *dest,
     const gchar *src,
     gsize dest_size);
gsize g_strlcat (gchar *dest,
     const gchar *src,
     gsize dest_size);
gchar * g_strstr_len (const gchar *haystack,
     gssize haystack_len,
     const gchar *needle);
gchar * g_strrstr (const gchar *haystack,
     const gchar *needle);
gchar * g_strrstr_len (const gchar *haystack,
     gssize haystack_len,
     const gchar *needle);

gboolean g_str_has_suffix (const gchar *str,
     const gchar *suffix);
gboolean g_str_has_prefix (const gchar *str,
     const gchar *prefix);



gdouble g_strtod (const gchar *nptr,
     gchar **endptr);
gdouble g_ascii_strtod (const gchar *nptr,
     gchar **endptr);
guint64 g_ascii_strtoull (const gchar *nptr,
     gchar **endptr,
     guint base);




gchar * g_ascii_dtostr (gchar *buffer,
     gint buf_len,
     gdouble d);
gchar * g_ascii_formatd (gchar *buffer,
     gint buf_len,
     const gchar *format,
     gdouble d);


gchar* g_strchug (gchar *string);

gchar* g_strchomp (gchar *string);



gint g_ascii_strcasecmp (const gchar *s1,
        const gchar *s2);
gint g_ascii_strncasecmp (const gchar *s1,
        const gchar *s2,
        gsize n);
gchar* g_ascii_strdown (const gchar *str,
        gssize len) __attribute__((__malloc__));
gchar* g_ascii_strup (const gchar *str,
        gssize len) __attribute__((__malloc__));
# 169 "/usr/include/glib-2.0/glib/gstrfuncs.h"
gint g_strcasecmp (const gchar *s1,
     const gchar *s2);
gint g_strncasecmp (const gchar *s1,
     const gchar *s2,
     guint n);
gchar* g_strdown (gchar *string);
gchar* g_strup (gchar *string);






gchar* g_strdup (const gchar *str) __attribute__((__malloc__));
gchar* g_strdup_printf (const gchar *format,
     ...) __attribute__((__format__ (__printf__, 1, 2))) __attribute__((__malloc__));
gchar* g_strdup_vprintf (const gchar *format,
     va_list args) __attribute__((__malloc__));
gchar* g_strndup (const gchar *str,
     gsize n) __attribute__((__malloc__));
gchar* g_strnfill (gsize length,
     gchar fill_char) __attribute__((__malloc__));
gchar* g_strconcat (const gchar *string1,
     ...) __attribute__((__malloc__)) __attribute__((__sentinel__));
gchar* g_strjoin (const gchar *separator,
     ...) __attribute__((__malloc__)) __attribute__((__sentinel__));





gchar* g_strcompress (const gchar *source) __attribute__((__malloc__));
# 210 "/usr/include/glib-2.0/glib/gstrfuncs.h"
gchar* g_strescape (const gchar *source,
     const gchar *exceptions) __attribute__((__malloc__));

gpointer g_memdup (gconstpointer mem,
     guint byte_size) __attribute__((__malloc__));
# 225 "/usr/include/glib-2.0/glib/gstrfuncs.h"
gchar** g_strsplit (const gchar *string,
     const gchar *delimiter,
     gint max_tokens) __attribute__((__malloc__));
gchar ** g_strsplit_set (const gchar *string,
     const gchar *delimiters,
     gint max_tokens) __attribute__((__malloc__));
gchar* g_strjoinv (const gchar *separator,
     gchar **str_array) __attribute__((__malloc__));
void g_strfreev (gchar **str_array);
gchar** g_strdupv (gchar **str_array) __attribute__((__malloc__));
guint g_strv_length (gchar **str_array);

gchar* g_stpcpy (gchar *dest,
                                        const char *src);

const gchar *g_strip_context (const gchar *msgid,
     const gchar *msgval);


# 68 "/usr/include/glib-2.0/glib.h" 2


# 1 "/usr/include/glib-2.0/glib/gthreadpool.h" 1
# 32 "/usr/include/glib-2.0/glib/gthreadpool.h"


typedef struct _GThreadPool GThreadPool;






struct _GThreadPool
{
  GFunc func;
  gpointer user_data;
  gboolean exclusive;
};






GThreadPool* g_thread_pool_new (GFunc func,
                                               gpointer user_data,
                                               gint max_threads,
                                               gboolean exclusive,
                                               GError **error);





void g_thread_pool_push (GThreadPool *pool,
                                               gpointer data,
                                               GError **error);




void g_thread_pool_set_max_threads (GThreadPool *pool,
                                               gint max_threads,
                                               GError **error);
gint g_thread_pool_get_max_threads (GThreadPool *pool);



guint g_thread_pool_get_num_threads (GThreadPool *pool);


guint g_thread_pool_unprocessed (GThreadPool *pool);





void g_thread_pool_free (GThreadPool *pool,
                                               gboolean immediate,
                                               gboolean wait);



void g_thread_pool_set_max_unused_threads (gint max_threads);
gint g_thread_pool_get_max_unused_threads (void);
guint g_thread_pool_get_num_unused_threads (void);


void g_thread_pool_stop_unused_threads (void);


void g_thread_pool_set_sort_function (GThreadPool *pool,
                                        GCompareDataFunc func,
            gpointer user_data);


void g_thread_pool_set_max_idle_time (guint interval);
guint g_thread_pool_get_max_idle_time (void);


# 71 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/gtimer.h" 1
# 32 "/usr/include/glib-2.0/glib/gtimer.h"






typedef struct _GTimer GTimer;



GTimer* g_timer_new (void);
void g_timer_destroy (GTimer *timer);
void g_timer_start (GTimer *timer);
void g_timer_stop (GTimer *timer);
void g_timer_reset (GTimer *timer);
void g_timer_continue (GTimer *timer);
gdouble g_timer_elapsed (GTimer *timer,
    gulong *microseconds);

void g_usleep (gulong microseconds);

void g_time_val_add (GTimeVal *time_,
                         glong microseconds);


# 72 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/gtree.h" 1
# 32 "/usr/include/glib-2.0/glib/gtree.h"


typedef struct _GTree GTree;

typedef gboolean (*GTraverseFunc) (gpointer key,
                                   gpointer value,
                                   gpointer data);



GTree* g_tree_new (GCompareFunc key_compare_func);
GTree* g_tree_new_with_data (GCompareDataFunc key_compare_func,
                                 gpointer key_compare_data);
GTree* g_tree_new_full (GCompareDataFunc key_compare_func,
                                 gpointer key_compare_data,
                                 GDestroyNotify key_destroy_func,
                                 GDestroyNotify value_destroy_func);
void g_tree_destroy (GTree *tree);
void g_tree_insert (GTree *tree,
                                 gpointer key,
                                 gpointer value);
void g_tree_replace (GTree *tree,
                                 gpointer key,
                                 gpointer value);
gboolean g_tree_remove (GTree *tree,
                                 gconstpointer key);
gboolean g_tree_steal (GTree *tree,
                                 gconstpointer key);
gpointer g_tree_lookup (GTree *tree,
                                 gconstpointer key);
gboolean g_tree_lookup_extended (GTree *tree,
                                 gconstpointer lookup_key,
                                 gpointer *orig_key,
                                 gpointer *value);
void g_tree_foreach (GTree *tree,
                                 GTraverseFunc func,
                                 gpointer user_data);


void g_tree_traverse (GTree *tree,
                                 GTraverseFunc traverse_func,
                                 GTraverseType traverse_type,
                                 gpointer user_data);


gpointer g_tree_search (GTree *tree,
                                 GCompareFunc search_func,
                                 gconstpointer user_data);
gint g_tree_height (GTree *tree);
gint g_tree_nnodes (GTree *tree);




# 73 "/usr/include/glib-2.0/glib.h" 2
# 22 "client.c" 2
# 1 "/usr/include/stdio.h" 1 3 4
# 30 "/usr/include/stdio.h" 3 4




# 1 "/usr/lib/gcc/i386-redhat-linux/4.1.0/include/stddef.h" 1 3 4
# 35 "/usr/include/stdio.h" 2 3 4
# 44 "/usr/include/stdio.h" 3 4


typedef struct _IO_FILE FILE;





# 62 "/usr/include/stdio.h" 3 4
typedef struct _IO_FILE __FILE;
# 72 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/libio.h" 1 3 4
# 32 "/usr/include/libio.h" 3 4
# 1 "/usr/include/_G_config.h" 1 3 4
# 14 "/usr/include/_G_config.h" 3 4
# 1 "/usr/lib/gcc/i386-redhat-linux/4.1.0/include/stddef.h" 1 3 4
# 355 "/usr/lib/gcc/i386-redhat-linux/4.1.0/include/stddef.h" 3 4
typedef unsigned int wint_t;
# 15 "/usr/include/_G_config.h" 2 3 4
# 24 "/usr/include/_G_config.h" 3 4
# 1 "/usr/include/wchar.h" 1 3 4
# 48 "/usr/include/wchar.h" 3 4
# 1 "/usr/lib/gcc/i386-redhat-linux/4.1.0/include/stddef.h" 1 3 4
# 49 "/usr/include/wchar.h" 2 3 4

# 1 "/usr/include/bits/wchar.h" 1 3 4
# 51 "/usr/include/wchar.h" 2 3 4
# 76 "/usr/include/wchar.h" 3 4
typedef struct
{
  int __count;
  union
  {
    wint_t __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
# 25 "/usr/include/_G_config.h" 2 3 4

typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
# 44 "/usr/include/_G_config.h" 3 4
# 1 "/usr/include/gconv.h" 1 3 4
# 28 "/usr/include/gconv.h" 3 4
# 1 "/usr/include/wchar.h" 1 3 4
# 48 "/usr/include/wchar.h" 3 4
# 1 "/usr/lib/gcc/i386-redhat-linux/4.1.0/include/stddef.h" 1 3 4
# 49 "/usr/include/wchar.h" 2 3 4
# 29 "/usr/include/gconv.h" 2 3 4


# 1 "/usr/lib/gcc/i386-redhat-linux/4.1.0/include/stddef.h" 1 3 4
# 32 "/usr/include/gconv.h" 2 3 4





enum
{
  __GCONV_OK = 0,
  __GCONV_NOCONV,
  __GCONV_NODB,
  __GCONV_NOMEM,

  __GCONV_EMPTY_INPUT,
  __GCONV_FULL_OUTPUT,
  __GCONV_ILLEGAL_INPUT,
  __GCONV_INCOMPLETE_INPUT,

  __GCONV_ILLEGAL_DESCRIPTOR,
  __GCONV_INTERNAL_ERROR
};



enum
{
  __GCONV_IS_LAST = 0x0001,
  __GCONV_IGNORE_ERRORS = 0x0002
};



struct __gconv_step;
struct __gconv_step_data;
struct __gconv_loaded_object;
struct __gconv_trans_data;



typedef int (*__gconv_fct) (struct __gconv_step *, struct __gconv_step_data *,
       __const unsigned char **, __const unsigned char *,
       unsigned char **, size_t *, int, int);


typedef wint_t (*__gconv_btowc_fct) (struct __gconv_step *, unsigned char);


typedef int (*__gconv_init_fct) (struct __gconv_step *);
typedef void (*__gconv_end_fct) (struct __gconv_step *);



typedef int (*__gconv_trans_fct) (struct __gconv_step *,
      struct __gconv_step_data *, void *,
      __const unsigned char *,
      __const unsigned char **,
      __const unsigned char *, unsigned char **,
      size_t *);


typedef int (*__gconv_trans_context_fct) (void *, __const unsigned char *,
       __const unsigned char *,
       unsigned char *, unsigned char *);


typedef int (*__gconv_trans_query_fct) (__const char *, __const char ***,
     size_t *);


typedef int (*__gconv_trans_init_fct) (void **, const char *);
typedef void (*__gconv_trans_end_fct) (void *);

struct __gconv_trans_data
{

  __gconv_trans_fct __trans_fct;
  __gconv_trans_context_fct __trans_context_fct;
  __gconv_trans_end_fct __trans_end_fct;
  void *__data;
  struct __gconv_trans_data *__next;
};



struct __gconv_step
{
  struct __gconv_loaded_object *__shlib_handle;
  __const char *__modname;

  int __counter;

  char *__from_name;
  char *__to_name;

  __gconv_fct __fct;
  __gconv_btowc_fct __btowc_fct;
  __gconv_init_fct __init_fct;
  __gconv_end_fct __end_fct;



  int __min_needed_from;
  int __max_needed_from;
  int __min_needed_to;
  int __max_needed_to;


  int __stateful;

  void *__data;
};



struct __gconv_step_data
{
  unsigned char *__outbuf;
  unsigned char *__outbufend;



  int __flags;



  int __invocation_counter;



  int __internal_use;

  __mbstate_t *__statep;
  __mbstate_t __state;



  struct __gconv_trans_data *__trans;
};



typedef struct __gconv_info
{
  size_t __nsteps;
  struct __gconv_step *__steps;
  __extension__ struct __gconv_step_data __data [];
} *__gconv_t;
# 45 "/usr/include/_G_config.h" 2 3 4
typedef union
{
  struct __gconv_info __cd;
  struct
  {
    struct __gconv_info __cd;
    struct __gconv_step_data __data;
  } __combined;
} _G_iconv_t;

typedef int _G_int16_t __attribute__ ((__mode__ (__HI__)));
typedef int _G_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int _G_uint16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int _G_uint32_t __attribute__ ((__mode__ (__SI__)));
# 33 "/usr/include/libio.h" 2 3 4
# 166 "/usr/include/libio.h" 3 4
struct _IO_jump_t; struct _IO_FILE;
# 176 "/usr/include/libio.h" 3 4
typedef void _IO_lock_t;





struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
# 199 "/usr/include/libio.h" 3 4
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
# 267 "/usr/include/libio.h" 3 4
struct _IO_FILE {
  int _flags;




  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;



  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
# 315 "/usr/include/libio.h" 3 4
  __off64_t _offset;
# 324 "/usr/include/libio.h" 3 4
  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;
  size_t __pad5;

  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};


typedef struct _IO_FILE _IO_FILE;


struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
# 360 "/usr/include/libio.h" 3 4
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, __const char *__buf,
     size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);


typedef int __io_close_fn (void *__cookie);
# 412 "/usr/include/libio.h" 3 4
extern int __underflow (_IO_FILE *) __attribute__ ((__nothrow__));
extern int __uflow (_IO_FILE *) __attribute__ ((__nothrow__));
extern int __overflow (_IO_FILE *, int) __attribute__ ((__nothrow__));
extern wint_t __wunderflow (_IO_FILE *) __attribute__ ((__nothrow__));
extern wint_t __wuflow (_IO_FILE *) __attribute__ ((__nothrow__));
extern wint_t __woverflow (_IO_FILE *, wint_t) __attribute__ ((__nothrow__));
# 450 "/usr/include/libio.h" 3 4
extern int _IO_getc (_IO_FILE *__fp) __attribute__ ((__nothrow__));
extern int _IO_putc (int __c, _IO_FILE *__fp) __attribute__ ((__nothrow__));
extern int _IO_feof (_IO_FILE *__fp) __attribute__ ((__nothrow__));
extern int _IO_ferror (_IO_FILE *__fp) __attribute__ ((__nothrow__));

extern int _IO_peekc_locked (_IO_FILE *__fp) __attribute__ ((__nothrow__));





extern void _IO_flockfile (_IO_FILE *) __attribute__ ((__nothrow__));
extern void _IO_funlockfile (_IO_FILE *) __attribute__ ((__nothrow__));
extern int _IO_ftrylockfile (_IO_FILE *) __attribute__ ((__nothrow__));
# 480 "/usr/include/libio.h" 3 4
extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
   __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
    __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t) __attribute__ ((__nothrow__));
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t) __attribute__ ((__nothrow__));

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int) __attribute__ ((__nothrow__));
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int) __attribute__ ((__nothrow__));

extern void _IO_free_backup_area (_IO_FILE *) __attribute__ ((__nothrow__));
# 73 "/usr/include/stdio.h" 2 3 4
# 86 "/usr/include/stdio.h" 3 4


typedef _G_fpos_t fpos_t;




# 138 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/bits/stdio_lim.h" 1 3 4
# 139 "/usr/include/stdio.h" 2 3 4



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;









extern int remove (__const char *__filename) __attribute__ ((__nothrow__));

extern int rename (__const char *__old, __const char *__new) __attribute__ ((__nothrow__));














extern FILE *tmpfile (void);
# 185 "/usr/include/stdio.h" 3 4
extern char *tmpnam (char *__s) __attribute__ ((__nothrow__));





extern char *tmpnam_r (char *__s) __attribute__ ((__nothrow__));
# 203 "/usr/include/stdio.h" 3 4
extern char *tempnam (__const char *__dir, __const char *__pfx)
     __attribute__ ((__nothrow__)) __attribute__ ((__malloc__));








extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);

# 228 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 242 "/usr/include/stdio.h" 3 4






extern FILE *fopen (__const char *__restrict __filename,
      __const char *__restrict __modes);




extern FILE *freopen (__const char *__restrict __filename,
        __const char *__restrict __modes,
        FILE *__restrict __stream);
# 269 "/usr/include/stdio.h" 3 4

# 280 "/usr/include/stdio.h" 3 4
extern FILE *fdopen (int __fd, __const char *__modes) __attribute__ ((__nothrow__));
# 306 "/usr/include/stdio.h" 3 4



extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __attribute__ ((__nothrow__));



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) __attribute__ ((__nothrow__));





extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) __attribute__ ((__nothrow__));


extern void setlinebuf (FILE *__stream) __attribute__ ((__nothrow__));








extern int fprintf (FILE *__restrict __stream,
      __const char *__restrict __format, ...);




extern int printf (__const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      __const char *__restrict __format, ...) __attribute__ ((__nothrow__));





extern int vfprintf (FILE *__restrict __s, __const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (__const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, __const char *__restrict __format,
       __gnuc_va_list __arg) __attribute__ ((__nothrow__));





extern int snprintf (char *__restrict __s, size_t __maxlen,
       __const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        __const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0)));

# 400 "/usr/include/stdio.h" 3 4





extern int fscanf (FILE *__restrict __stream,
     __const char *__restrict __format, ...) ;




extern int scanf (__const char *__restrict __format, ...) ;

extern int sscanf (__const char *__restrict __s,
     __const char *__restrict __format, ...) __attribute__ ((__nothrow__));

# 442 "/usr/include/stdio.h" 3 4





extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);

# 466 "/usr/include/stdio.h" 3 4
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 477 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);











extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);

# 510 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);








extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     ;






extern char *gets (char *__s) ;

# 591 "/usr/include/stdio.h" 3 4





extern int fputs (__const char *__restrict __s, FILE *__restrict __stream);





extern int puts (__const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (__const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s) ;

# 644 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (__const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream) ;








extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);

# 680 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 699 "/usr/include/stdio.h" 3 4






extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, __const fpos_t *__pos);
# 722 "/usr/include/stdio.h" 3 4

# 731 "/usr/include/stdio.h" 3 4


extern void clearerr (FILE *__stream) __attribute__ ((__nothrow__));

extern int feof (FILE *__stream) __attribute__ ((__nothrow__)) ;

extern int ferror (FILE *__stream) __attribute__ ((__nothrow__)) ;




extern void clearerr_unlocked (FILE *__stream) __attribute__ ((__nothrow__));
extern int feof_unlocked (FILE *__stream) __attribute__ ((__nothrow__)) ;
extern int ferror_unlocked (FILE *__stream) __attribute__ ((__nothrow__)) ;








extern void perror (__const char *__s);






# 1 "/usr/include/bits/sys_errlist.h" 1 3 4
# 27 "/usr/include/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern __const char *__const sys_errlist[];
# 761 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) __attribute__ ((__nothrow__)) ;




extern int fileno_unlocked (FILE *__stream) __attribute__ ((__nothrow__)) ;
# 780 "/usr/include/stdio.h" 3 4
extern FILE *popen (__const char *__command, __const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) __attribute__ ((__nothrow__));
# 820 "/usr/include/stdio.h" 3 4
extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__));



extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__)) ;


extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__));
# 841 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/bits/stdio.h" 1 3 4
# 33 "/usr/include/bits/stdio.h" 3 4
extern __inline int
vprintf (__const char *__restrict __fmt, __gnuc_va_list __arg)
{
  return vfprintf (stdout, __fmt, __arg);
}


extern __inline int
getchar (void)
{
  return _IO_getc (stdin);
}




extern __inline int
getc_unlocked (FILE *__fp)
{
  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
}


extern __inline int
getchar_unlocked (void)
{
  return (__builtin_expect (((stdin)->_IO_read_ptr >= (stdin)->_IO_read_end), 0) ? __uflow (stdin) : *(unsigned char *) (stdin)->_IO_read_ptr++);
}




extern __inline int
putchar (int __c)
{
  return _IO_putc (__c, stdout);
}




extern __inline int
fputc_unlocked (int __c, FILE *__stream)
{
  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}





extern __inline int
putc_unlocked (int __c, FILE *__stream)
{
  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}


extern __inline int
putchar_unlocked (int __c)
{
  return (__builtin_expect (((stdout)->_IO_write_ptr >= (stdout)->_IO_write_end), 0) ? __overflow (stdout, (unsigned char) (__c)) : (unsigned char) (*(stdout)->_IO_write_ptr++ = (__c)));
}
# 111 "/usr/include/bits/stdio.h" 3 4
extern __inline int
__attribute__ ((__nothrow__)) feof_unlocked (FILE *__stream)
{
  return (((__stream)->_flags & 0x10) != 0);
}


extern __inline int
__attribute__ ((__nothrow__)) ferror_unlocked (FILE *__stream)
{
  return (((__stream)->_flags & 0x20) != 0);
}
# 842 "/usr/include/stdio.h" 2 3 4
# 850 "/usr/include/stdio.h" 3 4

# 23 "client.c" 2
# 1 "/usr/include/string.h" 1 3 4
# 28 "/usr/include/string.h" 3 4





# 1 "/usr/lib/gcc/i386-redhat-linux/4.1.0/include/stddef.h" 1 3 4
# 34 "/usr/include/string.h" 2 3 4




extern void *memcpy (void *__restrict __dest,
       __const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, __const void *__src, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));






extern void *memccpy (void *__restrict __dest, __const void *__restrict __src,
        int __c, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));





extern void *memset (void *__s, int __c, size_t __n) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int memcmp (__const void *__s1, __const void *__s2, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern void *memchr (__const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));

# 82 "/usr/include/string.h" 3 4


extern char *strcpy (char *__restrict __dest, __const char *__restrict __src)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        __const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, __const char *__restrict __src)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, __const char *__restrict __src,
        size_t __n) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (__const char *__s1, __const char *__s2)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (__const char *__s1, __const char *__s2, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (__const char *__s1, __const char *__s2)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         __const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));

# 130 "/usr/include/string.h" 3 4
extern char *strdup (__const char *__s)
     __attribute__ ((__nothrow__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 165 "/usr/include/string.h" 3 4


extern char *strchr (__const char *__s, int __c)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));

extern char *strrchr (__const char *__s, int __c)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));

# 181 "/usr/include/string.h" 3 4



extern size_t strcspn (__const char *__s, __const char *__reject)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (__const char *__s, __const char *__accept)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strpbrk (__const char *__s, __const char *__accept)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strstr (__const char *__haystack, __const char *__needle)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern char *strtok (char *__restrict __s, __const char *__restrict __delim)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));




extern char *__strtok_r (char *__restrict __s,
    __const char *__restrict __delim,
    char **__restrict __save_ptr)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, __const char *__restrict __delim,
         char **__restrict __save_ptr)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 3)));
# 240 "/usr/include/string.h" 3 4


extern size_t strlen (__const char *__s)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));

# 254 "/usr/include/string.h" 3 4


extern char *strerror (int __errnum) __attribute__ ((__nothrow__));

# 270 "/usr/include/string.h" 3 4
extern int strerror_r (int __errnum, char *__buf, size_t __buflen) __asm__ ("" "__xpg_strerror_r") __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));
# 288 "/usr/include/string.h" 3 4
extern void __bzero (void *__s, size_t __n) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern void bcopy (__const void *__src, void *__dest, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int bcmp (__const void *__s1, __const void *__s2, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *index (__const char *__s, int __c)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern char *rindex (__const char *__s, int __c)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));



extern int ffs (int __i) __attribute__ ((__nothrow__)) __attribute__ ((__const__));
# 325 "/usr/include/string.h" 3 4
extern int strcasecmp (__const char *__s1, __const char *__s2)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (__const char *__s1, __const char *__s2, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 348 "/usr/include/string.h" 3 4
extern char *strsep (char **__restrict __stringp,
       __const char *__restrict __delim)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
# 414 "/usr/include/string.h" 3 4
# 1 "/usr/include/bits/string.h" 1 3 4
# 415 "/usr/include/string.h" 2 3 4


# 1 "/usr/include/bits/string2.h" 1 3 4
# 52 "/usr/include/bits/string2.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 37 "/usr/include/endian.h" 3 4
# 1 "/usr/include/bits/endian.h" 1 3 4
# 38 "/usr/include/endian.h" 2 3 4
# 53 "/usr/include/bits/string2.h" 2 3 4
# 394 "/usr/include/bits/string2.h" 3 4
extern void *__rawmemchr (const void *__s, int __c);
# 969 "/usr/include/bits/string2.h" 3 4
extern __inline size_t __strcspn_c1 (__const char *__s, int __reject);
extern __inline size_t
__strcspn_c1 (__const char *__s, int __reject)
{
  register size_t __result = 0;
  while (__s[__result] != '\0' && __s[__result] != __reject)
    ++__result;
  return __result;
}

extern __inline size_t __strcspn_c2 (__const char *__s, int __reject1,
         int __reject2);
extern __inline size_t
__strcspn_c2 (__const char *__s, int __reject1, int __reject2)
{
  register size_t __result = 0;
  while (__s[__result] != '\0' && __s[__result] != __reject1
  && __s[__result] != __reject2)
    ++__result;
  return __result;
}

extern __inline size_t __strcspn_c3 (__const char *__s, int __reject1,
         int __reject2, int __reject3);
extern __inline size_t
__strcspn_c3 (__const char *__s, int __reject1, int __reject2,
       int __reject3)
{
  register size_t __result = 0;
  while (__s[__result] != '\0' && __s[__result] != __reject1
  && __s[__result] != __reject2 && __s[__result] != __reject3)
    ++__result;
  return __result;
}
# 1045 "/usr/include/bits/string2.h" 3 4
extern __inline size_t __strspn_c1 (__const char *__s, int __accept);
extern __inline size_t
__strspn_c1 (__const char *__s, int __accept)
{
  register size_t __result = 0;

  while (__s[__result] == __accept)
    ++__result;
  return __result;
}

extern __inline size_t __strspn_c2 (__const char *__s, int __accept1,
        int __accept2);
extern __inline size_t
__strspn_c2 (__const char *__s, int __accept1, int __accept2)
{
  register size_t __result = 0;

  while (__s[__result] == __accept1 || __s[__result] == __accept2)
    ++__result;
  return __result;
}

extern __inline size_t __strspn_c3 (__const char *__s, int __accept1,
        int __accept2, int __accept3);
extern __inline size_t
__strspn_c3 (__const char *__s, int __accept1, int __accept2, int __accept3)
{
  register size_t __result = 0;

  while (__s[__result] == __accept1 || __s[__result] == __accept2
  || __s[__result] == __accept3)
    ++__result;
  return __result;
}
# 1121 "/usr/include/bits/string2.h" 3 4
extern __inline char *__strpbrk_c2 (__const char *__s, int __accept1,
         int __accept2);
extern __inline char *
__strpbrk_c2 (__const char *__s, int __accept1, int __accept2)
{

  while (*__s != '\0' && *__s != __accept1 && *__s != __accept2)
    ++__s;
  return *__s == '\0' ? ((void *)0) : (char *) (size_t) __s;
}

extern __inline char *__strpbrk_c3 (__const char *__s, int __accept1,
         int __accept2, int __accept3);
extern __inline char *
__strpbrk_c3 (__const char *__s, int __accept1, int __accept2,
       int __accept3)
{

  while (*__s != '\0' && *__s != __accept1 && *__s != __accept2
  && *__s != __accept3)
    ++__s;
  return *__s == '\0' ? ((void *)0) : (char *) (size_t) __s;
}
# 1173 "/usr/include/bits/string2.h" 3 4
extern __inline char *__strtok_r_1c (char *__s, char __sep, char **__nextp);
extern __inline char *
__strtok_r_1c (char *__s, char __sep, char **__nextp)
{
  char *__result;
  if (__s == ((void *)0))
    __s = *__nextp;
  while (*__s == __sep)
    ++__s;
  __result = ((void *)0);
  if (*__s != '\0')
    {
      __result = __s++;
      while (*__s != '\0')
 if (*__s++ == __sep)
   {
     __s[-1] = '\0';
     break;
   }
      *__nextp = __s;
    }
  return __result;
}
# 1205 "/usr/include/bits/string2.h" 3 4
extern char *__strsep_g (char **__stringp, __const char *__delim);
# 1223 "/usr/include/bits/string2.h" 3 4
extern __inline char *__strsep_1c (char **__s, char __reject);
extern __inline char *
__strsep_1c (char **__s, char __reject)
{
  register char *__retval = *__s;
  if (__retval != ((void *)0) && (*__s = (__extension__ (__builtin_constant_p (__reject) && !__builtin_constant_p (__retval) && (__reject) == '\0' ? (char *) __rawmemchr (__retval, __reject) : __builtin_strchr (__retval, __reject)))) != ((void *)0))
    *(*__s)++ = '\0';
  return __retval;
}

extern __inline char *__strsep_2c (char **__s, char __reject1, char __reject2);
extern __inline char *
__strsep_2c (char **__s, char __reject1, char __reject2)
{
  register char *__retval = *__s;
  if (__retval != ((void *)0))
    {
      register char *__cp = __retval;
      while (1)
 {
   if (*__cp == '\0')
     {
       __cp = ((void *)0);
   break;
     }
   if (*__cp == __reject1 || *__cp == __reject2)
     {
       *__cp++ = '\0';
       break;
     }
   ++__cp;
 }
      *__s = __cp;
    }
  return __retval;
}

extern __inline char *__strsep_3c (char **__s, char __reject1, char __reject2,
       char __reject3);
extern __inline char *
__strsep_3c (char **__s, char __reject1, char __reject2, char __reject3)
{
  register char *__retval = *__s;
  if (__retval != ((void *)0))
    {
      register char *__cp = __retval;
      while (1)
 {
   if (*__cp == '\0')
     {
       __cp = ((void *)0);
   break;
     }
   if (*__cp == __reject1 || *__cp == __reject2 || *__cp == __reject3)
     {
       *__cp++ = '\0';
       break;
     }
   ++__cp;
 }
      *__s = __cp;
    }
  return __retval;
}
# 1299 "/usr/include/bits/string2.h" 3 4
# 1 "/usr/include/stdlib.h" 1 3 4
# 33 "/usr/include/stdlib.h" 3 4
# 1 "/usr/lib/gcc/i386-redhat-linux/4.1.0/include/stddef.h" 1 3 4
# 34 "/usr/include/stdlib.h" 2 3 4


# 587 "/usr/include/stdlib.h" 3 4


extern void *malloc (size_t __size) __attribute__ ((__nothrow__)) __attribute__ ((__malloc__)) ;

extern void *calloc (size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__)) __attribute__ ((__malloc__)) ;

# 978 "/usr/include/stdlib.h" 3 4

# 1300 "/usr/include/bits/string2.h" 2 3 4




extern char *__strdup (__const char *__string) __attribute__ ((__nothrow__)) __attribute__ ((__malloc__));
# 1323 "/usr/include/bits/string2.h" 3 4
extern char *__strndup (__const char *__string, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__malloc__));
# 418 "/usr/include/string.h" 2 3 4
# 426 "/usr/include/string.h" 3 4

# 24 "client.c" 2
# 1 "/usr/include/stdlib.h" 1 3 4
# 33 "/usr/include/stdlib.h" 3 4
# 1 "/usr/lib/gcc/i386-redhat-linux/4.1.0/include/stddef.h" 1 3 4
# 34 "/usr/include/stdlib.h" 2 3 4


# 96 "/usr/include/stdlib.h" 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;



# 140 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) __attribute__ ((__nothrow__)) ;




extern double atof (__const char *__nptr)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (__const char *__nptr)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (__const char *__nptr)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





__extension__ extern long long int atoll (__const char *__nptr)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





extern double strtod (__const char *__restrict __nptr,
        char **__restrict __endptr)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;

# 182 "/usr/include/stdlib.h" 3 4


extern long int strtol (__const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;

extern unsigned long int strtoul (__const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;




__extension__
extern long long int strtoq (__const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;

__extension__
extern unsigned long long int strtouq (__const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;





__extension__
extern long long int strtoll (__const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;

__extension__
extern unsigned long long int strtoull (__const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;

# 279 "/usr/include/stdlib.h" 3 4
extern double __strtod_internal (__const char *__restrict __nptr,
     char **__restrict __endptr, int __group)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;
extern float __strtof_internal (__const char *__restrict __nptr,
    char **__restrict __endptr, int __group)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;
extern long double __strtold_internal (__const char *__restrict __nptr,
           char **__restrict __endptr,
           int __group)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;

extern long int __strtol_internal (__const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, int __group)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;



extern unsigned long int __strtoul_internal (__const char *__restrict __nptr,
          char **__restrict __endptr,
          int __base, int __group)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;




__extension__
extern long long int __strtoll_internal (__const char *__restrict __nptr,
      char **__restrict __endptr,
      int __base, int __group)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;



__extension__
extern unsigned long long int __strtoull_internal (__const char *
         __restrict __nptr,
         char **__restrict __endptr,
         int __base, int __group)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;








extern __inline double
__attribute__ ((__nothrow__)) strtod (__const char *__restrict __nptr, char **__restrict __endptr)
{
  return __strtod_internal (__nptr, __endptr, 0);
}
extern __inline long int
__attribute__ ((__nothrow__)) strtol (__const char *__restrict __nptr, char **__restrict __endptr, int __base)

{
  return __strtol_internal (__nptr, __endptr, __base, 0);
}
extern __inline unsigned long int
__attribute__ ((__nothrow__)) strtoul (__const char *__restrict __nptr, char **__restrict __endptr, int __base)

{
  return __strtoul_internal (__nptr, __endptr, __base, 0);
}

# 364 "/usr/include/stdlib.h" 3 4
__extension__ extern __inline long long int
__attribute__ ((__nothrow__)) strtoq (__const char *__restrict __nptr, char **__restrict __endptr, int __base)

{
  return __strtoll_internal (__nptr, __endptr, __base, 0);
}
__extension__ extern __inline unsigned long long int
__attribute__ ((__nothrow__)) strtouq (__const char *__restrict __nptr, char **__restrict __endptr, int __base)

{
  return __strtoull_internal (__nptr, __endptr, __base, 0);
}




__extension__ extern __inline long long int
__attribute__ ((__nothrow__)) strtoll (__const char *__restrict __nptr, char **__restrict __endptr, int __base)

{
  return __strtoll_internal (__nptr, __endptr, __base, 0);
}
__extension__ extern __inline unsigned long long int
__attribute__ ((__nothrow__)) strtoull (__const char * __restrict __nptr, char **__restrict __endptr, int __base)

{
  return __strtoull_internal (__nptr, __endptr, __base, 0);
}




extern __inline double
__attribute__ ((__nothrow__)) atof (__const char *__nptr)
{
  return strtod (__nptr, (char **) ((void *)0));
}
extern __inline int
__attribute__ ((__nothrow__)) atoi (__const char *__nptr)
{
  return (int) strtol (__nptr, (char **) ((void *)0), 10);
}
extern __inline long int
__attribute__ ((__nothrow__)) atol (__const char *__nptr)
{
  return strtol (__nptr, (char **) ((void *)0), 10);
}




__extension__ extern __inline long long int
__attribute__ ((__nothrow__)) atoll (__const char *__nptr)
{
  return strtoll (__nptr, (char **) ((void *)0), 10);
}

# 429 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) __attribute__ ((__nothrow__)) ;


extern long int a64l (__const char *__s)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;




# 1 "/usr/include/sys/types.h" 1 3 4
# 29 "/usr/include/sys/types.h" 3 4






typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;



typedef __ino_t ino_t;
# 62 "/usr/include/sys/types.h" 3 4
typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;





typedef __off_t off_t;
# 105 "/usr/include/sys/types.h" 3 4
typedef __id_t id_t;




typedef __ssize_t ssize_t;





typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;
# 147 "/usr/include/sys/types.h" 3 4
# 1 "/usr/lib/gcc/i386-redhat-linux/4.1.0/include/stddef.h" 1 3 4
# 148 "/usr/include/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
# 195 "/usr/include/sys/types.h" 3 4
typedef int int8_t __attribute__ ((__mode__ (__QI__)));
typedef int int16_t __attribute__ ((__mode__ (__HI__)));
typedef int int32_t __attribute__ ((__mode__ (__SI__)));
typedef int int64_t __attribute__ ((__mode__ (__DI__)));


typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));
# 220 "/usr/include/sys/types.h" 3 4
# 1 "/usr/include/sys/select.h" 1 3 4
# 31 "/usr/include/sys/select.h" 3 4
# 1 "/usr/include/bits/select.h" 1 3 4
# 32 "/usr/include/sys/select.h" 2 3 4


# 1 "/usr/include/bits/sigset.h" 1 3 4
# 23 "/usr/include/bits/sigset.h" 3 4
typedef int __sig_atomic_t;




typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
  } __sigset_t;
# 35 "/usr/include/sys/select.h" 2 3 4



typedef __sigset_t sigset_t;







# 1 "/usr/include/bits/time.h" 1 3 4
# 69 "/usr/include/bits/time.h" 3 4
struct timeval
  {
    __time_t tv_sec;
    __suseconds_t tv_usec;
  };
# 47 "/usr/include/sys/select.h" 2 3 4


typedef __suseconds_t suseconds_t;





typedef long int __fd_mask;
# 67 "/usr/include/sys/select.h" 3 4
typedef struct
  {






    __fd_mask __fds_bits[1024 / (8 * sizeof (__fd_mask))];


  } fd_set;






typedef __fd_mask fd_mask;
# 99 "/usr/include/sys/select.h" 3 4

# 109 "/usr/include/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 121 "/usr/include/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);



# 221 "/usr/include/sys/types.h" 2 3 4


# 1 "/usr/include/sys/sysmacros.h" 1 3 4
# 29 "/usr/include/sys/sysmacros.h" 3 4
__extension__
extern __inline unsigned int gnu_dev_major (unsigned long long int __dev)
     __attribute__ ((__nothrow__));
__extension__
extern __inline unsigned int gnu_dev_minor (unsigned long long int __dev)
     __attribute__ ((__nothrow__));
__extension__
extern __inline unsigned long long int gnu_dev_makedev (unsigned int __major,
       unsigned int __minor)
     __attribute__ ((__nothrow__));


__extension__ extern __inline unsigned int
__attribute__ ((__nothrow__)) gnu_dev_major (unsigned long long int __dev)
{
  return ((__dev >> 8) & 0xfff) | ((unsigned int) (__dev >> 32) & ~0xfff);
}

__extension__ extern __inline unsigned int
__attribute__ ((__nothrow__)) gnu_dev_minor (unsigned long long int __dev)
{
  return (__dev & 0xff) | ((unsigned int) (__dev >> 12) & ~0xff);
}

__extension__ extern __inline unsigned long long int
__attribute__ ((__nothrow__)) gnu_dev_makedev (unsigned int __major, unsigned int __minor)
{
  return ((__minor & 0xff) | ((__major & 0xfff) << 8)
   | (((unsigned long long int) (__minor & ~0xff)) << 12)
   | (((unsigned long long int) (__major & ~0xfff)) << 32));
}
# 224 "/usr/include/sys/types.h" 2 3 4
# 235 "/usr/include/sys/types.h" 3 4
typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 270 "/usr/include/sys/types.h" 3 4
# 1 "/usr/include/bits/pthreadtypes.h" 1 3 4
# 36 "/usr/include/bits/pthreadtypes.h" 3 4
typedef unsigned long int pthread_t;


typedef union
{
  char __size[36];
  long int __align;
} pthread_attr_t;


typedef struct __pthread_internal_slist
{
  struct __pthread_internal_slist *__next;
} __pthread_slist_t;




typedef union
{
  struct __pthread_mutex_s
  {
    int __lock;
    unsigned int __count;
    int __owner;


    int __kind;
    unsigned int __nusers;
    __extension__ union
    {
      int __spins;
      __pthread_slist_t __list;
    };
  } __data;
  char __size[24];
  long int __align;
} pthread_mutex_t;

typedef union
{
  char __size[4];
  long int __align;
} pthread_mutexattr_t;




typedef union
{
  struct
  {
    int __lock;
    unsigned int __futex;
    __extension__ unsigned long long int __total_seq;
    __extension__ unsigned long long int __wakeup_seq;
    __extension__ unsigned long long int __woken_seq;
    void *__mutex;
    unsigned int __nwaiters;
    unsigned int __broadcast_seq;
  } __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;

typedef union
{
  char __size[4];
  long int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;





typedef union
{
  struct
  {
    int __lock;
    unsigned int __nr_readers;
    unsigned int __readers_wakeup;
    unsigned int __writer_wakeup;
    unsigned int __nr_readers_queued;
    unsigned int __nr_writers_queued;


    unsigned int __flags;
    int __writer;
  } __data;
  char __size[32];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[20];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 271 "/usr/include/sys/types.h" 2 3 4



# 439 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) __attribute__ ((__nothrow__));


extern void srandom (unsigned int __seed) __attribute__ ((__nothrow__));





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));






extern int rand (void) __attribute__ ((__nothrow__));

extern void srand (unsigned int __seed) __attribute__ ((__nothrow__));




extern int rand_r (unsigned int *__seed) __attribute__ ((__nothrow__));







extern double drand48 (void) __attribute__ ((__nothrow__));
extern double erand48 (unsigned short int __xsubi[3]) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) __attribute__ ((__nothrow__));
extern long int nrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) __attribute__ ((__nothrow__));
extern long int jrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) __attribute__ ((__nothrow__));
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    unsigned long long int __a;
  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
# 597 "/usr/include/stdlib.h" 3 4



extern void *realloc (void *__ptr, size_t __size)
     __attribute__ ((__nothrow__)) __attribute__ ((__malloc__)) __attribute__ ((__warn_unused_result__));

extern void free (void *__ptr) __attribute__ ((__nothrow__));




extern void cfree (void *__ptr) __attribute__ ((__nothrow__));



# 1 "/usr/include/alloca.h" 1 3 4
# 25 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib/gcc/i386-redhat-linux/4.1.0/include/stddef.h" 1 3 4
# 26 "/usr/include/alloca.h" 2 3 4







extern void *alloca (size_t __size) __attribute__ ((__nothrow__));






# 613 "/usr/include/stdlib.h" 2 3 4




extern void *valloc (size_t __size) __attribute__ ((__nothrow__)) __attribute__ ((__malloc__)) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;




extern void abort (void) __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));





extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));






extern void exit (int __status) __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));

# 658 "/usr/include/stdlib.h" 3 4


extern char *getenv (__const char *__name) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;




extern char *__secure_getenv (__const char *__name)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;





extern int putenv (char *__string) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));





extern int setenv (__const char *__name, __const char *__value, int __replace)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));


extern int unsetenv (__const char *__name) __attribute__ ((__nothrow__));






extern int clearenv (void) __attribute__ ((__nothrow__));
# 698 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;
# 709 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 729 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;








extern int system (__const char *__command) ;

# 757 "/usr/include/stdlib.h" 3 4
extern char *realpath (__const char *__restrict __name,
         char *__restrict __resolved) __attribute__ ((__nothrow__)) ;






typedef int (*__compar_fn_t) (__const void *, __const void *);









extern void *bsearch (__const void *__key, __const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;



extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));



extern int abs (int __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__)) ;
extern long int labs (long int __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__)) ;












extern div_t div (int __numer, int __denom)
     __attribute__ ((__nothrow__)) __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     __attribute__ ((__nothrow__)) __attribute__ ((__const__)) ;

# 822 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4, 5)));







extern int mblen (__const char *__s, size_t __n) __attribute__ ((__nothrow__)) ;


extern int mbtowc (wchar_t *__restrict __pwc,
     __const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__)) ;


extern int wctomb (char *__s, wchar_t __wchar) __attribute__ ((__nothrow__)) ;



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   __const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__));

extern size_t wcstombs (char *__restrict __s,
   __const wchar_t *__restrict __pwcs, size_t __n)
     __attribute__ ((__nothrow__));








extern int rpmatch (__const char *__response) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;
# 927 "/usr/include/stdlib.h" 3 4
extern int posix_openpt (int __oflag) ;
# 962 "/usr/include/stdlib.h" 3 4
extern int getloadavg (double __loadavg[], int __nelem)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
# 978 "/usr/include/stdlib.h" 3 4

# 25 "client.c" 2

# 1 "everything.h" 1
# 9 "everything.h"
# 1 "../../include/orbit/orbit-types.h" 1



# 1 "../../include/orbit/util/orbit-util.h" 1




# 1 "../../include/orbit/orbit-config.h" 1
# 6 "../../include/orbit/util/orbit-util.h" 2
# 1 "../../include/orbit/util/basic_types.h" 1








enum {
 CORBA_FALSE = (0),
 CORBA_TRUE = (!(0))
};

typedef gint16 CORBA_short;
typedef gint32 CORBA_long;
typedef guint16 CORBA_unsigned_short;
typedef guint32 CORBA_unsigned_long;
typedef gfloat CORBA_float;
typedef gdouble CORBA_double;
typedef char CORBA_char;
typedef gunichar2 CORBA_wchar;
typedef guchar CORBA_boolean;
typedef guchar CORBA_octet;
typedef gdouble CORBA_long_double;




typedef CORBA_char *CORBA_string;
typedef CORBA_wchar *CORBA_wstring;




typedef struct CORBA_Object_type *CORBA_Object;
# 45 "../../include/orbit/util/basic_types.h"
typedef gint64 CORBA_long_long;
typedef guint64 CORBA_unsigned_long_long;
# 55 "../../include/orbit/util/basic_types.h"

# 7 "../../include/orbit/util/orbit-util.h" 2
# 1 "../../include/orbit/util/orbit-genrand.h" 1










typedef enum {
 ORBIT_GENUID_STRONG,
 ORBIT_GENUID_SIMPLE
} ORBitGenUidType;

typedef enum {
 ORBIT_GENUID_COOKIE,
 ORBIT_GENUID_OBJECT_ID
} ORBitGenUidRole;

gboolean ORBit_genuid_init (ORBitGenUidType type);
void ORBit_genuid_fini (void);
void ORBit_genuid_buffer (guint8 *buffer,
         int length,
         ORBitGenUidRole role);




# 8 "../../include/orbit/util/orbit-util.h" 2


# 28 "../../include/orbit/util/orbit-util.h"
gulong ORBit_wchar_strlen(CORBA_wchar *wstr);






# 5 "../../include/orbit/orbit-types.h" 2

# 1 "../../include/orbit/GIOP/giop-basics.h" 1



# 1 "../../linc2/include/linc/linc.h" 1
# 15 "../../linc2/include/linc/linc.h"
# 1 "../../linc2/include/linc/linc-config.h" 1
# 16 "../../linc2/include/linc/linc.h" 2
# 1 "../../linc2/include/linc/linc-types.h" 1
# 17 "../../linc2/include/linc/linc-types.h"
# 1 "/usr/include/glib-2.0/glib-object.h" 1
# 25 "/usr/include/glib-2.0/glib-object.h"
# 1 "/usr/include/glib-2.0/gobject/gboxed.h" 1
# 26 "/usr/include/glib-2.0/gobject/gboxed.h"
# 1 "/usr/include/glib-2.0/gobject/gtype.h" 1
# 28 "/usr/include/glib-2.0/gobject/gtype.h"

# 92 "/usr/include/glib-2.0/gobject/gtype.h"
typedef gulong GType;



typedef struct _GValue GValue;
typedef union _GTypeCValue GTypeCValue;
typedef struct _GTypePlugin GTypePlugin;
typedef struct _GTypeClass GTypeClass;
typedef struct _GTypeInterface GTypeInterface;
typedef struct _GTypeInstance GTypeInstance;
typedef struct _GTypeInfo GTypeInfo;
typedef struct _GTypeFundamentalInfo GTypeFundamentalInfo;
typedef struct _GInterfaceInfo GInterfaceInfo;
typedef struct _GTypeValueTable GTypeValueTable;
typedef struct _GTypeQuery GTypeQuery;




struct _GTypeClass
{

  GType g_type;
};
struct _GTypeInstance
{

  GTypeClass *g_class;
};
struct _GTypeInterface
{

  GType g_type;
  GType g_instance_type;
};
struct _GTypeQuery
{
  GType type;
  const gchar *type_name;
  guint class_size;
  guint instance_size;
};
# 157 "/usr/include/glib-2.0/gobject/gtype.h"
typedef enum
{
  G_TYPE_DEBUG_NONE = 0,
  G_TYPE_DEBUG_OBJECTS = 1 << 0,
  G_TYPE_DEBUG_SIGNALS = 1 << 1,
  G_TYPE_DEBUG_MASK = 0x03
} GTypeDebugFlags;



void g_type_init (void);
void g_type_init_with_debug_flags (GTypeDebugFlags debug_flags);
const gchar* g_type_name (GType type);
GQuark g_type_qname (GType type);
GType g_type_from_name (const gchar *name);
GType g_type_parent (GType type);
guint g_type_depth (GType type);
GType g_type_next_base (GType leaf_type,
            GType root_type);
gboolean g_type_is_a (GType type,
            GType is_a_type);
gpointer g_type_class_ref (GType type);
gpointer g_type_class_peek (GType type);
gpointer g_type_class_peek_static (GType type);
void g_type_class_unref (gpointer g_class);
gpointer g_type_class_peek_parent (gpointer g_class);
gpointer g_type_interface_peek (gpointer instance_class,
            GType iface_type);
gpointer g_type_interface_peek_parent (gpointer g_iface);

gpointer g_type_default_interface_ref (GType g_type);
gpointer g_type_default_interface_peek (GType g_type);
void g_type_default_interface_unref (gpointer g_iface);


GType* g_type_children (GType type,
            guint *n_children);
GType* g_type_interfaces (GType type,
            guint *n_interfaces);


void g_type_set_qdata (GType type,
            GQuark quark,
            gpointer data);
gpointer g_type_get_qdata (GType type,
            GQuark quark);
void g_type_query (GType type,
            GTypeQuery *query);



typedef void (*GBaseInitFunc) (gpointer g_class);
typedef void (*GBaseFinalizeFunc) (gpointer g_class);
typedef void (*GClassInitFunc) (gpointer g_class,
           gpointer class_data);
typedef void (*GClassFinalizeFunc) (gpointer g_class,
           gpointer class_data);
typedef void (*GInstanceInitFunc) (GTypeInstance *instance,
           gpointer g_class);
typedef void (*GInterfaceInitFunc) (gpointer g_iface,
           gpointer iface_data);
typedef void (*GInterfaceFinalizeFunc) (gpointer g_iface,
           gpointer iface_data);
typedef gboolean (*GTypeClassCacheFunc) (gpointer cache_data,
           GTypeClass *g_class);
typedef void (*GTypeInterfaceCheckFunc) (gpointer check_data,
           gpointer g_iface);
typedef enum
{
  G_TYPE_FLAG_CLASSED = (1 << 0),
  G_TYPE_FLAG_INSTANTIATABLE = (1 << 1),
  G_TYPE_FLAG_DERIVABLE = (1 << 2),
  G_TYPE_FLAG_DEEP_DERIVABLE = (1 << 3)
} GTypeFundamentalFlags;
typedef enum
{
  G_TYPE_FLAG_ABSTRACT = (1 << 4),
  G_TYPE_FLAG_VALUE_ABSTRACT = (1 << 5)
} GTypeFlags;
struct _GTypeInfo
{

  guint16 class_size;

  GBaseInitFunc base_init;
  GBaseFinalizeFunc base_finalize;


  GClassInitFunc class_init;
  GClassFinalizeFunc class_finalize;
  gconstpointer class_data;


  guint16 instance_size;
  guint16 n_preallocs;
  GInstanceInitFunc instance_init;


  const GTypeValueTable *value_table;
};
struct _GTypeFundamentalInfo
{
  GTypeFundamentalFlags type_flags;
};
struct _GInterfaceInfo
{
  GInterfaceInitFunc interface_init;
  GInterfaceFinalizeFunc interface_finalize;
  gpointer interface_data;
};
struct _GTypeValueTable
{
  void (*value_init) (GValue *value);
  void (*value_free) (GValue *value);
  void (*value_copy) (const GValue *src_value,
      GValue *dest_value);

  gpointer (*value_peek_pointer) (const GValue *value);
  gchar *collect_format;
  gchar* (*collect_value) (GValue *value,
      guint n_collect_values,
      GTypeCValue *collect_values,
      guint collect_flags);
  gchar *lcopy_format;
  gchar* (*lcopy_value) (const GValue *value,
      guint n_collect_values,
      GTypeCValue *collect_values,
      guint collect_flags);
};
GType g_type_register_static (GType parent_type,
      const gchar *type_name,
      const GTypeInfo *info,
      GTypeFlags flags);
GType g_type_register_dynamic (GType parent_type,
      const gchar *type_name,
      GTypePlugin *plugin,
      GTypeFlags flags);
GType g_type_register_fundamental (GType type_id,
      const gchar *type_name,
      const GTypeInfo *info,
      const GTypeFundamentalInfo *finfo,
      GTypeFlags flags);
void g_type_add_interface_static (GType instance_type,
      GType interface_type,
      const GInterfaceInfo *info);
void g_type_add_interface_dynamic (GType instance_type,
      GType interface_type,
      GTypePlugin *plugin);
void g_type_interface_add_prerequisite (GType interface_type,
      GType prerequisite_type);
GType*g_type_interface_prerequisites (GType interface_type,
      guint *n_prerequisites);
void g_type_class_add_private (gpointer g_class,
                                         gsize private_size);
gpointer g_type_instance_get_private (GTypeInstance *instance,
                                         GType private_type);
# 385 "/usr/include/glib-2.0/gobject/gtype.h"
GTypePlugin* g_type_get_plugin (GType type);
GTypePlugin* g_type_interface_get_plugin (GType instance_type,
       GType interface_type);
GType g_type_fundamental_next (void);
GType g_type_fundamental (GType type_id);
GTypeInstance* g_type_create_instance (GType type);
void g_type_free_instance (GTypeInstance *instance);

void g_type_add_class_cache_func (gpointer cache_data,
       GTypeClassCacheFunc cache_func);
void g_type_remove_class_cache_func (gpointer cache_data,
       GTypeClassCacheFunc cache_func);
void g_type_class_unref_uncached (gpointer g_class);

void g_type_add_interface_check (gpointer check_data,
       GTypeInterfaceCheckFunc check_func);
void g_type_remove_interface_check (gpointer check_data,
       GTypeInterfaceCheckFunc check_func);

GTypeValueTable* g_type_value_table_peek (GType type);



gboolean g_type_check_instance (GTypeInstance *instance);
GTypeInstance* g_type_check_instance_cast (GTypeInstance *instance,
       GType iface_type);
gboolean g_type_check_instance_is_a (GTypeInstance *instance,
       GType iface_type);
GTypeClass* g_type_check_class_cast (GTypeClass *g_class,
       GType is_a_type);
gboolean g_type_check_class_is_a (GTypeClass *g_class,
       GType is_a_type);
gboolean g_type_check_is_value_type (GType type);
gboolean g_type_check_value (GValue *value);
gboolean g_type_check_value_holds (GValue *value,
       GType type);
gboolean g_type_test_flags (GType type,
       guint flags);



const gchar* g_type_name_from_instance (GTypeInstance *instance);
const gchar* g_type_name_from_class (GTypeClass *g_class);



void g_value_c_init (void) __attribute__((visibility("hidden")));
void g_value_types_init (void) __attribute__((visibility("hidden")));
void g_enum_types_init (void) __attribute__((visibility("hidden")));
void g_param_type_init (void) __attribute__((visibility("hidden")));
void g_boxed_type_init (void) __attribute__((visibility("hidden")));
void g_object_type_init (void) __attribute__((visibility("hidden")));
void g_param_spec_types_init (void) __attribute__((visibility("hidden")));
void g_value_transforms_init (void) __attribute__((visibility("hidden")));
void g_signal_init (void) __attribute__((visibility("hidden")));
# 487 "/usr/include/glib-2.0/gobject/gtype.h"
extern GTypeDebugFlags _g_type_debug_flags;


# 27 "/usr/include/glib-2.0/gobject/gboxed.h" 2









typedef gpointer (*GBoxedCopyFunc) (gpointer boxed);
typedef void (*GBoxedFreeFunc) (gpointer boxed);



gpointer g_boxed_copy (GType boxed_type,
       gconstpointer src_boxed);
void g_boxed_free (GType boxed_type,
       gpointer boxed);
void g_value_set_boxed (GValue *value,
       gconstpointer v_boxed);
void g_value_set_static_boxed (GValue *value,
       gconstpointer v_boxed);
gpointer g_value_get_boxed (const GValue *value);
gpointer g_value_dup_boxed (const GValue *value);



GType g_boxed_type_register_static (const gchar *name,
       GBoxedCopyFunc boxed_copy,
       GBoxedFreeFunc boxed_free);
# 69 "/usr/include/glib-2.0/gobject/gboxed.h"
void g_value_take_boxed (GValue *value,
     gconstpointer v_boxed);

void g_value_set_boxed_take_ownership (GValue *value,
       gconstpointer v_boxed);

GType g_closure_get_type (void) __attribute__((__const__));
GType g_value_get_type (void) __attribute__((__const__));
GType g_value_array_get_type (void) __attribute__((__const__));
GType g_date_get_type (void) __attribute__((__const__));
GType g_strv_get_type (void) __attribute__((__const__));
GType g_gstring_get_type (void) __attribute__((__const__));
GType g_hash_table_get_type (void) __attribute__((__const__));

typedef gchar** GStrv;


# 26 "/usr/include/glib-2.0/glib-object.h" 2
# 1 "/usr/include/glib-2.0/gobject/genums.h" 1
# 26 "/usr/include/glib-2.0/gobject/genums.h"
# 1 "/usr/include/glib-2.0/gobject/gtype.h" 1
# 27 "/usr/include/glib-2.0/gobject/genums.h" 2


# 46 "/usr/include/glib-2.0/gobject/genums.h"
typedef struct _GEnumClass GEnumClass;
typedef struct _GFlagsClass GFlagsClass;
typedef struct _GEnumValue GEnumValue;
typedef struct _GFlagsValue GFlagsValue;
struct _GEnumClass
{
  GTypeClass g_type_class;


  gint minimum;
  gint maximum;
  guint n_values;
  GEnumValue *values;
};
struct _GFlagsClass
{
  GTypeClass g_type_class;


  guint mask;
  guint n_values;
  GFlagsValue *values;
};
struct _GEnumValue
{
  gint value;
  gchar *value_name;
  gchar *value_nick;
};
struct _GFlagsValue
{
  guint value;
  gchar *value_name;
  gchar *value_nick;
};



GEnumValue* g_enum_get_value (GEnumClass *enum_class,
       gint value);
GEnumValue* g_enum_get_value_by_name (GEnumClass *enum_class,
       const gchar *name);
GEnumValue* g_enum_get_value_by_nick (GEnumClass *enum_class,
       const gchar *nick);
GFlagsValue* g_flags_get_first_value (GFlagsClass *flags_class,
       guint value);
GFlagsValue* g_flags_get_value_by_name (GFlagsClass *flags_class,
       const gchar *name);
GFlagsValue* g_flags_get_value_by_nick (GFlagsClass *flags_class,
       const gchar *nick);
void g_value_set_enum (GValue *value,
       gint v_enum);
gint g_value_get_enum (const GValue *value);
void g_value_set_flags (GValue *value,
       guint v_flags);
guint g_value_get_flags (const GValue *value);







GType g_enum_register_static (const gchar *name,
        const GEnumValue *const_static_values);
GType g_flags_register_static (const gchar *name,
        const GFlagsValue *const_static_values);



void g_enum_complete_type_info (GType g_enum_type,
        GTypeInfo *info,
        const GEnumValue *const_values);
void g_flags_complete_type_info (GType g_flags_type,
        GTypeInfo *info,
        const GFlagsValue *const_values);


# 27 "/usr/include/glib-2.0/glib-object.h" 2
# 1 "/usr/include/glib-2.0/gobject/gobject.h" 1
# 26 "/usr/include/glib-2.0/gobject/gobject.h"
# 1 "/usr/include/glib-2.0/gobject/gtype.h" 1
# 27 "/usr/include/glib-2.0/gobject/gobject.h" 2
# 1 "/usr/include/glib-2.0/gobject/gvalue.h" 1
# 28 "/usr/include/glib-2.0/gobject/gvalue.h"
# 1 "/usr/include/glib-2.0/gobject/gtype.h" 1
# 29 "/usr/include/glib-2.0/gobject/gvalue.h" 2


# 41 "/usr/include/glib-2.0/gobject/gvalue.h"
typedef void (*GValueTransform) (const GValue *src_value,
     GValue *dest_value);
struct _GValue
{

  GType g_type;


  union {
    gint v_int;
    guint v_uint;
    glong v_long;
    gulong v_ulong;
    gint64 v_int64;
    guint64 v_uint64;
    gfloat v_float;
    gdouble v_double;
    gpointer v_pointer;
  } data[2];
};



GValue* g_value_init (GValue *value,
      GType g_type);
void g_value_copy (const GValue *src_value,
      GValue *dest_value);
GValue* g_value_reset (GValue *value);
void g_value_unset (GValue *value);
void g_value_set_instance (GValue *value,
      gpointer instance);



gboolean g_value_fits_pointer (const GValue *value);
gpointer g_value_peek_pointer (const GValue *value);



gboolean g_value_type_compatible (GType src_type,
      GType dest_type);
gboolean g_value_type_transformable (GType src_type,
      GType dest_type);
gboolean g_value_transform (const GValue *src_value,
      GValue *dest_value);
void g_value_register_transform_func (GType src_type,
      GType dest_type,
      GValueTransform transform_func);




# 28 "/usr/include/glib-2.0/gobject/gobject.h" 2
# 1 "/usr/include/glib-2.0/gobject/gparam.h" 1
# 28 "/usr/include/glib-2.0/gobject/gparam.h"
# 1 "/usr/include/glib-2.0/gobject/gvalue.h" 1
# 29 "/usr/include/glib-2.0/gobject/gparam.h" 2


# 49 "/usr/include/glib-2.0/gobject/gparam.h"
typedef enum
{
  G_PARAM_READABLE = 1 << 0,
  G_PARAM_WRITABLE = 1 << 1,
  G_PARAM_CONSTRUCT = 1 << 2,
  G_PARAM_CONSTRUCT_ONLY = 1 << 3,
  G_PARAM_LAX_VALIDATION = 1 << 4,
  G_PARAM_STATIC_NAME = 1 << 5,

  G_PARAM_PRIVATE = G_PARAM_STATIC_NAME,

  G_PARAM_STATIC_NICK = 1 << 6,
  G_PARAM_STATIC_BLURB = 1 << 7
} GParamFlags;







typedef struct _GParamSpec GParamSpec;
typedef struct _GParamSpecClass GParamSpecClass;
typedef struct _GParameter GParameter;
typedef struct _GParamSpecPool GParamSpecPool;
struct _GParamSpec
{
  GTypeInstance g_type_instance;

  gchar *name;
  GParamFlags flags;
  GType value_type;
  GType owner_type;


  gchar *_nick;
  gchar *_blurb;
  GData *qdata;
  guint ref_count;
  guint param_id;
};
struct _GParamSpecClass
{
  GTypeClass g_type_class;

  GType value_type;

  void (*finalize) (GParamSpec *pspec);


  void (*value_set_default) (GParamSpec *pspec,
      GValue *value);
  gboolean (*value_validate) (GParamSpec *pspec,
      GValue *value);
  gint (*values_cmp) (GParamSpec *pspec,
      const GValue *value1,
      const GValue *value2);

  gpointer dummy[4];
};
struct _GParameter
{
  const gchar *name;
  GValue value;
};



GParamSpec* g_param_spec_ref (GParamSpec *pspec);
void g_param_spec_unref (GParamSpec *pspec);
void g_param_spec_sink (GParamSpec *pspec);
GParamSpec* g_param_spec_ref_sink (GParamSpec *pspec);
gpointer g_param_spec_get_qdata (GParamSpec *pspec,
       GQuark quark);
void g_param_spec_set_qdata (GParamSpec *pspec,
       GQuark quark,
       gpointer data);
void g_param_spec_set_qdata_full (GParamSpec *pspec,
       GQuark quark,
       gpointer data,
       GDestroyNotify destroy);
gpointer g_param_spec_steal_qdata (GParamSpec *pspec,
       GQuark quark);
GParamSpec* g_param_spec_get_redirect_target (GParamSpec *pspec);

void g_param_value_set_default (GParamSpec *pspec,
       GValue *value);
gboolean g_param_value_defaults (GParamSpec *pspec,
       GValue *value);
gboolean g_param_value_validate (GParamSpec *pspec,
       GValue *value);
gboolean g_param_value_convert (GParamSpec *pspec,
       const GValue *src_value,
       GValue *dest_value,
       gboolean strict_validation);
gint g_param_values_cmp (GParamSpec *pspec,
       const GValue *value1,
       const GValue *value2);
const gchar* g_param_spec_get_name (GParamSpec *pspec);
const gchar* g_param_spec_get_nick (GParamSpec *pspec);
const gchar* g_param_spec_get_blurb (GParamSpec *pspec);
void g_value_set_param (GValue *value,
       GParamSpec *param);
GParamSpec* g_value_get_param (const GValue *value);
GParamSpec* g_value_dup_param (const GValue *value);


void g_value_take_param (GValue *value,
              GParamSpec *param);

void g_value_set_param_take_ownership (GValue *value,
              GParamSpec *param);



typedef struct _GParamSpecTypeInfo GParamSpecTypeInfo;
struct _GParamSpecTypeInfo
{

  guint16 instance_size;
  guint16 n_preallocs;
  void (*instance_init) (GParamSpec *pspec);


  GType value_type;
  void (*finalize) (GParamSpec *pspec);
  void (*value_set_default) (GParamSpec *pspec,
      GValue *value);
  gboolean (*value_validate) (GParamSpec *pspec,
      GValue *value);
  gint (*values_cmp) (GParamSpec *pspec,
      const GValue *value1,
      const GValue *value2);
};
GType g_param_type_register_static (const gchar *name,
      const GParamSpecTypeInfo *pspec_info);


GType _g_param_type_register_static_constant (const gchar *name,
            const GParamSpecTypeInfo *pspec_info,
            GType opt_type);



gpointer g_param_spec_internal (GType param_type,
       const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       GParamFlags flags);
GParamSpecPool* g_param_spec_pool_new (gboolean type_prefixing);
void g_param_spec_pool_insert (GParamSpecPool *pool,
       GParamSpec *pspec,
       GType owner_type);
void g_param_spec_pool_remove (GParamSpecPool *pool,
       GParamSpec *pspec);
GParamSpec* g_param_spec_pool_lookup (GParamSpecPool *pool,
       const gchar *param_name,
       GType owner_type,
       gboolean walk_ancestors);
GList* g_param_spec_pool_list_owned (GParamSpecPool *pool,
       GType owner_type);
GParamSpec** g_param_spec_pool_list (GParamSpecPool *pool,
       GType owner_type,
       guint *n_pspecs_p);
# 232 "/usr/include/glib-2.0/gobject/gparam.h"

# 29 "/usr/include/glib-2.0/gobject/gobject.h" 2
# 1 "/usr/include/glib-2.0/gobject/gclosure.h" 1
# 27 "/usr/include/glib-2.0/gobject/gclosure.h"
# 1 "/usr/include/glib-2.0/gobject/gtype.h" 1
# 28 "/usr/include/glib-2.0/gobject/gclosure.h" 2


# 40 "/usr/include/glib-2.0/gobject/gclosure.h"
typedef struct _GClosure GClosure;
typedef struct _GClosureNotifyData GClosureNotifyData;
typedef void (*GCallback) (void);
typedef void (*GClosureNotify) (gpointer data,
      GClosure *closure);
typedef void (*GClosureMarshal) (GClosure *closure,
      GValue *return_value,
      guint n_param_values,
      const GValue *param_values,
      gpointer invocation_hint,
      gpointer marshal_data);
typedef struct _GCClosure GCClosure;



struct _GClosureNotifyData
{
  gpointer data;
  GClosureNotify notify;
};
struct _GClosure
{

  volatile guint ref_count : 15;
  volatile guint meta_marshal : 1;
  volatile guint n_guards : 1;
  volatile guint n_fnotifiers : 2;
  volatile guint n_inotifiers : 8;
  volatile guint in_inotify : 1;
  volatile guint floating : 1;

  volatile guint derivative_flag : 1;

  volatile guint in_marshal : 1;
  volatile guint is_invalid : 1;

                  void (*marshal) (GClosure *closure,
         GValue *return_value,
         guint n_param_values,
         const GValue *param_values,
         gpointer invocation_hint,
         gpointer marshal_data);
                    gpointer data;

                  GClosureNotifyData *notifiers;
# 96 "/usr/include/glib-2.0/gobject/gclosure.h"
};


struct _GCClosure
{
  GClosure closure;
  gpointer callback;
};



GClosure* g_cclosure_new (GCallback callback_func,
       gpointer user_data,
       GClosureNotify destroy_data);
GClosure* g_cclosure_new_swap (GCallback callback_func,
       gpointer user_data,
       GClosureNotify destroy_data);
GClosure* g_signal_type_cclosure_new (GType itype,
       guint struct_offset);



GClosure* g_closure_ref (GClosure *closure);
void g_closure_sink (GClosure *closure);
void g_closure_unref (GClosure *closure);

GClosure* g_closure_new_simple (guint sizeof_closure,
       gpointer data);
void g_closure_add_finalize_notifier (GClosure *closure,
       gpointer notify_data,
       GClosureNotify notify_func);
void g_closure_remove_finalize_notifier (GClosure *closure,
       gpointer notify_data,
       GClosureNotify notify_func);
void g_closure_add_invalidate_notifier (GClosure *closure,
       gpointer notify_data,
       GClosureNotify notify_func);
void g_closure_remove_invalidate_notifier (GClosure *closure,
       gpointer notify_data,
       GClosureNotify notify_func);
void g_closure_add_marshal_guards (GClosure *closure,
       gpointer pre_marshal_data,
       GClosureNotify pre_marshal_notify,
       gpointer post_marshal_data,
       GClosureNotify post_marshal_notify);
void g_closure_set_marshal (GClosure *closure,
       GClosureMarshal marshal);
void g_closure_set_meta_marshal (GClosure *closure,
       gpointer marshal_data,
       GClosureMarshal meta_marshal);
void g_closure_invalidate (GClosure *closure);
void g_closure_invoke (GClosure *closure,
       GValue *return_value,
       guint n_param_values,
       const GValue *param_values,
       gpointer invocation_hint);
# 164 "/usr/include/glib-2.0/gobject/gclosure.h"

# 30 "/usr/include/glib-2.0/gobject/gobject.h" 2
# 1 "/usr/include/glib-2.0/gobject/gsignal.h" 1
# 26 "/usr/include/glib-2.0/gobject/gsignal.h"
# 1 "/usr/include/glib-2.0/gobject/gclosure.h" 1
# 27 "/usr/include/glib-2.0/gobject/gsignal.h" 2
# 1 "/usr/include/glib-2.0/gobject/gvalue.h" 1
# 28 "/usr/include/glib-2.0/gobject/gsignal.h" 2
# 1 "/usr/include/glib-2.0/gobject/gparam.h" 1
# 29 "/usr/include/glib-2.0/gobject/gsignal.h" 2
# 1 "/usr/include/glib-2.0/gobject/gmarshal.h" 1






extern void g_cclosure_marshal_VOID__VOID (GClosure *closure,
                                           GValue *return_value,
                                           guint n_param_values,
                                           const GValue *param_values,
                                           gpointer invocation_hint,
                                           gpointer marshal_data);


extern void g_cclosure_marshal_VOID__BOOLEAN (GClosure *closure,
                                              GValue *return_value,
                                              guint n_param_values,
                                              const GValue *param_values,
                                              gpointer invocation_hint,
                                              gpointer marshal_data);


extern void g_cclosure_marshal_VOID__CHAR (GClosure *closure,
                                           GValue *return_value,
                                           guint n_param_values,
                                           const GValue *param_values,
                                           gpointer invocation_hint,
                                           gpointer marshal_data);


extern void g_cclosure_marshal_VOID__UCHAR (GClosure *closure,
                                            GValue *return_value,
                                            guint n_param_values,
                                            const GValue *param_values,
                                            gpointer invocation_hint,
                                            gpointer marshal_data);


extern void g_cclosure_marshal_VOID__INT (GClosure *closure,
                                          GValue *return_value,
                                          guint n_param_values,
                                          const GValue *param_values,
                                          gpointer invocation_hint,
                                          gpointer marshal_data);


extern void g_cclosure_marshal_VOID__UINT (GClosure *closure,
                                           GValue *return_value,
                                           guint n_param_values,
                                           const GValue *param_values,
                                           gpointer invocation_hint,
                                           gpointer marshal_data);


extern void g_cclosure_marshal_VOID__LONG (GClosure *closure,
                                           GValue *return_value,
                                           guint n_param_values,
                                           const GValue *param_values,
                                           gpointer invocation_hint,
                                           gpointer marshal_data);


extern void g_cclosure_marshal_VOID__ULONG (GClosure *closure,
                                            GValue *return_value,
                                            guint n_param_values,
                                            const GValue *param_values,
                                            gpointer invocation_hint,
                                            gpointer marshal_data);


extern void g_cclosure_marshal_VOID__ENUM (GClosure *closure,
                                           GValue *return_value,
                                           guint n_param_values,
                                           const GValue *param_values,
                                           gpointer invocation_hint,
                                           gpointer marshal_data);


extern void g_cclosure_marshal_VOID__FLAGS (GClosure *closure,
                                            GValue *return_value,
                                            guint n_param_values,
                                            const GValue *param_values,
                                            gpointer invocation_hint,
                                            gpointer marshal_data);


extern void g_cclosure_marshal_VOID__FLOAT (GClosure *closure,
                                            GValue *return_value,
                                            guint n_param_values,
                                            const GValue *param_values,
                                            gpointer invocation_hint,
                                            gpointer marshal_data);


extern void g_cclosure_marshal_VOID__DOUBLE (GClosure *closure,
                                             GValue *return_value,
                                             guint n_param_values,
                                             const GValue *param_values,
                                             gpointer invocation_hint,
                                             gpointer marshal_data);


extern void g_cclosure_marshal_VOID__STRING (GClosure *closure,
                                             GValue *return_value,
                                             guint n_param_values,
                                             const GValue *param_values,
                                             gpointer invocation_hint,
                                             gpointer marshal_data);


extern void g_cclosure_marshal_VOID__PARAM (GClosure *closure,
                                            GValue *return_value,
                                            guint n_param_values,
                                            const GValue *param_values,
                                            gpointer invocation_hint,
                                            gpointer marshal_data);


extern void g_cclosure_marshal_VOID__BOXED (GClosure *closure,
                                            GValue *return_value,
                                            guint n_param_values,
                                            const GValue *param_values,
                                            gpointer invocation_hint,
                                            gpointer marshal_data);


extern void g_cclosure_marshal_VOID__POINTER (GClosure *closure,
                                              GValue *return_value,
                                              guint n_param_values,
                                              const GValue *param_values,
                                              gpointer invocation_hint,
                                              gpointer marshal_data);


extern void g_cclosure_marshal_VOID__OBJECT (GClosure *closure,
                                             GValue *return_value,
                                             guint n_param_values,
                                             const GValue *param_values,
                                             gpointer invocation_hint,
                                             gpointer marshal_data);


extern void g_cclosure_marshal_VOID__UINT_POINTER (GClosure *closure,
                                                   GValue *return_value,
                                                   guint n_param_values,
                                                   const GValue *param_values,
                                                   gpointer invocation_hint,
                                                   gpointer marshal_data);


extern void g_cclosure_marshal_BOOLEAN__FLAGS (GClosure *closure,
                                               GValue *return_value,
                                               guint n_param_values,
                                               const GValue *param_values,
                                               gpointer invocation_hint,
                                               gpointer marshal_data);



extern void g_cclosure_marshal_STRING__OBJECT_POINTER (GClosure *closure,
                                                       GValue *return_value,
                                                       guint n_param_values,
                                                       const GValue *param_values,
                                                       gpointer invocation_hint,
                                                       gpointer marshal_data);


# 30 "/usr/include/glib-2.0/gobject/gsignal.h" 2




typedef struct _GSignalQuery GSignalQuery;
typedef struct _GSignalInvocationHint GSignalInvocationHint;
typedef GClosureMarshal GSignalCMarshaller;
typedef gboolean (*GSignalEmissionHook) (GSignalInvocationHint *ihint,
      guint n_param_values,
      const GValue *param_values,
      gpointer data);
typedef gboolean (*GSignalAccumulator) (GSignalInvocationHint *ihint,
      GValue *return_accu,
      const GValue *handler_return,
      gpointer data);



typedef enum
{
  G_SIGNAL_RUN_FIRST = 1 << 0,
  G_SIGNAL_RUN_LAST = 1 << 1,
  G_SIGNAL_RUN_CLEANUP = 1 << 2,
  G_SIGNAL_NO_RECURSE = 1 << 3,
  G_SIGNAL_DETAILED = 1 << 4,
  G_SIGNAL_ACTION = 1 << 5,
  G_SIGNAL_NO_HOOKS = 1 << 6
} GSignalFlags;

typedef enum
{
  G_CONNECT_AFTER = 1 << 0,
  G_CONNECT_SWAPPED = 1 << 1
} GConnectFlags;
typedef enum
{
  G_SIGNAL_MATCH_ID = 1 << 0,
  G_SIGNAL_MATCH_DETAIL = 1 << 1,
  G_SIGNAL_MATCH_CLOSURE = 1 << 2,
  G_SIGNAL_MATCH_FUNC = 1 << 3,
  G_SIGNAL_MATCH_DATA = 1 << 4,
  G_SIGNAL_MATCH_UNBLOCKED = 1 << 5
} GSignalMatchType;





struct _GSignalInvocationHint
{
  guint signal_id;
  GQuark detail;
  GSignalFlags run_type;
};
struct _GSignalQuery
{
  guint signal_id;
  const gchar *signal_name;
  GType itype;
  GSignalFlags signal_flags;
  GType return_type;
  guint n_params;
  const GType *param_types;
};



guint g_signal_newv (const gchar *signal_name,
          GType itype,
          GSignalFlags signal_flags,
          GClosure *class_closure,
          GSignalAccumulator accumulator,
          gpointer accu_data,
          GSignalCMarshaller c_marshaller,
          GType return_type,
          guint n_params,
          GType *param_types);
guint g_signal_new_valist (const gchar *signal_name,
          GType itype,
          GSignalFlags signal_flags,
          GClosure *class_closure,
          GSignalAccumulator accumulator,
          gpointer accu_data,
          GSignalCMarshaller c_marshaller,
          GType return_type,
          guint n_params,
          va_list args);
guint g_signal_new (const gchar *signal_name,
          GType itype,
          GSignalFlags signal_flags,
          guint class_offset,
          GSignalAccumulator accumulator,
          gpointer accu_data,
          GSignalCMarshaller c_marshaller,
          GType return_type,
          guint n_params,
          ...);
void g_signal_emitv (const GValue *instance_and_params,
          guint signal_id,
          GQuark detail,
          GValue *return_value);
void g_signal_emit_valist (gpointer instance,
          guint signal_id,
          GQuark detail,
          va_list var_args);
void g_signal_emit (gpointer instance,
          guint signal_id,
          GQuark detail,
          ...);
void g_signal_emit_by_name (gpointer instance,
          const gchar *detailed_signal,
          ...);
guint g_signal_lookup (const gchar *name,
          GType itype);
const gchar* g_signal_name (guint signal_id);
void g_signal_query (guint signal_id,
          GSignalQuery *query);
guint* g_signal_list_ids (GType itype,
          guint *n_ids);
gboolean g_signal_parse_name (const gchar *detailed_signal,
          GType itype,
          guint *signal_id_p,
          GQuark *detail_p,
          gboolean force_detail_quark);
GSignalInvocationHint* g_signal_get_invocation_hint (gpointer instance);



void g_signal_stop_emission (gpointer instance,
          guint signal_id,
          GQuark detail);
void g_signal_stop_emission_by_name (gpointer instance,
          const gchar *detailed_signal);
gulong g_signal_add_emission_hook (guint signal_id,
          GQuark detail,
          GSignalEmissionHook hook_func,
          gpointer hook_data,
          GDestroyNotify data_destroy);
void g_signal_remove_emission_hook (guint signal_id,
          gulong hook_id);



gboolean g_signal_has_handler_pending (gpointer instance,
            guint signal_id,
            GQuark detail,
            gboolean may_be_blocked);
gulong g_signal_connect_closure_by_id (gpointer instance,
            guint signal_id,
            GQuark detail,
            GClosure *closure,
            gboolean after);
gulong g_signal_connect_closure (gpointer instance,
            const gchar *detailed_signal,
            GClosure *closure,
            gboolean after);
gulong g_signal_connect_data (gpointer instance,
            const gchar *detailed_signal,
            GCallback c_handler,
            gpointer data,
            GClosureNotify destroy_data,
            GConnectFlags connect_flags);
void g_signal_handler_block (gpointer instance,
            gulong handler_id);
void g_signal_handler_unblock (gpointer instance,
            gulong handler_id);
void g_signal_handler_disconnect (gpointer instance,
            gulong handler_id);
gboolean g_signal_handler_is_connected (gpointer instance,
            gulong handler_id);
gulong g_signal_handler_find (gpointer instance,
            GSignalMatchType mask,
            guint signal_id,
            GQuark detail,
            GClosure *closure,
            gpointer func,
            gpointer data);
guint g_signal_handlers_block_matched (gpointer instance,
            GSignalMatchType mask,
            guint signal_id,
            GQuark detail,
            GClosure *closure,
            gpointer func,
            gpointer data);
guint g_signal_handlers_unblock_matched (gpointer instance,
            GSignalMatchType mask,
            guint signal_id,
            GQuark detail,
            GClosure *closure,
            gpointer func,
            gpointer data);
guint g_signal_handlers_disconnect_matched (gpointer instance,
            GSignalMatchType mask,
            guint signal_id,
            GQuark detail,
            GClosure *closure,
            gpointer func,
            gpointer data);



void g_signal_override_class_closure (guint signal_id,
            GType instance_type,
            GClosure *class_closure);
void g_signal_chain_from_overridden (const GValue *instance_and_params,
            GValue *return_value);
# 259 "/usr/include/glib-2.0/gobject/gsignal.h"
gboolean g_signal_accumulator_true_handled (GSignalInvocationHint *ihint,
         GValue *return_accu,
         const GValue *handler_return,
         gpointer dummy);


void g_signal_handlers_destroy (gpointer instance);
void _g_signals_destroy (GType itype);


# 31 "/usr/include/glib-2.0/gobject/gobject.h" 2


# 58 "/usr/include/glib-2.0/gobject/gobject.h"
typedef struct _GObject GObject;
typedef struct _GObjectClass GObjectClass;
typedef struct _GObject GInitiallyUnowned;
typedef struct _GObjectClass GInitiallyUnownedClass;
typedef struct _GObjectConstructParam GObjectConstructParam;
typedef void (*GObjectGetPropertyFunc) (GObject *object,
                                         guint property_id,
                                         GValue *value,
                                         GParamSpec *pspec);
typedef void (*GObjectSetPropertyFunc) (GObject *object,
                                         guint property_id,
                                         const GValue *value,
                                         GParamSpec *pspec);
typedef void (*GObjectFinalizeFunc) (GObject *object);
typedef void (*GWeakNotify) (gpointer data,
      GObject *where_the_object_was);
struct _GObject
{
  GTypeInstance g_type_instance;


  volatile guint ref_count;
  GData *qdata;
};
struct _GObjectClass
{
  GTypeClass g_type_class;


  GSList *construct_properties;



  GObject* (*constructor) (GType type,
                                 guint n_construct_properties,
                                 GObjectConstructParam *construct_properties);
  void (*set_property) (GObject *object,
                                         guint property_id,
                                         const GValue *value,
                                         GParamSpec *pspec);
  void (*get_property) (GObject *object,
                                         guint property_id,
                                         GValue *value,
                                         GParamSpec *pspec);
  void (*dispose) (GObject *object);
  void (*finalize) (GObject *object);


  void (*dispatch_properties_changed) (GObject *object,
          guint n_pspecs,
          GParamSpec **pspecs);


  void (*notify) (GObject *object,
      GParamSpec *pspec);


  gpointer pdummy[8];
};
struct _GObjectConstructParam
{
  GParamSpec *pspec;
  GValue *value;
};



GType g_initially_unowned_get_type (void);
void g_object_class_install_property (GObjectClass *oclass,
            guint property_id,
            GParamSpec *pspec);
GParamSpec* g_object_class_find_property (GObjectClass *oclass,
            const gchar *property_name);
GParamSpec**g_object_class_list_properties (GObjectClass *oclass,
            guint *n_properties);
void g_object_class_override_property (GObjectClass *oclass,
            guint property_id,
            const gchar *name);

void g_object_interface_install_property (gpointer g_iface,
       GParamSpec *pspec);
GParamSpec* g_object_interface_find_property (gpointer g_iface,
       const gchar *property_name);
GParamSpec**g_object_interface_list_properties (gpointer g_iface,
       guint *n_properties_p);

gpointer g_object_new (GType object_type,
            const gchar *first_property_name,
            ...);
gpointer g_object_newv (GType object_type,
            guint n_parameters,
            GParameter *parameters);
GObject* g_object_new_valist (GType object_type,
            const gchar *first_property_name,
            va_list var_args);
void g_object_set (gpointer object,
            const gchar *first_property_name,
            ...) __attribute__((__sentinel__));
void g_object_get (gpointer object,
            const gchar *first_property_name,
            ...) __attribute__((__sentinel__));
gpointer g_object_connect (gpointer object,
            const gchar *signal_spec,
            ...) __attribute__((__sentinel__));
void g_object_disconnect (gpointer object,
            const gchar *signal_spec,
            ...) __attribute__((__sentinel__));
void g_object_set_valist (GObject *object,
            const gchar *first_property_name,
            va_list var_args);
void g_object_get_valist (GObject *object,
            const gchar *first_property_name,
            va_list var_args);
void g_object_set_property (GObject *object,
            const gchar *property_name,
            const GValue *value);
void g_object_get_property (GObject *object,
            const gchar *property_name,
            GValue *value);
void g_object_freeze_notify (GObject *object);
void g_object_notify (GObject *object,
            const gchar *property_name);
void g_object_thaw_notify (GObject *object);
gboolean g_object_is_floating (gpointer object);
gpointer g_object_ref_sink (gpointer object);
gpointer g_object_ref (gpointer object);
void g_object_unref (gpointer object);
void g_object_weak_ref (GObject *object,
            GWeakNotify notify,
            gpointer data);
void g_object_weak_unref (GObject *object,
            GWeakNotify notify,
            gpointer data);
void g_object_add_weak_pointer (GObject *object,
                                               gpointer *weak_pointer_location);
void g_object_remove_weak_pointer (GObject *object,
                                               gpointer *weak_pointer_location);

typedef void (*GToggleNotify) (gpointer data,
          GObject *object,
          gboolean is_last_ref);

void g_object_add_toggle_ref (GObject *object,
     GToggleNotify notify,
     gpointer data);
void g_object_remove_toggle_ref (GObject *object,
     GToggleNotify notify,
     gpointer data);

gpointer g_object_get_qdata (GObject *object,
            GQuark quark);
void g_object_set_qdata (GObject *object,
            GQuark quark,
            gpointer data);
void g_object_set_qdata_full (GObject *object,
            GQuark quark,
            gpointer data,
            GDestroyNotify destroy);
gpointer g_object_steal_qdata (GObject *object,
            GQuark quark);
gpointer g_object_get_data (GObject *object,
            const gchar *key);
void g_object_set_data (GObject *object,
            const gchar *key,
            gpointer data);
void g_object_set_data_full (GObject *object,
            const gchar *key,
            gpointer data,
            GDestroyNotify destroy);
gpointer g_object_steal_data (GObject *object,
            const gchar *key);
void g_object_watch_closure (GObject *object,
            GClosure *closure);
GClosure* g_cclosure_new_object (GCallback callback_func,
            GObject *object);
GClosure* g_cclosure_new_object_swap (GCallback callback_func,
            GObject *object);
GClosure* g_closure_new_object (guint sizeof_closure,
            GObject *object);
void g_value_set_object (GValue *value,
            gpointer v_object);
gpointer g_value_get_object (const GValue *value);
GObject* g_value_dup_object (const GValue *value);
gulong g_signal_connect_object (gpointer instance,
            const gchar *detailed_signal,
            GCallback c_handler,
            gpointer gobject,
            GConnectFlags connect_flags);


void g_object_force_floating (GObject *object);
void g_object_run_dispose (GObject *object);


void g_value_take_object (GValue *value,
            gpointer v_object);

void g_value_set_object_take_ownership (GValue *value,
            gpointer v_object);



gsize g_object_compat_control (gsize what,
            gpointer data);
# 281 "/usr/include/glib-2.0/gobject/gobject.h"

# 28 "/usr/include/glib-2.0/glib-object.h" 2
# 1 "/usr/include/glib-2.0/gobject/gparam.h" 1
# 29 "/usr/include/glib-2.0/glib-object.h" 2
# 1 "/usr/include/glib-2.0/gobject/gparamspecs.h" 1
# 28 "/usr/include/glib-2.0/gobject/gparamspecs.h"
# 1 "/usr/include/glib-2.0/gobject/gvalue.h" 1
# 29 "/usr/include/glib-2.0/gobject/gparamspecs.h" 2
# 1 "/usr/include/glib-2.0/gobject/genums.h" 1
# 30 "/usr/include/glib-2.0/gobject/gparamspecs.h" 2
# 1 "/usr/include/glib-2.0/gobject/gboxed.h" 1
# 31 "/usr/include/glib-2.0/gobject/gparamspecs.h" 2
# 1 "/usr/include/glib-2.0/gobject/gobject.h" 1
# 32 "/usr/include/glib-2.0/gobject/gparamspecs.h" 2


# 105 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecChar GParamSpecChar;
typedef struct _GParamSpecUChar GParamSpecUChar;
typedef struct _GParamSpecBoolean GParamSpecBoolean;
typedef struct _GParamSpecInt GParamSpecInt;
typedef struct _GParamSpecUInt GParamSpecUInt;
typedef struct _GParamSpecLong GParamSpecLong;
typedef struct _GParamSpecULong GParamSpecULong;
typedef struct _GParamSpecInt64 GParamSpecInt64;
typedef struct _GParamSpecUInt64 GParamSpecUInt64;
typedef struct _GParamSpecUnichar GParamSpecUnichar;
typedef struct _GParamSpecEnum GParamSpecEnum;
typedef struct _GParamSpecFlags GParamSpecFlags;
typedef struct _GParamSpecFloat GParamSpecFloat;
typedef struct _GParamSpecDouble GParamSpecDouble;
typedef struct _GParamSpecString GParamSpecString;
typedef struct _GParamSpecParam GParamSpecParam;
typedef struct _GParamSpecBoxed GParamSpecBoxed;
typedef struct _GParamSpecPointer GParamSpecPointer;
typedef struct _GParamSpecValueArray GParamSpecValueArray;
typedef struct _GParamSpecObject GParamSpecObject;
typedef struct _GParamSpecOverride GParamSpecOverride;
typedef struct _GParamSpecGType GParamSpecGType;

struct _GParamSpecChar
{
  GParamSpec parent_instance;

  gint8 minimum;
  gint8 maximum;
  gint8 default_value;
};
struct _GParamSpecUChar
{
  GParamSpec parent_instance;

  guint8 minimum;
  guint8 maximum;
  guint8 default_value;
};
struct _GParamSpecBoolean
{
  GParamSpec parent_instance;

  gboolean default_value;
};
struct _GParamSpecInt
{
  GParamSpec parent_instance;

  gint minimum;
  gint maximum;
  gint default_value;
};
struct _GParamSpecUInt
{
  GParamSpec parent_instance;

  guint minimum;
  guint maximum;
  guint default_value;
};
struct _GParamSpecLong
{
  GParamSpec parent_instance;

  glong minimum;
  glong maximum;
  glong default_value;
};
struct _GParamSpecULong
{
  GParamSpec parent_instance;

  gulong minimum;
  gulong maximum;
  gulong default_value;
};
struct _GParamSpecInt64
{
  GParamSpec parent_instance;

  gint64 minimum;
  gint64 maximum;
  gint64 default_value;
};
struct _GParamSpecUInt64
{
  GParamSpec parent_instance;

  guint64 minimum;
  guint64 maximum;
  guint64 default_value;
};
struct _GParamSpecUnichar
{
  GParamSpec parent_instance;

  gunichar default_value;
};
struct _GParamSpecEnum
{
  GParamSpec parent_instance;

  GEnumClass *enum_class;
  gint default_value;
};
struct _GParamSpecFlags
{
  GParamSpec parent_instance;

  GFlagsClass *flags_class;
  guint default_value;
};
struct _GParamSpecFloat
{
  GParamSpec parent_instance;

  gfloat minimum;
  gfloat maximum;
  gfloat default_value;
  gfloat epsilon;
};
struct _GParamSpecDouble
{
  GParamSpec parent_instance;

  gdouble minimum;
  gdouble maximum;
  gdouble default_value;
  gdouble epsilon;
};
struct _GParamSpecString
{
  GParamSpec parent_instance;

  gchar *default_value;
  gchar *cset_first;
  gchar *cset_nth;
  gchar substitutor;
  guint null_fold_if_empty : 1;
  guint ensure_non_null : 1;
};
struct _GParamSpecParam
{
  GParamSpec parent_instance;
};
struct _GParamSpecBoxed
{
  GParamSpec parent_instance;
};
struct _GParamSpecPointer
{
  GParamSpec parent_instance;
};
struct _GParamSpecValueArray
{
  GParamSpec parent_instance;
  GParamSpec *element_spec;
  guint fixed_n_elements;
};
struct _GParamSpecObject
{
  GParamSpec parent_instance;
};
struct _GParamSpecOverride
{

  GParamSpec parent_instance;
  GParamSpec *overridden;
};
struct _GParamSpecGType
{
  GParamSpec parent_instance;
  GType is_a_type;
};


GParamSpec* g_param_spec_char (const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       gint8 minimum,
       gint8 maximum,
       gint8 default_value,
       GParamFlags flags);
GParamSpec* g_param_spec_uchar (const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       guint8 minimum,
       guint8 maximum,
       guint8 default_value,
       GParamFlags flags);
GParamSpec* g_param_spec_boolean (const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       gboolean default_value,
       GParamFlags flags);
GParamSpec* g_param_spec_int (const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       gint minimum,
       gint maximum,
       gint default_value,
       GParamFlags flags);
GParamSpec* g_param_spec_uint (const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       guint minimum,
       guint maximum,
       guint default_value,
       GParamFlags flags);
GParamSpec* g_param_spec_long (const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       glong minimum,
       glong maximum,
       glong default_value,
       GParamFlags flags);
GParamSpec* g_param_spec_ulong (const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       gulong minimum,
       gulong maximum,
       gulong default_value,
       GParamFlags flags);
GParamSpec* g_param_spec_int64 (const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       gint64 minimum,
       gint64 maximum,
       gint64 default_value,
       GParamFlags flags);
GParamSpec* g_param_spec_uint64 (const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       guint64 minimum,
       guint64 maximum,
       guint64 default_value,
       GParamFlags flags);
GParamSpec* g_param_spec_unichar (const gchar *name,
              const gchar *nick,
              const gchar *blurb,
              gunichar default_value,
              GParamFlags flags);
GParamSpec* g_param_spec_enum (const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       GType enum_type,
       gint default_value,
       GParamFlags flags);
GParamSpec* g_param_spec_flags (const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       GType flags_type,
       guint default_value,
       GParamFlags flags);
GParamSpec* g_param_spec_float (const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       gfloat minimum,
       gfloat maximum,
       gfloat default_value,
       GParamFlags flags);
GParamSpec* g_param_spec_double (const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       gdouble minimum,
       gdouble maximum,
       gdouble default_value,
       GParamFlags flags);
GParamSpec* g_param_spec_string (const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       const gchar *default_value,
       GParamFlags flags);
GParamSpec* g_param_spec_param (const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       GType param_type,
       GParamFlags flags);
GParamSpec* g_param_spec_boxed (const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       GType boxed_type,
       GParamFlags flags);
GParamSpec* g_param_spec_pointer (const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       GParamFlags flags);
GParamSpec* g_param_spec_value_array (const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       GParamSpec *element_spec,
       GParamFlags flags);
GParamSpec* g_param_spec_object (const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       GType object_type,
       GParamFlags flags);
GParamSpec* g_param_spec_override (const gchar *name,
       GParamSpec *overridden);
GParamSpec* g_param_spec_gtype (const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       GType is_a_type,
       GParamFlags flags);
# 435 "/usr/include/glib-2.0/gobject/gparamspecs.h"
extern GType *g_param_spec_types;


# 30 "/usr/include/glib-2.0/glib-object.h" 2
# 1 "/usr/include/glib-2.0/gobject/gsignal.h" 1
# 31 "/usr/include/glib-2.0/glib-object.h" 2
# 1 "/usr/include/glib-2.0/gobject/gsourceclosure.h" 1
# 26 "/usr/include/glib-2.0/gobject/gsourceclosure.h"
# 1 "/usr/include/glib-2.0/gobject/gclosure.h" 1
# 27 "/usr/include/glib-2.0/gobject/gsourceclosure.h" 2



void g_source_set_closure (GSource *source,
      GClosure *closure);

GType g_io_channel_get_type (void);
GType g_io_condition_get_type (void);





# 32 "/usr/include/glib-2.0/glib-object.h" 2
# 1 "/usr/include/glib-2.0/gobject/gtype.h" 1
# 33 "/usr/include/glib-2.0/glib-object.h" 2
# 1 "/usr/include/glib-2.0/gobject/gtypemodule.h" 1
# 26 "/usr/include/glib-2.0/gobject/gtypemodule.h"
# 1 "/usr/include/glib-2.0/gobject/gobject.h" 1
# 27 "/usr/include/glib-2.0/gobject/gtypemodule.h" 2
# 1 "/usr/include/glib-2.0/gobject/genums.h" 1
# 28 "/usr/include/glib-2.0/gobject/gtypemodule.h" 2



typedef struct _GTypeModule GTypeModule;
typedef struct _GTypeModuleClass GTypeModuleClass;
# 41 "/usr/include/glib-2.0/gobject/gtypemodule.h"
struct _GTypeModule
{
  GObject parent_instance;

  guint use_count;
  GSList *type_infos;
  GSList *interface_infos;


  gchar *name;
};

struct _GTypeModuleClass
{
  GObjectClass parent_class;


  gboolean (* load) (GTypeModule *module);
  void (* unload) (GTypeModule *module);



  void (*reserved1) (void);
  void (*reserved2) (void);
  void (*reserved3) (void);
  void (*reserved4) (void);
};

GType g_type_module_get_type (void) __attribute__((__const__));
gboolean g_type_module_use (GTypeModule *module);
void g_type_module_unuse (GTypeModule *module);
void g_type_module_set_name (GTypeModule *module,
                                       const gchar *name);
GType g_type_module_register_type (GTypeModule *module,
                                       GType parent_type,
                                       const gchar *type_name,
                                       const GTypeInfo *type_info,
                                       GTypeFlags flags);
void g_type_module_add_interface (GTypeModule *module,
                                       GType instance_type,
                                       GType interface_type,
                                       const GInterfaceInfo *interface_info);
GType g_type_module_register_enum (GTypeModule *module,
                                       const gchar *name,
                                       const GEnumValue *const_static_values);
GType g_type_module_register_flags (GTypeModule *module,
                                       const gchar *name,
                                       const GFlagsValue *const_static_values);


# 34 "/usr/include/glib-2.0/glib-object.h" 2
# 1 "/usr/include/glib-2.0/gobject/gtypeplugin.h" 1
# 26 "/usr/include/glib-2.0/gobject/gtypeplugin.h"
# 1 "/usr/include/glib-2.0/gobject/gtype.h" 1
# 27 "/usr/include/glib-2.0/gobject/gtypeplugin.h" 2


# 40 "/usr/include/glib-2.0/gobject/gtypeplugin.h"
typedef struct _GTypePluginClass GTypePluginClass;
typedef void (*GTypePluginUse) (GTypePlugin *plugin);
typedef void (*GTypePluginUnuse) (GTypePlugin *plugin);
typedef void (*GTypePluginCompleteTypeInfo) (GTypePlugin *plugin,
         GType g_type,
         GTypeInfo *info,
         GTypeValueTable *value_table);
typedef void (*GTypePluginCompleteInterfaceInfo) (GTypePlugin *plugin,
         GType instance_type,
         GType interface_type,
         GInterfaceInfo *info);
struct _GTypePluginClass
{

  GTypeInterface base_iface;


  GTypePluginUse use_plugin;
  GTypePluginUnuse unuse_plugin;
  GTypePluginCompleteTypeInfo complete_type_info;
  GTypePluginCompleteInterfaceInfo complete_interface_info;
};



GType g_type_plugin_get_type (void) __attribute__((__const__));
void g_type_plugin_use (GTypePlugin *plugin);
void g_type_plugin_unuse (GTypePlugin *plugin);
void g_type_plugin_complete_type_info (GTypePlugin *plugin,
       GType g_type,
       GTypeInfo *info,
       GTypeValueTable *value_table);
void g_type_plugin_complete_interface_info (GTypePlugin *plugin,
       GType instance_type,
       GType interface_type,
       GInterfaceInfo *info);


# 35 "/usr/include/glib-2.0/glib-object.h" 2
# 1 "/usr/include/glib-2.0/gobject/gvalue.h" 1
# 36 "/usr/include/glib-2.0/glib-object.h" 2
# 1 "/usr/include/glib-2.0/gobject/gvaluearray.h" 1
# 28 "/usr/include/glib-2.0/gobject/gvaluearray.h"
# 1 "/usr/include/glib-2.0/gobject/gvalue.h" 1
# 29 "/usr/include/glib-2.0/gobject/gvaluearray.h" 2






typedef struct _GValueArray GValueArray;
struct _GValueArray
{
  guint n_values;
  GValue *values;


  guint n_prealloced;
};



GValue* g_value_array_get_nth (GValueArray *value_array,
           guint index_);
GValueArray* g_value_array_new (guint n_prealloced);
void g_value_array_free (GValueArray *value_array);
GValueArray* g_value_array_copy (const GValueArray *value_array);
GValueArray* g_value_array_prepend (GValueArray *value_array,
           const GValue *value);
GValueArray* g_value_array_append (GValueArray *value_array,
           const GValue *value);
GValueArray* g_value_array_insert (GValueArray *value_array,
           guint index_,
           const GValue *value);
GValueArray* g_value_array_remove (GValueArray *value_array,
           guint index_);
GValueArray* g_value_array_sort (GValueArray *value_array,
           GCompareFunc compare_func);
GValueArray* g_value_array_sort_with_data (GValueArray *value_array,
           GCompareDataFunc compare_func,
           gpointer user_data);



# 37 "/usr/include/glib-2.0/glib-object.h" 2
# 1 "/usr/include/glib-2.0/gobject/gvaluetypes.h" 1
# 28 "/usr/include/glib-2.0/gobject/gvaluetypes.h"
# 1 "/usr/include/glib-2.0/gobject/gvalue.h" 1
# 29 "/usr/include/glib-2.0/gobject/gvaluetypes.h" 2


# 51 "/usr/include/glib-2.0/gobject/gvaluetypes.h"
void g_value_set_char (GValue *value,
       gchar v_char);
gchar g_value_get_char (const GValue *value);
void g_value_set_uchar (GValue *value,
       guchar v_uchar);
guchar g_value_get_uchar (const GValue *value);
void g_value_set_boolean (GValue *value,
       gboolean v_boolean);
gboolean g_value_get_boolean (const GValue *value);
void g_value_set_int (GValue *value,
       gint v_int);
gint g_value_get_int (const GValue *value);
void g_value_set_uint (GValue *value,
       guint v_uint);
guint g_value_get_uint (const GValue *value);
void g_value_set_long (GValue *value,
       glong v_long);
glong g_value_get_long (const GValue *value);
void g_value_set_ulong (GValue *value,
       gulong v_ulong);
gulong g_value_get_ulong (const GValue *value);
void g_value_set_int64 (GValue *value,
       gint64 v_int64);
gint64 g_value_get_int64 (const GValue *value);
void g_value_set_uint64 (GValue *value,
       guint64 v_uint64);
guint64 g_value_get_uint64 (const GValue *value);
void g_value_set_float (GValue *value,
       gfloat v_float);
gfloat g_value_get_float (const GValue *value);
void g_value_set_double (GValue *value,
       gdouble v_double);
gdouble g_value_get_double (const GValue *value);
void g_value_set_string (GValue *value,
       const gchar *v_string);
void g_value_set_static_string (GValue *value,
       const gchar *v_string);
const gchar* g_value_get_string (const GValue *value);
gchar* g_value_dup_string (const GValue *value);
void g_value_set_pointer (GValue *value,
       gpointer v_pointer);
gpointer g_value_get_pointer (const GValue *value);
GType g_gtype_get_type (void);
void g_value_set_gtype (GValue *value,
       GType v_gtype);
GType g_value_get_gtype (const GValue *value);



GType g_pointer_type_register_static (const gchar *name);


gchar* g_strdup_value_contents (const GValue *value);


void g_value_take_string (GValue *value,
       gchar *v_string);

void g_value_set_string_take_ownership (GValue *value,
       gchar *v_string);




typedef gchar* gchararray;



# 38 "/usr/include/glib-2.0/glib-object.h" 2
# 18 "../../linc2/include/linc/linc-types.h" 2



typedef enum {
 LINK_CONNECTION_SSL = 1 << 0,
 LINK_CONNECTION_NONBLOCKING = 1 << 1,
 LINK_CONNECTION_BLOCK_SIGNAL = 1 << 2,
 LINK_CONNECTION_LOCAL_ONLY = 1 << 3
} LinkConnectionOptions;

typedef struct _LinkWatch LinkWatch;
typedef struct _LinkProtocolInfo LinkProtocolInfo;
# 49 "../../linc2/include/linc/linc-types.h"
GMutex *link_mutex_new (void);


# 17 "../../linc2/include/linc/linc.h" 2
# 1 "../../linc2/include/linc/linc-protocol.h" 1
# 17 "../../linc2/include/linc/linc-protocol.h"

# 26 "../../linc2/include/linc/linc-protocol.h"
# 1 "/usr/include/sys/socket.h" 1 3 4
# 25 "/usr/include/sys/socket.h" 3 4


# 1 "/usr/include/sys/uio.h" 1 3 4
# 26 "/usr/include/sys/uio.h" 3 4



# 1 "/usr/include/bits/uio.h" 1 3 4
# 42 "/usr/include/bits/uio.h" 3 4
struct iovec
  {
    void *iov_base;
    size_t iov_len;
  };
# 30 "/usr/include/sys/uio.h" 2 3 4
# 40 "/usr/include/sys/uio.h" 3 4
extern ssize_t readv (int __fd, __const struct iovec *__iovec, int __count);
# 50 "/usr/include/sys/uio.h" 3 4
extern ssize_t writev (int __fd, __const struct iovec *__iovec, int __count);


# 28 "/usr/include/sys/socket.h" 2 3 4

# 1 "/usr/lib/gcc/i386-redhat-linux/4.1.0/include/stddef.h" 1 3 4
# 30 "/usr/include/sys/socket.h" 2 3 4





# 1 "/usr/include/bits/socket.h" 1 3 4
# 29 "/usr/include/bits/socket.h" 3 4
# 1 "/usr/lib/gcc/i386-redhat-linux/4.1.0/include/stddef.h" 1 3 4
# 30 "/usr/include/bits/socket.h" 2 3 4

# 1 "/usr/lib/gcc/i386-redhat-linux/4.1.0/include/limits.h" 1 3 4
# 32 "/usr/include/bits/socket.h" 2 3 4




typedef __socklen_t socklen_t;




enum __socket_type
{
  SOCK_STREAM = 1,


  SOCK_DGRAM = 2,


  SOCK_RAW = 3,

  SOCK_RDM = 4,

  SOCK_SEQPACKET = 5,


  SOCK_PACKET = 10



};
# 142 "/usr/include/bits/socket.h" 3 4
# 1 "/usr/include/bits/sockaddr.h" 1 3 4
# 29 "/usr/include/bits/sockaddr.h" 3 4
typedef unsigned short int sa_family_t;
# 143 "/usr/include/bits/socket.h" 2 3 4


struct sockaddr
  {
    sa_family_t sa_family;
    char sa_data[14];
  };
# 162 "/usr/include/bits/socket.h" 3 4
struct sockaddr_storage
  {
    sa_family_t ss_family;
    __uint32_t __ss_align;
    char __ss_padding[(128 - (2 * sizeof (__uint32_t)))];
  };



enum
  {
    MSG_OOB = 0x01,

    MSG_PEEK = 0x02,

    MSG_DONTROUTE = 0x04,






    MSG_CTRUNC = 0x08,

    MSG_PROXY = 0x10,

    MSG_TRUNC = 0x20,

    MSG_DONTWAIT = 0x40,

    MSG_EOR = 0x80,

    MSG_WAITALL = 0x100,

    MSG_FIN = 0x200,

    MSG_SYN = 0x400,

    MSG_CONFIRM = 0x800,

    MSG_RST = 0x1000,

    MSG_ERRQUEUE = 0x2000,

    MSG_NOSIGNAL = 0x4000,

    MSG_MORE = 0x8000

  };




struct msghdr
  {
    void *msg_name;
    socklen_t msg_namelen;

    struct iovec *msg_iov;
    size_t msg_iovlen;

    void *msg_control;
    size_t msg_controllen;

    int msg_flags;
  };


struct cmsghdr
  {
    size_t cmsg_len;

    int cmsg_level;
    int cmsg_type;

    __extension__ unsigned char __cmsg_data [];

  };
# 257 "/usr/include/bits/socket.h" 3 4
extern struct cmsghdr *__cmsg_nxthdr (struct msghdr *__mhdr,
          struct cmsghdr *__cmsg) __attribute__ ((__nothrow__));




extern __inline struct cmsghdr *
__attribute__ ((__nothrow__)) __cmsg_nxthdr (struct msghdr *__mhdr, struct cmsghdr *__cmsg)
{
  if ((size_t) __cmsg->cmsg_len < sizeof (struct cmsghdr))

    return 0;

  __cmsg = (struct cmsghdr *) ((unsigned char *) __cmsg
          + (((__cmsg->cmsg_len) + sizeof (size_t) - 1) & (size_t) ~(sizeof (size_t) - 1)));
  if ((unsigned char *) (__cmsg + 1) > ((unsigned char *) __mhdr->msg_control
     + __mhdr->msg_controllen)
      || ((unsigned char *) __cmsg + (((__cmsg->cmsg_len) + sizeof (size_t) - 1) & (size_t) ~(sizeof (size_t) - 1))
   > ((unsigned char *) __mhdr->msg_control + __mhdr->msg_controllen)))

    return 0;
  return __cmsg;
}




enum
  {
    SCM_RIGHTS = 0x01


    , SCM_CREDENTIALS = 0x02


  };



struct ucred
{
  pid_t pid;
  uid_t uid;
  gid_t gid;
};


# 1 "/usr/include/asm/socket.h" 1 3 4



# 1 "/usr/include/asm/sockios.h" 1 3 4
# 5 "/usr/include/asm/socket.h" 2 3 4
# 305 "/usr/include/bits/socket.h" 2 3 4



struct linger
  {
    int l_onoff;
    int l_linger;
  };
# 36 "/usr/include/sys/socket.h" 2 3 4




struct osockaddr
  {
    unsigned short int sa_family;
    unsigned char sa_data[14];
  };




enum
{
  SHUT_RD = 0,

  SHUT_WR,

  SHUT_RDWR

};
# 100 "/usr/include/sys/socket.h" 3 4
extern int socket (int __domain, int __type, int __protocol) __attribute__ ((__nothrow__));





extern int socketpair (int __domain, int __type, int __protocol,
         int __fds[2]) __attribute__ ((__nothrow__));


extern int bind (int __fd, __const struct sockaddr * __addr, socklen_t __len)
     __attribute__ ((__nothrow__));


extern int getsockname (int __fd, struct sockaddr *__restrict __addr,
   socklen_t *__restrict __len) __attribute__ ((__nothrow__));
# 124 "/usr/include/sys/socket.h" 3 4
extern int connect (int __fd, __const struct sockaddr * __addr, socklen_t __len);



extern int getpeername (int __fd, struct sockaddr *__restrict __addr,
   socklen_t *__restrict __len) __attribute__ ((__nothrow__));






extern ssize_t send (int __fd, __const void *__buf, size_t __n, int __flags);






extern ssize_t recv (int __fd, void *__buf, size_t __n, int __flags);






extern ssize_t sendto (int __fd, __const void *__buf, size_t __n,
         int __flags, __const struct sockaddr * __addr,
         socklen_t __addr_len);
# 161 "/usr/include/sys/socket.h" 3 4
extern ssize_t recvfrom (int __fd, void *__restrict __buf, size_t __n,
    int __flags, struct sockaddr *__restrict __addr,
    socklen_t *__restrict __addr_len);







extern ssize_t sendmsg (int __fd, __const struct msghdr *__message,
   int __flags);






extern ssize_t recvmsg (int __fd, struct msghdr *__message, int __flags);





extern int getsockopt (int __fd, int __level, int __optname,
         void *__restrict __optval,
         socklen_t *__restrict __optlen) __attribute__ ((__nothrow__));




extern int setsockopt (int __fd, int __level, int __optname,
         __const void *__optval, socklen_t __optlen) __attribute__ ((__nothrow__));





extern int listen (int __fd, int __n) __attribute__ ((__nothrow__));
# 209 "/usr/include/sys/socket.h" 3 4
extern int accept (int __fd, struct sockaddr *__restrict __addr,
     socklen_t *__restrict __addr_len);







extern int shutdown (int __fd, int __how) __attribute__ ((__nothrow__));




extern int sockatmark (int __fd) __attribute__ ((__nothrow__));







extern int isfdtype (int __fd, int __fdtype) __attribute__ ((__nothrow__));
# 240 "/usr/include/sys/socket.h" 3 4

# 27 "../../linc2/include/linc/linc-protocol.h" 2
# 1 "/usr/include/netdb.h" 1 3 4
# 28 "/usr/include/netdb.h" 3 4
# 1 "/usr/include/netinet/in.h" 1 3 4
# 23 "/usr/include/netinet/in.h" 3 4
# 1 "/usr/include/stdint.h" 1 3 4
# 28 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 29 "/usr/include/stdint.h" 2 3 4
# 49 "/usr/include/stdint.h" 3 4
typedef unsigned char uint8_t;
typedef unsigned short int uint16_t;

typedef unsigned int uint32_t;





__extension__
typedef unsigned long long int uint64_t;






typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;



__extension__
typedef long long int int_least64_t;



typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;



__extension__
typedef unsigned long long int uint_least64_t;






typedef signed char int_fast8_t;





typedef int int_fast16_t;
typedef int int_fast32_t;
__extension__
typedef long long int int_fast64_t;



typedef unsigned char uint_fast8_t;





typedef unsigned int uint_fast16_t;
typedef unsigned int uint_fast32_t;
__extension__
typedef unsigned long long int uint_fast64_t;
# 126 "/usr/include/stdint.h" 3 4
typedef int intptr_t;


typedef unsigned int uintptr_t;
# 138 "/usr/include/stdint.h" 3 4
__extension__
typedef long long int intmax_t;
__extension__
typedef unsigned long long int uintmax_t;
# 24 "/usr/include/netinet/in.h" 2 3 4







enum
  {
    IPPROTO_IP = 0,

    IPPROTO_HOPOPTS = 0,

    IPPROTO_ICMP = 1,

    IPPROTO_IGMP = 2,

    IPPROTO_IPIP = 4,

    IPPROTO_TCP = 6,

    IPPROTO_EGP = 8,

    IPPROTO_PUP = 12,

    IPPROTO_UDP = 17,

    IPPROTO_IDP = 22,

    IPPROTO_TP = 29,

    IPPROTO_IPV6 = 41,

    IPPROTO_ROUTING = 43,

    IPPROTO_FRAGMENT = 44,

    IPPROTO_RSVP = 46,

    IPPROTO_GRE = 47,

    IPPROTO_ESP = 50,

    IPPROTO_AH = 51,

    IPPROTO_ICMPV6 = 58,

    IPPROTO_NONE = 59,

    IPPROTO_DSTOPTS = 60,

    IPPROTO_MTP = 92,

    IPPROTO_ENCAP = 98,

    IPPROTO_PIM = 103,

    IPPROTO_COMP = 108,

    IPPROTO_SCTP = 132,

    IPPROTO_RAW = 255,

    IPPROTO_MAX
  };



typedef uint16_t in_port_t;


enum
  {
    IPPORT_ECHO = 7,
    IPPORT_DISCARD = 9,
    IPPORT_SYSTAT = 11,
    IPPORT_DAYTIME = 13,
    IPPORT_NETSTAT = 15,
    IPPORT_FTP = 21,
    IPPORT_TELNET = 23,
    IPPORT_SMTP = 25,
    IPPORT_TIMESERVER = 37,
    IPPORT_NAMESERVER = 42,
    IPPORT_WHOIS = 43,
    IPPORT_MTP = 57,

    IPPORT_TFTP = 69,
    IPPORT_RJE = 77,
    IPPORT_FINGER = 79,
    IPPORT_TTYLINK = 87,
    IPPORT_SUPDUP = 95,


    IPPORT_EXECSERVER = 512,
    IPPORT_LOGINSERVER = 513,
    IPPORT_CMDSERVER = 514,
    IPPORT_EFSSERVER = 520,


    IPPORT_BIFFUDP = 512,
    IPPORT_WHOSERVER = 513,
    IPPORT_ROUTESERVER = 520,


    IPPORT_RESERVED = 1024,


    IPPORT_USERRESERVED = 5000
  };



typedef uint32_t in_addr_t;
struct in_addr
  {
    in_addr_t s_addr;
  };
# 193 "/usr/include/netinet/in.h" 3 4
struct in6_addr
  {
    union
      {
 uint8_t u6_addr8[16];
 uint16_t u6_addr16[8];
 uint32_t u6_addr32[4];
      } in6_u;



  };

extern const struct in6_addr in6addr_any;
extern const struct in6_addr in6addr_loopback;
# 219 "/usr/include/netinet/in.h" 3 4
struct sockaddr_in
  {
    sa_family_t sin_family;
    in_port_t sin_port;
    struct in_addr sin_addr;


    unsigned char sin_zero[sizeof (struct sockaddr) -
      (sizeof (unsigned short int)) -
      sizeof (in_port_t) -
      sizeof (struct in_addr)];
  };


struct sockaddr_in6
  {
    sa_family_t sin6_family;
    in_port_t sin6_port;
    uint32_t sin6_flowinfo;
    struct in6_addr sin6_addr;
    uint32_t sin6_scope_id;
  };



struct ip_mreq
  {

    struct in_addr imr_multiaddr;


    struct in_addr imr_interface;
  };

struct ip_mreq_source
  {

    struct in_addr imr_multiaddr;


    struct in_addr imr_interface;


    struct in_addr imr_sourceaddr;
  };


struct ipv6_mreq
  {

    struct in6_addr ipv6mr_multiaddr;


    unsigned int ipv6mr_interface;
  };



struct group_req
  {

    uint32_t gr_interface;


    struct sockaddr_storage gr_group;
  };

struct group_source_req
  {

    uint32_t gsr_interface;


    struct sockaddr_storage gsr_group;


    struct sockaddr_storage gsr_source;
  };



struct ip_msfilter
  {

    struct in_addr imsf_multiaddr;


    struct in_addr imsf_interface;


    uint32_t imsf_fmode;


    uint32_t imsf_numsrc;

    struct in_addr imsf_slist[1];
  };





struct group_filter
  {

    uint32_t gf_interface;


    struct sockaddr_storage gf_group;


    uint32_t gf_fmode;


    uint32_t gf_numsrc;

    struct sockaddr_storage gf_slist[1];
};
# 345 "/usr/include/netinet/in.h" 3 4
# 1 "/usr/include/bits/in.h" 1 3 4
# 82 "/usr/include/bits/in.h" 3 4
struct ip_opts
  {
    struct in_addr ip_dst;
    char ip_opts[40];
  };


struct ip_mreqn
  {
    struct in_addr imr_multiaddr;
    struct in_addr imr_address;
    int imr_ifindex;
  };


struct in_pktinfo
  {
    int ipi_ifindex;
    struct in_addr ipi_spec_dst;
    struct in_addr ipi_addr;
  };
# 346 "/usr/include/netinet/in.h" 2 3 4
# 354 "/usr/include/netinet/in.h" 3 4
extern uint32_t ntohl (uint32_t __netlong) __attribute__ ((__nothrow__)) __attribute__ ((__const__));
extern uint16_t ntohs (uint16_t __netshort)
     __attribute__ ((__nothrow__)) __attribute__ ((__const__));
extern uint32_t htonl (uint32_t __hostlong)
     __attribute__ ((__nothrow__)) __attribute__ ((__const__));
extern uint16_t htons (uint16_t __hostshort)
     __attribute__ ((__nothrow__)) __attribute__ ((__const__));




# 1 "/usr/include/bits/byteswap.h" 1 3 4
# 366 "/usr/include/netinet/in.h" 2 3 4
# 428 "/usr/include/netinet/in.h" 3 4
extern int bindresvport (int __sockfd, struct sockaddr_in *__sock_in) __attribute__ ((__nothrow__));


extern int bindresvport6 (int __sockfd, struct sockaddr_in6 *__sock_in)
     __attribute__ ((__nothrow__));
# 456 "/usr/include/netinet/in.h" 3 4
struct in6_pktinfo
  {
    struct in6_addr ipi6_addr;
    unsigned int ipi6_ifindex;
  };
# 510 "/usr/include/netinet/in.h" 3 4

# 29 "/usr/include/netdb.h" 2 3 4




# 1 "/usr/include/rpc/netdb.h" 1 3 4
# 42 "/usr/include/rpc/netdb.h" 3 4
# 1 "/usr/lib/gcc/i386-redhat-linux/4.1.0/include/stddef.h" 1 3 4
# 43 "/usr/include/rpc/netdb.h" 2 3 4



struct rpcent
{
  char *r_name;
  char **r_aliases;
  int r_number;
};

extern void setrpcent (int __stayopen) __attribute__ ((__nothrow__));
extern void endrpcent (void) __attribute__ ((__nothrow__));
extern struct rpcent *getrpcbyname (__const char *__name) __attribute__ ((__nothrow__));
extern struct rpcent *getrpcbynumber (int __number) __attribute__ ((__nothrow__));
extern struct rpcent *getrpcent (void) __attribute__ ((__nothrow__));


extern int getrpcbyname_r (__const char *__name, struct rpcent *__result_buf,
      char *__buffer, size_t __buflen,
      struct rpcent **__result) __attribute__ ((__nothrow__));

extern int getrpcbynumber_r (int __number, struct rpcent *__result_buf,
        char *__buffer, size_t __buflen,
        struct rpcent **__result) __attribute__ ((__nothrow__));

extern int getrpcent_r (struct rpcent *__result_buf, char *__buffer,
   size_t __buflen, struct rpcent **__result) __attribute__ ((__nothrow__));



# 34 "/usr/include/netdb.h" 2 3 4
# 43 "/usr/include/netdb.h" 3 4
# 1 "/usr/include/bits/netdb.h" 1 3 4
# 27 "/usr/include/bits/netdb.h" 3 4
struct netent
{
  char *n_name;
  char **n_aliases;
  int n_addrtype;
  uint32_t n_net;
};
# 44 "/usr/include/netdb.h" 2 3 4
# 54 "/usr/include/netdb.h" 3 4







extern int *__h_errno_location (void) __attribute__ ((__nothrow__)) __attribute__ ((__const__));
# 88 "/usr/include/netdb.h" 3 4
extern void herror (__const char *__str) __attribute__ ((__nothrow__));


extern __const char *hstrerror (int __err_num) __attribute__ ((__nothrow__));




struct hostent
{
  char *h_name;
  char **h_aliases;
  int h_addrtype;
  int h_length;
  char **h_addr_list;

};






extern void sethostent (int __stay_open);





extern void endhostent (void);






extern struct hostent *gethostent (void);






extern struct hostent *gethostbyaddr (__const void *__addr, __socklen_t __len,
          int __type);





extern struct hostent *gethostbyname (__const char *__name);
# 149 "/usr/include/netdb.h" 3 4
extern struct hostent *gethostbyname2 (__const char *__name, int __af);
# 161 "/usr/include/netdb.h" 3 4
extern int gethostent_r (struct hostent *__restrict __result_buf,
    char *__restrict __buf, size_t __buflen,
    struct hostent **__restrict __result,
    int *__restrict __h_errnop);

extern int gethostbyaddr_r (__const void *__restrict __addr, __socklen_t __len,
       int __type,
       struct hostent *__restrict __result_buf,
       char *__restrict __buf, size_t __buflen,
       struct hostent **__restrict __result,
       int *__restrict __h_errnop);

extern int gethostbyname_r (__const char *__restrict __name,
       struct hostent *__restrict __result_buf,
       char *__restrict __buf, size_t __buflen,
       struct hostent **__restrict __result,
       int *__restrict __h_errnop);

extern int gethostbyname2_r (__const char *__restrict __name, int __af,
        struct hostent *__restrict __result_buf,
        char *__restrict __buf, size_t __buflen,
        struct hostent **__restrict __result,
        int *__restrict __h_errnop);
# 192 "/usr/include/netdb.h" 3 4
extern void setnetent (int __stay_open);





extern void endnetent (void);






extern struct netent *getnetent (void);






extern struct netent *getnetbyaddr (uint32_t __net, int __type);





extern struct netent *getnetbyname (__const char *__name);
# 231 "/usr/include/netdb.h" 3 4
extern int getnetent_r (struct netent *__restrict __result_buf,
   char *__restrict __buf, size_t __buflen,
   struct netent **__restrict __result,
   int *__restrict __h_errnop);

extern int getnetbyaddr_r (uint32_t __net, int __type,
      struct netent *__restrict __result_buf,
      char *__restrict __buf, size_t __buflen,
      struct netent **__restrict __result,
      int *__restrict __h_errnop);

extern int getnetbyname_r (__const char *__restrict __name,
      struct netent *__restrict __result_buf,
      char *__restrict __buf, size_t __buflen,
      struct netent **__restrict __result,
      int *__restrict __h_errnop);




struct servent
{
  char *s_name;
  char **s_aliases;
  int s_port;
  char *s_proto;
};






extern void setservent (int __stay_open);





extern void endservent (void);






extern struct servent *getservent (void);






extern struct servent *getservbyname (__const char *__name,
          __const char *__proto);






extern struct servent *getservbyport (int __port, __const char *__proto);
# 303 "/usr/include/netdb.h" 3 4
extern int getservent_r (struct servent *__restrict __result_buf,
    char *__restrict __buf, size_t __buflen,
    struct servent **__restrict __result);

extern int getservbyname_r (__const char *__restrict __name,
       __const char *__restrict __proto,
       struct servent *__restrict __result_buf,
       char *__restrict __buf, size_t __buflen,
       struct servent **__restrict __result);

extern int getservbyport_r (int __port, __const char *__restrict __proto,
       struct servent *__restrict __result_buf,
       char *__restrict __buf, size_t __buflen,
       struct servent **__restrict __result);




struct protoent
{
  char *p_name;
  char **p_aliases;
  int p_proto;
};






extern void setprotoent (int __stay_open);





extern void endprotoent (void);






extern struct protoent *getprotoent (void);





extern struct protoent *getprotobyname (__const char *__name);





extern struct protoent *getprotobynumber (int __proto);
# 369 "/usr/include/netdb.h" 3 4
extern int getprotoent_r (struct protoent *__restrict __result_buf,
     char *__restrict __buf, size_t __buflen,
     struct protoent **__restrict __result);

extern int getprotobyname_r (__const char *__restrict __name,
        struct protoent *__restrict __result_buf,
        char *__restrict __buf, size_t __buflen,
        struct protoent **__restrict __result);

extern int getprotobynumber_r (int __proto,
          struct protoent *__restrict __result_buf,
          char *__restrict __buf, size_t __buflen,
          struct protoent **__restrict __result);
# 390 "/usr/include/netdb.h" 3 4
extern int setnetgrent (__const char *__netgroup);







extern void endnetgrent (void);
# 407 "/usr/include/netdb.h" 3 4
extern int getnetgrent (char **__restrict __hostp,
   char **__restrict __userp,
   char **__restrict __domainp);
# 418 "/usr/include/netdb.h" 3 4
extern int innetgr (__const char *__netgroup, __const char *__host,
      __const char *__user, __const char *domain);







extern int getnetgrent_r (char **__restrict __hostp,
     char **__restrict __userp,
     char **__restrict __domainp,
     char *__restrict __buffer, size_t __buflen);
# 446 "/usr/include/netdb.h" 3 4
extern int rcmd (char **__restrict __ahost, unsigned short int __rport,
   __const char *__restrict __locuser,
   __const char *__restrict __remuser,
   __const char *__restrict __cmd, int *__restrict __fd2p);
# 458 "/usr/include/netdb.h" 3 4
extern int rcmd_af (char **__restrict __ahost, unsigned short int __rport,
      __const char *__restrict __locuser,
      __const char *__restrict __remuser,
      __const char *__restrict __cmd, int *__restrict __fd2p,
      sa_family_t __af);
# 474 "/usr/include/netdb.h" 3 4
extern int rexec (char **__restrict __ahost, int __rport,
    __const char *__restrict __name,
    __const char *__restrict __pass,
    __const char *__restrict __cmd, int *__restrict __fd2p);
# 486 "/usr/include/netdb.h" 3 4
extern int rexec_af (char **__restrict __ahost, int __rport,
       __const char *__restrict __name,
       __const char *__restrict __pass,
       __const char *__restrict __cmd, int *__restrict __fd2p,
       sa_family_t __af);
# 500 "/usr/include/netdb.h" 3 4
extern int ruserok (__const char *__rhost, int __suser,
      __const char *__remuser, __const char *__locuser);
# 510 "/usr/include/netdb.h" 3 4
extern int ruserok_af (__const char *__rhost, int __suser,
         __const char *__remuser, __const char *__locuser,
         sa_family_t __af);
# 522 "/usr/include/netdb.h" 3 4
extern int rresvport (int *__alport);
# 531 "/usr/include/netdb.h" 3 4
extern int rresvport_af (int *__alport, sa_family_t __af);






struct addrinfo
{
  int ai_flags;
  int ai_family;
  int ai_socktype;
  int ai_protocol;
  socklen_t ai_addrlen;
  struct sockaddr *ai_addr;
  char *ai_canonname;
  struct addrinfo *ai_next;
};
# 631 "/usr/include/netdb.h" 3 4
extern int getaddrinfo (__const char *__restrict __name,
   __const char *__restrict __service,
   __const struct addrinfo *__restrict __req,
   struct addrinfo **__restrict __pai);


extern void freeaddrinfo (struct addrinfo *__ai) __attribute__ ((__nothrow__));


extern __const char *gai_strerror (int __ecode) __attribute__ ((__nothrow__));





extern int getnameinfo (__const struct sockaddr *__restrict __sa,
   socklen_t __salen, char *__restrict __host,
   socklen_t __hostlen, char *__restrict __serv,
   socklen_t __servlen, unsigned int __flags);
# 682 "/usr/include/netdb.h" 3 4

# 28 "../../linc2/include/linc/linc-protocol.h" 2



typedef unsigned int LinkSockLen;

typedef enum {
 LINK_PROTOCOL_SECURE = 1<<0,
 LINK_PROTOCOL_NEEDS_BIND = 1<<1
} LinkProtocolFlags;

typedef void (*LinkProtocolSetupFunc) (int fd,
          LinkConnectionOptions cnx_flags);
typedef void (*LinkProtocolDestroyFunc) (int fd,
          const char *host_info,
          const char *serv_info);
typedef struct sockaddr *(*LinkProtocolGetSockAddrFunc) (const LinkProtocolInfo *proto,
        const char *hostname,
        const char *service,
        LinkSockLen *saddr_len);

typedef gboolean (*LinkProtocolGetSockInfoFunc) (const LinkProtocolInfo *proto,
       const struct sockaddr *sockaddr,
       gchar **hostname,
       gchar **service);

typedef gboolean (*LinkProtocolIsLocal) (const LinkProtocolInfo *proto,
       const struct sockaddr *sockaddr,
       LinkSockLen saddr_len);

struct _LinkProtocolInfo {
 const char *name;
 int family;
 int addr_len;
 int stream_proto_num;
 LinkProtocolFlags flags;

 LinkProtocolSetupFunc setup;
 LinkProtocolDestroyFunc destroy;
 LinkProtocolGetSockAddrFunc get_sockaddr;
 LinkProtocolGetSockInfoFunc get_sockinfo;
 LinkProtocolIsLocal is_local;

 gpointer dummy[8];
};

typedef enum {
 LINK_NET_ID_IS_LOCAL,
 LINK_NET_ID_IS_SHORT_HOSTNAME,
 LINK_NET_ID_IS_FQDN,
 LINK_NET_ID_IS_IPADDR
} LinkNetIdType;


LinkProtocolInfo * link_protocol_find (const char *name);
LinkProtocolInfo * link_protocol_find_num (const int family);
LinkProtocolInfo * link_protocol_all (void);
char *link_get_tmpdir (void);
void link_set_tmpdir (const char *dir);
void link_use_local_hostname (LinkNetIdType use);
const char* link_get_local_hostname (void);


# 18 "../../linc2/include/linc/linc.h" 2
# 1 "../../linc2/include/linc/linc-connection.h" 1
# 17 "../../linc2/include/linc/linc-connection.h"

# 42 "../../linc2/include/linc/linc-connection.h"
typedef enum { LINK_CONNECTING, LINK_CONNECTED, LINK_DISCONNECTED } LinkConnectionStatus;

typedef struct _LinkWriteOpts LinkWriteOpts;
typedef struct _LinkConnectionPrivate LinkConnectionPrivate;

typedef struct {
 GObject parent;

 const LinkProtocolInfo *proto;

 LinkConnectionStatus status;
 LinkConnectionOptions options;
 guint was_initiated : 1;
 guint is_auth : 1;
 guint inhibit_reconnect : 1;

 gchar *remote_host_info;
 gchar *remote_serv_info;

 LinkConnectionPrivate *priv;

 GSList *idle_broken_callbacks;
} LinkConnection;

typedef struct {
 GObjectClass parent_class;

 void (* state_changed) (LinkConnection *cnx,
        LinkConnectionStatus status);
 gboolean (* handle_input) (LinkConnection *cnx);


 void (* broken) (LinkConnection *cnx);




 void (* blocking) (LinkConnection *cnx,
        gulong buffer_size);
} LinkConnectionClass;

GType link_connection_get_type (void) __attribute__((__const__));

void link_connection_from_fd (LinkConnection *cnx,
       int fd,
       const LinkProtocolInfo *proto,
       gchar *remote_host_info,
       gchar *remote_serv_info,
       gboolean was_initiated,
       LinkConnectionStatus status,
       LinkConnectionOptions options);

LinkConnection *link_connection_initiate (GType derived_type,
       const char *proto_name,
       const char *remote_host_info,
       const char *remote_serv_info,
       LinkConnectionOptions options,
       const char *first_property,
       ...);
LinkConnectionStatus link_connection_try_reconnect (LinkConnection *cnx);

gpointer link_connection_ref (gpointer cnx);
void link_connection_unref (gpointer cnx);

typedef enum {
 LINK_IO_OK = 0,
 LINK_IO_FATAL_ERROR = -1,
 LINK_IO_QUEUED_DATA = -2
} LinkIOStatus;

glong link_connection_read (LinkConnection *cnx,
           guchar *buf,
           int len,
           gboolean block_for_full_read);



LinkIOStatus link_connection_write (LinkConnection *cnx,
           const guchar *buf,
           gulong len,
           const LinkWriteOpts *opt_write_opts);

LinkIOStatus link_connection_writev (LinkConnection *cnx,
           struct iovec *vecs,
           int nvecs,
           const LinkWriteOpts *opt_write_opts);

void link_connection_state_changed (LinkConnection *cnx,
         LinkConnectionStatus status);

LinkConnectionStatus link_connection_get_status (LinkConnection *cnx);
void link_connection_disconnect (LinkConnection *cnx);
LinkConnectionStatus link_connection_wait_connected (LinkConnection *cnx);




void link_connection_set_max_buffer (LinkConnection *cnx,
        gulong max_buffer_bytes);
LinkWriteOpts *link_write_options_new (gboolean block_on_write);

void link_write_options_free (LinkWriteOpts *write_opts);


typedef void (*LinkBrokenCallback) (LinkConnection *, gpointer user_data);
void link_connection_add_broken_cb (LinkConnection *cnx,
        LinkBrokenCallback fn,
        gpointer user_data);
void link_connection_remove_broken_cb (LinkConnection *cnx,
        LinkBrokenCallback opt_fn,
        gpointer opt_user_data);

void link_connections_close (void);


# 19 "../../linc2/include/linc/linc.h" 2
# 1 "../../linc2/include/linc/linc-server.h" 1
# 17 "../../linc2/include/linc/linc-server.h"

# 29 "../../linc2/include/linc/linc-server.h"
typedef struct _LinkServerPrivate LinkServerPrivate;

typedef struct {
 GObject parent;

 const LinkProtocolInfo *proto;

 char *local_host_info;
 char *local_serv_info;


 LinkConnectionOptions create_options;

 LinkServerPrivate *priv;
} LinkServer;

typedef struct {
 GObjectClass parent_class;

 LinkConnection *(* create_connection) (LinkServer *srv);

 void (* new_connection) (LinkServer *srv,
            LinkConnection *cnx);
} LinkServerClass;

GType link_server_get_type (void) __attribute__((__const__));

gboolean link_server_setup (LinkServer *srv,
          const char *proto_name,
          const char *local_host_info,
          const char *local_serv_info,
          LinkConnectionOptions create_options);


# 20 "../../linc2/include/linc/linc.h" 2
# 1 "../../linc2/include/linc/linc-source.h" 1
# 12 "../../linc2/include/linc/linc-source.h"





GSource *link_source_create_watch (GMainContext *context,
        int fd,
        GIOChannel *opt_channel,
        GIOCondition condition,
        GIOFunc func,
        gpointer user_data);
void link_source_set_condition (GSource *source,
        GIOCondition condition);


# 21 "../../linc2/include/linc/linc.h" 2



extern GMainLoop *link_loop;

void link_init (gboolean thread_safe);
void link_set_io_thread (gboolean io_in_thread);
void link_shutdown (void);
void link_main_iteration (gboolean block_for_reply);
gboolean link_main_pending (void);
void link_main_loop_run (void);
GMainLoop *link_main_get_loop (void);
guint link_main_idle_add (GSourceFunc function,
      gpointer data);

void link_wait (void);
void link_signal (void);

gboolean link_thread_io (void);
gboolean link_thread_safe (void);





int link_pipe (int *handles);


# 5 "../../include/orbit/GIOP/giop-basics.h" 2





typedef struct _GIOPRecvBuffer GIOPRecvBuffer;
typedef struct _GIOPSendBuffer GIOPSendBuffer;
typedef struct _GIOPConnection GIOPConnection;

typedef enum {
  GIOP_1_0,
  GIOP_1_1,
  GIOP_1_2,
  GIOP_LATEST = GIOP_1_2,
  GIOP_NUM_VERSIONS
} GIOPVersion;




# 7 "../../include/orbit/orbit-types.h" 2

# 1 "../../include/orbit/orb-core/orb-core-types.h" 1



# 1 "../../include/orbit/orb-core/orb-types.h" 1






# 33 "../../include/orbit/orb-core/orb-types.h"
typedef struct CORBA_any_struct CORBA_any;

typedef struct {
        CORBA_unsigned_short _digits;
        CORBA_short _scale;
        signed char _sign;
        signed char _value[1];
} CORBA_fixed_d_s;

struct CORBA_NVList_type {
 CORBA_unsigned_long flags;
 GArray *list;
};
# 61 "../../include/orbit/orb-core/orb-types.h"

# 5 "../../include/orbit/orb-core/orb-core-types.h" 2
# 1 "../../include/orbit/orb-core/corba-typecode-type.h" 1










typedef struct CORBA_TypeCode_struct *CORBA_TypeCode;



# 6 "../../include/orbit/orb-core/orb-core-types.h" 2
# 1 "../../include/orbit/orb-core/corba-any-type.h" 1



# 1 "../../include/orbit/orb-core/corba-pobj.h" 1
# 5 "../../include/orbit/orb-core/corba-any-type.h" 2



struct CORBA_any_struct {
 CORBA_TypeCode _type;
 gpointer _value;
 CORBA_boolean _release;
};


# 7 "../../include/orbit/orb-core/orb-core-types.h" 2
# 1 "../../include/orbit/orb-core/corba-environment-type.h" 1










 typedef struct CORBA_Environment_type CORBA_Environment;


struct CORBA_Environment_type {
 CORBA_char *_id;
 CORBA_unsigned_long _major;
 CORBA_any _any;
};


# 8 "../../include/orbit/orb-core/orb-core-types.h" 2
# 1 "../../include/orbit/orb-core/corba-orb-type.h" 1




# 1 "../../include/orbit/orb-core/orbit-object.h" 1
# 12 "../../include/orbit/orb-core/orbit-object.h"


typedef enum {
 ORBIT_ROT_NULL,
 ORBIT_ROT_OBJREF,

 ORBIT_ROT_ORB,
 ORBIT_ROT_ADAPTOR,
 ORBIT_ROT_POAMANAGER,
 ORBIT_ROT_POLICY,
 ORBIT_ROT_TYPECODE,
 ORBIT_ROT_REQUEST,
 ORBIT_ROT_SERVERREQUEST,
 ORBIT_ROT_CONTEXT,
 ORBIT_ROT_DYNANY,
 ORBIT_ROT_OAOBJECT,
 ORBIT_ROT_ORBGROUP,
 ORBIT_ROT_POACURRENT,
 ORBIT_ROT_CLIENT_POLICY
} ORBit_RootObject_Type;

typedef struct ORBit_RootObject_struct *ORBit_RootObject;

typedef void (* ORBit_RootObject_DestroyFunc) (ORBit_RootObject obj);

typedef struct _ORBit_RootObject_Interface {
 ORBit_RootObject_Type type;
 ORBit_RootObject_DestroyFunc destroy;
} ORBit_RootObject_Interface;

struct ORBit_RootObject_struct {
 const ORBit_RootObject_Interface *interface;
  int refs;
};



void ORBit_RootObject_init (ORBit_RootObject obj,
         const ORBit_RootObject_Interface *interface);
# 61 "../../include/orbit/orb-core/orbit-object.h"
gpointer ORBit_RootObject_duplicate (gpointer obj);
gpointer ORBit_RootObject_duplicate_T (gpointer obj);
void ORBit_RootObject_release (gpointer obj);
void ORBit_RootObject_release_T (gpointer obj);

extern GMutex *ORBit_RootObject_lifecycle_lock;




# 6 "../../include/orbit/orb-core/corba-orb-type.h" 2






typedef struct CORBA_ORB_type *CORBA_ORB;




   typedef CORBA_string CORBA_ORB_ObjectId;
# 31 "../../include/orbit/orb-core/corba-orb-type.h"
   extern const struct CORBA_TypeCode_struct TC_CORBA_ORB_ObjectId_struct;
# 40 "../../include/orbit/orb-core/corba-orb-type.h"
   typedef CORBA_Object CORBA_InterfaceDef;
   extern CORBA_unsigned_long CORBA_InterfaceDef__classid;
# 53 "../../include/orbit/orb-core/corba-orb-type.h"
   extern const struct CORBA_TypeCode_struct TC_CORBA_InterfaceDef_struct;






struct CORBA_ORB_type {
 struct ORBit_RootObject_struct root_object;

 GMutex *lock;

 GIOPVersion default_giop_version;

 GSList *servers;
 GSList *profiles;
 GPtrArray *adaptors;
 GHashTable *forw_binds;
 GSList *current_invocations;
 gpointer default_ctx;
 GHashTable *initial_refs;
 guint life_flags;





 GHashTable *objrefs;
};




# 9 "../../include/orbit/orb-core/orb-core-types.h" 2

# 1 "../../include/orbit/orb-core/corba-context-type.h" 1









typedef struct {
 CORBA_unsigned_long len;
 const CORBA_char *str;
} ORBit_ContextMarshalItem;




# 11 "../../include/orbit/orb-core/orb-core-types.h" 2

# 1 "../../include/orbit/orb-core/corba-typecode.h" 1












struct CORBA_TypeCode_struct {
 struct ORBit_RootObject_struct parent;
 CORBA_unsigned_long kind;
 CORBA_unsigned_long flags;
 CORBA_short c_length;
 CORBA_short c_align;
 CORBA_unsigned_long length;
 CORBA_unsigned_long sub_parts;
 CORBA_TypeCode *subtypes;
 CORBA_TypeCode discriminator;
 char *name;
 char *repo_id;
 char **subnames;
 CORBA_long *sublabels;
 CORBA_long default_index;
 CORBA_unsigned_long recurse_depth;
 CORBA_unsigned_short digits;
 CORBA_short scale;
};

extern const ORBit_RootObject_Interface ORBit_TypeCode_epv;
# 57 "../../include/orbit/orb-core/corba-typecode.h"
extern const struct CORBA_TypeCode_struct TC_null_struct;
extern const struct CORBA_TypeCode_struct TC_void_struct;
extern const struct CORBA_TypeCode_struct TC_CORBA_char_struct;
extern const struct CORBA_TypeCode_struct TC_CORBA_wchar_struct;
extern const struct CORBA_TypeCode_struct TC_CORBA_string_struct;
extern const struct CORBA_TypeCode_struct TC_CORBA_wstring_struct;
extern const struct CORBA_TypeCode_struct TC_CORBA_long_struct;
extern const struct CORBA_TypeCode_struct TC_CORBA_unsigned_long_struct;
extern const struct CORBA_TypeCode_struct TC_CORBA_short_struct;
extern const struct CORBA_TypeCode_struct TC_CORBA_unsigned_short_struct;
extern const struct CORBA_TypeCode_struct TC_CORBA_octet_struct;

extern const struct CORBA_TypeCode_struct TC_CORBA_Object_struct;
extern const struct CORBA_TypeCode_struct TC_CORBA_any_struct;
extern const struct CORBA_TypeCode_struct TC_CORBA_TypeCode_struct;
extern const struct CORBA_TypeCode_struct TC_CORBA_boolean_struct;
extern const struct CORBA_TypeCode_struct TC_CORBA_float_struct;
extern const struct CORBA_TypeCode_struct TC_CORBA_double_struct;
extern const struct CORBA_TypeCode_struct TC_CORBA_long_double_struct;
extern const struct CORBA_TypeCode_struct TC_CORBA_long_long_struct;
extern const struct CORBA_TypeCode_struct TC_CORBA_unsigned_long_long_struct;





void ORBit_encode_CORBA_TypeCode (CORBA_TypeCode tc,
      GIOPSendBuffer *buf);
gboolean ORBit_decode_CORBA_TypeCode (CORBA_TypeCode *tc,
      GIOPRecvBuffer *buf);

const char *ORBit_tk_to_name (CORBA_unsigned_long tk);




# 13 "../../include/orbit/orb-core/orb-core-types.h" 2
# 1 "../../include/orbit/orb-core/allocators.h" 1










void CORBA_free (gpointer mem);
gpointer ORBit_alloc_tcval (CORBA_TypeCode tc,
         guint nelements);
gpointer ORBit_realloc_tcval (gpointer old,
         CORBA_TypeCode tc,
         guint old_num_elements,
         guint num_elements);
# 43 "../../include/orbit/orb-core/allocators.h"
typedef gpointer (*ORBit_Mem_free_fn) (gpointer mem,
           gpointer func_data);





typedef enum {
 ORBIT_MEMHOW_NONE = 0,
 ORBIT_MEMHOW_SIMPLE = 1,
 ORBIT_MEMHOW_TYPECODE = 2,
 ORBIT_MEMHOW_FREEFNC = 3
} ORBitMemHow;

typedef struct ORBit_Memprefix {
 union {
  CORBA_TypeCode tc;
  ORBit_Mem_free_fn free_fn;
 } u;
 ORBitMemHow how;
} ORBit_MemPrefix;

void ORBit_free (gpointer mem);
void ORBit_free_T (gpointer mem);

CORBA_char *ORBit_alloc_string (size_t string_length);
gpointer ORBit_alloc_simple (size_t block_size);
gpointer ORBit_alloc_by_tc (CORBA_TypeCode tc);
gpointer ORBit_alloc_with_free_fn (size_t element_size,
          guint num_elements,
          ORBit_Mem_free_fn free_fn);
CORBA_TypeCode ORBit_alloc_get_tcval (gpointer mem);

gpointer CORBA_any__freekids (gpointer mem, gpointer dat);
gpointer ORBit_freekids_via_TypeCode (CORBA_TypeCode tc, gpointer mem);




# 14 "../../include/orbit/orb-core/orb-core-types.h" 2


# 1 "../../include/orbit/orb-core/corba-defs.h" 1
# 9 "../../include/orbit/orb-core/corba-defs.h"
# 1 "../../include/orbit/orbit-types.h" 1
# 10 "../../include/orbit/orb-core/corba-defs.h" 2
# 21 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_Object CORBA_ConstructionPolicy;
extern CORBA_unsigned_long CORBA_ConstructionPolicy__classid;
# 37 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_ConstructionPolicy_struct;







typedef CORBA_Object CORBA_Current;
extern CORBA_unsigned_long CORBA_Current__classid;
# 63 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_Current_struct;







typedef CORBA_Object CORBA_DomainManager;
extern CORBA_unsigned_long CORBA_DomainManager__classid;
# 89 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_DomainManager_struct;







typedef CORBA_Object CORBA_Policy;
extern CORBA_unsigned_long CORBA_Policy__classid;
# 115 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_Policy_struct;







typedef CORBA_Object CORBA_AbstractInterfaceDef;
extern CORBA_unsigned_long CORBA_AbstractInterfaceDef__classid;
# 141 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_AbstractInterfaceDef_struct;







typedef CORBA_Object CORBA_AliasDef;
extern CORBA_unsigned_long CORBA_AliasDef__classid;
# 167 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_AliasDef_struct;







typedef CORBA_Object CORBA_ArrayDef;
extern CORBA_unsigned_long CORBA_ArrayDef__classid;
# 193 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_ArrayDef_struct;







typedef CORBA_Object CORBA_AttributeDef;
extern CORBA_unsigned_long CORBA_AttributeDef__classid;
# 219 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_AttributeDef_struct;







typedef CORBA_Object CORBA_ConstantDef;
extern CORBA_unsigned_long CORBA_ConstantDef__classid;
# 245 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_ConstantDef_struct;







typedef CORBA_Object CORBA_Contained;
extern CORBA_unsigned_long CORBA_Contained__classid;
# 271 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_Contained_struct;







typedef CORBA_Object CORBA_Container;
extern CORBA_unsigned_long CORBA_Container__classid;
# 297 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_Container_struct;







typedef CORBA_Object CORBA_EnumDef;
extern CORBA_unsigned_long CORBA_EnumDef__classid;
# 323 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_EnumDef_struct;







typedef CORBA_Object CORBA_ExceptionDef;
extern CORBA_unsigned_long CORBA_ExceptionDef__classid;
# 349 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_ExceptionDef_struct;







typedef CORBA_Object CORBA_ExtInterfaceDef;
extern CORBA_unsigned_long CORBA_ExtInterfaceDef__classid;
# 375 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_ExtInterfaceDef_struct;







typedef CORBA_Object CORBA_ExtValueDef;
extern CORBA_unsigned_long CORBA_ExtValueDef__classid;
# 401 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_ExtValueDef_struct;







typedef CORBA_Object CORBA_ExtAbstractInterfaceDef;
extern CORBA_unsigned_long CORBA_ExtAbstractInterfaceDef__classid;
# 427 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_ExtAbstractInterfaceDef_struct;







typedef CORBA_Object CORBA_ExtLocalInterfaceDef;
extern CORBA_unsigned_long CORBA_ExtLocalInterfaceDef__classid;
# 453 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_ExtLocalInterfaceDef_struct;







typedef CORBA_Object CORBA_FixedDef;
extern CORBA_unsigned_long CORBA_FixedDef__classid;
# 479 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_FixedDef_struct;







typedef CORBA_Object CORBA_IDLType;
extern CORBA_unsigned_long CORBA_IDLType__classid;
# 505 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_IDLType_struct;
# 541 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_Object CORBA_IRObject;
extern CORBA_unsigned_long CORBA_IRObject__classid;
# 557 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_IRObject_struct;







typedef CORBA_Object CORBA_LocalInterfaceDef;
extern CORBA_unsigned_long CORBA_LocalInterfaceDef__classid;
# 583 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_LocalInterfaceDef_struct;







typedef CORBA_Object CORBA_ModuleDef;
extern CORBA_unsigned_long CORBA_ModuleDef__classid;
# 609 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_ModuleDef_struct;







typedef CORBA_Object CORBA_NativeDef;
extern CORBA_unsigned_long CORBA_NativeDef__classid;
# 635 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_NativeDef_struct;







typedef CORBA_Object CORBA_OperationDef;
extern CORBA_unsigned_long CORBA_OperationDef__classid;
# 661 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_OperationDef_struct;







typedef CORBA_Object CORBA_PrimitiveDef;
extern CORBA_unsigned_long CORBA_PrimitiveDef__classid;
# 687 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_PrimitiveDef_struct;







typedef CORBA_Object CORBA_Repository;
extern CORBA_unsigned_long CORBA_Repository__classid;
# 713 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_Repository_struct;







typedef CORBA_Object CORBA_SequenceDef;
extern CORBA_unsigned_long CORBA_SequenceDef__classid;
# 739 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_SequenceDef_struct;







typedef CORBA_Object CORBA_StringDef;
extern CORBA_unsigned_long CORBA_StringDef__classid;
# 765 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_StringDef_struct;







typedef CORBA_Object CORBA_StructDef;
extern CORBA_unsigned_long CORBA_StructDef__classid;
# 791 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_StructDef_struct;
# 827 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_Object CORBA_TypedefDef;
extern CORBA_unsigned_long CORBA_TypedefDef__classid;
# 843 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_TypedefDef_struct;







typedef CORBA_Object CORBA_UnionDef;
extern CORBA_unsigned_long CORBA_UnionDef__classid;
# 869 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_UnionDef_struct;







typedef CORBA_Object CORBA_ValueDef;
extern CORBA_unsigned_long CORBA_ValueDef__classid;
# 895 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_ValueDef_struct;







typedef CORBA_Object CORBA_ValueBoxDef;
extern CORBA_unsigned_long CORBA_ValueBoxDef__classid;
# 921 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_ValueBoxDef_struct;







typedef CORBA_Object CORBA_ValueMemberDef;
extern CORBA_unsigned_long CORBA_ValueMemberDef__classid;
# 947 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_ValueMemberDef_struct;







typedef CORBA_Object CORBA_WstringDef;
extern CORBA_unsigned_long CORBA_WstringDef__classid;
# 973 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_WstringDef_struct;





typedef CORBA_string CORBA_Identifier;
# 998 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_Identifier_struct;
# 1012 "../../include/orbit/orb-core/corba-defs.h"
typedef enum {
  CORBA_COMPLETED_YES,
  CORBA_COMPLETED_NO,
  CORBA_COMPLETED_MAYBE
} CORBA_completion_status;
# 1031 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_completion_status_struct;





typedef enum {
  CORBA_NO_EXCEPTION,
  CORBA_USER_EXCEPTION,
  CORBA_SYSTEM_EXCEPTION
} CORBA_exception_type;
# 1058 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_exception_type_struct;







typedef struct CORBA_UNKNOWN_type CORBA_UNKNOWN;
struct CORBA_UNKNOWN_type {
CORBA_unsigned_long minor;
CORBA_completion_status completed;
};
# 1088 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_UNKNOWN_struct;
# 1100 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_BAD_PARAM_type CORBA_BAD_PARAM;
struct CORBA_BAD_PARAM_type {
CORBA_unsigned_long minor;
CORBA_completion_status completed;
};
# 1120 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_BAD_PARAM_struct;
# 1132 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_NO_MEMORY_type CORBA_NO_MEMORY;
struct CORBA_NO_MEMORY_type {
CORBA_unsigned_long minor;
CORBA_completion_status completed;
};
# 1152 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_NO_MEMORY_struct;
# 1164 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_IMP_LIMIT_type CORBA_IMP_LIMIT;
struct CORBA_IMP_LIMIT_type {
CORBA_unsigned_long minor;
CORBA_completion_status completed;
};
# 1184 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_IMP_LIMIT_struct;
# 1196 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_COMM_FAILURE_type CORBA_COMM_FAILURE;
struct CORBA_COMM_FAILURE_type {
CORBA_unsigned_long minor;
CORBA_completion_status completed;
};
# 1216 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_COMM_FAILURE_struct;
# 1228 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_INV_OBJREF_type CORBA_INV_OBJREF;
struct CORBA_INV_OBJREF_type {
CORBA_unsigned_long minor;
CORBA_completion_status completed;
};
# 1248 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_INV_OBJREF_struct;
# 1260 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_NO_PERMISSION_type CORBA_NO_PERMISSION;
struct CORBA_NO_PERMISSION_type {
CORBA_unsigned_long minor;
CORBA_completion_status completed;
};
# 1280 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_NO_PERMISSION_struct;
# 1292 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_INTERNAL_type CORBA_INTERNAL;
struct CORBA_INTERNAL_type {
CORBA_unsigned_long minor;
CORBA_completion_status completed;
};
# 1312 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_INTERNAL_struct;
# 1324 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_MARSHAL_type CORBA_MARSHAL;
struct CORBA_MARSHAL_type {
CORBA_unsigned_long minor;
CORBA_completion_status completed;
};
# 1344 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_MARSHAL_struct;
# 1356 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_INITIALIZE_type CORBA_INITIALIZE;
struct CORBA_INITIALIZE_type {
CORBA_unsigned_long minor;
CORBA_completion_status completed;
};
# 1376 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_INITIALIZE_struct;
# 1388 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_NO_IMPLEMENT_type CORBA_NO_IMPLEMENT;
struct CORBA_NO_IMPLEMENT_type {
CORBA_unsigned_long minor;
CORBA_completion_status completed;
};
# 1408 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_NO_IMPLEMENT_struct;
# 1420 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_BAD_TYPECODE_type CORBA_BAD_TYPECODE;
struct CORBA_BAD_TYPECODE_type {
CORBA_unsigned_long minor;
CORBA_completion_status completed;
};
# 1440 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_BAD_TYPECODE_struct;
# 1452 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_BAD_OPERATION_type CORBA_BAD_OPERATION;
struct CORBA_BAD_OPERATION_type {
CORBA_unsigned_long minor;
CORBA_completion_status completed;
};
# 1472 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_BAD_OPERATION_struct;
# 1484 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_NO_RESOURCES_type CORBA_NO_RESOURCES;
struct CORBA_NO_RESOURCES_type {
CORBA_unsigned_long minor;
CORBA_completion_status completed;
};
# 1504 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_NO_RESOURCES_struct;
# 1516 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_NO_RESPONSE_type CORBA_NO_RESPONSE;
struct CORBA_NO_RESPONSE_type {
CORBA_unsigned_long minor;
CORBA_completion_status completed;
};
# 1536 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_NO_RESPONSE_struct;
# 1548 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_PERSIST_STORE_type CORBA_PERSIST_STORE;
struct CORBA_PERSIST_STORE_type {
CORBA_unsigned_long minor;
CORBA_completion_status completed;
};
# 1568 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_PERSIST_STORE_struct;
# 1580 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_BAD_INV_ORDER_type CORBA_BAD_INV_ORDER;
struct CORBA_BAD_INV_ORDER_type {
CORBA_unsigned_long minor;
CORBA_completion_status completed;
};
# 1600 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_BAD_INV_ORDER_struct;
# 1612 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_TRANSIENT_type CORBA_TRANSIENT;
struct CORBA_TRANSIENT_type {
CORBA_unsigned_long minor;
CORBA_completion_status completed;
};
# 1632 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_TRANSIENT_struct;
# 1644 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_FREE_MEM_type CORBA_FREE_MEM;
struct CORBA_FREE_MEM_type {
CORBA_unsigned_long minor;
CORBA_completion_status completed;
};
# 1664 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_FREE_MEM_struct;
# 1676 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_INV_IDENT_type CORBA_INV_IDENT;
struct CORBA_INV_IDENT_type {
CORBA_unsigned_long minor;
CORBA_completion_status completed;
};
# 1696 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_INV_IDENT_struct;
# 1708 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_INV_FLAG_type CORBA_INV_FLAG;
struct CORBA_INV_FLAG_type {
CORBA_unsigned_long minor;
CORBA_completion_status completed;
};
# 1728 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_INV_FLAG_struct;
# 1740 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_INTF_REPOS_type CORBA_INTF_REPOS;
struct CORBA_INTF_REPOS_type {
CORBA_unsigned_long minor;
CORBA_completion_status completed;
};
# 1760 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_INTF_REPOS_struct;
# 1772 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_BAD_CONTEXT_type CORBA_BAD_CONTEXT;
struct CORBA_BAD_CONTEXT_type {
CORBA_unsigned_long minor;
CORBA_completion_status completed;
};
# 1792 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_BAD_CONTEXT_struct;
# 1804 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_OBJ_ADAPTER_type CORBA_OBJ_ADAPTER;
struct CORBA_OBJ_ADAPTER_type {
CORBA_unsigned_long minor;
CORBA_completion_status completed;
};
# 1824 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_OBJ_ADAPTER_struct;
# 1836 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_DATA_CONVERSION_type CORBA_DATA_CONVERSION;
struct CORBA_DATA_CONVERSION_type {
CORBA_unsigned_long minor;
CORBA_completion_status completed;
};
# 1856 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_DATA_CONVERSION_struct;
# 1868 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_OBJECT_NOT_EXIST_type CORBA_OBJECT_NOT_EXIST;
struct CORBA_OBJECT_NOT_EXIST_type {
CORBA_unsigned_long minor;
CORBA_completion_status completed;
};
# 1888 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_OBJECT_NOT_EXIST_struct;
# 1900 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_TRANSACTION_REQUIRED_type CORBA_TRANSACTION_REQUIRED;
struct CORBA_TRANSACTION_REQUIRED_type {
CORBA_unsigned_long minor;
CORBA_completion_status completed;
};
# 1920 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_TRANSACTION_REQUIRED_struct;
# 1932 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_TRANSACTION_ROLLEDBACK_type CORBA_TRANSACTION_ROLLEDBACK;
struct CORBA_TRANSACTION_ROLLEDBACK_type {
CORBA_unsigned_long minor;
CORBA_completion_status completed;
};
# 1952 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_TRANSACTION_ROLLEDBACK_struct;
# 1964 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_INVALID_TRANSACTION_type CORBA_INVALID_TRANSACTION;
struct CORBA_INVALID_TRANSACTION_type {
CORBA_unsigned_long minor;
CORBA_completion_status completed;
};
# 1984 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_INVALID_TRANSACTION_struct;
# 1996 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_INV_POLICY_type CORBA_INV_POLICY;
struct CORBA_INV_POLICY_type {
CORBA_unsigned_long minor;
CORBA_completion_status completed;
};
# 2016 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_INV_POLICY_struct;
# 2028 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_CODESET_INCOMPATIBLE_type CORBA_CODESET_INCOMPATIBLE;
struct CORBA_CODESET_INCOMPATIBLE_type {
CORBA_unsigned_long minor;
CORBA_completion_status completed;
};
# 2048 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_CODESET_INCOMPATIBLE_struct;
# 2060 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_REBIND_type CORBA_REBIND;
struct CORBA_REBIND_type {
CORBA_unsigned_long minor;
CORBA_completion_status completed;
};
# 2080 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_REBIND_struct;
# 2092 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_TIMEOUT_type CORBA_TIMEOUT;
struct CORBA_TIMEOUT_type {
CORBA_unsigned_long minor;
CORBA_completion_status completed;
};
# 2112 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_TIMEOUT_struct;
# 2124 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_TRANSACTION_UNAVAILABLE_type CORBA_TRANSACTION_UNAVAILABLE;
struct CORBA_TRANSACTION_UNAVAILABLE_type {
CORBA_unsigned_long minor;
CORBA_completion_status completed;
};
# 2144 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_TRANSACTION_UNAVAILABLE_struct;
# 2156 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_TRANSACTION_MODE_type CORBA_TRANSACTION_MODE;
struct CORBA_TRANSACTION_MODE_type {
CORBA_unsigned_long minor;
CORBA_completion_status completed;
};
# 2176 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_TRANSACTION_MODE_struct;
# 2188 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_BAD_QOS_type CORBA_BAD_QOS;
struct CORBA_BAD_QOS_type {
CORBA_unsigned_long minor;
CORBA_completion_status completed;
};
# 2208 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_BAD_QOS_struct;
# 2244 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_unsigned_long CORBA_PolicyType;
# 2261 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_PolicyType_struct;
# 2309 "../../include/orbit/orb-core/corba-defs.h"
typedef struct { CORBA_unsigned_long _maximum, _length; CORBA_Object* _buffer; CORBA_boolean _release; } CORBA_sequence_CORBA_Object;
# 2325 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_CORBA_Object_struct;
# 2349 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_Object CORBA_sequence_CORBA_Policy;
# 2365 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_CORBA_Policy_struct;
# 2378 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_Policy CORBA_PolicyList;
# 2395 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_PolicyList_struct;
# 2418 "../../include/orbit/orb-core/corba-defs.h"
typedef struct { CORBA_unsigned_long _maximum, _length; CORBA_unsigned_long* _buffer; CORBA_boolean _release; } CORBA_sequence_CORBA_unsigned_long;
# 2434 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_CORBA_unsigned_long_struct;
# 2458 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_unsigned_long CORBA_sequence_CORBA_PolicyType;
# 2474 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_CORBA_PolicyType_struct;
# 2487 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_PolicyType CORBA_PolicyTypeSeq;
# 2504 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_PolicyTypeSeq_struct;
# 2517 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_InvalidPolicies_type CORBA_InvalidPolicies;
# 2532 "../../include/orbit/orb-core/corba-defs.h"
typedef struct { CORBA_unsigned_long _maximum, _length; CORBA_unsigned_short* _buffer; CORBA_boolean _release; } CORBA_sequence_CORBA_unsigned_short;
# 2548 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_CORBA_unsigned_short_struct;







struct CORBA_InvalidPolicies_type {
CORBA_sequence_CORBA_unsigned_short indices;
};
# 2576 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_InvalidPolicies_struct;







typedef CORBA_short CORBA_PolicyErrorCode;
# 2603 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_PolicyErrorCode_struct;
# 2615 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_PolicyError_type CORBA_PolicyError;
struct CORBA_PolicyError_type {
CORBA_PolicyErrorCode reason;
};
# 2634 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_PolicyError_struct;
# 2772 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_Object CORBA_sequence_CORBA_DomainManager;
# 2788 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_CORBA_DomainManager_struct;
# 2801 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_DomainManager CORBA_DomainManagersList;
# 2818 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_DomainManagersList_struct;
# 2829 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_string CORBA_ScopedName;
# 2846 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_ScopedName_struct;







typedef CORBA_string CORBA_RepositoryId;
# 2873 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_RepositoryId_struct;







typedef enum {
  CORBA_dk_none,
  CORBA_dk_all,
  CORBA_dk_Attribute,
  CORBA_dk_Constant,
  CORBA_dk_Exception,
  CORBA_dk_Interface,
  CORBA_dk_Module,
  CORBA_dk_Operation,
  CORBA_dk_Typedef,
  CORBA_dk_Alias,
  CORBA_dk_Struct,
  CORBA_dk_Union,
  CORBA_dk_Enum,
  CORBA_dk_Primitive,
  CORBA_dk_String,
  CORBA_dk_Sequence,
  CORBA_dk_Array,
  CORBA_dk_Repository,
  CORBA_dk_Wstring,
  CORBA_dk_Fixed,
  CORBA_dk_Value,
  CORBA_dk_ValueBox,
  CORBA_dk_ValueMember,
  CORBA_dk_Native,
  CORBA_dk_AbstractInterface,
  CORBA_dk_LocalInterface,
  CORBA_dk_Component,
  CORBA_dk_Home,
  CORBA_dk_Factory,
  CORBA_dk_Finder,
  CORBA_dk_Emits,
  CORBA_dk_Publishes,
  CORBA_dk_Consumes,
  CORBA_dk_Provides,
  CORBA_dk_Uses,
  CORBA_dk_Event
} CORBA_DefinitionKind;
# 2935 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_DefinitionKind_struct;
# 2969 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_string CORBA_VersionSpec;
# 2986 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_VersionSpec_struct;
# 3022 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_Contained_Description_type CORBA_Contained_Description;
struct CORBA_Contained_Description_type {
CORBA_DefinitionKind kind;
CORBA_any value;
};
# 3042 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_Contained_Description_struct;
# 3364 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_Object CORBA_sequence_CORBA_InterfaceDef;
# 3380 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_CORBA_InterfaceDef_struct;
# 3393 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_InterfaceDef CORBA_InterfaceDefSeq;
# 3410 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_InterfaceDefSeq_struct;
# 3499 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_Object CORBA_sequence_CORBA_ValueDef;
# 3515 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_CORBA_ValueDef_struct;
# 3528 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_ValueDef CORBA_ValueDefSeq;
# 3545 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_ValueDefSeq_struct;
# 3660 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_Object CORBA_sequence_CORBA_AbstractInterfaceDef;
# 3676 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_CORBA_AbstractInterfaceDef_struct;
# 3689 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_AbstractInterfaceDef CORBA_AbstractInterfaceDefSeq;
# 3706 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_AbstractInterfaceDefSeq_struct;
# 3795 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_Object CORBA_sequence_CORBA_LocalInterfaceDef;
# 3811 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_CORBA_LocalInterfaceDef_struct;
# 3824 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_LocalInterfaceDef CORBA_LocalInterfaceDefSeq;
# 3841 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_LocalInterfaceDefSeq_struct;
# 3930 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_Object CORBA_sequence_CORBA_ExtInterfaceDef;
# 3946 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_CORBA_ExtInterfaceDef_struct;
# 3959 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_ExtInterfaceDef CORBA_ExtInterfaceDefSeq;
# 3976 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_ExtInterfaceDefSeq_struct;
# 4065 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_Object CORBA_sequence_CORBA_ExtValueDef;
# 4081 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_CORBA_ExtValueDef_struct;
# 4094 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_ExtValueDef CORBA_ExtValueDefSeq;
# 4111 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_ExtValueDefSeq_struct;
# 4200 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_Object CORBA_sequence_CORBA_ExtAbstractInterfaceDef;
# 4216 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_CORBA_ExtAbstractInterfaceDef_struct;
# 4229 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_ExtAbstractInterfaceDef CORBA_ExtAbstractInterfaceDefSeq;
# 4246 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_ExtAbstractInterfaceDefSeq_struct;
# 4335 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_Object CORBA_sequence_CORBA_ExtLocalInterfaceDef;
# 4351 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_CORBA_ExtLocalInterfaceDef_struct;
# 4364 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_ExtLocalInterfaceDef CORBA_ExtLocalInterfaceDefSeq;
# 4381 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_ExtLocalInterfaceDefSeq_struct;
# 4444 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_Object CORBA_sequence_CORBA_Contained;
# 4460 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_CORBA_Contained_struct;
# 4473 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_Contained CORBA_ContainedSeq;
# 4490 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_ContainedSeq_struct;
# 4501 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_StructMember_type CORBA_StructMember;
struct CORBA_StructMember_type {
CORBA_Identifier name;
CORBA_TypeCode type;
CORBA_IDLType type_def;
};
# 4522 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_StructMember_struct;
# 4544 "../../include/orbit/orb-core/corba-defs.h"
typedef struct { CORBA_unsigned_long _maximum, _length; CORBA_StructMember* _buffer; CORBA_boolean _release; } CORBA_sequence_CORBA_StructMember;
# 4560 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_CORBA_StructMember_struct;
# 4572 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_StructMember CORBA_StructMemberSeq;
# 4589 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_StructMemberSeq_struct;
# 4600 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_Initializer_type CORBA_Initializer;
struct CORBA_Initializer_type {
CORBA_StructMemberSeq members;
CORBA_Identifier name;
};
# 4620 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_Initializer_struct;
# 4642 "../../include/orbit/orb-core/corba-defs.h"
typedef struct { CORBA_unsigned_long _maximum, _length; CORBA_Initializer* _buffer; CORBA_boolean _release; } CORBA_sequence_CORBA_Initializer;
# 4658 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_CORBA_Initializer_struct;
# 4670 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_Initializer CORBA_InitializerSeq;
# 4687 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_InitializerSeq_struct;
# 4698 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_UnionMember_type CORBA_UnionMember;
struct CORBA_UnionMember_type {
CORBA_Identifier name;
CORBA_any label;
CORBA_TypeCode type;
CORBA_IDLType type_def;
};
# 4720 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_UnionMember_struct;







typedef struct CORBA_ExceptionDescription_type CORBA_ExceptionDescription;
struct CORBA_ExceptionDescription_type {
CORBA_Identifier name;
CORBA_RepositoryId id;
CORBA_RepositoryId defined_in;
CORBA_VersionSpec version;
CORBA_TypeCode type;
};
# 4753 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_ExceptionDescription_struct;
# 4775 "../../include/orbit/orb-core/corba-defs.h"
typedef struct { CORBA_unsigned_long _maximum, _length; CORBA_ExceptionDescription* _buffer; CORBA_boolean _release; } CORBA_sequence_CORBA_ExceptionDescription;
# 4791 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_CORBA_ExceptionDescription_struct;
# 4803 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_ExceptionDescription CORBA_ExcDescriptionSeq;
# 4820 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_ExcDescriptionSeq_struct;
# 4831 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_ExtInitializer_type CORBA_ExtInitializer;
struct CORBA_ExtInitializer_type {
CORBA_StructMemberSeq members;
CORBA_ExcDescriptionSeq exceptions;
CORBA_Identifier name;
};
# 4852 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_ExtInitializer_struct;
# 4874 "../../include/orbit/orb-core/corba-defs.h"
typedef struct { CORBA_unsigned_long _maximum, _length; CORBA_ExtInitializer* _buffer; CORBA_boolean _release; } CORBA_sequence_CORBA_ExtInitializer;
# 4890 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_CORBA_ExtInitializer_struct;
# 4902 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_ExtInitializer CORBA_ExtInitializerSeq;
# 4919 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_ExtInitializerSeq_struct;
# 4942 "../../include/orbit/orb-core/corba-defs.h"
typedef struct { CORBA_unsigned_long _maximum, _length; CORBA_UnionMember* _buffer; CORBA_boolean _release; } CORBA_sequence_CORBA_UnionMember;
# 4958 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_CORBA_UnionMember_struct;
# 4970 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_UnionMember CORBA_UnionMemberSeq;
# 4987 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_UnionMemberSeq_struct;
# 5010 "../../include/orbit/orb-core/corba-defs.h"
typedef struct { CORBA_unsigned_long _maximum, _length; CORBA_string* _buffer; CORBA_boolean _release; } CORBA_sequence_CORBA_string;
# 5026 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_CORBA_string_struct;
# 5050 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_string CORBA_sequence_CORBA_Identifier;
# 5066 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_CORBA_Identifier_struct;
# 5079 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_Identifier CORBA_EnumMemberSeq;
# 5096 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_EnumMemberSeq_struct;
# 5133 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_Container_Description_type CORBA_Container_Description;
struct CORBA_Container_Description_type {
CORBA_Contained contained_object;
CORBA_DefinitionKind kind;
CORBA_any value;
};
# 5154 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_Container_Description_struct;
# 5176 "../../include/orbit/orb-core/corba-defs.h"
typedef struct { CORBA_unsigned_long _maximum, _length; CORBA_Container_Description* _buffer; CORBA_boolean _release; } CORBA_sequence_CORBA_Container_Description;
# 5192 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_CORBA_Container_Description_struct;
# 5204 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_Container_Description CORBA_Container_DescriptionSeq;
# 5221 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_Container_DescriptionSeq_struct;
# 5258 "../../include/orbit/orb-core/corba-defs.h"
typedef enum {
  CORBA_pk_null,
  CORBA_pk_void,
  CORBA_pk_short,
  CORBA_pk_long,
  CORBA_pk_ushort,
  CORBA_pk_ulong,
  CORBA_pk_float,
  CORBA_pk_double,
  CORBA_pk_boolean,
  CORBA_pk_char,
  CORBA_pk_octet,
  CORBA_pk_any,
  CORBA_pk_TypeCode,
  CORBA_pk_Principal,
  CORBA_pk_string,
  CORBA_pk_objref,
  CORBA_pk_longlong,
  CORBA_pk_ulonglong,
  CORBA_pk_longdouble,
  CORBA_pk_wchar,
  CORBA_pk_wstring,
  CORBA_pk_value_base
} CORBA_PrimitiveKind;
# 5296 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_PrimitiveKind_struct;
# 5356 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_ModuleDescription_type CORBA_ModuleDescription;
struct CORBA_ModuleDescription_type {
CORBA_Identifier name;
CORBA_RepositoryId id;
CORBA_RepositoryId defined_in;
CORBA_VersionSpec version;
};
# 5378 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_ModuleDescription_struct;
# 5414 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_ConstantDescription_type CORBA_ConstantDescription;
struct CORBA_ConstantDescription_type {
CORBA_Identifier name;
CORBA_RepositoryId id;
CORBA_RepositoryId defined_in;
CORBA_VersionSpec version;
CORBA_TypeCode type;
CORBA_any value;
};
# 5438 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_ConstantDescription_struct;
# 5474 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_TypeDescription_type CORBA_TypeDescription;
struct CORBA_TypeDescription_type {
CORBA_Identifier name;
CORBA_RepositoryId id;
CORBA_RepositoryId defined_in;
CORBA_VersionSpec version;
CORBA_TypeCode type;
};
# 5497 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_TypeDescription_struct;
# 5819 "../../include/orbit/orb-core/corba-defs.h"
typedef enum {
  CORBA_ATTR_NORMAL,
  CORBA_ATTR_READONLY
} CORBA_AttributeMode;
# 5837 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_AttributeMode_struct;
# 5871 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_AttributeDescription_type CORBA_AttributeDescription;
struct CORBA_AttributeDescription_type {
CORBA_Identifier name;
CORBA_RepositoryId id;
CORBA_RepositoryId defined_in;
CORBA_VersionSpec version;
CORBA_TypeCode type;
CORBA_AttributeMode mode;
};
# 5895 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_AttributeDescription_struct;







typedef struct CORBA_ExtAttributeDescription_type CORBA_ExtAttributeDescription;
struct CORBA_ExtAttributeDescription_type {
CORBA_Identifier name;
CORBA_RepositoryId id;
CORBA_RepositoryId defined_in;
CORBA_VersionSpec version;
CORBA_TypeCode type;
CORBA_AttributeMode mode;
CORBA_ExcDescriptionSeq get_exceptions;
CORBA_ExcDescriptionSeq put_exceptions;
};
# 5931 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_ExtAttributeDescription_struct;
# 5943 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_Object CORBA_ExtAttributeDef;
extern CORBA_unsigned_long CORBA_ExtAttributeDef__classid;
# 5959 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_ExtAttributeDef_struct;





typedef enum {
  CORBA_OP_NORMAL,
  CORBA_OP_ONEWAY
} CORBA_OperationMode;
# 5985 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_OperationMode_struct;





typedef enum {
  CORBA_PARAM_IN,
  CORBA_PARAM_OUT,
  CORBA_PARAM_INOUT
} CORBA_ParameterMode;
# 6012 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_ParameterMode_struct;





typedef struct CORBA_ParameterDescription_type CORBA_ParameterDescription;
struct CORBA_ParameterDescription_type {
CORBA_Identifier name;
CORBA_TypeCode type;
CORBA_IDLType type_def;
CORBA_ParameterMode mode;
};
# 6042 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_ParameterDescription_struct;
# 6064 "../../include/orbit/orb-core/corba-defs.h"
typedef struct { CORBA_unsigned_long _maximum, _length; CORBA_ParameterDescription* _buffer; CORBA_boolean _release; } CORBA_sequence_CORBA_ParameterDescription;
# 6080 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_CORBA_ParameterDescription_struct;
# 6092 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_ParameterDescription CORBA_ParDescriptionSeq;
# 6109 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_ParDescriptionSeq_struct;
# 6120 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_Identifier CORBA_ContextIdentifier;
# 6137 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_ContextIdentifier_struct;
# 6199 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_string CORBA_sequence_CORBA_ContextIdentifier;
# 6215 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_CORBA_ContextIdentifier_struct;
# 6228 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_ContextIdentifier CORBA_ContextIdSeq;
# 6245 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_ContextIdSeq_struct;
# 6308 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_Object CORBA_sequence_CORBA_ExceptionDef;
# 6324 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_CORBA_ExceptionDef_struct;
# 6337 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_ExceptionDef CORBA_ExceptionDefSeq;
# 6354 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_ExceptionDefSeq_struct;
# 6391 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_OperationDescription_type CORBA_OperationDescription;
struct CORBA_OperationDescription_type {
CORBA_Identifier name;
CORBA_RepositoryId id;
CORBA_RepositoryId defined_in;
CORBA_VersionSpec version;
CORBA_TypeCode result;
CORBA_OperationMode mode;
CORBA_ContextIdSeq contexts;
CORBA_ParDescriptionSeq parameters;
CORBA_ExcDescriptionSeq exceptions;
};
# 6418 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_OperationDescription_struct;
# 6481 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_string CORBA_sequence_CORBA_RepositoryId;
# 6497 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_CORBA_RepositoryId_struct;
# 6510 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_RepositoryId CORBA_RepositoryIdSeq;
# 6527 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_RepositoryIdSeq_struct;
# 6550 "../../include/orbit/orb-core/corba-defs.h"
typedef struct { CORBA_unsigned_long _maximum, _length; CORBA_OperationDescription* _buffer; CORBA_boolean _release; } CORBA_sequence_CORBA_OperationDescription;
# 6566 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_CORBA_OperationDescription_struct;
# 6578 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_OperationDescription CORBA_OpDescriptionSeq;
# 6595 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_OpDescriptionSeq_struct;
# 6618 "../../include/orbit/orb-core/corba-defs.h"
typedef struct { CORBA_unsigned_long _maximum, _length; CORBA_AttributeDescription* _buffer; CORBA_boolean _release; } CORBA_sequence_CORBA_AttributeDescription;
# 6634 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_CORBA_AttributeDescription_struct;
# 6646 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_AttributeDescription CORBA_AttrDescriptionSeq;
# 6663 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_AttrDescriptionSeq_struct;
# 6686 "../../include/orbit/orb-core/corba-defs.h"
typedef struct { CORBA_unsigned_long _maximum, _length; CORBA_ExtAttributeDescription* _buffer; CORBA_boolean _release; } CORBA_sequence_CORBA_ExtAttributeDescription;
# 6702 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_CORBA_ExtAttributeDescription_struct;
# 6714 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_ExtAttributeDescription CORBA_ExtAttrDescriptionSeq;
# 6731 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_ExtAttrDescriptionSeq_struct;
# 6768 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_InterfaceDef_FullInterfaceDescription_type CORBA_InterfaceDef_FullInterfaceDescription;
struct CORBA_InterfaceDef_FullInterfaceDescription_type {
CORBA_Identifier name;
CORBA_RepositoryId id;
CORBA_RepositoryId defined_in;
CORBA_VersionSpec version;
CORBA_OpDescriptionSeq operations;
CORBA_AttrDescriptionSeq attributes;
CORBA_RepositoryIdSeq base_interfaces;
CORBA_TypeCode type;
CORBA_boolean is_abstract;
};
# 6795 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_InterfaceDef_FullInterfaceDescription_struct;







typedef struct CORBA_InterfaceDescription_type CORBA_InterfaceDescription;
struct CORBA_InterfaceDescription_type {
CORBA_Identifier name;
CORBA_RepositoryId id;
CORBA_RepositoryId defined_in;
CORBA_VersionSpec version;
CORBA_RepositoryIdSeq base_interfaces;
CORBA_boolean is_abstract;
};
# 6829 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_InterfaceDescription_struct;
# 6841 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_Object CORBA_InterfaceAttrExtension;
extern CORBA_unsigned_long CORBA_InterfaceAttrExtension__classid;
# 6857 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_InterfaceAttrExtension_struct;





typedef struct CORBA_InterfaceAttrExtension_ExtFullInterfaceDescription_type CORBA_InterfaceAttrExtension_ExtFullInterfaceDescription;
struct CORBA_InterfaceAttrExtension_ExtFullInterfaceDescription_type {
CORBA_Identifier name;
CORBA_RepositoryId id;
CORBA_RepositoryId defined_in;
CORBA_VersionSpec version;
CORBA_OpDescriptionSeq operations;
CORBA_ExtAttrDescriptionSeq attributes;
CORBA_RepositoryIdSeq base_interfaces;
CORBA_TypeCode type;
};
# 6891 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_InterfaceAttrExtension_ExtFullInterfaceDescription_struct;
# 6927 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_short CORBA_Visibility;
# 6944 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_Visibility_struct;
# 6962 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_ValueMember_type CORBA_ValueMember;
struct CORBA_ValueMember_type {
CORBA_Identifier name;
CORBA_RepositoryId id;
CORBA_RepositoryId defined_in;
CORBA_VersionSpec version;
CORBA_TypeCode type;
CORBA_IDLType type_def;
CORBA_Visibility access;
};
# 6987 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_ValueMember_struct;
# 7009 "../../include/orbit/orb-core/corba-defs.h"
typedef struct { CORBA_unsigned_long _maximum, _length; CORBA_ValueMember* _buffer; CORBA_boolean _release; } CORBA_sequence_CORBA_ValueMember;
# 7025 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_CORBA_ValueMember_struct;
# 7037 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_ValueMember CORBA_ValueMemberSeq;
# 7054 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_ValueMemberSeq_struct;
# 7117 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_ValueDef_FullValueDescription_type CORBA_ValueDef_FullValueDescription;
struct CORBA_ValueDef_FullValueDescription_type {
CORBA_Identifier name;
CORBA_RepositoryId id;
CORBA_boolean is_abstract;
CORBA_boolean is_custom;
CORBA_RepositoryId defined_in;
CORBA_VersionSpec version;
CORBA_OpDescriptionSeq operations;
CORBA_AttrDescriptionSeq attributes;
CORBA_ValueMemberSeq members;
CORBA_InitializerSeq initializers;
CORBA_RepositoryIdSeq supported_interfaces;
CORBA_RepositoryIdSeq abstract_base_values;
CORBA_boolean is_truncatable;
CORBA_RepositoryId base_value;
CORBA_TypeCode type;
};
# 7150 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_ValueDef_FullValueDescription_struct;







typedef struct CORBA_ValueDescription_type CORBA_ValueDescription;
struct CORBA_ValueDescription_type {
CORBA_Identifier name;
CORBA_RepositoryId id;
CORBA_boolean is_abstract;
CORBA_boolean is_custom;
CORBA_RepositoryId defined_in;
CORBA_VersionSpec version;
CORBA_RepositoryIdSeq supported_interfaces;
CORBA_RepositoryIdSeq abstract_base_values;
CORBA_boolean is_truncatable;
CORBA_RepositoryId base_value;
};
# 7188 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_ValueDescription_struct;
# 7224 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_ExtValueDef_ExtFullValueDescription_type CORBA_ExtValueDef_ExtFullValueDescription;
struct CORBA_ExtValueDef_ExtFullValueDescription_type {
CORBA_Identifier name;
CORBA_RepositoryId id;
CORBA_boolean is_abstract;
CORBA_boolean is_custom;
CORBA_RepositoryId defined_in;
CORBA_VersionSpec version;
CORBA_OpDescriptionSeq operations;
CORBA_ExtAttrDescriptionSeq attributes;
CORBA_ValueMemberSeq members;
CORBA_ExtInitializerSeq initializers;
CORBA_RepositoryIdSeq supported_interfaces;
CORBA_RepositoryIdSeq abstract_base_values;
CORBA_boolean is_truncatable;
CORBA_RepositoryId base_value;
CORBA_TypeCode type;
};
# 7257 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_ExtValueDef_ExtFullValueDescription_struct;
# 7397 "../../include/orbit/orb-core/corba-defs.h"
typedef enum {
  CORBA_tk_null,
  CORBA_tk_void,
  CORBA_tk_short,
  CORBA_tk_long,
  CORBA_tk_ushort,
  CORBA_tk_ulong,
  CORBA_tk_float,
  CORBA_tk_double,
  CORBA_tk_boolean,
  CORBA_tk_char,
  CORBA_tk_octet,
  CORBA_tk_any,
  CORBA_tk_TypeCode,
  CORBA_tk_Principal,
  CORBA_tk_objref,
  CORBA_tk_struct,
  CORBA_tk_union,
  CORBA_tk_enum,
  CORBA_tk_string,
  CORBA_tk_sequence,
  CORBA_tk_array,
  CORBA_tk_alias,
  CORBA_tk_except,
  CORBA_tk_longlong,
  CORBA_tk_ulonglong,
  CORBA_tk_longdouble,
  CORBA_tk_wchar,
  CORBA_tk_wstring,
  CORBA_tk_fixed,
  CORBA_tk_value,
  CORBA_tk_value_box,
  CORBA_tk_native,
  CORBA_tk_abstract_interface,
  CORBA_tk_local_interface,
  CORBA_tk_component,
  CORBA_tk_home,
  CORBA_tk_event
} CORBA_TCKind;
# 7450 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_TCKind_struct;





typedef CORBA_short CORBA_ValueModifier;
# 7475 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_ValueModifier_struct;
# 7529 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_TypeCode_Bounds_type CORBA_TypeCode_Bounds;
struct CORBA_TypeCode_Bounds_type {
int dummy;
};
# 7548 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_TypeCode_Bounds_struct;
# 7560 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_TypeCode_BadKind_type CORBA_TypeCode_BadKind;
struct CORBA_TypeCode_BadKind_type {
int dummy;
};
# 7579 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_TypeCode_BadKind_struct;
# 7601 "../../include/orbit/orb-core/corba-defs.h"
typedef struct { CORBA_unsigned_long _maximum, _length; CORBA_any* _buffer; CORBA_boolean _release; } CORBA_sequence_CORBA_any;
# 7617 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_CORBA_any_struct;
# 7629 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_any CORBA_AnySeq;
# 7646 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_AnySeq_struct;
# 7669 "../../include/orbit/orb-core/corba-defs.h"
typedef struct { CORBA_unsigned_long _maximum, _length; CORBA_boolean* _buffer; CORBA_boolean _release; } CORBA_sequence_CORBA_boolean;
# 7685 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_CORBA_boolean_struct;
# 7697 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_boolean CORBA_BooleanSeq;
# 7714 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_BooleanSeq_struct;
# 7737 "../../include/orbit/orb-core/corba-defs.h"
typedef struct { CORBA_unsigned_long _maximum, _length; CORBA_char* _buffer; CORBA_boolean _release; } CORBA_sequence_CORBA_char;
# 7753 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_CORBA_char_struct;
# 7765 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_char CORBA_CharSeq;
# 7782 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_CharSeq_struct;
# 7805 "../../include/orbit/orb-core/corba-defs.h"
typedef struct { CORBA_unsigned_long _maximum, _length; CORBA_wchar* _buffer; CORBA_boolean _release; } CORBA_sequence_CORBA_wchar;
# 7821 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_CORBA_wchar_struct;
# 7833 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_wchar CORBA_WCharSeq;
# 7850 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_WCharSeq_struct;
# 7873 "../../include/orbit/orb-core/corba-defs.h"
typedef struct { CORBA_unsigned_long _maximum, _length; CORBA_octet* _buffer; CORBA_boolean _release; } CORBA_sequence_CORBA_octet;
# 7889 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_CORBA_octet_struct;
# 7901 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_octet CORBA_OctetSeq;
# 7918 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_OctetSeq_struct;
# 7941 "../../include/orbit/orb-core/corba-defs.h"
typedef struct { CORBA_unsigned_long _maximum, _length; CORBA_short* _buffer; CORBA_boolean _release; } CORBA_sequence_CORBA_short;
# 7957 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_CORBA_short_struct;
# 7969 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_short CORBA_ShortSeq;
# 7986 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_ShortSeq_struct;
# 8037 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_unsigned_short CORBA_UShortSeq;
# 8054 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_UShortSeq_struct;
# 8077 "../../include/orbit/orb-core/corba-defs.h"
typedef struct { CORBA_unsigned_long _maximum, _length; CORBA_long* _buffer; CORBA_boolean _release; } CORBA_sequence_CORBA_long;
# 8093 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_CORBA_long_struct;
# 8105 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_long CORBA_LongSeq;
# 8122 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_LongSeq_struct;
# 8173 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_unsigned_long CORBA_ULongSeq;
# 8190 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_ULongSeq_struct;
# 8213 "../../include/orbit/orb-core/corba-defs.h"
typedef struct { CORBA_unsigned_long _maximum, _length; CORBA_long_long* _buffer; CORBA_boolean _release; } CORBA_sequence_CORBA_long_long;
# 8229 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_CORBA_long_long_struct;
# 8241 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_long_long CORBA_LongLongSeq;
# 8258 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_LongLongSeq_struct;
# 8281 "../../include/orbit/orb-core/corba-defs.h"
typedef struct { CORBA_unsigned_long _maximum, _length; CORBA_unsigned_long_long* _buffer; CORBA_boolean _release; } CORBA_sequence_CORBA_unsigned_long_long;
# 8297 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_CORBA_unsigned_long_long_struct;
# 8309 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_unsigned_long_long CORBA_ULongLongSeq;
# 8326 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_ULongLongSeq_struct;
# 8349 "../../include/orbit/orb-core/corba-defs.h"
typedef struct { CORBA_unsigned_long _maximum, _length; CORBA_float* _buffer; CORBA_boolean _release; } CORBA_sequence_CORBA_float;
# 8365 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_CORBA_float_struct;
# 8377 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_float CORBA_FloatSeq;
# 8394 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_FloatSeq_struct;
# 8417 "../../include/orbit/orb-core/corba-defs.h"
typedef struct { CORBA_unsigned_long _maximum, _length; CORBA_double* _buffer; CORBA_boolean _release; } CORBA_sequence_CORBA_double;
# 8433 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_CORBA_double_struct;
# 8445 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_double CORBA_DoubleSeq;
# 8462 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_DoubleSeq_struct;
# 8485 "../../include/orbit/orb-core/corba-defs.h"
typedef struct { CORBA_unsigned_long _maximum, _length; CORBA_long_double* _buffer; CORBA_boolean _release; } CORBA_sequence_CORBA_long_double;
# 8501 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_CORBA_long_double_struct;
# 8513 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_long_double CORBA_LongDoubleSeq;
# 8530 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_LongDoubleSeq_struct;
# 8581 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_string CORBA_StringSeq;
# 8598 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_StringSeq_struct;
# 8621 "../../include/orbit/orb-core/corba-defs.h"
typedef struct { CORBA_unsigned_long _maximum, _length; CORBA_wstring* _buffer; CORBA_boolean _release; } CORBA_sequence_CORBA_wstring;
# 8637 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_CORBA_wstring_struct;
# 8649 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_wstring CORBA_WStringSeq;
# 8666 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_WStringSeq_struct;
# 8679 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_BadFixedValue_type CORBA_BadFixedValue;
struct CORBA_BadFixedValue_type {
CORBA_unsigned_long offset;
};
# 8698 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_BadFixedValue_struct;
# 8724 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_SystemException_type CORBA_SystemException;
struct CORBA_SystemException_type {
CORBA_unsigned_long minor;
CORBA_completion_status completed;
};
# 8744 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_SystemException_struct;
# 8755 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_Context_type *CORBA_Context;







typedef struct CORBA_NVList_type *CORBA_NVList;
# 8787 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_Request_type *CORBA_Request;







typedef struct CORBA_ServerRequest_type *CORBA_ServerRequest;






typedef CORBA_unsigned_long CORBA_Flags;
# 8819 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_Flags_struct;







typedef struct CORBA_NamedValue_type CORBA_NamedValue;
struct CORBA_NamedValue_type {
CORBA_Identifier name;
CORBA_any argument;
CORBA_long len;
CORBA_Flags arg_modes;
};
# 8851 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_NamedValue_struct;







typedef enum {
  CORBA_SET_OVERRIDE,
  CORBA_ADD_OVERRIDE
} CORBA_SetOverrideType;
# 8879 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_SetOverrideType_struct;
# 8947 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_Object CORBA_sequence_CORBA_Request;
# 8963 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_CORBA_Request_struct;
# 8976 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_Request CORBA_RequestSeq;
# 8993 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_RequestSeq_struct;
# 9004 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_AbstractBase_type *CORBA_AbstractBase;



typedef CORBA_unsigned_short CORBA_ServiceType;
# 9025 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_ServiceType_struct;







typedef CORBA_unsigned_long CORBA_ServiceOption;
# 9052 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_ServiceOption_struct;







typedef CORBA_unsigned_long CORBA_ServiceDetailType;
# 9079 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_ServiceDetailType_struct;
# 9093 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_ServiceDetail_type CORBA_ServiceDetail;
# 9134 "../../include/orbit/orb-core/corba-defs.h"
struct CORBA_ServiceDetail_type {
CORBA_ServiceDetailType service_detail_type;
CORBA_sequence_CORBA_octet service_detail;
};
# 9153 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_ServiceDetail_struct;







typedef struct CORBA_ServiceInformation_type CORBA_ServiceInformation;
# 9218 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_unsigned_long CORBA_sequence_CORBA_ServiceOption;
# 9234 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_CORBA_ServiceOption_struct;
# 9259 "../../include/orbit/orb-core/corba-defs.h"
typedef struct { CORBA_unsigned_long _maximum, _length; CORBA_ServiceDetail* _buffer; CORBA_boolean _release; } CORBA_sequence_CORBA_ServiceDetail;
# 9275 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_CORBA_ServiceDetail_struct;







struct CORBA_ServiceInformation_type {
CORBA_sequence_CORBA_ServiceOption service_options;
CORBA_sequence_CORBA_ServiceDetail service_details;
};
# 9304 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_ServiceInformation_struct;







typedef struct CORBA_ValueFactory_type *CORBA_ValueFactory;



typedef CORBA_string CORBA_ORBid;
# 9335 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_ORBid_struct;
# 9347 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_WrongTransaction_type CORBA_WrongTransaction;
struct CORBA_WrongTransaction_type {
int dummy;
};
# 9366 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_WrongTransaction_struct;
# 9463 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_string CORBA_sequence_CORBA_ORB_ObjectId;
# 9479 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_CORBA_ORB_ObjectId_struct;
# 9492 "../../include/orbit/orb-core/corba-defs.h"
typedef CORBA_sequence_CORBA_ORB_ObjectId CORBA_ORB_ObjectIdList;
# 9509 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_ORB_ObjectIdList_struct;
# 9522 "../../include/orbit/orb-core/corba-defs.h"
typedef struct CORBA_ORB_InvalidName_type CORBA_ORB_InvalidName;
struct CORBA_ORB_InvalidName_type {
int dummy;
};
# 9541 "../../include/orbit/orb-core/corba-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_ORB_InvalidName_struct;







typedef struct CORBA_OpaqueValue_type *CORBA_OpaqueValue;
# 9587 "../../include/orbit/orb-core/corba-defs.h"
CORBA_PolicyType CORBA_Policy__get_policy_type(CORBA_Policy _obj, CORBA_Environment *ev);
CORBA_Policy CORBA_Policy_copy(CORBA_Policy _obj, CORBA_Environment *ev);
void CORBA_Policy_destroy(CORBA_Policy _obj, CORBA_Environment *ev);
CORBA_Policy CORBA_DomainManager_get_domain_policy(CORBA_DomainManager _obj, const CORBA_PolicyType policy_type, CORBA_Environment *ev);



void CORBA_ConstructionPolicy_make_domain_manager(CORBA_ConstructionPolicy _obj, const CORBA_InterfaceDef object_type, const CORBA_boolean constr_policy, CORBA_Environment *ev);
CORBA_DefinitionKind CORBA_IRObject__get_def_kind(CORBA_IRObject _obj, CORBA_Environment *ev);
void CORBA_IRObject_destroy(CORBA_IRObject _obj, CORBA_Environment *ev);


CORBA_RepositoryId CORBA_Contained__get_id(CORBA_Contained _obj, CORBA_Environment *ev);
void CORBA_Contained__set_id(CORBA_Contained _obj, const CORBA_char * value, CORBA_Environment *ev);
CORBA_Identifier CORBA_Contained__get_name(CORBA_Contained _obj, CORBA_Environment *ev);
void CORBA_Contained__set_name(CORBA_Contained _obj, const CORBA_char * value, CORBA_Environment *ev);
CORBA_VersionSpec CORBA_Contained__get_version(CORBA_Contained _obj, CORBA_Environment *ev);
void CORBA_Contained__set_version(CORBA_Contained _obj, const CORBA_char * value, CORBA_Environment *ev);
CORBA_Container CORBA_Contained__get_defined_in(CORBA_Contained _obj, CORBA_Environment *ev);
CORBA_ScopedName CORBA_Contained__get_absolute_name(CORBA_Contained _obj, CORBA_Environment *ev);
CORBA_Repository CORBA_Contained__get_containing_repository(CORBA_Contained _obj, CORBA_Environment *ev);
CORBA_Contained_Description* CORBA_Contained_describe(CORBA_Contained _obj, CORBA_Environment *ev);
void CORBA_Contained_move(CORBA_Contained _obj, const CORBA_Container new_container, const CORBA_char * new_name, const CORBA_char * new_version, CORBA_Environment *ev);


CORBA_Contained CORBA_Container_lookup(CORBA_Container _obj, const CORBA_char * search_name, CORBA_Environment *ev);
CORBA_ContainedSeq* CORBA_Container_contents(CORBA_Container _obj, const CORBA_DefinitionKind limit_type, const CORBA_boolean exclude_inherited, CORBA_Environment *ev);
CORBA_ContainedSeq* CORBA_Container_lookup_name(CORBA_Container _obj, const CORBA_char * search_name, const CORBA_long levels_to_search, const CORBA_DefinitionKind limit_type, const CORBA_boolean exclude_inherited, CORBA_Environment *ev);
CORBA_Container_DescriptionSeq* CORBA_Container_describe_contents(CORBA_Container _obj, const CORBA_DefinitionKind limit_type, const CORBA_boolean exclude_inherited, const CORBA_long max_returned_objs, CORBA_Environment *ev);
CORBA_ModuleDef CORBA_Container_create_module(CORBA_Container _obj, const CORBA_char * id, const CORBA_char * name, const CORBA_char * version, CORBA_Environment *ev);
CORBA_ConstantDef CORBA_Container_create_constant(CORBA_Container _obj, const CORBA_char * id, const CORBA_char * name, const CORBA_char * version, const CORBA_IDLType type, const CORBA_any* value, CORBA_Environment *ev);
CORBA_StructDef CORBA_Container_create_struct(CORBA_Container _obj, const CORBA_char * id, const CORBA_char * name, const CORBA_char * version, const CORBA_StructMemberSeq* members, CORBA_Environment *ev);
CORBA_UnionDef CORBA_Container_create_union(CORBA_Container _obj, const CORBA_char * id, const CORBA_char * name, const CORBA_char * version, const CORBA_IDLType discriminator_type, const CORBA_UnionMemberSeq* members, CORBA_Environment *ev);
CORBA_EnumDef CORBA_Container_create_enum(CORBA_Container _obj, const CORBA_char * id, const CORBA_char * name, const CORBA_char * version, const CORBA_EnumMemberSeq* members, CORBA_Environment *ev);
CORBA_AliasDef CORBA_Container_create_alias(CORBA_Container _obj, const CORBA_char * id, const CORBA_char * name, const CORBA_char * version, const CORBA_IDLType original_type, CORBA_Environment *ev);
CORBA_InterfaceDef CORBA_Container_create_interface(CORBA_Container _obj, const CORBA_char * id, const CORBA_char * name, const CORBA_char * version, const CORBA_InterfaceDefSeq* base_interfaces, const CORBA_boolean is_abstract, CORBA_Environment *ev);
CORBA_ValueDef CORBA_Container_create_value(CORBA_Container _obj, const CORBA_char * id, const CORBA_char * name, const CORBA_char * version, const CORBA_boolean is_custom, const CORBA_boolean is_abstract, const CORBA_ValueDef base_value, const CORBA_boolean is_truncatable, const CORBA_ValueDefSeq* abstract_base_values, const CORBA_InterfaceDefSeq* supported_interfaces, const CORBA_InitializerSeq* initializers, CORBA_Environment *ev);
CORBA_ValueBoxDef CORBA_Container_create_value_box(CORBA_Container _obj, const CORBA_char * id, const CORBA_char * name, const CORBA_char * version, const CORBA_IDLType original_type_def, CORBA_Environment *ev);
CORBA_ExceptionDef CORBA_Container_create_exception(CORBA_Container _obj, const CORBA_char * id, const CORBA_char * name, const CORBA_char * version, const CORBA_StructMemberSeq* members, CORBA_Environment *ev);
CORBA_NativeDef CORBA_Container_create_native(CORBA_Container _obj, const CORBA_char * id, const CORBA_char * name, const CORBA_char * version, CORBA_Environment *ev);
CORBA_AbstractInterfaceDef CORBA_Container_create_abstract_interface(CORBA_Container _obj, const CORBA_char * id, const CORBA_char * name, const CORBA_char * version, const CORBA_AbstractInterfaceDefSeq* base_interfaces, CORBA_Environment *ev);
CORBA_LocalInterfaceDef CORBA_Container_create_local_interface(CORBA_Container _obj, const CORBA_char * id, const CORBA_char * name, const CORBA_char * version, const CORBA_InterfaceDefSeq* base_interfaces, CORBA_Environment *ev);
CORBA_ExtValueDef CORBA_Container_create_ext_value(CORBA_Container _obj, const CORBA_char * id, const CORBA_char * name, const CORBA_char * version, const CORBA_boolean is_custom, const CORBA_boolean is_abstract, const CORBA_ValueDef base_value, const CORBA_boolean is_truncatable, const CORBA_ValueDefSeq* abstract_base_values, const CORBA_InterfaceDefSeq* supported_interfaces, const CORBA_ExtInitializerSeq* initializers, CORBA_Environment *ev);


CORBA_TypeCode CORBA_IDLType__get_type(CORBA_IDLType _obj, CORBA_Environment *ev);
# 9653 "../../include/orbit/orb-core/corba-defs.h"
CORBA_Contained CORBA_Repository_lookup_id(CORBA_Repository _obj, const CORBA_char * search_id, CORBA_Environment *ev);
CORBA_TypeCode CORBA_Repository_get_canonical_typecode(CORBA_Repository _obj, const CORBA_TypeCode tc, CORBA_Environment *ev);
CORBA_PrimitiveDef CORBA_Repository_get_primitive(CORBA_Repository _obj, const CORBA_PrimitiveKind kind, CORBA_Environment *ev);
CORBA_StringDef CORBA_Repository_create_string(CORBA_Repository _obj, const CORBA_unsigned_long bound, CORBA_Environment *ev);
CORBA_WstringDef CORBA_Repository_create_wstring(CORBA_Repository _obj, const CORBA_unsigned_long bound, CORBA_Environment *ev);
CORBA_SequenceDef CORBA_Repository_create_sequence(CORBA_Repository _obj, const CORBA_unsigned_long bound, const CORBA_IDLType element_type, CORBA_Environment *ev);
CORBA_ArrayDef CORBA_Repository_create_array(CORBA_Repository _obj, const CORBA_unsigned_long length, const CORBA_IDLType element_type, CORBA_Environment *ev);
CORBA_FixedDef CORBA_Repository_create_fixed(CORBA_Repository _obj, const CORBA_unsigned_short digits, const CORBA_short scale, CORBA_Environment *ev);
# 9705 "../../include/orbit/orb-core/corba-defs.h"
CORBA_TypeCode CORBA_ConstantDef__get_type(CORBA_ConstantDef _obj, CORBA_Environment *ev);
CORBA_IDLType CORBA_ConstantDef__get_type_def(CORBA_ConstantDef _obj, CORBA_Environment *ev);
void CORBA_ConstantDef__set_type_def(CORBA_ConstantDef _obj, const CORBA_IDLType value, CORBA_Environment *ev);
CORBA_any* CORBA_ConstantDef__get_value(CORBA_ConstantDef _obj, CORBA_Environment *ev);
void CORBA_ConstantDef__set_value(CORBA_ConstantDef _obj, const CORBA_any* value, CORBA_Environment *ev);
# 9756 "../../include/orbit/orb-core/corba-defs.h"
CORBA_StructMemberSeq* CORBA_StructDef__get_members(CORBA_StructDef _obj, CORBA_Environment *ev);
void CORBA_StructDef__set_members(CORBA_StructDef _obj, const CORBA_StructMemberSeq* value, CORBA_Environment *ev);
# 9790 "../../include/orbit/orb-core/corba-defs.h"
CORBA_TypeCode CORBA_UnionDef__get_discriminator_type(CORBA_UnionDef _obj, CORBA_Environment *ev);
CORBA_IDLType CORBA_UnionDef__get_discriminator_type_def(CORBA_UnionDef _obj, CORBA_Environment *ev);
void CORBA_UnionDef__set_discriminator_type_def(CORBA_UnionDef _obj, const CORBA_IDLType value, CORBA_Environment *ev);
CORBA_UnionMemberSeq* CORBA_UnionDef__get_members(CORBA_UnionDef _obj, CORBA_Environment *ev);
void CORBA_UnionDef__set_members(CORBA_UnionDef _obj, const CORBA_UnionMemberSeq* value, CORBA_Environment *ev);
# 9809 "../../include/orbit/orb-core/corba-defs.h"
CORBA_EnumMemberSeq* CORBA_EnumDef__get_members(CORBA_EnumDef _obj, CORBA_Environment *ev);
void CORBA_EnumDef__set_members(CORBA_EnumDef _obj, const CORBA_EnumMemberSeq* value, CORBA_Environment *ev);
# 9825 "../../include/orbit/orb-core/corba-defs.h"
CORBA_IDLType CORBA_AliasDef__get_original_type_def(CORBA_AliasDef _obj, CORBA_Environment *ev);
void CORBA_AliasDef__set_original_type_def(CORBA_AliasDef _obj, const CORBA_IDLType value, CORBA_Environment *ev);
# 9844 "../../include/orbit/orb-core/corba-defs.h"
CORBA_PrimitiveKind CORBA_PrimitiveDef__get_kind(CORBA_PrimitiveDef _obj, CORBA_Environment *ev);



CORBA_unsigned_long CORBA_StringDef__get_bound(CORBA_StringDef _obj, CORBA_Environment *ev);
void CORBA_StringDef__set_bound(CORBA_StringDef _obj, const CORBA_unsigned_long value, CORBA_Environment *ev);



CORBA_unsigned_long CORBA_WstringDef__get_bound(CORBA_WstringDef _obj, CORBA_Environment *ev);
void CORBA_WstringDef__set_bound(CORBA_WstringDef _obj, const CORBA_unsigned_long value, CORBA_Environment *ev);



CORBA_unsigned_short CORBA_FixedDef__get_digits(CORBA_FixedDef _obj, CORBA_Environment *ev);
void CORBA_FixedDef__set_digits(CORBA_FixedDef _obj, const CORBA_unsigned_short value, CORBA_Environment *ev);
CORBA_short CORBA_FixedDef__get_scale(CORBA_FixedDef _obj, CORBA_Environment *ev);
void CORBA_FixedDef__set_scale(CORBA_FixedDef _obj, const CORBA_short value, CORBA_Environment *ev);



CORBA_unsigned_long CORBA_SequenceDef__get_bound(CORBA_SequenceDef _obj, CORBA_Environment *ev);
void CORBA_SequenceDef__set_bound(CORBA_SequenceDef _obj, const CORBA_unsigned_long value, CORBA_Environment *ev);
CORBA_TypeCode CORBA_SequenceDef__get_element_type(CORBA_SequenceDef _obj, CORBA_Environment *ev);
CORBA_IDLType CORBA_SequenceDef__get_element_type_def(CORBA_SequenceDef _obj, CORBA_Environment *ev);
void CORBA_SequenceDef__set_element_type_def(CORBA_SequenceDef _obj, const CORBA_IDLType value, CORBA_Environment *ev);



CORBA_unsigned_long CORBA_ArrayDef__get_length(CORBA_ArrayDef _obj, CORBA_Environment *ev);
void CORBA_ArrayDef__set_length(CORBA_ArrayDef _obj, const CORBA_unsigned_long value, CORBA_Environment *ev);
CORBA_TypeCode CORBA_ArrayDef__get_element_type(CORBA_ArrayDef _obj, CORBA_Environment *ev);
CORBA_IDLType CORBA_ArrayDef__get_element_type_def(CORBA_ArrayDef _obj, CORBA_Environment *ev);
void CORBA_ArrayDef__set_element_type_def(CORBA_ArrayDef _obj, const CORBA_IDLType value, CORBA_Environment *ev);
# 9909 "../../include/orbit/orb-core/corba-defs.h"
CORBA_TypeCode CORBA_ExceptionDef__get_type(CORBA_ExceptionDef _obj, CORBA_Environment *ev);
CORBA_StructMemberSeq* CORBA_ExceptionDef__get_members(CORBA_ExceptionDef _obj, CORBA_Environment *ev);
void CORBA_ExceptionDef__set_members(CORBA_ExceptionDef _obj, const CORBA_StructMemberSeq* value, CORBA_Environment *ev);
# 9925 "../../include/orbit/orb-core/corba-defs.h"
CORBA_TypeCode CORBA_AttributeDef__get_type(CORBA_AttributeDef _obj, CORBA_Environment *ev);
CORBA_IDLType CORBA_AttributeDef__get_type_def(CORBA_AttributeDef _obj, CORBA_Environment *ev);
void CORBA_AttributeDef__set_type_def(CORBA_AttributeDef _obj, const CORBA_IDLType value, CORBA_Environment *ev);
CORBA_AttributeMode CORBA_AttributeDef__get_mode(CORBA_AttributeDef _obj, CORBA_Environment *ev);
void CORBA_AttributeDef__set_mode(CORBA_AttributeDef _obj, const CORBA_AttributeMode value, CORBA_Environment *ev);
# 9948 "../../include/orbit/orb-core/corba-defs.h"
CORBA_ExcDescriptionSeq* CORBA_ExtAttributeDef__get_get_exceptions(CORBA_ExtAttributeDef _obj, CORBA_Environment *ev);
void CORBA_ExtAttributeDef__set_get_exceptions(CORBA_ExtAttributeDef _obj, const CORBA_ExcDescriptionSeq* value, CORBA_Environment *ev);
CORBA_ExcDescriptionSeq* CORBA_ExtAttributeDef__get_set_exceptions(CORBA_ExtAttributeDef _obj, CORBA_Environment *ev);
void CORBA_ExtAttributeDef__set_set_exceptions(CORBA_ExtAttributeDef _obj, const CORBA_ExcDescriptionSeq* value, CORBA_Environment *ev);
CORBA_ExtAttributeDescription* CORBA_ExtAttributeDef_describe_attribute(CORBA_ExtAttributeDef _obj, CORBA_Environment *ev);
# 9966 "../../include/orbit/orb-core/corba-defs.h"
CORBA_TypeCode CORBA_OperationDef__get_result(CORBA_OperationDef _obj, CORBA_Environment *ev);
CORBA_IDLType CORBA_OperationDef__get_result_def(CORBA_OperationDef _obj, CORBA_Environment *ev);
void CORBA_OperationDef__set_result_def(CORBA_OperationDef _obj, const CORBA_IDLType value, CORBA_Environment *ev);
CORBA_ParDescriptionSeq* CORBA_OperationDef__get_params(CORBA_OperationDef _obj, CORBA_Environment *ev);
void CORBA_OperationDef__set_params(CORBA_OperationDef _obj, const CORBA_ParDescriptionSeq* value, CORBA_Environment *ev);
CORBA_OperationMode CORBA_OperationDef__get_mode(CORBA_OperationDef _obj, CORBA_Environment *ev);
void CORBA_OperationDef__set_mode(CORBA_OperationDef _obj, const CORBA_OperationMode value, CORBA_Environment *ev);
CORBA_ContextIdSeq* CORBA_OperationDef__get_contexts(CORBA_OperationDef _obj, CORBA_Environment *ev);
void CORBA_OperationDef__set_contexts(CORBA_OperationDef _obj, const CORBA_ContextIdSeq* value, CORBA_Environment *ev);
CORBA_ExceptionDefSeq* CORBA_OperationDef__get_exceptions(CORBA_OperationDef _obj, CORBA_Environment *ev);
void CORBA_OperationDef__set_exceptions(CORBA_OperationDef _obj, const CORBA_ExceptionDefSeq* value, CORBA_Environment *ev);
# 10009 "../../include/orbit/orb-core/corba-defs.h"
CORBA_InterfaceDefSeq* CORBA_InterfaceDef__get_base_interfaces(CORBA_InterfaceDef _obj, CORBA_Environment *ev);
void CORBA_InterfaceDef__set_base_interfaces(CORBA_InterfaceDef _obj, const CORBA_InterfaceDefSeq* value, CORBA_Environment *ev);
CORBA_boolean CORBA_InterfaceDef__get_is_abstract(CORBA_InterfaceDef _obj, CORBA_Environment *ev);
void CORBA_InterfaceDef__set_is_abstract(CORBA_InterfaceDef _obj, const CORBA_boolean value, CORBA_Environment *ev);
CORBA_boolean CORBA_InterfaceDef_is_a(CORBA_InterfaceDef _obj, const CORBA_char * interface_id, CORBA_Environment *ev);
CORBA_InterfaceDef_FullInterfaceDescription* CORBA_InterfaceDef_describe_interface(CORBA_InterfaceDef _obj, CORBA_Environment *ev);
CORBA_AttributeDef CORBA_InterfaceDef_create_attribute(CORBA_InterfaceDef _obj, const CORBA_char * id, const CORBA_char * name, const CORBA_char * version, const CORBA_IDLType type, const CORBA_AttributeMode mode, CORBA_Environment *ev);
CORBA_OperationDef CORBA_InterfaceDef_create_operation(CORBA_InterfaceDef _obj, const CORBA_char * id, const CORBA_char * name, const CORBA_char * version, const CORBA_IDLType result, const CORBA_OperationMode mode, const CORBA_ParDescriptionSeq* params, const CORBA_ExceptionDefSeq* exceptions, const CORBA_ContextIdSeq* contexts, CORBA_Environment *ev);
CORBA_InterfaceAttrExtension_ExtFullInterfaceDescription* CORBA_InterfaceAttrExtension_describe_ext_interface(CORBA_InterfaceAttrExtension _obj, CORBA_Environment *ev);
CORBA_ExtAttributeDef CORBA_InterfaceAttrExtension_create_ext_attribute(CORBA_InterfaceAttrExtension _obj, const CORBA_char * id, const CORBA_char * name, const CORBA_char * version, const CORBA_IDLType type, const CORBA_AttributeMode mode, const CORBA_ExceptionDefSeq* get_exceptions, const CORBA_ExceptionDefSeq* set_exceptions, CORBA_Environment *ev);
# 10074 "../../include/orbit/orb-core/corba-defs.h"
CORBA_TypeCode CORBA_ValueMemberDef__get_type(CORBA_ValueMemberDef _obj, CORBA_Environment *ev);
CORBA_IDLType CORBA_ValueMemberDef__get_type_def(CORBA_ValueMemberDef _obj, CORBA_Environment *ev);
void CORBA_ValueMemberDef__set_type_def(CORBA_ValueMemberDef _obj, const CORBA_IDLType value, CORBA_Environment *ev);
CORBA_Visibility CORBA_ValueMemberDef__get_access(CORBA_ValueMemberDef _obj, CORBA_Environment *ev);
void CORBA_ValueMemberDef__set_access(CORBA_ValueMemberDef _obj, const CORBA_Visibility value, CORBA_Environment *ev);
# 10111 "../../include/orbit/orb-core/corba-defs.h"
CORBA_InterfaceDefSeq* CORBA_ValueDef__get_supported_interfaces(CORBA_ValueDef _obj, CORBA_Environment *ev);
void CORBA_ValueDef__set_supported_interfaces(CORBA_ValueDef _obj, const CORBA_InterfaceDefSeq* value, CORBA_Environment *ev);
CORBA_InitializerSeq* CORBA_ValueDef__get_initializers(CORBA_ValueDef _obj, CORBA_Environment *ev);
void CORBA_ValueDef__set_initializers(CORBA_ValueDef _obj, const CORBA_InitializerSeq* value, CORBA_Environment *ev);
CORBA_ValueDef CORBA_ValueDef__get_base_value(CORBA_ValueDef _obj, CORBA_Environment *ev);
void CORBA_ValueDef__set_base_value(CORBA_ValueDef _obj, const CORBA_ValueDef value, CORBA_Environment *ev);
CORBA_ValueDefSeq* CORBA_ValueDef__get_abstract_base_values(CORBA_ValueDef _obj, CORBA_Environment *ev);
void CORBA_ValueDef__set_abstract_base_values(CORBA_ValueDef _obj, const CORBA_ValueDefSeq* value, CORBA_Environment *ev);
CORBA_boolean CORBA_ValueDef__get_is_abstract(CORBA_ValueDef _obj, CORBA_Environment *ev);
void CORBA_ValueDef__set_is_abstract(CORBA_ValueDef _obj, const CORBA_boolean value, CORBA_Environment *ev);
CORBA_boolean CORBA_ValueDef__get_is_custom(CORBA_ValueDef _obj, CORBA_Environment *ev);
void CORBA_ValueDef__set_is_custom(CORBA_ValueDef _obj, const CORBA_boolean value, CORBA_Environment *ev);
CORBA_boolean CORBA_ValueDef__get_is_truncatable(CORBA_ValueDef _obj, CORBA_Environment *ev);
void CORBA_ValueDef__set_is_truncatable(CORBA_ValueDef _obj, const CORBA_boolean value, CORBA_Environment *ev);
CORBA_boolean CORBA_ValueDef_is_a(CORBA_ValueDef _obj, const CORBA_char * id, CORBA_Environment *ev);
CORBA_ValueDef_FullValueDescription* CORBA_ValueDef_describe_value(CORBA_ValueDef _obj, CORBA_Environment *ev);
CORBA_ValueMemberDef CORBA_ValueDef_create_value_member(CORBA_ValueDef _obj, const CORBA_char * id, const CORBA_char * name, const CORBA_char * version, const CORBA_IDLType type, const CORBA_Visibility access, CORBA_Environment *ev);
CORBA_AttributeDef CORBA_ValueDef_create_attribute(CORBA_ValueDef _obj, const CORBA_char * id, const CORBA_char * name, const CORBA_char * version, const CORBA_IDLType type, const CORBA_AttributeMode mode, CORBA_Environment *ev);
CORBA_OperationDef CORBA_ValueDef_create_operation(CORBA_ValueDef _obj, const CORBA_char * id, const CORBA_char * name, const CORBA_char * version, const CORBA_IDLType result, const CORBA_OperationMode mode, const CORBA_ParDescriptionSeq* params, const CORBA_ExceptionDefSeq* exceptions, const CORBA_ContextIdSeq* contexts, CORBA_Environment *ev);
# 10181 "../../include/orbit/orb-core/corba-defs.h"
CORBA_ExtInitializerSeq* CORBA_ExtValueDef__get_ext_initializers(CORBA_ExtValueDef _obj, CORBA_Environment *ev);
void CORBA_ExtValueDef__set_ext_initializers(CORBA_ExtValueDef _obj, const CORBA_ExtInitializerSeq* value, CORBA_Environment *ev);
CORBA_ExtValueDef_ExtFullValueDescription* CORBA_ExtValueDef_describe_ext_value(CORBA_ExtValueDef _obj, CORBA_Environment *ev);
CORBA_ExtAttributeDef CORBA_ExtValueDef_create_ext_attribute(CORBA_ExtValueDef _obj, const CORBA_char * id, const CORBA_char * name, const CORBA_char * version, const CORBA_IDLType type, const CORBA_AttributeMode mode, const CORBA_ExceptionDefSeq* get_exceptions, const CORBA_ExceptionDefSeq* set_exceptions, CORBA_Environment *ev);
# 10199 "../../include/orbit/orb-core/corba-defs.h"
CORBA_IDLType CORBA_ValueBoxDef__get_original_type_def(CORBA_ValueBoxDef _obj, CORBA_Environment *ev);
void CORBA_ValueBoxDef__set_original_type_def(CORBA_ValueBoxDef _obj, const CORBA_IDLType value, CORBA_Environment *ev);
# 10365 "../../include/orbit/orb-core/corba-defs.h"
CORBA_boolean CORBA_TypeCode_equal(CORBA_TypeCode _obj, const CORBA_TypeCode tc, CORBA_Environment *ev);
CORBA_boolean CORBA_TypeCode_equivalent(CORBA_TypeCode _obj, const CORBA_TypeCode tc, CORBA_Environment *ev);
CORBA_TypeCode CORBA_TypeCode_get_compact_typecode(CORBA_TypeCode _obj, CORBA_Environment *ev);
CORBA_TCKind CORBA_TypeCode_kind(CORBA_TypeCode _obj, CORBA_Environment *ev);
CORBA_RepositoryId CORBA_TypeCode_id(CORBA_TypeCode _obj, CORBA_Environment *ev);
CORBA_Identifier CORBA_TypeCode_name(CORBA_TypeCode _obj, CORBA_Environment *ev);
CORBA_unsigned_long CORBA_TypeCode_member_count(CORBA_TypeCode _obj, CORBA_Environment *ev);
CORBA_Identifier CORBA_TypeCode_member_name(CORBA_TypeCode _obj, const CORBA_unsigned_long index, CORBA_Environment *ev);
CORBA_TypeCode CORBA_TypeCode_member_type(CORBA_TypeCode _obj, const CORBA_unsigned_long index, CORBA_Environment *ev);
CORBA_any* CORBA_TypeCode_member_label(CORBA_TypeCode _obj, const CORBA_unsigned_long index, CORBA_Environment *ev);
CORBA_TypeCode CORBA_TypeCode_discriminator_type(CORBA_TypeCode _obj, CORBA_Environment *ev);
CORBA_long CORBA_TypeCode_default_index(CORBA_TypeCode _obj, CORBA_Environment *ev);
CORBA_unsigned_long CORBA_TypeCode_length(CORBA_TypeCode _obj, CORBA_Environment *ev);
CORBA_TypeCode CORBA_TypeCode_content_type(CORBA_TypeCode _obj, CORBA_Environment *ev);
CORBA_unsigned_short CORBA_TypeCode_fixed_digits(CORBA_TypeCode _obj, CORBA_Environment *ev);
CORBA_short CORBA_TypeCode_fixed_scale(CORBA_TypeCode _obj, CORBA_Environment *ev);
CORBA_Visibility CORBA_TypeCode_member_visibility(CORBA_TypeCode _obj, const CORBA_unsigned_long index, CORBA_Environment *ev);
CORBA_ValueModifier CORBA_TypeCode_type_modifier(CORBA_TypeCode _obj, CORBA_Environment *ev);
CORBA_TypeCode CORBA_TypeCode_concrete_base_type(CORBA_TypeCode _obj, CORBA_Environment *ev);
CORBA_InterfaceDef CORBA_Object_get_interface(CORBA_Object _obj, CORBA_Environment *ev);
CORBA_boolean CORBA_Object_is_nil(CORBA_Object _obj, CORBA_Environment *ev);
CORBA_Object CORBA_Object_duplicate(CORBA_Object _obj, CORBA_Environment *ev);
void CORBA_Object_release(CORBA_Object _obj, CORBA_Environment *ev);
CORBA_boolean CORBA_Object_is_a(CORBA_Object _obj, const CORBA_char * logical_type_id, CORBA_Environment *ev);
CORBA_boolean CORBA_Object_non_existent(CORBA_Object _obj, CORBA_Environment *ev);
CORBA_boolean CORBA_Object_is_equivalent(CORBA_Object _obj, const CORBA_Object other_object, CORBA_Environment *ev);
CORBA_unsigned_long CORBA_Object_hash(CORBA_Object _obj, const CORBA_unsigned_long maximum, CORBA_Environment *ev);
void CORBA_Object_create_request(CORBA_Object _obj, const CORBA_Context ctx, const CORBA_char * operation, const CORBA_NVList arg_list, CORBA_NamedValue* result, CORBA_Request* request, const CORBA_Flags req_flag, CORBA_Environment *ev);
CORBA_Policy CORBA_Object_get_policy(CORBA_Object _obj, const CORBA_PolicyType policy_type, CORBA_Environment *ev);
CORBA_DomainManagersList* CORBA_Object_get_domain_managers(CORBA_Object _obj, CORBA_Environment *ev);
CORBA_Object CORBA_Object_set_policy_overrides(CORBA_Object _obj, const CORBA_PolicyList* policies, const CORBA_SetOverrideType set_add, CORBA_Environment *ev);
CORBA_Policy CORBA_Object_get_client_policy(CORBA_Object _obj, const CORBA_PolicyType type, CORBA_Environment *ev);
CORBA_PolicyList* CORBA_Object_get_policy_overrides(CORBA_Object _obj, const CORBA_PolicyTypeSeq* types, CORBA_Environment *ev);
CORBA_boolean CORBA_Object_validate_connection(CORBA_Object _obj, CORBA_PolicyList** inconsistent_policies, CORBA_Environment *ev);
CORBA_Object CORBA_Object_get_component(CORBA_Object _obj, CORBA_Environment *ev);
CORBA_ORBid CORBA_ORB_id(CORBA_ORB _obj, CORBA_Environment *ev);
CORBA_string CORBA_ORB_object_to_string(CORBA_ORB _obj, const CORBA_Object obj, CORBA_Environment *ev);
CORBA_Object CORBA_ORB_string_to_object(CORBA_ORB _obj, const CORBA_char * str, CORBA_Environment *ev);
void CORBA_ORB_create_list(CORBA_ORB _obj, const CORBA_long count, CORBA_NVList* new_list, CORBA_Environment *ev);
void CORBA_ORB_create_operation_list(CORBA_ORB _obj, const CORBA_OperationDef oper, CORBA_NVList* new_list, CORBA_Environment *ev);
void CORBA_ORB_get_default_context(CORBA_ORB _obj, CORBA_Context* ctx, CORBA_Environment *ev);
void CORBA_ORB_send_multiple_requests_oneway(CORBA_ORB _obj, const CORBA_RequestSeq* req, CORBA_Environment *ev);
void CORBA_ORB_send_multiple_requests_deferred(CORBA_ORB _obj, const CORBA_RequestSeq* req, CORBA_Environment *ev);
CORBA_boolean CORBA_ORB_poll_next_response(CORBA_ORB _obj, CORBA_Environment *ev);
void CORBA_ORB_get_next_response(CORBA_ORB _obj, CORBA_Request* req, CORBA_Environment *ev);
CORBA_boolean CORBA_ORB_get_service_information(CORBA_ORB _obj, const CORBA_ServiceType service_type, CORBA_ServiceInformation** service_information, CORBA_Environment *ev);
CORBA_ORB_ObjectIdList* CORBA_ORB_list_initial_services(CORBA_ORB _obj, CORBA_Environment *ev);
CORBA_Object CORBA_ORB_resolve_initial_references(CORBA_ORB _obj, const CORBA_char * identifier, CORBA_Environment *ev);
CORBA_TypeCode CORBA_ORB_create_struct_tc(CORBA_ORB _obj, const CORBA_char * id, const CORBA_char * name, const CORBA_StructMemberSeq* members, CORBA_Environment *ev);
CORBA_TypeCode CORBA_ORB_create_union_tc(CORBA_ORB _obj, const CORBA_char * id, const CORBA_char * name, const CORBA_TypeCode discriminator_type, const CORBA_UnionMemberSeq* members, CORBA_Environment *ev);
CORBA_TypeCode CORBA_ORB_create_enum_tc(CORBA_ORB _obj, const CORBA_char * id, const CORBA_char * name, const CORBA_EnumMemberSeq* members, CORBA_Environment *ev);
CORBA_TypeCode CORBA_ORB_create_alias_tc(CORBA_ORB _obj, const CORBA_char * id, const CORBA_char * name, const CORBA_TypeCode original_type, CORBA_Environment *ev);
CORBA_TypeCode CORBA_ORB_create_exception_tc(CORBA_ORB _obj, const CORBA_char * id, const CORBA_char * name, const CORBA_StructMemberSeq* members, CORBA_Environment *ev);
CORBA_TypeCode CORBA_ORB_create_interface_tc(CORBA_ORB _obj, const CORBA_char * id, const CORBA_char * name, CORBA_Environment *ev);
CORBA_TypeCode CORBA_ORB_create_string_tc(CORBA_ORB _obj, const CORBA_unsigned_long bound, CORBA_Environment *ev);
CORBA_TypeCode CORBA_ORB_create_wstring_tc(CORBA_ORB _obj, const CORBA_unsigned_long bound, CORBA_Environment *ev);
CORBA_TypeCode CORBA_ORB_create_fixed_tc(CORBA_ORB _obj, const CORBA_unsigned_short digits, const CORBA_short scale, CORBA_Environment *ev);
CORBA_TypeCode CORBA_ORB_create_sequence_tc(CORBA_ORB _obj, const CORBA_unsigned_long bound, const CORBA_TypeCode element_type, CORBA_Environment *ev);
CORBA_TypeCode CORBA_ORB_create_recursive_sequence_tc(CORBA_ORB _obj, const CORBA_unsigned_long bound, const CORBA_unsigned_long offset, CORBA_Environment *ev);
CORBA_TypeCode CORBA_ORB_create_array_tc(CORBA_ORB _obj, const CORBA_unsigned_long length, const CORBA_TypeCode element_type, CORBA_Environment *ev);
CORBA_TypeCode CORBA_ORB_create_value_tc(CORBA_ORB _obj, const CORBA_char * id, const CORBA_char * name, const CORBA_ValueModifier type_modifier, const CORBA_TypeCode concrete_base, const CORBA_ValueMemberSeq* members, CORBA_Environment *ev);
CORBA_TypeCode CORBA_ORB_create_value_box_tc(CORBA_ORB _obj, const CORBA_char * id, const CORBA_char * name, const CORBA_TypeCode boxed_type, CORBA_Environment *ev);
CORBA_TypeCode CORBA_ORB_create_native_tc(CORBA_ORB _obj, const CORBA_char * id, const CORBA_char * name, CORBA_Environment *ev);
CORBA_TypeCode CORBA_ORB_create_recursive_tc(CORBA_ORB _obj, const CORBA_char * id, CORBA_Environment *ev);
CORBA_TypeCode CORBA_ORB_create_abstract_interface_tc(CORBA_ORB _obj, const CORBA_char * id, const CORBA_char * name, CORBA_Environment *ev);
CORBA_TypeCode CORBA_ORB_create_local_interface_tc(CORBA_ORB _obj, const CORBA_char * id, const CORBA_char * name, CORBA_Environment *ev);
CORBA_TypeCode CORBA_ORB_create_component_tc(CORBA_ORB _obj, const CORBA_char * id, const CORBA_char * name, CORBA_Environment *ev);
CORBA_TypeCode CORBA_ORB_create_home_tc(CORBA_ORB _obj, const CORBA_char * id, const CORBA_char * name, CORBA_Environment *ev);
CORBA_TypeCode CORBA_ORB_create_event_tc(CORBA_ORB _obj, const CORBA_char * id, const CORBA_char * name, const CORBA_ValueModifier type_modifier, const CORBA_TypeCode concrete_base, const CORBA_ValueMemberSeq* members, CORBA_Environment *ev);
CORBA_boolean CORBA_ORB_work_pending(CORBA_ORB _obj, CORBA_Environment *ev);
void CORBA_ORB_perform_work(CORBA_ORB _obj, CORBA_Environment *ev);
void CORBA_ORB_run(CORBA_ORB _obj, CORBA_Environment *ev);
void CORBA_ORB_shutdown(CORBA_ORB _obj, const CORBA_boolean wait_for_completion, CORBA_Environment *ev);
void CORBA_ORB_destroy(CORBA_ORB _obj, CORBA_Environment *ev);
CORBA_Policy CORBA_ORB_create_policy(CORBA_ORB _obj, const CORBA_PolicyType type, const CORBA_any* val, CORBA_Environment *ev);
CORBA_ValueFactory CORBA_ORB_register_value_factory(CORBA_ORB _obj, const CORBA_char * id, const CORBA_ValueFactory factory, CORBA_Environment *ev);
void CORBA_ORB_unregister_value_factory(CORBA_ORB _obj, const CORBA_char * id, CORBA_Environment *ev);
CORBA_ValueFactory CORBA_ORB_lookup_value_factory(CORBA_ORB _obj, const CORBA_char * id, CORBA_Environment *ev);
void CORBA_ORB_register_initial_reference(CORBA_ORB _obj, const CORBA_char * id, const CORBA_Object obj, CORBA_Environment *ev);
void CORBA_Request_add_arg(CORBA_Request _obj, const CORBA_char * name, const CORBA_TypeCode arg_type, const CORBA_OpaqueValue value, const CORBA_long len, const CORBA_Flags arg_flags, CORBA_Environment *ev);
void CORBA_Request_invoke(CORBA_Request _obj, const CORBA_Flags invoke_flags, CORBA_Environment *ev);
void CORBA_Request_delete(CORBA_Request _obj, CORBA_Environment *ev);
void CORBA_Request_send(CORBA_Request _obj, const CORBA_Flags invoke_flags, CORBA_Environment *ev);
void CORBA_Request_get_response(CORBA_Request _obj, CORBA_Environment *ev);
CORBA_boolean CORBA_Request_poll_response(CORBA_Request _obj, CORBA_Environment *ev);
CORBA_Object CORBA_Request_sendp(CORBA_Request _obj, CORBA_Environment *ev);
void CORBA_Request_prepare(CORBA_Request _obj, const CORBA_Object p, CORBA_Environment *ev);
void CORBA_Request_sendc(CORBA_Request _obj, const CORBA_Object handler, CORBA_Environment *ev);
void CORBA_Context_set_one_value(CORBA_Context _obj, const CORBA_char * prop_name, const CORBA_char * value, CORBA_Environment *ev);
void CORBA_Context_set_values(CORBA_Context _obj, const CORBA_NVList values, CORBA_Environment *ev);
void CORBA_Context_get_values(CORBA_Context _obj, const CORBA_char * start_scope, const CORBA_Flags op_flags, const CORBA_char * prop_name, CORBA_NVList* values, CORBA_Environment *ev);
void CORBA_Context_delete_values(CORBA_Context _obj, const CORBA_char * prop_name, CORBA_Environment *ev);
void CORBA_Context_create_child(CORBA_Context _obj, const CORBA_char * ctx_name, CORBA_Context* child_ctx, CORBA_Environment *ev);
void CORBA_Context_delete(CORBA_Context _obj, const CORBA_Flags del_flags, CORBA_Environment *ev);
void CORBA_NVList_add_item(CORBA_NVList _obj, const CORBA_char * item_name, const CORBA_TypeCode item_type, const CORBA_OpaqueValue value, const CORBA_long value_len, const CORBA_Flags item_flags, CORBA_Environment *ev);
void CORBA_NVList_free(CORBA_NVList _obj, CORBA_Environment *ev);
void CORBA_NVList_free_memory(CORBA_NVList _obj, CORBA_Environment *ev);
void CORBA_NVList_get_count(CORBA_NVList _obj, CORBA_long* count, CORBA_Environment *ev);
CORBA_Identifier CORBA_ServerRequest__get_operation(CORBA_ServerRequest _obj, CORBA_Environment *ev);
void CORBA_ServerRequest_arguments(CORBA_ServerRequest _obj, CORBA_NVList* nv, CORBA_Environment *ev);
CORBA_Context CORBA_ServerRequest_ctx(CORBA_ServerRequest _obj, CORBA_Environment *ev);
void CORBA_ServerRequest_set_result(CORBA_ServerRequest _obj, const CORBA_any* val, CORBA_Environment *ev);
void CORBA_ServerRequest_set_exception(CORBA_ServerRequest _obj, const CORBA_any* val, CORBA_Environment *ev);
# 17 "../../include/orbit/orb-core/orb-core-types.h" 2
# 9 "../../include/orbit/orbit-types.h" 2
# 1 "../../include/orbit/poa/poa-basics.h" 1









 typedef gpointer PortableServer_Servant;







 typedef struct PortableServer_POA_type *PortableServer_POA;


typedef struct {
 void *_private;
 void (*finalize) (PortableServer_Servant,
          CORBA_Environment *);
 PortableServer_POA (*default_POA) (PortableServer_Servant,
          CORBA_Environment *);
 void (*add_ref) (PortableServer_Servant,
          CORBA_Environment *);
 void (*remove_ref) (PortableServer_Servant,
          CORBA_Environment *);
 CORBA_InterfaceDef (*get_interface) (PortableServer_Servant,
                                             CORBA_Environment *);
 CORBA_boolean (*is_a) (PortableServer_Servant,
          const char *,
          CORBA_Environment *);
 CORBA_boolean (*non_existent) (PortableServer_Servant,
          CORBA_Environment *);
} PortableServer_ServantBase__epv;

typedef PortableServer_ServantBase__epv *PortableServer_ServantBase__vepv;

typedef struct {
 void *_private;
 PortableServer_ServantBase__vepv *vepv;
} PortableServer_ServantBase;

typedef PortableServer_ServantBase__epv PortableServer_RefCountServantBase__epv;
typedef PortableServer_ServantBase__epv *PortableServer_RefCountServantBase__vepv;
typedef PortableServer_ServantBase PortableServer_RefCountServantBase;



typedef struct ORBit_POAObject_type *ORBit_POAObject;
typedef struct ORBit_OAObject_type *ORBit_OAObject;

typedef gshort ORBit_VepvIdx;

typedef void (*ORBitSmallSkeleton) (PortableServer_ServantBase *servant,
        gpointer ret,
        gpointer *args,
        gpointer ctx,
        CORBA_Environment *ev,
        gpointer implementation);

typedef ORBitSmallSkeleton (*ORBit_impl_finder)
       (PortableServer_ServantBase *servant,
        const char *method,
        gpointer *m_data,
        gpointer *implementation);

typedef ORBit_impl_finder ORBit_small_impl_finder;




# 10 "../../include/orbit/orbit-types.h" 2
# 10 "everything.h" 2
# 59 "everything.h"
typedef enum {
  test_veggie,
  test_chicken,
  test_tomato,
  test_oxtail
} test_Soup;
# 79 "everything.h"
extern

const struct CORBA_TypeCode_struct TC_test_Soup_struct;
# 97 "everything.h"
typedef CORBA_Object test_BasicServer;
extern CORBA_unsigned_long test_BasicServer__classid;
# 113 "everything.h"
extern

const struct CORBA_TypeCode_struct TC_test_BasicServer_struct;







typedef CORBA_Object test_StructServer;
extern CORBA_unsigned_long test_StructServer__classid;
# 139 "everything.h"
extern

const struct CORBA_TypeCode_struct TC_test_StructServer_struct;







typedef CORBA_Object test_SequenceServer;
extern CORBA_unsigned_long test_SequenceServer__classid;
# 165 "everything.h"
extern

const struct CORBA_TypeCode_struct TC_test_SequenceServer_struct;







typedef CORBA_Object test_UnionServer;
extern CORBA_unsigned_long test_UnionServer__classid;
# 191 "everything.h"
extern

const struct CORBA_TypeCode_struct TC_test_UnionServer_struct;







typedef CORBA_Object test_ArrayServer;
extern CORBA_unsigned_long test_ArrayServer__classid;
# 217 "everything.h"
extern

const struct CORBA_TypeCode_struct TC_test_ArrayServer_struct;







typedef CORBA_Object test_AnyServer;
extern CORBA_unsigned_long test_AnyServer__classid;
# 243 "everything.h"
extern

const struct CORBA_TypeCode_struct TC_test_AnyServer_struct;







typedef CORBA_Object test_BaseServer;
extern CORBA_unsigned_long test_BaseServer__classid;
# 269 "everything.h"
extern

const struct CORBA_TypeCode_struct TC_test_BaseServer_struct;







typedef CORBA_Object test_B1;
extern CORBA_unsigned_long test_B1__classid;
# 295 "everything.h"
extern

const struct CORBA_TypeCode_struct TC_test_B1_struct;







typedef CORBA_Object test_B2;
extern CORBA_unsigned_long test_B2__classid;
# 321 "everything.h"
extern

const struct CORBA_TypeCode_struct TC_test_B2_struct;







typedef CORBA_Object test_DerivedServer;
extern CORBA_unsigned_long test_DerivedServer__classid;
# 347 "everything.h"
extern

const struct CORBA_TypeCode_struct TC_test_DerivedServer_struct;







typedef CORBA_Object test_TransientObj;
extern CORBA_unsigned_long test_TransientObj__classid;
# 373 "everything.h"
extern

const struct CORBA_TypeCode_struct TC_test_TransientObj_struct;







typedef CORBA_Object test_ContextServer;
extern CORBA_unsigned_long test_ContextServer__classid;
# 399 "everything.h"
extern

const struct CORBA_TypeCode_struct TC_test_ContextServer_struct;







typedef CORBA_Object test_DeadReferenceObj;
extern CORBA_unsigned_long test_DeadReferenceObj__classid;
# 425 "everything.h"
extern

const struct CORBA_TypeCode_struct TC_test_DeadReferenceObj_struct;







typedef CORBA_Object test_PingPongServer;
extern CORBA_unsigned_long test_PingPongServer__classid;
# 451 "everything.h"
extern

const struct CORBA_TypeCode_struct TC_test_PingPongServer_struct;







typedef CORBA_Object test_LifeCycleServer;
extern CORBA_unsigned_long test_LifeCycleServer__classid;
# 477 "everything.h"
extern

const struct CORBA_TypeCode_struct TC_test_LifeCycleServer_struct;







typedef CORBA_Object test_TestFactory;
extern CORBA_unsigned_long test_TestFactory__classid;
# 503 "everything.h"
extern

const struct CORBA_TypeCode_struct TC_test_TestFactory_struct;
# 589 "everything.h"
typedef struct test_FixedLengthStruct_type test_FixedLengthStruct;
struct test_FixedLengthStruct_type {
CORBA_short a;
};
# 608 "everything.h"
extern

const struct CORBA_TypeCode_struct TC_test_FixedLengthStruct_struct;







typedef test_FixedLengthStruct test_DummyStruct;
# 635 "everything.h"
extern

const struct CORBA_TypeCode_struct TC_test_DummyStruct_struct;







typedef struct test_VariableLengthStruct_type test_VariableLengthStruct;
struct test_VariableLengthStruct_type {
CORBA_string a;
};
# 664 "everything.h"
extern

const struct CORBA_TypeCode_struct TC_test_VariableLengthStruct_struct;







typedef struct test_StructAny_type test_StructAny;
struct test_StructAny_type {
CORBA_string a;
CORBA_any b;
};
# 694 "everything.h"
extern

const struct CORBA_TypeCode_struct TC_test_StructAny_struct;







typedef struct test_CompoundStruct_type test_CompoundStruct;
struct test_CompoundStruct_type {
test_VariableLengthStruct a;
};
# 723 "everything.h"
extern

const struct CORBA_TypeCode_struct TC_test_CompoundStruct_struct;







typedef struct test_ObjectStruct_type test_ObjectStruct;
struct test_ObjectStruct_type {
test_DerivedServer serv;
};
# 752 "everything.h"
extern

const struct CORBA_TypeCode_struct TC_test_ObjectStruct_struct;







typedef struct test_AlignHoleInnerStruct_type test_AlignHoleInnerStruct;
struct test_AlignHoleInnerStruct_type {
CORBA_double a;
CORBA_octet b;
};
# 782 "everything.h"
extern

const struct CORBA_TypeCode_struct TC_test_AlignHoleInnerStruct_struct;







typedef struct test_AlignHoleStruct_type test_AlignHoleStruct;
struct test_AlignHoleStruct_type {
test_AlignHoleInnerStruct a;
CORBA_char b;
};
# 812 "everything.h"
extern

const struct CORBA_TypeCode_struct TC_test_AlignHoleStruct_struct;
# 862 "everything.h"
typedef CORBA_sequence_CORBA_string test_StrSeq;
# 879 "everything.h"
extern

const struct CORBA_TypeCode_struct TC_test_StrSeq_struct;
# 930 "everything.h"
typedef CORBA_sequence_CORBA_string test_AnotherStrSeq;
# 947 "everything.h"
extern

const struct CORBA_TypeCode_struct TC_test_AnotherStrSeq_struct;
# 970 "everything.h"
typedef struct { CORBA_unsigned_long _maximum, _length; test_CompoundStruct* _buffer; CORBA_boolean _release; } CORBA_sequence_test_CompoundStruct;
# 986 "everything.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_test_CompoundStruct_struct;
# 998 "everything.h"
typedef CORBA_sequence_test_CompoundStruct test_BoundedStructSeq;
# 1015 "everything.h"
extern

const struct CORBA_TypeCode_struct TC_test_BoundedStructSeq_struct;
# 1066 "everything.h"
typedef CORBA_sequence_CORBA_long test_BoundedLongSeq;
# 1083 "everything.h"
extern

const struct CORBA_TypeCode_struct TC_test_BoundedLongSeq_struct;
# 1134 "everything.h"
typedef CORBA_sequence_CORBA_long test_LongSeq;
# 1151 "everything.h"
extern

const struct CORBA_TypeCode_struct TC_test_LongSeq_struct;
# 1214 "everything.h"
typedef struct { CORBA_unsigned_long _maximum, _length; CORBA_sequence_CORBA_string* _buffer; CORBA_boolean _release; } CORBA_sequence_CORBA_sequence_CORBA_string;
# 1230 "everything.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_CORBA_sequence_CORBA_string_struct;
# 1254 "everything.h"
typedef CORBA_sequence_CORBA_sequence_CORBA_string CORBA_sequence_test_StrSeq;
# 1270 "everything.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_test_StrSeq_struct;
# 1283 "everything.h"
typedef CORBA_sequence_test_StrSeq test_StrSeqSeq;
# 1300 "everything.h"
extern

const struct CORBA_TypeCode_struct TC_test_StrSeqSeq_struct;
# 1351 "everything.h"
typedef CORBA_sequence_CORBA_any test_AnySeq;
# 1368 "everything.h"
extern

const struct CORBA_TypeCode_struct TC_test_AnySeq_struct;
# 1379 "everything.h"
typedef struct test_StructWithSequenceInIt_type test_StructWithSequenceInIt;
struct test_StructWithSequenceInIt_type {
test_StrSeqSeq theSeq;
};
# 1398 "everything.h"
extern

const struct CORBA_TypeCode_struct TC_test_StructWithSequenceInIt_struct;
# 1434 "everything.h"
typedef enum {
  test_ENUM_IN,
  test_ENUM_INOUT_IN,
  test_ENUM_INOUT_OUT,
  test_ENUM_OUT,
  test_ENUM_RETN
} test_AnEnum;
# 1455 "everything.h"
extern

const struct CORBA_TypeCode_struct TC_test_AnEnum_struct;





typedef test_AnEnum test_DummyEnum;
# 1480 "everything.h"
extern

const struct CORBA_TypeCode_struct TC_test_DummyEnum_struct;
# 1492 "everything.h"
typedef struct test_SimpleException_type test_SimpleException;
struct test_SimpleException_type {
int dummy;
};
# 1511 "everything.h"
extern

const struct CORBA_TypeCode_struct TC_test_SimpleException_struct;
# 1523 "everything.h"
typedef struct test_TestException_type test_TestException;
struct test_TestException_type {
CORBA_string reason;
CORBA_long number;
test_LongSeq aseq;
test_TestFactory factory;
};
# 1545 "everything.h"
extern

const struct CORBA_TypeCode_struct TC_test_TestException_struct;
# 1559 "everything.h"
typedef CORBA_octet test_OctetArray[4];
typedef CORBA_octet test_OctetArray_slice;
# 1575 "everything.h"
extern

const struct CORBA_TypeCode_struct TC_test_OctetArray_struct;







typedef CORBA_long test_LongArray[4];
typedef CORBA_long test_LongArray_slice;
# 1601 "everything.h"
extern

const struct CORBA_TypeCode_struct TC_test_LongArray_struct;







typedef CORBA_string test_StrArray[4];
typedef CORBA_string test_StrArray_slice;
# 1627 "everything.h"
extern

const struct CORBA_TypeCode_struct TC_test_StrArray_struct;







typedef CORBA_string test_StrArrayMultiDimensional[4][3][5];
typedef CORBA_string test_StrArrayMultiDimensional_slice[3][5];
# 1653 "everything.h"
extern

const struct CORBA_TypeCode_struct TC_test_StrArrayMultiDimensional_struct;







typedef test_FixedLengthStruct test_FixedLengthStructArray[4];
typedef test_FixedLengthStruct test_FixedLengthStructArray_slice;
# 1679 "everything.h"
extern

const struct CORBA_TypeCode_struct TC_test_FixedLengthStructArray_struct;







typedef test_VariableLengthStruct test_VariableLengthStructArray[4];
typedef test_VariableLengthStruct test_VariableLengthStructArray_slice;
# 1705 "everything.h"
extern

const struct CORBA_TypeCode_struct TC_test_VariableLengthStructArray_struct;







typedef test_AlignHoleStruct test_AlignHoleStructArray[4];
typedef test_AlignHoleStruct test_AlignHoleStructArray_slice;
# 1731 "everything.h"
extern

const struct CORBA_TypeCode_struct TC_test_AlignHoleStructArray_struct;
# 1899 "everything.h"
typedef CORBA_Object test_C1;
extern CORBA_unsigned_long test_C1__classid;
# 1915 "everything.h"
extern

const struct CORBA_TypeCode_struct TC_test_C1_struct;
# 1949 "everything.h"
typedef struct test_FixedLengthUnion_type test_FixedLengthUnion;
struct test_FixedLengthUnion_type {
CORBA_char _d;
union {
CORBA_long x;
CORBA_char y;
CORBA_boolean z;
test_FixedLengthStruct v;
} _u;
};
# 1973 "everything.h"
extern

const struct CORBA_TypeCode_struct TC_test_FixedLengthUnion_struct;







typedef struct test_VariableLengthUnion_type test_VariableLengthUnion;
struct test_VariableLengthUnion_type {
CORBA_long _d;
union {
CORBA_long x;
CORBA_long w;
CORBA_string y;
CORBA_double j;
CORBA_boolean z;
test_VariableLengthStruct a;
test_StrSeq b;
test_FixedLengthUnion c;
test_StrArray d;
} _u;
};
# 2012 "everything.h"
extern

const struct CORBA_TypeCode_struct TC_test_VariableLengthUnion_struct;







typedef enum {
  test_EnumUnion_red,
  test_EnumUnion_green,
  test_EnumUnion_blue
} test_EnumUnion_Colour;
# 2041 "everything.h"
extern

const struct CORBA_TypeCode_struct TC_test_EnumUnion_Colour_struct;





typedef struct test_EnumUnion_type test_EnumUnion;
struct test_EnumUnion_type {
test_EnumUnion_Colour _d;
union {
CORBA_long x;
CORBA_boolean y;
} _u;
};
# 2071 "everything.h"
extern

const struct CORBA_TypeCode_struct TC_test_EnumUnion_struct;







typedef struct test_BooleanUnion_type test_BooleanUnion;
struct test_BooleanUnion_type {
CORBA_boolean _d;
union {
test_VariableLengthStruct x;
CORBA_string y;
} _u;
};
# 2103 "everything.h"
extern

const struct CORBA_TypeCode_struct TC_test_BooleanUnion_struct;







typedef CORBA_string test_StrArray2[20];
typedef CORBA_string test_StrArray2_slice;
# 2129 "everything.h"
extern

const struct CORBA_TypeCode_struct TC_test_StrArray2_struct;







typedef struct test_ArrayUnion_type test_ArrayUnion;
struct test_ArrayUnion_type {
CORBA_unsigned_short _d;
union {
test_StrArray2 d;
} _u;
};
# 2160 "everything.h"
extern

const struct CORBA_TypeCode_struct TC_test_ArrayUnion_struct;
# 2182 "everything.h"
typedef struct { CORBA_unsigned_long _maximum, _length; test_VariableLengthUnion* _buffer; CORBA_boolean _release; } CORBA_sequence_test_VariableLengthUnion;
# 2198 "everything.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_test_VariableLengthUnion_struct;
# 2210 "everything.h"
typedef CORBA_sequence_test_VariableLengthUnion test_unionSeq;
# 2227 "everything.h"
extern

const struct CORBA_TypeCode_struct TC_test_unionSeq_struct;
# 2238 "everything.h"
typedef test_FixedLengthUnion test_FixedLengthUnionArray[4];
typedef test_FixedLengthUnion test_FixedLengthUnionArray_slice;
# 2254 "everything.h"
extern

const struct CORBA_TypeCode_struct TC_test_FixedLengthUnionArray_struct;
# 2370 "everything.h"
typedef struct {
  void *_private;
test_BasicServer (*getBasicServer)(PortableServer_Servant _servant, CORBA_Environment *ev);
test_StructServer (*getStructServer)(PortableServer_Servant _servant, CORBA_Environment *ev);
CORBA_string (*getStructServerIOR)(PortableServer_Servant _servant, CORBA_Environment *ev);
test_SequenceServer (*getSequenceServer)(PortableServer_Servant _servant, CORBA_Environment *ev);
test_UnionServer (*getUnionServer)(PortableServer_Servant _servant, CORBA_Environment *ev);
test_ArrayServer (*getArrayServer)(PortableServer_Servant _servant, CORBA_Environment *ev);
test_AnyServer (*getAnyServer)(PortableServer_Servant _servant, CORBA_Environment *ev);
test_ContextServer (*getContextServer)(PortableServer_Servant _servant, CORBA_Environment *ev);
void (*segv)(PortableServer_Servant _servant, const CORBA_char * when, CORBA_Environment *ev);
test_BaseServer (*getBaseServer)(PortableServer_Servant _servant, CORBA_Environment *ev);
test_DerivedServer (*getDerivedServer)(PortableServer_Servant _servant, CORBA_Environment *ev);
test_BaseServer (*getDerivedServerAsBaseServer)(PortableServer_Servant _servant, CORBA_Environment *ev);
test_B2 (*getDerivedServerAsB2)(PortableServer_Servant _servant, CORBA_Environment *ev);
test_TransientObj (*createTransientObj)(PortableServer_Servant _servant, CORBA_Environment *ev);
test_DeadReferenceObj (*createDeadReferenceObj)(PortableServer_Servant _servant, CORBA_Environment *ev);
test_PingPongServer (*createPingPongServer)(PortableServer_Servant _servant, CORBA_Environment *ev);
test_LifeCycleServer (*createLifeCycleServer)(PortableServer_Servant _servant, CORBA_Environment *ev);
void (*noOp)(PortableServer_Servant _servant, CORBA_Environment *ev);
} POA_test_TestFactory__epv;
typedef struct {
  PortableServer_ServantBase__epv *_base_epv;
  POA_test_TestFactory__epv *test_TestFactory_epv;
} POA_test_TestFactory__vepv;
typedef struct {
  void *_private;
  POA_test_TestFactory__vepv *vepv;
} POA_test_TestFactory;
extern void POA_test_TestFactory__init(PortableServer_Servant servant, CORBA_Environment *ev);
extern void POA_test_TestFactory__fini(PortableServer_Servant servant, CORBA_Environment *ev);



typedef struct {
  void *_private;
void (*deactivateOnReturn)(PortableServer_Servant _servant, CORBA_Environment *ev);
void (*deactivateUnrefOnReturn)(PortableServer_Servant _servant, CORBA_Environment *ev);
} POA_test_LifeCycleServer__epv;
typedef struct {
  PortableServer_ServantBase__epv *_base_epv;
  POA_test_LifeCycleServer__epv *test_LifeCycleServer_epv;
} POA_test_LifeCycleServer__vepv;
typedef struct {
  void *_private;
  POA_test_LifeCycleServer__vepv *vepv;
} POA_test_LifeCycleServer;
extern void POA_test_LifeCycleServer__init(PortableServer_Servant servant, CORBA_Environment *ev);
extern void POA_test_LifeCycleServer__fini(PortableServer_Servant servant, CORBA_Environment *ev);



typedef struct {
  void *_private;
void (*test)(PortableServer_Servant _servant, CORBA_Environment *ev);
} POA_test_DeadReferenceObj__epv;
typedef struct {
  PortableServer_ServantBase__epv *_base_epv;
  POA_test_DeadReferenceObj__epv *test_DeadReferenceObj_epv;
} POA_test_DeadReferenceObj__vepv;
typedef struct {
  void *_private;
  POA_test_DeadReferenceObj__vepv *vepv;
} POA_test_DeadReferenceObj;
extern void POA_test_DeadReferenceObj__init(PortableServer_Servant servant, CORBA_Environment *ev);
extern void POA_test_DeadReferenceObj__fini(PortableServer_Servant servant, CORBA_Environment *ev);



typedef struct {
  void *_private;
void (*remove)(PortableServer_Servant _servant, CORBA_Environment *ev);
} POA_test_TransientObj__epv;
typedef struct {
  PortableServer_ServantBase__epv *_base_epv;
  POA_test_TransientObj__epv *test_TransientObj_epv;
} POA_test_TransientObj__vepv;
typedef struct {
  void *_private;
  POA_test_TransientObj__vepv *vepv;
} POA_test_TransientObj;
extern void POA_test_TransientObj__init(PortableServer_Servant servant, CORBA_Environment *ev);
extern void POA_test_TransientObj__fini(PortableServer_Servant servant, CORBA_Environment *ev);



typedef struct {
  void *_private;
test_StrSeq* (*opStrSeq)(PortableServer_Servant _servant, const test_StrSeq* inArg, test_StrSeq* inoutArg, test_StrSeq** outArg, CORBA_Environment *ev);
test_BoundedStructSeq* (*opBoundedStructSeq)(PortableServer_Servant _servant, const test_BoundedStructSeq* inArg, test_BoundedStructSeq* inoutArg, test_BoundedStructSeq** outArg, CORBA_Environment *ev);
test_LongSeq* (*opMassiveSeq)(PortableServer_Servant _servant, CORBA_Environment *ev);
test_AnySeq* (*opAnySeq)(PortableServer_Servant _servant, CORBA_Environment *ev);
} POA_test_SequenceServer__epv;
typedef struct {
  PortableServer_ServantBase__epv *_base_epv;
  POA_test_SequenceServer__epv *test_SequenceServer_epv;
} POA_test_SequenceServer__vepv;
typedef struct {
  void *_private;
  POA_test_SequenceServer__vepv *vepv;
} POA_test_SequenceServer;
extern void POA_test_SequenceServer__init(PortableServer_Servant servant, CORBA_Environment *ev);
extern void POA_test_SequenceServer__fini(PortableServer_Servant servant, CORBA_Environment *ev);



typedef struct {
  void *_private;
test_LongArray_slice* (*opLongArray)(PortableServer_Servant _servant, const test_LongArray inArg, test_LongArray inoutArg, test_LongArray outArg, CORBA_Environment *ev);
test_OctetArray_slice* (*opOctetArray)(PortableServer_Servant _servant, const test_OctetArray inArg, test_OctetArray inoutArg, test_OctetArray outArg, CORBA_Environment *ev);
test_FixedLengthStructArray_slice* (*opFixedLengthStructArray)(PortableServer_Servant _servant, const test_FixedLengthStructArray inArg, test_FixedLengthStructArray inoutArg, test_FixedLengthStructArray outArg, CORBA_Environment *ev);
test_StrArray_slice* (*opStrArray)(PortableServer_Servant _servant, const test_StrArray inArg, test_StrArray inoutArg, test_StrArray_slice** outArg, CORBA_Environment *ev);
test_AlignHoleStructArray_slice* (*opAlignHoleStructArray)(PortableServer_Servant _servant, const test_AlignHoleStructArray inArg, test_AlignHoleStructArray inoutArg, test_AlignHoleStructArray outArg, CORBA_Environment *ev);
} POA_test_ArrayServer__epv;
typedef struct {
  PortableServer_ServantBase__epv *_base_epv;
  POA_test_ArrayServer__epv *test_ArrayServer_epv;
} POA_test_ArrayServer__vepv;
typedef struct {
  void *_private;
  POA_test_ArrayServer__vepv *vepv;
} POA_test_ArrayServer;
extern void POA_test_ArrayServer__init(PortableServer_Servant servant, CORBA_Environment *ev);
extern void POA_test_ArrayServer__fini(PortableServer_Servant servant, CORBA_Environment *ev);



typedef struct {
  void *_private;
CORBA_string (*_get_foo)(PortableServer_Servant _servant, CORBA_Environment *ev);
void (*_set_foo)(PortableServer_Servant _servant, const CORBA_char * value, CORBA_Environment *ev);
CORBA_long (*_get_bah)(PortableServer_Servant _servant, CORBA_Environment *ev);
CORBA_string (*opString)(PortableServer_Servant _servant, const CORBA_char * inArg, CORBA_string* inoutArg, CORBA_string* outArg, CORBA_Environment *ev);
CORBA_long (*opLong)(PortableServer_Servant _servant, const CORBA_long inArg, CORBA_long* inoutArg, CORBA_long* outArg, CORBA_Environment *ev);
CORBA_long_long (*opLongLong)(PortableServer_Servant _servant, const CORBA_long_long inArg, CORBA_long_long* inoutArg, CORBA_long_long* outArg, CORBA_Environment *ev);
CORBA_float (*opFloat)(PortableServer_Servant _servant, const CORBA_float inArg, CORBA_float* inoutArg, CORBA_float* outArg, CORBA_Environment *ev);
CORBA_double (*opDouble)(PortableServer_Servant _servant, const CORBA_double inArg, CORBA_double* inoutArg, CORBA_double* outArg, CORBA_Environment *ev);
CORBA_long_double (*opLongDouble)(PortableServer_Servant _servant, const CORBA_long_double inArg, CORBA_long_double* inoutArg, CORBA_long_double* outArg, CORBA_Environment *ev);
test_AnEnum (*opEnum)(PortableServer_Servant _servant, const test_AnEnum inArg, test_AnEnum* inoutArg, test_AnEnum* outArg, CORBA_Environment *ev);
void (*opException)(PortableServer_Servant _servant, CORBA_Environment *ev);
void (*opOneWay)(PortableServer_Servant _servant, const CORBA_char * inArg, CORBA_Environment *ev);
void (*noImplement)(PortableServer_Servant _servant, CORBA_Environment *ev);
void (*testLargeStringSeq)(PortableServer_Servant _servant, const test_StrSeq* seq, CORBA_Environment *ev);
CORBA_long (*getObjectCount)(PortableServer_Servant _servant, CORBA_Environment *ev);
CORBA_Object (*getObject)(PortableServer_Servant _servant, const CORBA_long which, CORBA_Environment *ev);
void (*testBoolString)(PortableServer_Servant _servant, const CORBA_boolean inBool, const CORBA_char * inArg, CORBA_string* inoutArg, CORBA_Environment *ev);
} POA_test_BasicServer__epv;
typedef struct {
  PortableServer_ServantBase__epv *_base_epv;
  POA_test_BasicServer__epv *test_BasicServer_epv;
} POA_test_BasicServer__vepv;
typedef struct {
  void *_private;
  POA_test_BasicServer__vepv *vepv;
} POA_test_BasicServer;
extern void POA_test_BasicServer__init(PortableServer_Servant servant, CORBA_Environment *ev);
extern void POA_test_BasicServer__fini(PortableServer_Servant servant, CORBA_Environment *ev);



typedef struct {
  void *_private;
test_FixedLengthStruct (*opFixed)(PortableServer_Servant _servant, const test_FixedLengthStruct* inArg, test_FixedLengthStruct* inoutArg, test_FixedLengthStruct* outArg, CORBA_Environment *ev);
test_VariableLengthStruct* (*opVariable)(PortableServer_Servant _servant, const test_VariableLengthStruct* inArg, test_VariableLengthStruct* inoutArg, test_VariableLengthStruct** outArg, CORBA_Environment *ev);
test_CompoundStruct* (*opCompound)(PortableServer_Servant _servant, const test_CompoundStruct* inArg, test_CompoundStruct* inoutArg, test_CompoundStruct** outArg, CORBA_Environment *ev);
test_AlignHoleStruct (*opAlignHole)(PortableServer_Servant _servant, const test_AlignHoleStruct* inArg, test_AlignHoleStruct* inoutArg, test_AlignHoleStruct* outArg, CORBA_Environment *ev);
void (*opObjectStruct)(PortableServer_Servant _servant, const test_ObjectStruct* inArg, CORBA_Environment *ev);
test_StructAny* (*opStructAny)(PortableServer_Servant _servant, CORBA_Environment *ev);
} POA_test_StructServer__epv;
typedef struct {
  PortableServer_ServantBase__epv *_base_epv;
  POA_test_BasicServer__epv *test_BasicServer_epv;
  POA_test_StructServer__epv *test_StructServer_epv;
} POA_test_StructServer__vepv;
typedef struct {
  void *_private;
  POA_test_StructServer__vepv *vepv;
} POA_test_StructServer;
extern void POA_test_StructServer__init(PortableServer_Servant servant, CORBA_Environment *ev);
extern void POA_test_StructServer__fini(PortableServer_Servant servant, CORBA_Environment *ev);



typedef struct {
  void *_private;
CORBA_long (*opPolymorphic)(PortableServer_Servant _servant, CORBA_Environment *ev);
CORBA_string (*_get_attribPolymorphic)(PortableServer_Servant _servant, CORBA_Environment *ev);
void (*_set_attribPolymorphic)(PortableServer_Servant _servant, const CORBA_char * value, CORBA_Environment *ev);
} POA_test_BaseServer__epv;
typedef struct {
  PortableServer_ServantBase__epv *_base_epv;
  POA_test_BaseServer__epv *test_BaseServer_epv;
} POA_test_BaseServer__vepv;
typedef struct {
  void *_private;
  POA_test_BaseServer__vepv *vepv;
} POA_test_BaseServer;
extern void POA_test_BaseServer__init(PortableServer_Servant servant, CORBA_Environment *ev);
extern void POA_test_BaseServer__fini(PortableServer_Servant servant, CORBA_Environment *ev);



typedef struct {
  void *_private;
} POA_test_B1__epv;
typedef struct {
  PortableServer_ServantBase__epv *_base_epv;
  POA_test_BaseServer__epv *test_BaseServer_epv;
  POA_test_B1__epv *test_B1_epv;
} POA_test_B1__vepv;
typedef struct {
  void *_private;
  POA_test_B1__vepv *vepv;
} POA_test_B1;
extern void POA_test_B1__init(PortableServer_Servant servant, CORBA_Environment *ev);
extern void POA_test_B1__fini(PortableServer_Servant servant, CORBA_Environment *ev);



typedef struct {
  void *_private;
} POA_test_B2__epv;
typedef struct {
  PortableServer_ServantBase__epv *_base_epv;
  POA_test_BaseServer__epv *test_BaseServer_epv;
  POA_test_B2__epv *test_B2_epv;
} POA_test_B2__vepv;
typedef struct {
  void *_private;
  POA_test_B2__vepv *vepv;
} POA_test_B2;
extern void POA_test_B2__init(PortableServer_Servant servant, CORBA_Environment *ev);
extern void POA_test_B2__fini(PortableServer_Servant servant, CORBA_Environment *ev);



typedef struct {
  void *_private;
} POA_test_C1__epv;
typedef struct {
  PortableServer_ServantBase__epv *_base_epv;
  POA_test_BaseServer__epv *test_BaseServer_epv;
  POA_test_B1__epv *test_B1_epv;
  POA_test_B2__epv *test_B2_epv;
  POA_test_C1__epv *test_C1_epv;
} POA_test_C1__vepv;
typedef struct {
  void *_private;
  POA_test_C1__vepv *vepv;
} POA_test_C1;
extern void POA_test_C1__init(PortableServer_Servant servant, CORBA_Environment *ev);
extern void POA_test_C1__fini(PortableServer_Servant servant, CORBA_Environment *ev);



typedef struct {
  void *_private;
} POA_test_DerivedServer__epv;
typedef struct {
  PortableServer_ServantBase__epv *_base_epv;
  POA_test_BaseServer__epv *test_BaseServer_epv;
  POA_test_B1__epv *test_B1_epv;
  POA_test_B2__epv *test_B2_epv;
  POA_test_C1__epv *test_C1_epv;
  POA_test_DerivedServer__epv *test_DerivedServer_epv;
} POA_test_DerivedServer__vepv;
typedef struct {
  void *_private;
  POA_test_DerivedServer__vepv *vepv;
} POA_test_DerivedServer;
extern void POA_test_DerivedServer__init(PortableServer_Servant servant, CORBA_Environment *ev);
extern void POA_test_DerivedServer__fini(PortableServer_Servant servant, CORBA_Environment *ev);



typedef struct {
  void *_private;
test_FixedLengthUnion (*opFixed)(PortableServer_Servant _servant, const test_FixedLengthUnion* inArg, test_FixedLengthUnion* inoutArg, test_FixedLengthUnion* outArg, CORBA_Environment *ev);
test_VariableLengthUnion* (*opVariable)(PortableServer_Servant _servant, const test_VariableLengthUnion* inArg, test_VariableLengthUnion* inoutArg, test_VariableLengthUnion** outArg, CORBA_Environment *ev);
test_EnumUnion (*opMisc)(PortableServer_Servant _servant, const test_unionSeq* inSeq, const test_BooleanUnion* inArg, test_ArrayUnion** outArg, CORBA_Environment *ev);
test_FixedLengthUnionArray_slice* (*opFixedLengthUnionArray)(PortableServer_Servant _servant, const test_FixedLengthUnionArray inArg, test_FixedLengthUnionArray inoutArg, test_FixedLengthUnionArray outArg, CORBA_Environment *ev);
} POA_test_UnionServer__epv;
typedef struct {
  PortableServer_ServantBase__epv *_base_epv;
  POA_test_UnionServer__epv *test_UnionServer_epv;
} POA_test_UnionServer__vepv;
typedef struct {
  void *_private;
  POA_test_UnionServer__vepv *vepv;
} POA_test_UnionServer;
extern void POA_test_UnionServer__init(PortableServer_Servant servant, CORBA_Environment *ev);
extern void POA_test_UnionServer__fini(PortableServer_Servant servant, CORBA_Environment *ev);



typedef struct {
  void *_private;
CORBA_any* (*opAnyStrSeq)(PortableServer_Servant _servant, CORBA_Environment *ev);
CORBA_any* (*opAnyLong)(PortableServer_Servant _servant, const CORBA_any* inArg, CORBA_any* inoutArg, CORBA_any** outArg, CORBA_Environment *ev);
CORBA_any* (*opAnyString)(PortableServer_Servant _servant, const CORBA_any* inArg, CORBA_any* inoutArg, CORBA_any** outArg, CORBA_Environment *ev);
CORBA_any* (*opAnyStruct)(PortableServer_Servant _servant, const CORBA_any* inArg, CORBA_any* inoutArg, CORBA_any** outArg, CORBA_Environment *ev);
CORBA_TypeCode (*opTypeCode)(PortableServer_Servant _servant, const CORBA_TypeCode inArg, CORBA_TypeCode* inoutArg, CORBA_TypeCode* outArg, CORBA_Environment *ev);
} POA_test_AnyServer__epv;
typedef struct {
  PortableServer_ServantBase__epv *_base_epv;
  POA_test_AnyServer__epv *test_AnyServer_epv;
} POA_test_AnyServer__vepv;
typedef struct {
  void *_private;
  POA_test_AnyServer__vepv *vepv;
} POA_test_AnyServer;
extern void POA_test_AnyServer__init(PortableServer_Servant servant, CORBA_Environment *ev);
extern void POA_test_AnyServer__fini(PortableServer_Servant servant, CORBA_Environment *ev);



typedef struct {
  void *_private;
CORBA_Object (*opWithContext)(PortableServer_Servant _servant, const CORBA_Object inArg, CORBA_Object* inoutArg, CORBA_Object* outArg, CORBA_Context _ctx, CORBA_Environment *ev);
} POA_test_ContextServer__epv;
typedef struct {
  PortableServer_ServantBase__epv *_base_epv;
  POA_test_ContextServer__epv *test_ContextServer_epv;
} POA_test_ContextServer__vepv;
typedef struct {
  void *_private;
  POA_test_ContextServer__vepv *vepv;
} POA_test_ContextServer;
extern void POA_test_ContextServer__init(PortableServer_Servant servant, CORBA_Environment *ev);
extern void POA_test_ContextServer__fini(PortableServer_Servant servant, CORBA_Environment *ev);



typedef struct {
  void *_private;
void (*opSleep)(PortableServer_Servant _servant, const CORBA_char * large_string, CORBA_Environment *ev);
void (*opOneWay)(PortableServer_Servant _servant, const CORBA_long l, CORBA_Environment *ev);
void (*opOneWayCallback)(PortableServer_Servant _servant, const test_PingPongServer obj, CORBA_Environment *ev);
void (*opRoundTrip)(PortableServer_Servant _servant, CORBA_Environment *ev);
CORBA_long (*pingPong)(PortableServer_Servant _servant, const test_PingPongServer replyTo, const CORBA_long idx, CORBA_Environment *ev);
void (*set)(PortableServer_Servant _servant, const test_PingPongServer reg, const CORBA_char * name, CORBA_Environment *ev);
CORBA_Object (*get)(PortableServer_Servant _servant, const CORBA_char * name, CORBA_Environment *ev);
} POA_test_PingPongServer__epv;
typedef struct {
  PortableServer_ServantBase__epv *_base_epv;
  POA_test_PingPongServer__epv *test_PingPongServer_epv;
} POA_test_PingPongServer__vepv;
typedef struct {
  void *_private;
  POA_test_PingPongServer__vepv *vepv;
} POA_test_PingPongServer;
extern void POA_test_PingPongServer__init(PortableServer_Servant servant, CORBA_Environment *ev);
extern void POA_test_PingPongServer__fini(PortableServer_Servant servant, CORBA_Environment *ev);



void _ORBIT_skel_small_test_TestFactory_getBasicServer(POA_test_TestFactory *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, test_BasicServer (*_impl_getBasicServer)(PortableServer_Servant _servant, CORBA_Environment *ev));
void _ORBIT_skel_small_test_TestFactory_getStructServer(POA_test_TestFactory *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, test_StructServer (*_impl_getStructServer)(PortableServer_Servant _servant, CORBA_Environment *ev));
void _ORBIT_skel_small_test_TestFactory_getStructServerIOR(POA_test_TestFactory *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, CORBA_string (*_impl_getStructServerIOR)(PortableServer_Servant _servant, CORBA_Environment *ev));
void _ORBIT_skel_small_test_TestFactory_getSequenceServer(POA_test_TestFactory *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, test_SequenceServer (*_impl_getSequenceServer)(PortableServer_Servant _servant, CORBA_Environment *ev));
void _ORBIT_skel_small_test_TestFactory_getUnionServer(POA_test_TestFactory *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, test_UnionServer (*_impl_getUnionServer)(PortableServer_Servant _servant, CORBA_Environment *ev));
void _ORBIT_skel_small_test_TestFactory_getArrayServer(POA_test_TestFactory *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, test_ArrayServer (*_impl_getArrayServer)(PortableServer_Servant _servant, CORBA_Environment *ev));
void _ORBIT_skel_small_test_TestFactory_getAnyServer(POA_test_TestFactory *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, test_AnyServer (*_impl_getAnyServer)(PortableServer_Servant _servant, CORBA_Environment *ev));
void _ORBIT_skel_small_test_TestFactory_getContextServer(POA_test_TestFactory *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, test_ContextServer (*_impl_getContextServer)(PortableServer_Servant _servant, CORBA_Environment *ev));
void _ORBIT_skel_small_test_TestFactory_segv(POA_test_TestFactory *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, void (*_impl_segv)(PortableServer_Servant _servant, const CORBA_char * when, CORBA_Environment *ev));
void _ORBIT_skel_small_test_TestFactory_getBaseServer(POA_test_TestFactory *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, test_BaseServer (*_impl_getBaseServer)(PortableServer_Servant _servant, CORBA_Environment *ev));
void _ORBIT_skel_small_test_TestFactory_getDerivedServer(POA_test_TestFactory *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, test_DerivedServer (*_impl_getDerivedServer)(PortableServer_Servant _servant, CORBA_Environment *ev));
void _ORBIT_skel_small_test_TestFactory_getDerivedServerAsBaseServer(POA_test_TestFactory *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, test_BaseServer (*_impl_getDerivedServerAsBaseServer)(PortableServer_Servant _servant, CORBA_Environment *ev));
void _ORBIT_skel_small_test_TestFactory_getDerivedServerAsB2(POA_test_TestFactory *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, test_B2 (*_impl_getDerivedServerAsB2)(PortableServer_Servant _servant, CORBA_Environment *ev));
void _ORBIT_skel_small_test_TestFactory_createTransientObj(POA_test_TestFactory *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, test_TransientObj (*_impl_createTransientObj)(PortableServer_Servant _servant, CORBA_Environment *ev));
void _ORBIT_skel_small_test_TestFactory_createDeadReferenceObj(POA_test_TestFactory *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, test_DeadReferenceObj (*_impl_createDeadReferenceObj)(PortableServer_Servant _servant, CORBA_Environment *ev));
void _ORBIT_skel_small_test_TestFactory_createPingPongServer(POA_test_TestFactory *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, test_PingPongServer (*_impl_createPingPongServer)(PortableServer_Servant _servant, CORBA_Environment *ev));
void _ORBIT_skel_small_test_TestFactory_createLifeCycleServer(POA_test_TestFactory *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, test_LifeCycleServer (*_impl_createLifeCycleServer)(PortableServer_Servant _servant, CORBA_Environment *ev));
void _ORBIT_skel_small_test_TestFactory_noOp(POA_test_TestFactory *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, void (*_impl_noOp)(PortableServer_Servant _servant, CORBA_Environment *ev));
void _ORBIT_skel_small_test_LifeCycleServer_deactivateOnReturn(POA_test_LifeCycleServer *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, void (*_impl_deactivateOnReturn)(PortableServer_Servant _servant, CORBA_Environment *ev));
void _ORBIT_skel_small_test_LifeCycleServer_deactivateUnrefOnReturn(POA_test_LifeCycleServer *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, void (*_impl_deactivateUnrefOnReturn)(PortableServer_Servant _servant, CORBA_Environment *ev));
void _ORBIT_skel_small_test_DeadReferenceObj_test(POA_test_DeadReferenceObj *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, void (*_impl_test)(PortableServer_Servant _servant, CORBA_Environment *ev));
void _ORBIT_skel_small_test_TransientObj_remove(POA_test_TransientObj *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, void (*_impl_remove)(PortableServer_Servant _servant, CORBA_Environment *ev));
void _ORBIT_skel_small_test_SequenceServer_opStrSeq(POA_test_SequenceServer *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, test_StrSeq* (*_impl_opStrSeq)(PortableServer_Servant _servant, const test_StrSeq* inArg, test_StrSeq* inoutArg, test_StrSeq** outArg, CORBA_Environment *ev));
void _ORBIT_skel_small_test_SequenceServer_opBoundedStructSeq(POA_test_SequenceServer *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, test_BoundedStructSeq* (*_impl_opBoundedStructSeq)(PortableServer_Servant _servant, const test_BoundedStructSeq* inArg, test_BoundedStructSeq* inoutArg, test_BoundedStructSeq** outArg, CORBA_Environment *ev));
void _ORBIT_skel_small_test_SequenceServer_opMassiveSeq(POA_test_SequenceServer *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, test_LongSeq* (*_impl_opMassiveSeq)(PortableServer_Servant _servant, CORBA_Environment *ev));
void _ORBIT_skel_small_test_SequenceServer_opAnySeq(POA_test_SequenceServer *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, test_AnySeq* (*_impl_opAnySeq)(PortableServer_Servant _servant, CORBA_Environment *ev));
void _ORBIT_skel_small_test_ArrayServer_opLongArray(POA_test_ArrayServer *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, test_LongArray_slice* (*_impl_opLongArray)(PortableServer_Servant _servant, const test_LongArray inArg, test_LongArray inoutArg, test_LongArray outArg, CORBA_Environment *ev));
void _ORBIT_skel_small_test_ArrayServer_opOctetArray(POA_test_ArrayServer *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, test_OctetArray_slice* (*_impl_opOctetArray)(PortableServer_Servant _servant, const test_OctetArray inArg, test_OctetArray inoutArg, test_OctetArray outArg, CORBA_Environment *ev));
void _ORBIT_skel_small_test_ArrayServer_opFixedLengthStructArray(POA_test_ArrayServer *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, test_FixedLengthStructArray_slice* (*_impl_opFixedLengthStructArray)(PortableServer_Servant _servant, const test_FixedLengthStructArray inArg, test_FixedLengthStructArray inoutArg, test_FixedLengthStructArray outArg, CORBA_Environment *ev));
void _ORBIT_skel_small_test_ArrayServer_opStrArray(POA_test_ArrayServer *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, test_StrArray_slice* (*_impl_opStrArray)(PortableServer_Servant _servant, const test_StrArray inArg, test_StrArray inoutArg, test_StrArray_slice** outArg, CORBA_Environment *ev));
void _ORBIT_skel_small_test_ArrayServer_opAlignHoleStructArray(POA_test_ArrayServer *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, test_AlignHoleStructArray_slice* (*_impl_opAlignHoleStructArray)(PortableServer_Servant _servant, const test_AlignHoleStructArray inArg, test_AlignHoleStructArray inoutArg, test_AlignHoleStructArray outArg, CORBA_Environment *ev));
void _ORBIT_skel_small_test_BasicServer__get_foo(POA_test_BasicServer *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, CORBA_string (*_impl__get_foo)(PortableServer_Servant _servant, CORBA_Environment *ev));
void _ORBIT_skel_small_test_BasicServer__set_foo(POA_test_BasicServer *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, void (*_impl__set_foo)(PortableServer_Servant _servant, const CORBA_char * value, CORBA_Environment *ev));
void _ORBIT_skel_small_test_BasicServer__get_bah(POA_test_BasicServer *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, CORBA_long (*_impl__get_bah)(PortableServer_Servant _servant, CORBA_Environment *ev));
void _ORBIT_skel_small_test_BasicServer_opString(POA_test_BasicServer *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, CORBA_string (*_impl_opString)(PortableServer_Servant _servant, const CORBA_char * inArg, CORBA_string* inoutArg, CORBA_string* outArg, CORBA_Environment *ev));
void _ORBIT_skel_small_test_BasicServer_opLong(POA_test_BasicServer *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, CORBA_long (*_impl_opLong)(PortableServer_Servant _servant, const CORBA_long inArg, CORBA_long* inoutArg, CORBA_long* outArg, CORBA_Environment *ev));
void _ORBIT_skel_small_test_BasicServer_opLongLong(POA_test_BasicServer *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, CORBA_long_long (*_impl_opLongLong)(PortableServer_Servant _servant, const CORBA_long_long inArg, CORBA_long_long* inoutArg, CORBA_long_long* outArg, CORBA_Environment *ev));
void _ORBIT_skel_small_test_BasicServer_opFloat(POA_test_BasicServer *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, CORBA_float (*_impl_opFloat)(PortableServer_Servant _servant, const CORBA_float inArg, CORBA_float* inoutArg, CORBA_float* outArg, CORBA_Environment *ev));
void _ORBIT_skel_small_test_BasicServer_opDouble(POA_test_BasicServer *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, CORBA_double (*_impl_opDouble)(PortableServer_Servant _servant, const CORBA_double inArg, CORBA_double* inoutArg, CORBA_double* outArg, CORBA_Environment *ev));
void _ORBIT_skel_small_test_BasicServer_opLongDouble(POA_test_BasicServer *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, CORBA_long_double (*_impl_opLongDouble)(PortableServer_Servant _servant, const CORBA_long_double inArg, CORBA_long_double* inoutArg, CORBA_long_double* outArg, CORBA_Environment *ev));
void _ORBIT_skel_small_test_BasicServer_opEnum(POA_test_BasicServer *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, test_AnEnum (*_impl_opEnum)(PortableServer_Servant _servant, const test_AnEnum inArg, test_AnEnum* inoutArg, test_AnEnum* outArg, CORBA_Environment *ev));
void _ORBIT_skel_small_test_BasicServer_opException(POA_test_BasicServer *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, void (*_impl_opException)(PortableServer_Servant _servant, CORBA_Environment *ev));
void _ORBIT_skel_small_test_BasicServer_opOneWay(POA_test_BasicServer *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, void (*_impl_opOneWay)(PortableServer_Servant _servant, const CORBA_char * inArg, CORBA_Environment *ev));
void _ORBIT_skel_small_test_BasicServer_noImplement(POA_test_BasicServer *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, void (*_impl_noImplement)(PortableServer_Servant _servant, CORBA_Environment *ev));
void _ORBIT_skel_small_test_BasicServer_testLargeStringSeq(POA_test_BasicServer *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, void (*_impl_testLargeStringSeq)(PortableServer_Servant _servant, const test_StrSeq* seq, CORBA_Environment *ev));
void _ORBIT_skel_small_test_BasicServer_getObjectCount(POA_test_BasicServer *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, CORBA_long (*_impl_getObjectCount)(PortableServer_Servant _servant, CORBA_Environment *ev));
void _ORBIT_skel_small_test_BasicServer_getObject(POA_test_BasicServer *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, CORBA_Object (*_impl_getObject)(PortableServer_Servant _servant, const CORBA_long which, CORBA_Environment *ev));
void _ORBIT_skel_small_test_BasicServer_testBoolString(POA_test_BasicServer *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, void (*_impl_testBoolString)(PortableServer_Servant _servant, const CORBA_boolean inBool, const CORBA_char * inArg, CORBA_string* inoutArg, CORBA_Environment *ev));
void _ORBIT_skel_small_test_StructServer_opFixed(POA_test_StructServer *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, test_FixedLengthStruct (*_impl_opFixed)(PortableServer_Servant _servant, const test_FixedLengthStruct* inArg, test_FixedLengthStruct* inoutArg, test_FixedLengthStruct* outArg, CORBA_Environment *ev));
void _ORBIT_skel_small_test_StructServer_opVariable(POA_test_StructServer *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, test_VariableLengthStruct* (*_impl_opVariable)(PortableServer_Servant _servant, const test_VariableLengthStruct* inArg, test_VariableLengthStruct* inoutArg, test_VariableLengthStruct** outArg, CORBA_Environment *ev));
void _ORBIT_skel_small_test_StructServer_opCompound(POA_test_StructServer *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, test_CompoundStruct* (*_impl_opCompound)(PortableServer_Servant _servant, const test_CompoundStruct* inArg, test_CompoundStruct* inoutArg, test_CompoundStruct** outArg, CORBA_Environment *ev));
void _ORBIT_skel_small_test_StructServer_opAlignHole(POA_test_StructServer *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, test_AlignHoleStruct (*_impl_opAlignHole)(PortableServer_Servant _servant, const test_AlignHoleStruct* inArg, test_AlignHoleStruct* inoutArg, test_AlignHoleStruct* outArg, CORBA_Environment *ev));
void _ORBIT_skel_small_test_StructServer_opObjectStruct(POA_test_StructServer *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, void (*_impl_opObjectStruct)(PortableServer_Servant _servant, const test_ObjectStruct* inArg, CORBA_Environment *ev));
void _ORBIT_skel_small_test_StructServer_opStructAny(POA_test_StructServer *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, test_StructAny* (*_impl_opStructAny)(PortableServer_Servant _servant, CORBA_Environment *ev));
void _ORBIT_skel_small_test_BaseServer_opPolymorphic(POA_test_BaseServer *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, CORBA_long (*_impl_opPolymorphic)(PortableServer_Servant _servant, CORBA_Environment *ev));
void _ORBIT_skel_small_test_BaseServer__get_attribPolymorphic(POA_test_BaseServer *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, CORBA_string (*_impl__get_attribPolymorphic)(PortableServer_Servant _servant, CORBA_Environment *ev));
void _ORBIT_skel_small_test_BaseServer__set_attribPolymorphic(POA_test_BaseServer *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, void (*_impl__set_attribPolymorphic)(PortableServer_Servant _servant, const CORBA_char * value, CORBA_Environment *ev));
void _ORBIT_skel_small_test_UnionServer_opFixed(POA_test_UnionServer *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, test_FixedLengthUnion (*_impl_opFixed)(PortableServer_Servant _servant, const test_FixedLengthUnion* inArg, test_FixedLengthUnion* inoutArg, test_FixedLengthUnion* outArg, CORBA_Environment *ev));
void _ORBIT_skel_small_test_UnionServer_opVariable(POA_test_UnionServer *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, test_VariableLengthUnion* (*_impl_opVariable)(PortableServer_Servant _servant, const test_VariableLengthUnion* inArg, test_VariableLengthUnion* inoutArg, test_VariableLengthUnion** outArg, CORBA_Environment *ev));
void _ORBIT_skel_small_test_UnionServer_opMisc(POA_test_UnionServer *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, test_EnumUnion (*_impl_opMisc)(PortableServer_Servant _servant, const test_unionSeq* inSeq, const test_BooleanUnion* inArg, test_ArrayUnion** outArg, CORBA_Environment *ev));
void _ORBIT_skel_small_test_UnionServer_opFixedLengthUnionArray(POA_test_UnionServer *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, test_FixedLengthUnionArray_slice* (*_impl_opFixedLengthUnionArray)(PortableServer_Servant _servant, const test_FixedLengthUnionArray inArg, test_FixedLengthUnionArray inoutArg, test_FixedLengthUnionArray outArg, CORBA_Environment *ev));
void _ORBIT_skel_small_test_AnyServer_opAnyStrSeq(POA_test_AnyServer *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, CORBA_any* (*_impl_opAnyStrSeq)(PortableServer_Servant _servant, CORBA_Environment *ev));
void _ORBIT_skel_small_test_AnyServer_opAnyLong(POA_test_AnyServer *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, CORBA_any* (*_impl_opAnyLong)(PortableServer_Servant _servant, const CORBA_any* inArg, CORBA_any* inoutArg, CORBA_any** outArg, CORBA_Environment *ev));
void _ORBIT_skel_small_test_AnyServer_opAnyString(POA_test_AnyServer *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, CORBA_any* (*_impl_opAnyString)(PortableServer_Servant _servant, const CORBA_any* inArg, CORBA_any* inoutArg, CORBA_any** outArg, CORBA_Environment *ev));
void _ORBIT_skel_small_test_AnyServer_opAnyStruct(POA_test_AnyServer *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, CORBA_any* (*_impl_opAnyStruct)(PortableServer_Servant _servant, const CORBA_any* inArg, CORBA_any* inoutArg, CORBA_any** outArg, CORBA_Environment *ev));
void _ORBIT_skel_small_test_AnyServer_opTypeCode(POA_test_AnyServer *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, CORBA_TypeCode (*_impl_opTypeCode)(PortableServer_Servant _servant, const CORBA_TypeCode inArg, CORBA_TypeCode* inoutArg, CORBA_TypeCode* outArg, CORBA_Environment *ev));
void _ORBIT_skel_small_test_ContextServer_opWithContext(POA_test_ContextServer *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, CORBA_Object (*_impl_opWithContext)(PortableServer_Servant _servant, const CORBA_Object inArg, CORBA_Object* inoutArg, CORBA_Object* outArg, CORBA_Context _ctx, CORBA_Environment *ev));
void _ORBIT_skel_small_test_PingPongServer_opSleep(POA_test_PingPongServer *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, void (*_impl_opSleep)(PortableServer_Servant _servant, const CORBA_char * large_string, CORBA_Environment *ev));
void _ORBIT_skel_small_test_PingPongServer_opOneWay(POA_test_PingPongServer *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, void (*_impl_opOneWay)(PortableServer_Servant _servant, const CORBA_long l, CORBA_Environment *ev));
void _ORBIT_skel_small_test_PingPongServer_opOneWayCallback(POA_test_PingPongServer *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, void (*_impl_opOneWayCallback)(PortableServer_Servant _servant, const test_PingPongServer obj, CORBA_Environment *ev));
void _ORBIT_skel_small_test_PingPongServer_opRoundTrip(POA_test_PingPongServer *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, void (*_impl_opRoundTrip)(PortableServer_Servant _servant, CORBA_Environment *ev));
void _ORBIT_skel_small_test_PingPongServer_pingPong(POA_test_PingPongServer *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, CORBA_long (*_impl_pingPong)(PortableServer_Servant _servant, const test_PingPongServer replyTo, const CORBA_long idx, CORBA_Environment *ev));
void _ORBIT_skel_small_test_PingPongServer_set(POA_test_PingPongServer *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, void (*_impl_set)(PortableServer_Servant _servant, const test_PingPongServer reg, const CORBA_char * name, CORBA_Environment *ev));
void _ORBIT_skel_small_test_PingPongServer_get(POA_test_PingPongServer *_ORBIT_servant, gpointer _ORBIT_retval, gpointer *_ORBIT_args, CORBA_Context ctx,CORBA_Environment *ev, CORBA_Object (*_impl_get)(PortableServer_Servant _servant, const CORBA_char * name, CORBA_Environment *ev));


test_BasicServer test_TestFactory_getBasicServer(test_TestFactory _obj, CORBA_Environment *ev);
test_StructServer test_TestFactory_getStructServer(test_TestFactory _obj, CORBA_Environment *ev);
CORBA_string test_TestFactory_getStructServerIOR(test_TestFactory _obj, CORBA_Environment *ev);
test_SequenceServer test_TestFactory_getSequenceServer(test_TestFactory _obj, CORBA_Environment *ev);
test_UnionServer test_TestFactory_getUnionServer(test_TestFactory _obj, CORBA_Environment *ev);
test_ArrayServer test_TestFactory_getArrayServer(test_TestFactory _obj, CORBA_Environment *ev);
test_AnyServer test_TestFactory_getAnyServer(test_TestFactory _obj, CORBA_Environment *ev);
test_ContextServer test_TestFactory_getContextServer(test_TestFactory _obj, CORBA_Environment *ev);
void test_TestFactory_segv(test_TestFactory _obj, const CORBA_char * when, CORBA_Environment *ev);
test_BaseServer test_TestFactory_getBaseServer(test_TestFactory _obj, CORBA_Environment *ev);
test_DerivedServer test_TestFactory_getDerivedServer(test_TestFactory _obj, CORBA_Environment *ev);
test_BaseServer test_TestFactory_getDerivedServerAsBaseServer(test_TestFactory _obj, CORBA_Environment *ev);
test_B2 test_TestFactory_getDerivedServerAsB2(test_TestFactory _obj, CORBA_Environment *ev);
test_TransientObj test_TestFactory_createTransientObj(test_TestFactory _obj, CORBA_Environment *ev);
test_DeadReferenceObj test_TestFactory_createDeadReferenceObj(test_TestFactory _obj, CORBA_Environment *ev);
test_PingPongServer test_TestFactory_createPingPongServer(test_TestFactory _obj, CORBA_Environment *ev);
test_LifeCycleServer test_TestFactory_createLifeCycleServer(test_TestFactory _obj, CORBA_Environment *ev);
void test_TestFactory_noOp(test_TestFactory _obj, CORBA_Environment *ev);
void test_LifeCycleServer_deactivateOnReturn(test_LifeCycleServer _obj, CORBA_Environment *ev);
void test_LifeCycleServer_deactivateUnrefOnReturn(test_LifeCycleServer _obj, CORBA_Environment *ev);
void test_DeadReferenceObj_test(test_DeadReferenceObj _obj, CORBA_Environment *ev);
void test_TransientObj_remove(test_TransientObj _obj, CORBA_Environment *ev);
test_StrSeq* test_SequenceServer_opStrSeq(test_SequenceServer _obj, const test_StrSeq* inArg, test_StrSeq* inoutArg, test_StrSeq** outArg, CORBA_Environment *ev);
test_BoundedStructSeq* test_SequenceServer_opBoundedStructSeq(test_SequenceServer _obj, const test_BoundedStructSeq* inArg, test_BoundedStructSeq* inoutArg, test_BoundedStructSeq** outArg, CORBA_Environment *ev);
test_LongSeq* test_SequenceServer_opMassiveSeq(test_SequenceServer _obj, CORBA_Environment *ev);
test_AnySeq* test_SequenceServer_opAnySeq(test_SequenceServer _obj, CORBA_Environment *ev);
test_LongArray_slice* test_ArrayServer_opLongArray(test_ArrayServer _obj, const test_LongArray inArg, test_LongArray inoutArg, test_LongArray outArg, CORBA_Environment *ev);
test_OctetArray_slice* test_ArrayServer_opOctetArray(test_ArrayServer _obj, const test_OctetArray inArg, test_OctetArray inoutArg, test_OctetArray outArg, CORBA_Environment *ev);
test_FixedLengthStructArray_slice* test_ArrayServer_opFixedLengthStructArray(test_ArrayServer _obj, const test_FixedLengthStructArray inArg, test_FixedLengthStructArray inoutArg, test_FixedLengthStructArray outArg, CORBA_Environment *ev);
test_StrArray_slice* test_ArrayServer_opStrArray(test_ArrayServer _obj, const test_StrArray inArg, test_StrArray inoutArg, test_StrArray_slice** outArg, CORBA_Environment *ev);
test_AlignHoleStructArray_slice* test_ArrayServer_opAlignHoleStructArray(test_ArrayServer _obj, const test_AlignHoleStructArray inArg, test_AlignHoleStructArray inoutArg, test_AlignHoleStructArray outArg, CORBA_Environment *ev);
CORBA_string test_BasicServer__get_foo(test_BasicServer _obj, CORBA_Environment *ev);
void test_BasicServer__set_foo(test_BasicServer _obj, const CORBA_char * value, CORBA_Environment *ev);
CORBA_long test_BasicServer__get_bah(test_BasicServer _obj, CORBA_Environment *ev);
CORBA_string test_BasicServer_opString(test_BasicServer _obj, const CORBA_char * inArg, CORBA_string* inoutArg, CORBA_string* outArg, CORBA_Environment *ev);
CORBA_long test_BasicServer_opLong(test_BasicServer _obj, const CORBA_long inArg, CORBA_long* inoutArg, CORBA_long* outArg, CORBA_Environment *ev);
CORBA_long_long test_BasicServer_opLongLong(test_BasicServer _obj, const CORBA_long_long inArg, CORBA_long_long* inoutArg, CORBA_long_long* outArg, CORBA_Environment *ev);
CORBA_float test_BasicServer_opFloat(test_BasicServer _obj, const CORBA_float inArg, CORBA_float* inoutArg, CORBA_float* outArg, CORBA_Environment *ev);
CORBA_double test_BasicServer_opDouble(test_BasicServer _obj, const CORBA_double inArg, CORBA_double* inoutArg, CORBA_double* outArg, CORBA_Environment *ev);
CORBA_long_double test_BasicServer_opLongDouble(test_BasicServer _obj, const CORBA_long_double inArg, CORBA_long_double* inoutArg, CORBA_long_double* outArg, CORBA_Environment *ev);
test_AnEnum test_BasicServer_opEnum(test_BasicServer _obj, const test_AnEnum inArg, test_AnEnum* inoutArg, test_AnEnum* outArg, CORBA_Environment *ev);
void test_BasicServer_opException(test_BasicServer _obj, CORBA_Environment *ev);
void test_BasicServer_opOneWay(test_BasicServer _obj, const CORBA_char * inArg, CORBA_Environment *ev);
void test_BasicServer_noImplement(test_BasicServer _obj, CORBA_Environment *ev);
void test_BasicServer_testLargeStringSeq(test_BasicServer _obj, const test_StrSeq* seq, CORBA_Environment *ev);
CORBA_long test_BasicServer_getObjectCount(test_BasicServer _obj, CORBA_Environment *ev);
CORBA_Object test_BasicServer_getObject(test_BasicServer _obj, const CORBA_long which, CORBA_Environment *ev);
void test_BasicServer_testBoolString(test_BasicServer _obj, const CORBA_boolean inBool, const CORBA_char * inArg, CORBA_string* inoutArg, CORBA_Environment *ev);
# 2867 "everything.h"
test_FixedLengthStruct test_StructServer_opFixed(test_StructServer _obj, const test_FixedLengthStruct* inArg, test_FixedLengthStruct* inoutArg, test_FixedLengthStruct* outArg, CORBA_Environment *ev);
test_VariableLengthStruct* test_StructServer_opVariable(test_StructServer _obj, const test_VariableLengthStruct* inArg, test_VariableLengthStruct* inoutArg, test_VariableLengthStruct** outArg, CORBA_Environment *ev);
test_CompoundStruct* test_StructServer_opCompound(test_StructServer _obj, const test_CompoundStruct* inArg, test_CompoundStruct* inoutArg, test_CompoundStruct** outArg, CORBA_Environment *ev);
test_AlignHoleStruct test_StructServer_opAlignHole(test_StructServer _obj, const test_AlignHoleStruct* inArg, test_AlignHoleStruct* inoutArg, test_AlignHoleStruct* outArg, CORBA_Environment *ev);
void test_StructServer_opObjectStruct(test_StructServer _obj, const test_ObjectStruct* inArg, CORBA_Environment *ev);
test_StructAny* test_StructServer_opStructAny(test_StructServer _obj, CORBA_Environment *ev);
CORBA_long test_BaseServer_opPolymorphic(test_BaseServer _obj, CORBA_Environment *ev);
CORBA_string test_BaseServer__get_attribPolymorphic(test_BaseServer _obj, CORBA_Environment *ev);
void test_BaseServer__set_attribPolymorphic(test_BaseServer _obj, const CORBA_char * value, CORBA_Environment *ev);
# 2888 "everything.h"
test_FixedLengthUnion test_UnionServer_opFixed(test_UnionServer _obj, const test_FixedLengthUnion* inArg, test_FixedLengthUnion* inoutArg, test_FixedLengthUnion* outArg, CORBA_Environment *ev);
test_VariableLengthUnion* test_UnionServer_opVariable(test_UnionServer _obj, const test_VariableLengthUnion* inArg, test_VariableLengthUnion* inoutArg, test_VariableLengthUnion** outArg, CORBA_Environment *ev);
test_EnumUnion test_UnionServer_opMisc(test_UnionServer _obj, const test_unionSeq* inSeq, const test_BooleanUnion* inArg, test_ArrayUnion** outArg, CORBA_Environment *ev);
test_FixedLengthUnionArray_slice* test_UnionServer_opFixedLengthUnionArray(test_UnionServer _obj, const test_FixedLengthUnionArray inArg, test_FixedLengthUnionArray inoutArg, test_FixedLengthUnionArray outArg, CORBA_Environment *ev);
CORBA_any* test_AnyServer_opAnyStrSeq(test_AnyServer _obj, CORBA_Environment *ev);
CORBA_any* test_AnyServer_opAnyLong(test_AnyServer _obj, const CORBA_any* inArg, CORBA_any* inoutArg, CORBA_any** outArg, CORBA_Environment *ev);
CORBA_any* test_AnyServer_opAnyString(test_AnyServer _obj, const CORBA_any* inArg, CORBA_any* inoutArg, CORBA_any** outArg, CORBA_Environment *ev);
CORBA_any* test_AnyServer_opAnyStruct(test_AnyServer _obj, const CORBA_any* inArg, CORBA_any* inoutArg, CORBA_any** outArg, CORBA_Environment *ev);
CORBA_TypeCode test_AnyServer_opTypeCode(test_AnyServer _obj, const CORBA_TypeCode inArg, CORBA_TypeCode* inoutArg, CORBA_TypeCode* outArg, CORBA_Environment *ev);
CORBA_Object test_ContextServer_opWithContext(test_ContextServer _obj, const CORBA_Object inArg, CORBA_Object* inoutArg, CORBA_Object* outArg, CORBA_Context _ctx, CORBA_Environment *ev);
void test_PingPongServer_opSleep(test_PingPongServer _obj, const CORBA_char * large_string, CORBA_Environment *ev);
void test_PingPongServer_opOneWay(test_PingPongServer _obj, const CORBA_long l, CORBA_Environment *ev);
void test_PingPongServer_opOneWayCallback(test_PingPongServer _obj, const test_PingPongServer obj, CORBA_Environment *ev);
void test_PingPongServer_opRoundTrip(test_PingPongServer _obj, CORBA_Environment *ev);
CORBA_long test_PingPongServer_pingPong(test_PingPongServer _obj, const test_PingPongServer replyTo, const CORBA_long idx, CORBA_Environment *ev);
void test_PingPongServer_set(test_PingPongServer _obj, const test_PingPongServer reg, const CORBA_char * name, CORBA_Environment *ev);
CORBA_Object test_PingPongServer_get(test_PingPongServer _obj, const CORBA_char * name, CORBA_Environment *ev);
# 1 "../../include/orbit/orb-core/orbit-interface.h" 1
# 19 "../../include/orbit/orb-core/orbit-interface.h"
typedef CORBA_long ORBit_IArgFlag;
# 41 "../../include/orbit/orb-core/orbit-interface.h"
extern

const struct CORBA_TypeCode_struct TC_ORBit_IArgFlag_struct;
# 67 "../../include/orbit/orb-core/orbit-interface.h"
typedef struct ORBit_IArg_type ORBit_IArg;
struct ORBit_IArg_type {
CORBA_TypeCode tc;
ORBit_IArgFlag flags;
CORBA_string name;
};
# 93 "../../include/orbit/orb-core/orbit-interface.h"
extern

const struct CORBA_TypeCode_struct TC_ORBit_IArg_struct;
# 120 "../../include/orbit/orb-core/orbit-interface.h"
typedef struct { CORBA_unsigned_long _maximum, _length; ORBit_IArg* _buffer; CORBA_boolean _release; } CORBA_sequence_ORBit_IArg;
# 141 "../../include/orbit/orb-core/orbit-interface.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_ORBit_IArg_struct;
# 153 "../../include/orbit/orb-core/orbit-interface.h"
typedef CORBA_sequence_ORBit_IArg ORBit_IArgs;
# 175 "../../include/orbit/orb-core/orbit-interface.h"
extern

const struct CORBA_TypeCode_struct TC_ORBit_IArgs_struct;
# 203 "../../include/orbit/orb-core/orbit-interface.h"
typedef struct { CORBA_unsigned_long _maximum, _length; CORBA_TypeCode* _buffer; CORBA_boolean _release; } CORBA_sequence_CORBA_TypeCode;
# 224 "../../include/orbit/orb-core/orbit-interface.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_CORBA_TypeCode_struct;
# 236 "../../include/orbit/orb-core/orbit-interface.h"
typedef CORBA_sequence_CORBA_TypeCode ORBit_ITypes;
# 258 "../../include/orbit/orb-core/orbit-interface.h"
extern

const struct CORBA_TypeCode_struct TC_ORBit_ITypes_struct;
# 319 "../../include/orbit/orb-core/orbit-interface.h"
typedef CORBA_sequence_CORBA_string ORBit_IContexts;
# 341 "../../include/orbit/orb-core/orbit-interface.h"
extern

const struct CORBA_TypeCode_struct TC_ORBit_IContexts_struct;
# 352 "../../include/orbit/orb-core/orbit-interface.h"
typedef CORBA_long ORBit_IMethodFlag;
# 374 "../../include/orbit/orb-core/orbit-interface.h"
extern

const struct CORBA_TypeCode_struct TC_ORBit_IMethodFlag_struct;
# 400 "../../include/orbit/orb-core/orbit-interface.h"
typedef struct ORBit_IMethod_type ORBit_IMethod;
struct ORBit_IMethod_type {
ORBit_IArgs arguments;
ORBit_IContexts contexts;
ORBit_ITypes exceptions;
CORBA_TypeCode ret;
CORBA_string name;
CORBA_long name_len;
ORBit_IMethodFlag flags;
};
# 430 "../../include/orbit/orb-core/orbit-interface.h"
extern

const struct CORBA_TypeCode_struct TC_ORBit_IMethod_struct;
# 457 "../../include/orbit/orb-core/orbit-interface.h"
typedef struct { CORBA_unsigned_long _maximum, _length; ORBit_IMethod* _buffer; CORBA_boolean _release; } CORBA_sequence_ORBit_IMethod;
# 478 "../../include/orbit/orb-core/orbit-interface.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_ORBit_IMethod_struct;
# 490 "../../include/orbit/orb-core/orbit-interface.h"
typedef CORBA_sequence_ORBit_IMethod ORBit_IMethods;
# 512 "../../include/orbit/orb-core/orbit-interface.h"
extern

const struct CORBA_TypeCode_struct TC_ORBit_IMethods_struct;
# 523 "../../include/orbit/orb-core/orbit-interface.h"
typedef struct ORBit_IInterface_type ORBit_IInterface;
# 574 "../../include/orbit/orb-core/orbit-interface.h"
struct ORBit_IInterface_type {
CORBA_TypeCode tc;
ORBit_IMethods methods;
CORBA_sequence_CORBA_string base_interfaces;
};
# 599 "../../include/orbit/orb-core/orbit-interface.h"
extern

const struct CORBA_TypeCode_struct TC_ORBit_IInterface_struct;
# 626 "../../include/orbit/orb-core/orbit-interface.h"
typedef struct { CORBA_unsigned_long _maximum, _length; ORBit_IInterface* _buffer; CORBA_boolean _release; } CORBA_sequence_ORBit_IInterface;
# 647 "../../include/orbit/orb-core/orbit-interface.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_ORBit_IInterface_struct;
# 659 "../../include/orbit/orb-core/orbit-interface.h"
typedef CORBA_sequence_ORBit_IInterface ORBit_IInterfaces;
# 681 "../../include/orbit/orb-core/orbit-interface.h"
extern

const struct CORBA_TypeCode_struct TC_ORBit_IInterfaces_struct;
# 694 "../../include/orbit/orb-core/orbit-interface.h"
typedef struct ORBit_NoIInterface_type ORBit_NoIInterface;
struct ORBit_NoIInterface_type {
int dummy;
};
# 718 "../../include/orbit/orb-core/orbit-interface.h"
extern

const struct CORBA_TypeCode_struct TC_ORBit_NoIInterface_struct;
# 738 "../../include/orbit/orb-core/orbit-interface.h"
# 1 "../../include/orbit/orbit.h" 1
# 15 "../../include/orbit/orbit.h"
# 1 "../../include/orbit/GIOP/giop.h" 1






# 1 "../../include/orbit/GIOP/giop-types.h" 1
# 10 "../../include/orbit/GIOP/giop-types.h"
# 1 "../../include/orbit/orb-core/corba-defs.h" 1
# 11 "../../include/orbit/GIOP/giop-types.h" 2
# 1 "../../include/orbit/orb-core/iop-defs.h" 1
# 19 "../../include/orbit/orb-core/iop-defs.h"
typedef CORBA_unsigned_long IOP_ProfileId;
# 34 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_IOP_ProfileId_struct;
# 56 "../../include/orbit/orb-core/iop-defs.h"
typedef struct IOP_TaggedProfile_type IOP_TaggedProfile;
# 93 "../../include/orbit/orb-core/iop-defs.h"
struct IOP_TaggedProfile_type {
IOP_ProfileId tag;
CORBA_sequence_CORBA_octet profile_data;
};
# 110 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_IOP_TaggedProfile_struct;







typedef struct IOP_IOR_type IOP_IOR;
# 133 "../../include/orbit/orb-core/iop-defs.h"
typedef struct { CORBA_unsigned_long _maximum, _length; IOP_TaggedProfile* _buffer; CORBA_boolean _release; } CORBA_sequence_IOP_TaggedProfile;
# 147 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_IOP_TaggedProfile_struct;







struct IOP_IOR_type {
CORBA_string type_id;
CORBA_sequence_IOP_TaggedProfile profiles;
};
# 174 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_IOP_IOR_struct;







typedef CORBA_unsigned_long IOP_ComponentId;
# 199 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_IOP_ComponentId_struct;







typedef struct IOP_TaggedComponent_type IOP_TaggedComponent;
# 246 "../../include/orbit/orb-core/iop-defs.h"
struct IOP_TaggedComponent_type {
IOP_ComponentId tag;
CORBA_sequence_CORBA_octet component_data;
};
# 263 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_IOP_TaggedComponent_struct;
# 283 "../../include/orbit/orb-core/iop-defs.h"
typedef struct { CORBA_unsigned_long _maximum, _length; IOP_TaggedComponent* _buffer; CORBA_boolean _release; } CORBA_sequence_IOP_TaggedComponent;
# 297 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_IOP_TaggedComponent_struct;
# 309 "../../include/orbit/orb-core/iop-defs.h"
typedef CORBA_sequence_IOP_TaggedComponent IOP_MultipleComponentProfile;
# 324 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_IOP_MultipleComponentProfile_struct;
# 471 "../../include/orbit/orb-core/iop-defs.h"
typedef CORBA_unsigned_long IOP_ServiceId;
# 486 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_IOP_ServiceId_struct;







typedef struct IOP_ServiceContext_type IOP_ServiceContext;
# 533 "../../include/orbit/orb-core/iop-defs.h"
struct IOP_ServiceContext_type {
IOP_ServiceId context_id;
CORBA_sequence_CORBA_octet context_data;
};
# 550 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_IOP_ServiceContext_struct;
# 570 "../../include/orbit/orb-core/iop-defs.h"
typedef struct { CORBA_unsigned_long _maximum, _length; IOP_ServiceContext* _buffer; CORBA_boolean _release; } CORBA_sequence_IOP_ServiceContext;
# 584 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_IOP_ServiceContext_struct;
# 596 "../../include/orbit/orb-core/iop-defs.h"
typedef CORBA_sequence_IOP_ServiceContext IOP_ServiceContextList;
# 611 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_IOP_ServiceContextList_struct;
# 692 "../../include/orbit/orb-core/iop-defs.h"
typedef CORBA_Object IOP_Codec;
extern CORBA_unsigned_long IOP_Codec__classid;
# 706 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_IOP_Codec_struct;







typedef struct IOP_Codec_InvalidTypeForEncoding_type IOP_Codec_InvalidTypeForEncoding;
struct IOP_Codec_InvalidTypeForEncoding_type {
int dummy;
};
# 733 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_IOP_Codec_InvalidTypeForEncoding_struct;
# 745 "../../include/orbit/orb-core/iop-defs.h"
typedef struct IOP_Codec_FormatMismatch_type IOP_Codec_FormatMismatch;
struct IOP_Codec_FormatMismatch_type {
int dummy;
};
# 762 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_IOP_Codec_FormatMismatch_struct;
# 774 "../../include/orbit/orb-core/iop-defs.h"
typedef struct IOP_Codec_TypeMismatch_type IOP_Codec_TypeMismatch;
struct IOP_Codec_TypeMismatch_type {
int dummy;
};
# 791 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_IOP_Codec_TypeMismatch_struct;







typedef CORBA_short IOP_EncodingFormat;
# 816 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_IOP_EncodingFormat_struct;
# 830 "../../include/orbit/orb-core/iop-defs.h"
typedef struct IOP_Encoding_type IOP_Encoding;
struct IOP_Encoding_type {
IOP_EncodingFormat format;
CORBA_octet major_version;
CORBA_octet minor_version;
};
# 849 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_IOP_Encoding_struct;
# 861 "../../include/orbit/orb-core/iop-defs.h"
typedef CORBA_Object IOP_CodecFactory;
extern CORBA_unsigned_long IOP_CodecFactory__classid;
# 875 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_IOP_CodecFactory_struct;







typedef struct IOP_CodecFactory_UnknownEncoding_type IOP_CodecFactory_UnknownEncoding;
struct IOP_CodecFactory_UnknownEncoding_type {
int dummy;
};
# 902 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_IOP_CodecFactory_UnknownEncoding_struct;







typedef struct IIOP_Version_type IIOP_Version;
struct IIOP_Version_type {
CORBA_octet major;
CORBA_octet minor;
};
# 930 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_IIOP_Version_struct;







typedef struct IIOP_ProfileBody_1_0_type IIOP_ProfileBody_1_0;
# 977 "../../include/orbit/orb-core/iop-defs.h"
struct IIOP_ProfileBody_1_0_type {
IIOP_Version iiop_version;
CORBA_string host;
CORBA_unsigned_short port;
CORBA_sequence_CORBA_octet object_key;
};
# 996 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_IIOP_ProfileBody_1_0_struct;







typedef struct IIOP_ProfileBody_1_1_type IIOP_ProfileBody_1_1;
# 1079 "../../include/orbit/orb-core/iop-defs.h"
struct IIOP_ProfileBody_1_1_type {
IIOP_Version iiop_version;
CORBA_string host;
CORBA_unsigned_short port;
CORBA_sequence_CORBA_octet object_key;
CORBA_sequence_IOP_TaggedComponent components;
};
# 1099 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_IIOP_ProfileBody_1_1_struct;







typedef struct IIOP_ListenPoint_type IIOP_ListenPoint;
struct IIOP_ListenPoint_type {
CORBA_string host;
CORBA_unsigned_short port;
};
# 1127 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_IIOP_ListenPoint_struct;
# 1147 "../../include/orbit/orb-core/iop-defs.h"
typedef struct { CORBA_unsigned_long _maximum, _length; IIOP_ListenPoint* _buffer; CORBA_boolean _release; } CORBA_sequence_IIOP_ListenPoint;
# 1161 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_IIOP_ListenPoint_struct;
# 1173 "../../include/orbit/orb-core/iop-defs.h"
typedef CORBA_sequence_IIOP_ListenPoint IIOP_ListenPointList;
# 1188 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_IIOP_ListenPointList_struct;
# 1199 "../../include/orbit/orb-core/iop-defs.h"
typedef struct IIOP_BiDirIIOPServiceContext_type IIOP_BiDirIIOPServiceContext;
struct IIOP_BiDirIIOPServiceContext_type {
IIOP_ListenPointList listen_points;
};
# 1216 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_IIOP_BiDirIIOPServiceContext_struct;







typedef struct GIOP_Version_type GIOP_Version;
struct GIOP_Version_type {
CORBA_octet major;
CORBA_octet minor;
};
# 1244 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_GIOP_Version_struct;
# 1290 "../../include/orbit/orb-core/iop-defs.h"
typedef CORBA_sequence_CORBA_octet GIOP_Principal;
# 1305 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_GIOP_Principal_struct;
# 1316 "../../include/orbit/orb-core/iop-defs.h"
typedef enum {
  GIOP_Request,
  GIOP_Reply,
  GIOP_CancelRequest,
  GIOP_LocateRequest,
  GIOP_LocateReply,
  GIOP_CloseConnection,
  GIOP_MessageError,
  GIOP_Fragment
} GIOP_MsgType_1_1;
# 1338 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_GIOP_MsgType_1_1_struct;





typedef GIOP_MsgType_1_1 GIOP_MsgType_1_2;
# 1361 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_GIOP_MsgType_1_2_struct;







typedef GIOP_MsgType_1_1 GIOP_MsgType_1_3;
# 1386 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_GIOP_MsgType_1_3_struct;







typedef struct GIOP_MessageHeader_1_0_type GIOP_MessageHeader_1_0;
struct GIOP_MessageHeader_1_0_type {
CORBA_char magic[4];
GIOP_Version GIOP_version;
CORBA_boolean byte_order;
CORBA_octet message_type;
CORBA_unsigned_long message_size;
};
# 1417 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_GIOP_MessageHeader_1_0_struct;







typedef struct GIOP_MessageHeader_1_1_type GIOP_MessageHeader_1_1;
struct GIOP_MessageHeader_1_1_type {
CORBA_char magic[4];
GIOP_Version GIOP_version;
CORBA_octet flags;
CORBA_octet message_type;
CORBA_unsigned_long message_size;
};
# 1448 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_GIOP_MessageHeader_1_1_struct;







typedef GIOP_MessageHeader_1_1 GIOP_MessageHeader_1_2;
# 1473 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_GIOP_MessageHeader_1_2_struct;







typedef GIOP_MessageHeader_1_1 GIOP_MessageHeader_1_3;
# 1498 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_GIOP_MessageHeader_1_3_struct;







typedef struct GIOP_RequestHeader_1_0_type GIOP_RequestHeader_1_0;
# 1545 "../../include/orbit/orb-core/iop-defs.h"
struct GIOP_RequestHeader_1_0_type {
IOP_ServiceContextList service_context;
CORBA_unsigned_long request_id;
CORBA_boolean response_expected;
CORBA_sequence_CORBA_octet object_key;
CORBA_string operation;
GIOP_Principal requesting_principal;
};
# 1566 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_GIOP_RequestHeader_1_0_struct;







typedef struct GIOP_RequestHeader_1_1_type GIOP_RequestHeader_1_1;
# 1613 "../../include/orbit/orb-core/iop-defs.h"
struct GIOP_RequestHeader_1_1_type {
IOP_ServiceContextList service_context;
CORBA_unsigned_long request_id;
CORBA_boolean response_expected;
CORBA_octet reserved[3];
CORBA_sequence_CORBA_octet object_key;
CORBA_string operation;
GIOP_Principal requesting_principal;
};
# 1635 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_GIOP_RequestHeader_1_1_struct;







typedef CORBA_short GIOP_AddressingDisposition;
# 1660 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_GIOP_AddressingDisposition_struct;
# 1682 "../../include/orbit/orb-core/iop-defs.h"
typedef struct GIOP_IORAddressingInfo_type GIOP_IORAddressingInfo;
struct GIOP_IORAddressingInfo_type {
CORBA_unsigned_long selected_profile_index;
IOP_IOR ior;
};
# 1700 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_GIOP_IORAddressingInfo_struct;







typedef struct GIOP_TargetAddress_type GIOP_TargetAddress;
# 1747 "../../include/orbit/orb-core/iop-defs.h"
struct GIOP_TargetAddress_type {
GIOP_AddressingDisposition _d;
union {
CORBA_sequence_CORBA_octet object_key;
IOP_TaggedProfile profile;
GIOP_IORAddressingInfo ior;
} _u;
};
# 1767 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_GIOP_TargetAddress_struct;







typedef struct GIOP_RequestHeader_1_2_type GIOP_RequestHeader_1_2;
struct GIOP_RequestHeader_1_2_type {
CORBA_unsigned_long request_id;
CORBA_octet response_flags;
CORBA_octet reserved[3];
GIOP_TargetAddress target;
CORBA_string operation;
IOP_ServiceContextList service_context;
};
# 1799 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_GIOP_RequestHeader_1_2_struct;







typedef GIOP_RequestHeader_1_2 GIOP_RequestHeader_1_3;
# 1824 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_GIOP_RequestHeader_1_3_struct;







typedef enum {
  GIOP_NO_EXCEPTION,
  GIOP_USER_EXCEPTION,
  GIOP_SYSTEM_EXCEPTION,
  GIOP_LOCATION_FORWARD
} GIOP_ReplyStatusType_1_0;
# 1852 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_GIOP_ReplyStatusType_1_0_struct;





typedef struct GIOP_ReplyHeader_1_0_type GIOP_ReplyHeader_1_0;
struct GIOP_ReplyHeader_1_0_type {
IOP_ServiceContextList service_context;
CORBA_unsigned_long request_id;
GIOP_ReplyStatusType_1_0 reply_status;
};
# 1879 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_GIOP_ReplyHeader_1_0_struct;







typedef GIOP_ReplyHeader_1_0 GIOP_ReplyHeader_1_1;
# 1904 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_GIOP_ReplyHeader_1_1_struct;







typedef struct GIOP_SystemExceptionReplyBody_type GIOP_SystemExceptionReplyBody;
struct GIOP_SystemExceptionReplyBody_type {
CORBA_string exception_id;
CORBA_unsigned_long minor_code_value;
CORBA_unsigned_long completion_status;
};
# 1933 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_GIOP_SystemExceptionReplyBody_struct;







typedef struct GIOP_CancelRequestHeader_type GIOP_CancelRequestHeader;
struct GIOP_CancelRequestHeader_type {
CORBA_unsigned_long request_id;
};
# 1960 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_GIOP_CancelRequestHeader_struct;







typedef struct GIOP_LocateRequestHeader_1_0_type GIOP_LocateRequestHeader_1_0;
# 2007 "../../include/orbit/orb-core/iop-defs.h"
struct GIOP_LocateRequestHeader_1_0_type {
CORBA_unsigned_long request_id;
CORBA_sequence_CORBA_octet object_key;
};
# 2024 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_GIOP_LocateRequestHeader_1_0_struct;







typedef GIOP_LocateRequestHeader_1_0 GIOP_LocateRequestHeader_1_1;
# 2049 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_GIOP_LocateRequestHeader_1_1_struct;







typedef struct GIOP_LocateRequestHeader_1_2_type GIOP_LocateRequestHeader_1_2;
struct GIOP_LocateRequestHeader_1_2_type {
CORBA_unsigned_long request_id;
GIOP_TargetAddress target;
};
# 2077 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_GIOP_LocateRequestHeader_1_2_struct;







typedef GIOP_LocateRequestHeader_1_2 GIOP_LocateRequestHeader_1_3;
# 2102 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_GIOP_LocateRequestHeader_1_3_struct;







typedef enum {
  GIOP_UNKNOWN_OBJECT,
  GIOP_OBJECT_HERE,
  GIOP_OBJECT_FORWARD
} GIOP_LocateStatusType_1_0;
# 2129 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_GIOP_LocateStatusType_1_0_struct;





typedef struct GIOP_LocateReplyHeader_1_0_type GIOP_LocateReplyHeader_1_0;
struct GIOP_LocateReplyHeader_1_0_type {
CORBA_unsigned_long request_id;
GIOP_LocateStatusType_1_0 locate_status;
};
# 2155 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_GIOP_LocateReplyHeader_1_0_struct;







typedef GIOP_LocateReplyHeader_1_0 GIOP_LocateReplyHeader_1_1;
# 2180 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_GIOP_LocateReplyHeader_1_1_struct;







typedef struct GIOP_FragmentHeader_1_2_type GIOP_FragmentHeader_1_2;
struct GIOP_FragmentHeader_1_2_type {
CORBA_unsigned_long request_id;
};
# 2207 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_GIOP_FragmentHeader_1_2_struct;







typedef GIOP_FragmentHeader_1_2 GIOP_FragmentHeader_1_3;
# 2232 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_GIOP_FragmentHeader_1_3_struct;
# 2282 "../../include/orbit/orb-core/iop-defs.h"
typedef CORBA_sequence_CORBA_octet CSI_X509CertificateChain;
# 2297 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CSI_X509CertificateChain_struct;
# 2344 "../../include/orbit/orb-core/iop-defs.h"
typedef CORBA_sequence_CORBA_octet CSI_X501DistinguishedName;
# 2359 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CSI_X501DistinguishedName_struct;
# 2406 "../../include/orbit/orb-core/iop-defs.h"
typedef CORBA_sequence_CORBA_octet CSI_UTF8String;
# 2421 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CSI_UTF8String_struct;
# 2468 "../../include/orbit/orb-core/iop-defs.h"
typedef CORBA_sequence_CORBA_octet CSI_OID;
# 2483 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CSI_OID_struct;
# 2540 "../../include/orbit/orb-core/iop-defs.h"
typedef struct { CORBA_unsigned_long _maximum, _length; CORBA_sequence_CORBA_octet* _buffer; CORBA_boolean _release; } CORBA_sequence_CORBA_sequence_CORBA_octet;
# 2554 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_CORBA_sequence_CORBA_octet_struct;
# 2576 "../../include/orbit/orb-core/iop-defs.h"
typedef CORBA_sequence_CORBA_sequence_CORBA_octet CORBA_sequence_CSI_OID;
# 2590 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_CSI_OID_struct;
# 2603 "../../include/orbit/orb-core/iop-defs.h"
typedef CORBA_sequence_CSI_OID CSI_OIDList;
# 2618 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CSI_OIDList_struct;
# 2665 "../../include/orbit/orb-core/iop-defs.h"
typedef CORBA_sequence_CORBA_octet CSI_GSSToken;
# 2680 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CSI_GSSToken_struct;
# 2727 "../../include/orbit/orb-core/iop-defs.h"
typedef CORBA_sequence_CORBA_octet CSI_GSS_NT_ExportedName;
# 2742 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CSI_GSS_NT_ExportedName_struct;
# 2835 "../../include/orbit/orb-core/iop-defs.h"
typedef CORBA_sequence_CORBA_sequence_CORBA_octet CORBA_sequence_CSI_GSS_NT_ExportedName;
# 2849 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_CSI_GSS_NT_ExportedName_struct;
# 2862 "../../include/orbit/orb-core/iop-defs.h"
typedef CORBA_sequence_CSI_GSS_NT_ExportedName CSI_GSS_NT_ExportedNameList;
# 2877 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CSI_GSS_NT_ExportedNameList_struct;
# 2888 "../../include/orbit/orb-core/iop-defs.h"
typedef CORBA_short CSI_MsgType;
# 2903 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CSI_MsgType_struct;
# 2929 "../../include/orbit/orb-core/iop-defs.h"
typedef CORBA_unsigned_long_long CSI_ContextId;
# 2944 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CSI_ContextId_struct;







typedef CORBA_unsigned_long CSI_AuthorizationElementType;
# 2969 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CSI_AuthorizationElementType_struct;
# 3019 "../../include/orbit/orb-core/iop-defs.h"
typedef CORBA_sequence_CORBA_octet CSI_AuthorizationElementContents;
# 3034 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CSI_AuthorizationElementContents_struct;
# 3045 "../../include/orbit/orb-core/iop-defs.h"
typedef struct CSI_AuthorizationElement_type CSI_AuthorizationElement;
struct CSI_AuthorizationElement_type {
CSI_AuthorizationElementType the_type;
CSI_AuthorizationElementContents the_element;
};
# 3063 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CSI_AuthorizationElement_struct;
# 3083 "../../include/orbit/orb-core/iop-defs.h"
typedef struct { CORBA_unsigned_long _maximum, _length; CSI_AuthorizationElement* _buffer; CORBA_boolean _release; } CORBA_sequence_CSI_AuthorizationElement;
# 3097 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_CSI_AuthorizationElement_struct;
# 3109 "../../include/orbit/orb-core/iop-defs.h"
typedef CORBA_sequence_CSI_AuthorizationElement CSI_AuthorizationToken;
# 3124 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CSI_AuthorizationToken_struct;
# 3135 "../../include/orbit/orb-core/iop-defs.h"
typedef CORBA_unsigned_long CSI_IdentityTokenType;
# 3150 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CSI_IdentityTokenType_struct;
# 3216 "../../include/orbit/orb-core/iop-defs.h"
typedef CORBA_sequence_CORBA_octet CSI_IdentityExtension;
# 3231 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CSI_IdentityExtension_struct;
# 3242 "../../include/orbit/orb-core/iop-defs.h"
typedef struct CSI_IdentityToken_type CSI_IdentityToken;
struct CSI_IdentityToken_type {
CSI_IdentityTokenType _d;
union {
CORBA_boolean absent;
CORBA_boolean anonymous;
CSI_GSS_NT_ExportedName principal_name;
CSI_X509CertificateChain certificate_chain;
CSI_X501DistinguishedName dn;
CSI_IdentityExtension id;
} _u;
};
# 3266 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CSI_IdentityToken_struct;







typedef struct CSI_EstablishContext_type CSI_EstablishContext;
struct CSI_EstablishContext_type {
CSI_ContextId client_context_id;
CSI_AuthorizationToken authorization_token;
CSI_IdentityToken identity_token;
CSI_GSSToken client_authentication_token;
};
# 3296 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CSI_EstablishContext_struct;







typedef struct CSI_CompleteEstablishContext_type CSI_CompleteEstablishContext;
struct CSI_CompleteEstablishContext_type {
CSI_ContextId client_context_id;
CORBA_boolean context_stateful;
CSI_GSSToken final_context_token;
};
# 3325 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CSI_CompleteEstablishContext_struct;







typedef struct CSI_ContextError_type CSI_ContextError;
struct CSI_ContextError_type {
CSI_ContextId client_context_id;
CORBA_long major_status;
CORBA_long minor_status;
CSI_GSSToken error_token;
};
# 3355 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CSI_ContextError_struct;







typedef struct CSI_MessageInContext_type CSI_MessageInContext;
struct CSI_MessageInContext_type {
CSI_ContextId client_context_id;
CORBA_boolean discard_context;
};
# 3383 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CSI_MessageInContext_struct;







typedef struct CSI_SASContextBody_type CSI_SASContextBody;
struct CSI_SASContextBody_type {
CSI_MsgType _d;
union {
CSI_EstablishContext establish_msg;
CSI_CompleteEstablishContext complete_msg;
CSI_ContextError error_msg;
CSI_MessageInContext in_context_msg;
} _u;
};
# 3415 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CSI_SASContextBody_struct;







typedef CORBA_string CSI_StringOID;
# 3440 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CSI_StringOID_struct;
# 3462 "../../include/orbit/orb-core/iop-defs.h"
typedef CORBA_unsigned_short CSIIOP_AssociationOptions;
# 3477 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CSIIOP_AssociationOptions_struct;
# 3535 "../../include/orbit/orb-core/iop-defs.h"
typedef CORBA_unsigned_long CSIIOP_ServiceConfigurationSyntax;
# 3550 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CSIIOP_ServiceConfigurationSyntax_struct;
# 3604 "../../include/orbit/orb-core/iop-defs.h"
typedef CORBA_sequence_CORBA_octet CSIIOP_ServiceSpecificName;
# 3619 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CSIIOP_ServiceSpecificName_struct;
# 3630 "../../include/orbit/orb-core/iop-defs.h"
typedef struct CSIIOP_ServiceConfiguration_type CSIIOP_ServiceConfiguration;
struct CSIIOP_ServiceConfiguration_type {
CSIIOP_ServiceConfigurationSyntax syntax;
CSIIOP_ServiceSpecificName name;
};
# 3648 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CSIIOP_ServiceConfiguration_struct;
# 3668 "../../include/orbit/orb-core/iop-defs.h"
typedef struct { CORBA_unsigned_long _maximum, _length; CSIIOP_ServiceConfiguration* _buffer; CORBA_boolean _release; } CORBA_sequence_CSIIOP_ServiceConfiguration;
# 3682 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_CSIIOP_ServiceConfiguration_struct;
# 3694 "../../include/orbit/orb-core/iop-defs.h"
typedef CORBA_sequence_CSIIOP_ServiceConfiguration CSIIOP_ServiceConfigurationList;
# 3709 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CSIIOP_ServiceConfigurationList_struct;
# 3720 "../../include/orbit/orb-core/iop-defs.h"
typedef struct CSIIOP_AS_ContextSec_type CSIIOP_AS_ContextSec;
struct CSIIOP_AS_ContextSec_type {
CSIIOP_AssociationOptions target_supports;
CSIIOP_AssociationOptions target_requires;
CSI_OID client_authentication_mech;
CSI_GSS_NT_ExportedName target_name;
};
# 3740 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CSIIOP_AS_ContextSec_struct;







typedef struct CSIIOP_SAS_ContextSec_type CSIIOP_SAS_ContextSec;
struct CSIIOP_SAS_ContextSec_type {
CSIIOP_AssociationOptions target_supports;
CSIIOP_AssociationOptions target_requires;
CSIIOP_ServiceConfigurationList privilege_authorities;
CSI_OIDList supported_naming_mechanisms;
CSI_IdentityTokenType supported_identity_types;
};
# 3771 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CSIIOP_SAS_ContextSec_struct;







typedef struct CSIIOP_CompoundSecMech_type CSIIOP_CompoundSecMech;
struct CSIIOP_CompoundSecMech_type {
CSIIOP_AssociationOptions target_requires;
IOP_TaggedComponent transport_mech;
CSIIOP_AS_ContextSec as_context_mech;
CSIIOP_SAS_ContextSec sas_context_mech;
};
# 3801 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CSIIOP_CompoundSecMech_struct;
# 3821 "../../include/orbit/orb-core/iop-defs.h"
typedef struct { CORBA_unsigned_long _maximum, _length; CSIIOP_CompoundSecMech* _buffer; CORBA_boolean _release; } CORBA_sequence_CSIIOP_CompoundSecMech;
# 3835 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_CSIIOP_CompoundSecMech_struct;
# 3847 "../../include/orbit/orb-core/iop-defs.h"
typedef CORBA_sequence_CSIIOP_CompoundSecMech CSIIOP_CompoundSecMechanisms;
# 3862 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CSIIOP_CompoundSecMechanisms_struct;
# 3873 "../../include/orbit/orb-core/iop-defs.h"
typedef struct CSIIOP_CompoundSecMechList_type CSIIOP_CompoundSecMechList;
struct CSIIOP_CompoundSecMechList_type {
CORBA_boolean stateful;
CSIIOP_CompoundSecMechanisms mechanism_list;
};
# 3891 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CSIIOP_CompoundSecMechList_struct;







typedef struct CSIIOP_TransportAddress_type CSIIOP_TransportAddress;
struct CSIIOP_TransportAddress_type {
CORBA_string host_name;
CORBA_unsigned_short port;
};
# 3919 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CSIIOP_TransportAddress_struct;
# 3939 "../../include/orbit/orb-core/iop-defs.h"
typedef struct { CORBA_unsigned_long _maximum, _length; CSIIOP_TransportAddress* _buffer; CORBA_boolean _release; } CORBA_sequence_CSIIOP_TransportAddress;
# 3953 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_CSIIOP_TransportAddress_struct;
# 3965 "../../include/orbit/orb-core/iop-defs.h"
typedef CORBA_sequence_CSIIOP_TransportAddress CSIIOP_TransportAddressList;
# 3980 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CSIIOP_TransportAddressList_struct;
# 3995 "../../include/orbit/orb-core/iop-defs.h"
typedef struct CSIIOP_SECIOP_SEC_TRANS_type CSIIOP_SECIOP_SEC_TRANS;
struct CSIIOP_SECIOP_SEC_TRANS_type {
CSIIOP_AssociationOptions target_supports;
CSIIOP_AssociationOptions target_requires;
CSI_OID mech_oid;
CSI_GSS_NT_ExportedName target_name;
CSIIOP_TransportAddressList addresses;
};
# 4016 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CSIIOP_SECIOP_SEC_TRANS_struct;
# 4030 "../../include/orbit/orb-core/iop-defs.h"
typedef struct CSIIOP_TLS_SEC_TRANS_type CSIIOP_TLS_SEC_TRANS;
struct CSIIOP_TLS_SEC_TRANS_type {
CSIIOP_AssociationOptions target_supports;
CSIIOP_AssociationOptions target_requires;
CSIIOP_TransportAddressList addresses;
};
# 4049 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CSIIOP_TLS_SEC_TRANS_struct;







typedef CORBA_unsigned_short BiDirPolicy_BidirectionalPolicyValue;
# 4074 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_BiDirPolicy_BidirectionalPolicyValue_struct;
# 4098 "../../include/orbit/orb-core/iop-defs.h"
typedef CORBA_Object BiDirPolicy_BidirectionalPolicy;
extern CORBA_unsigned_long BiDirPolicy_BidirectionalPolicy__classid;
# 4112 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_BiDirPolicy_BidirectionalPolicy_struct;





typedef CORBA_unsigned_long CONV_FRAME_CodeSetId;
# 4135 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CONV_FRAME_CodeSetId_struct;







typedef struct CONV_FRAME_CodeSetComponent_type CONV_FRAME_CodeSetComponent;
# 4194 "../../include/orbit/orb-core/iop-defs.h"
typedef CORBA_sequence_CORBA_unsigned_long CORBA_sequence_CONV_FRAME_CodeSetId;
# 4208 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_CONV_FRAME_CodeSetId_struct;
# 4219 "../../include/orbit/orb-core/iop-defs.h"
struct CONV_FRAME_CodeSetComponent_type {
CONV_FRAME_CodeSetId native_code_set;
CORBA_sequence_CONV_FRAME_CodeSetId conversion_code_sets;
};
# 4236 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CONV_FRAME_CodeSetComponent_struct;







typedef struct CONV_FRAME_CodeSetComponentInfo_type CONV_FRAME_CodeSetComponentInfo;
struct CONV_FRAME_CodeSetComponentInfo_type {
CONV_FRAME_CodeSetComponent ForCharData;
CONV_FRAME_CodeSetComponent ForWcharData;
};
# 4264 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CONV_FRAME_CodeSetComponentInfo_struct;







typedef struct CONV_FRAME_CodeSetContext_type CONV_FRAME_CodeSetContext;
struct CONV_FRAME_CodeSetContext_type {
CONV_FRAME_CodeSetId char_data;
CONV_FRAME_CodeSetId wchar_data;
};
# 4292 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CONV_FRAME_CodeSetContext_struct;
# 4314 "../../include/orbit/orb-core/iop-defs.h"
typedef struct IOP_ORBitSpecificProfileBody_type IOP_ORBitSpecificProfileBody;
# 4351 "../../include/orbit/orb-core/iop-defs.h"
struct IOP_ORBitSpecificProfileBody_type {
CORBA_string unix_sock_path;
CORBA_unsigned_short ipv6_port;
CORBA_sequence_CORBA_octet object_key;
};
# 4369 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_IOP_ORBitSpecificProfileBody_struct;







typedef struct IOP_GenericIOPProfileBody_type IOP_GenericIOPProfileBody;
# 4416 "../../include/orbit/orb-core/iop-defs.h"
struct IOP_GenericIOPProfileBody_type {
IIOP_Version iiop_version;
CORBA_string protocol;
CORBA_string host;
CORBA_string service;
CORBA_sequence_IOP_TaggedComponent components;
};
# 4436 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_IOP_GenericIOPProfileBody_struct;







typedef struct IOP_SSLGenericComponent_type IOP_SSLGenericComponent;
struct IOP_SSLGenericComponent_type {
CORBA_string service;
};
# 4463 "../../include/orbit/orb-core/iop-defs.h"
extern

const struct CORBA_TypeCode_struct TC_IOP_SSLGenericComponent_struct;







CORBA_OctetSeq* IOP_Codec_encode(IOP_Codec _obj, const CORBA_any* data, CORBA_Environment *ev);
CORBA_any* IOP_Codec_decode(IOP_Codec _obj, const CORBA_OctetSeq* data, CORBA_Environment *ev);
CORBA_OctetSeq* IOP_Codec_encode_value(IOP_Codec _obj, const CORBA_any* data, CORBA_Environment *ev);
CORBA_any* IOP_Codec_decode_value(IOP_Codec _obj, const CORBA_OctetSeq* data, const CORBA_TypeCode tc, CORBA_Environment *ev);
IOP_Codec IOP_CodecFactory_create_codec(IOP_CodecFactory _obj, const IOP_Encoding* enc, CORBA_Environment *ev);



BiDirPolicy_BidirectionalPolicyValue BiDirPolicy_BidirectionalPolicy__get_value(BiDirPolicy_BidirectionalPolicy _obj, CORBA_Environment *ev);
# 4492 "../../include/orbit/orb-core/iop-defs.h"
# 1 "../../include/orbit/orbit.h" 1
# 4493 "../../include/orbit/orb-core/iop-defs.h" 2
# 12 "../../include/orbit/GIOP/giop-types.h" 2







typedef struct _GIOPThread GIOPThread;

struct _GIOPThread {
 GMutex *lock;
 GCond *incoming;
 GMainContext *wake_context;

 GList *keys;

 GList *async_ents;
 GList *request_queue;

 GQueue *invoke_policies;

 void (*request_handler) (gpointer poa_object,
     gpointer recv_buffer,
     gpointer dummy);
};



typedef enum {
 GIOP_CONNECTION_SSL
} GIOPConnectionOptions;

extern const char giop_version_ids[GIOP_NUM_VERSIONS][2];

typedef struct {
 CORBA_char magic[4];
 CORBA_char version[2];
 CORBA_octet flags;
 CORBA_octet message_type;
 CORBA_unsigned_long message_size;
} GIOPMsgHeader;

typedef enum
{
 GIOP_REQUEST,
 GIOP_REPLY,
 GIOP_CANCELREQUEST,
 GIOP_LOCATEREQUEST,
 GIOP_LOCATEREPLY,
 GIOP_CLOSECONNECTION,
 GIOP_MESSAGEERROR,
 GIOP_FRAGMENT,
 GIOP_NUM_MSG_TYPES
} GIOPMsgType;
# 101 "../../include/orbit/GIOP/giop-types.h"
typedef CORBA_sequence_CORBA_octet CORBA_Principal;

typedef struct {
  IOP_ServiceContextList service_context;
  CORBA_unsigned_long request_id;
  CORBA_boolean response_expected;
  CORBA_sequence_CORBA_octet object_key;
  CORBA_char *operation;
  CORBA_Principal requesting_principal;
} GIOPMsgRequest_1_0;

typedef struct {
  IOP_ServiceContextList service_context;
  CORBA_unsigned_long request_id;
  CORBA_boolean response_expected;
  CORBA_char reserved[3];
  CORBA_sequence_CORBA_octet object_key;
  CORBA_char *operation;
  CORBA_Principal requesting_principal;
} GIOPMsgRequest_1_1;

typedef struct {
  CORBA_unsigned_long request_id;
  CORBA_octet response_flags;
  CORBA_octet reserved[3];
  GIOP_TargetAddress target;
  CORBA_char *operation;
  IOP_ServiceContextList service_context;
} GIOPMsgRequest_1_2;

typedef struct {
  IOP_ServiceContextList service_context;
  CORBA_unsigned_long request_id;
  CORBA_unsigned_long reply_status;
} GIOPMsgReply_1_0;

typedef GIOPMsgReply_1_0 GIOPMsgReply_1_1;

typedef struct {
  CORBA_unsigned_long request_id;
  CORBA_unsigned_long reply_status;
  IOP_ServiceContextList service_context;
} GIOPMsgReply_1_2;

typedef struct {
  CORBA_unsigned_long request_id;
} GIOPMsgCancelRequest;

typedef struct {
  CORBA_unsigned_long request_id;
  CORBA_sequence_CORBA_octet object_key;
} GIOPMsgLocateRequest_1_0;

typedef GIOPMsgLocateRequest_1_0 GIOPMsgLocateRequest_1_1;

typedef struct {
  CORBA_unsigned_long request_id;
  GIOP_TargetAddress target;
} GIOPMsgLocateRequest_1_2;

typedef struct {
  CORBA_unsigned_long request_id;
  CORBA_unsigned_long locate_status;
} GIOPMsgLocateReply_1_0;

typedef GIOPMsgLocateReply_1_0 GIOPMsgLocateReply_1_1;

typedef struct {
  CORBA_unsigned_long request_id;
  CORBA_unsigned_long locate_status;
} GIOPMsgLocateReply_1_2;

typedef struct {
  GIOPMsgHeader header;

  union {
    GIOPMsgRequest_1_0 request_1_0;
    GIOPMsgRequest_1_1 request_1_1;
    GIOPMsgRequest_1_2 request_1_2;
    GIOPMsgReply_1_0 reply_1_0;
    GIOPMsgReply_1_1 reply_1_1;
    GIOPMsgReply_1_2 reply_1_2;
    GIOPMsgCancelRequest cancel_request;
    GIOPMsgLocateRequest_1_0 locate_request_1_0;
    GIOPMsgLocateRequest_1_1 locate_request_1_1;
    GIOPMsgLocateRequest_1_2 locate_request_1_2;
    GIOPMsgLocateReply_1_0 locate_reply_1_0;
    GIOPMsgLocateReply_1_1 locate_reply_1_1;
    GIOPMsgLocateReply_1_2 locate_reply_1_2;
  } u;
} GIOPMsg;
# 211 "../../include/orbit/GIOP/giop-types.h"

# 8 "../../include/orbit/GIOP/giop.h" 2
# 1 "../../include/orbit/GIOP/giop-send-buffer.h" 1




# 1 "../../include/orbit/GIOP/giop-connection.h" 1





# 1 "../../include/orbit/GIOP/giop-server.h" 1







# 32 "../../include/orbit/GIOP/giop-server.h"
typedef struct {
 LinkServer parent;

 gpointer orb_data;
 GIOPVersion giop_version;
} GIOPServer;

typedef struct {
 LinkServerClass parent_class;
} GIOPServerClass;

GType giop_server_get_type (void) __attribute__((__const__));
GIOPServer *giop_server_new (GIOPVersion giop_version,
      const char *proto_name,
      const char *local_host_info,
      const char *local_serv_info,
      LinkConnectionOptions create_options,
      gpointer create_orb_data);




# 7 "../../include/orbit/GIOP/giop-connection.h" 2






# 27 "../../include/orbit/GIOP/giop-connection.h"
struct _GIOPConnection {
 LinkConnection parent;

 GIOPRecvBuffer *incoming_msg;
 GList *incoming_frags;

 GIOPVersion giop_version;

 gpointer orb_data;
};

typedef struct {
 LinkConnectionClass parent_class;
} GIOPConnectionClass;

GType giop_connection_get_type (void) __attribute__((__const__));
GIOPConnection *giop_connection_initiate (gpointer orb_data,
            const char *proto_name,
            const char *remote_host_info,
            const char *remote_serv_info,
            GIOPConnectionOptions options,
            GIOPVersion giop_version);
void giop_connections_shutdown (void);
void giop_connection_close (GIOPConnection *cnx);
LinkConnectionStatus giop_connection_try_reconnect (GIOPConnection *cnx);







# 6 "../../include/orbit/GIOP/giop-send-buffer.h" 2





typedef struct {
 gulong size;
 guchar *ptr;
} GIOPIndirectChunk;

struct _GIOPSendBuffer {
 GIOPMsg msg;

 struct iovec *iovecs;
 gulong num_alloced;
 gulong num_used;

 const guchar *lastptr;

 guchar *indirect;
 gulong indirect_left;

 GIOPIndirectChunk *indirects;
 guint num_indirects_alloced;

 guint num_indirects_used;
 GIOPVersion giop_version;
 guint header_size;
};

GIOPSendBuffer *giop_send_buffer_use (GIOPVersion giop_version);


GIOPSendBuffer *giop_send_buffer_use_request (GIOPVersion giop_version,
           CORBA_unsigned_long request_id,
           CORBA_boolean response_expected,
           const CORBA_sequence_CORBA_octet *objkey,
           const struct iovec *operation_vec,
           const struct iovec *principal_vec);

GIOPSendBuffer *giop_send_buffer_use_reply (GIOPVersion giop_version,
           CORBA_unsigned_long request_id,
           CORBA_unsigned_long reply_status);
GIOPSendBuffer *giop_send_buffer_use_locate_request (GIOPVersion giop_version,
           CORBA_unsigned_long request_id,
           const CORBA_sequence_CORBA_octet *objkey);
GIOPSendBuffer *giop_send_buffer_use_locate_reply (GIOPVersion giop_version,
           CORBA_unsigned_long request_id,
           CORBA_unsigned_long locate_status);
GIOPSendBuffer *giop_send_buffer_use_close_connection (GIOPVersion giop_version);
GIOPSendBuffer *giop_send_buffer_use_message_error (GIOPVersion giop_version);

void giop_send_buffer_unuse (GIOPSendBuffer *buf);
void giop_send_buffer_append (GIOPSendBuffer *buf,
      gconstpointer mem,
      gulong len);
guchar *giop_send_buffer_append_aligned (GIOPSendBuffer *buf,
      gconstpointer mem,
      gulong align_len);
void giop_send_buffer_append_string (GIOPSendBuffer *buf,
      const char *str);
void giop_send_buffer_align (GIOPSendBuffer *buf,
      gulong boundary);
int giop_send_buffer_write (GIOPSendBuffer *buf,
      GIOPConnection *cnx,
      gboolean block);




# 9 "../../include/orbit/GIOP/giop.h" 2
# 1 "../../include/orbit/GIOP/giop-recv-buffer.h" 1










typedef enum {
  GIOP_MSG_READING_HEADER,
  GIOP_MSG_READING_BODY,
  GIOP_MSG_AWAITING_FRAGMENTS,
  GIOP_MSG_READY
} GIOPMessageBufferState;

typedef struct _GIOPMessageQueueEntry GIOPMessageQueueEntry;

typedef void (*GIOPAsyncCallback) (GIOPMessageQueueEntry *ent);


struct _GIOPMessageQueueEntry {
 GIOPRecvBuffer *buffer;
 GIOPConnection *cnx;
 CORBA_unsigned_long msg_type;
 CORBA_unsigned_long request_id;
 GIOPThread *src_thread;

 GIOPAsyncCallback async_cb;
};

struct _GIOPRecvBuffer {
 GIOPMsg msg;

 guchar *message_body;
 guchar *cur;
 guchar *end;

 GIOPConnection *connection;
 GIOPMessageBufferState state;

 GIOPVersion giop_version;
 gulong left_to_read;
 guint free_body : 1;
};


GIOPRecvBuffer *giop_recv_buffer_use_buf (GIOPConnection *cnx);
GIOPRecvBuffer *giop_recv_buffer_use_encaps_buf (GIOPRecvBuffer *buf);
GIOPRecvBuffer *giop_recv_buffer_use_encaps (guchar *mem,
          gulong len);
void giop_recv_list_destroy_queue_entry (GIOPMessageQueueEntry *ent);
void giop_recv_list_setup_queue_entry (GIOPMessageQueueEntry *ent,
          GIOPConnection *cnx,
          CORBA_unsigned_long msg_type,
          CORBA_unsigned_long request_id);
void giop_recv_list_setup_queue_entry_async (GIOPMessageQueueEntry *ent,
       GIOPAsyncCallback cb);

GIOPRecvBuffer *giop_recv_buffer_get (GIOPMessageQueueEntry *ent);
void giop_recv_buffer_unuse (GIOPRecvBuffer *buf);







CORBA_unsigned_long giop_recv_buffer_get_request_id (GIOPRecvBuffer *buf);
char *giop_recv_buffer_get_opname (GIOPRecvBuffer *buf);
CORBA_sequence_CORBA_octet *giop_recv_buffer_get_objkey (GIOPRecvBuffer *buf);
void giop_recv_list_zap (GIOPConnection *cnx);
gboolean giop_connection_handle_input (LinkConnection *lcnx);
void giop_connection_destroy_frags (GIOPConnection *cnx);




# 10 "../../include/orbit/GIOP/giop.h" 2


# 1 "../../include/orbit/GIOP/giop-endian.h" 1










void giop_byteswap(guchar *outdata,
     const guchar *data,
     gulong datalen);


extern inline void giop_byteswap(guchar *outdata,
     const guchar *data,
     gulong datalen)
{
  const guchar *source_ptr = data;
  guchar *dest_ptr = outdata + datalen - 1;
  while(dest_ptr >= outdata)
    *dest_ptr-- = *source_ptr++;
}





# 13 "../../include/orbit/GIOP/giop.h" 2





void giop_init (gboolean thread_safe,
        gboolean blank_wire_data);
void giop_main_run (void);
void giop_shutdown (void);
gboolean giop_thread_safe (void);
gboolean giop_thread_io (void);
GIOPThread *giop_thread_self (void);
void giop_invoke_async (GIOPMessageQueueEntry *ent);
void giop_recv_set_limit (glong limit);
glong giop_recv_get_limit (void);
void giop_incoming_signal_T (GIOPThread *tdata, GIOPMsgType t);

typedef struct _GIOPQueue GIOPQueue;
GIOPThread *giop_thread_get_main (void);
void giop_thread_set_main_handler (gpointer request_handler);
void giop_thread_request_push (GIOPThread *tdata,
       gpointer *poa_object,
       gpointer *recv_buffer);
void giop_thread_request_push_key (gpointer key,
       gpointer *poa_object,
       gpointer *recv_buffer);
gboolean giop_thread_same_key (gpointer key,
       gboolean no_key_default);
void giop_thread_key_add (GIOPThread *tdata,
       gpointer key);
void giop_thread_key_release (gpointer key);
void giop_thread_new_check (GIOPThread *opt_self);
void giop_thread_queue_process (GIOPThread *tdata);
gboolean giop_thread_queue_empty_T (GIOPThread *tdata);
void giop_thread_queue_tail_wakeup(GIOPThread *tdata);




# 16 "../../include/orbit/orbit.h" 2

# 1 "../../include/orbit/orb-core/orb-core.h" 1





# 1 "../../include/orbit/orb-core/corba-defs.h" 1
# 7 "../../include/orbit/orb-core/orb-core.h" 2
# 1 "../../include/orbit/orb-core/iop-defs.h" 1
# 8 "../../include/orbit/orb-core/orb-core.h" 2

# 1 "../../include/orbit/orb-core/corba-orb.h" 1









CORBA_ORB CORBA_ORB_init (int *argc,
     char **argv,
     CORBA_ORBid orb_identifier,
     CORBA_Environment *ev);
# 41 "../../include/orbit/orb-core/corba-orb.h"
void ORBit_ORB_forw_bind (CORBA_ORB orb,
          CORBA_sequence_CORBA_octet *okey,
          CORBA_Object oref,
          CORBA_Environment *ev);

guint ORBit_ORB_idle_init (CORBA_ORB orb);

void ORBit_ORB_start_servers (CORBA_ORB orb);




# 10 "../../include/orbit/orb-core/orb-core.h" 2
# 1 "../../include/orbit/orb-core/corba-string.h" 1







CORBA_char *CORBA_string_alloc (CORBA_unsigned_long len);
CORBA_wchar *CORBA_wstring_alloc (CORBA_unsigned_long len);




CORBA_char *CORBA_string_dup (const CORBA_char *str);

CORBA_unsigned_long CORBA_wstring_len (CORBA_wchar *ws);



gpointer CORBA_string__freekids (gpointer mem,
      gpointer data);

CORBA_sequence_CORBA_octet *
         ORBit_sequence_CORBA_octet_dup (const CORBA_sequence_CORBA_octet *seq);




# 11 "../../include/orbit/orb-core/orb-core.h" 2

# 1 "../../include/orbit/orb-core/corba-environment.h" 1







CORBA_Environment *CORBA_exception__alloc (void);
CORBA_Environment *CORBA_exception__copy (const CORBA_Environment *ev);

void CORBA_exception_set (CORBA_Environment *ev,
        CORBA_exception_type major,
        const CORBA_char *except_repos_id,
        void *param);

CORBA_char *CORBA_exception_id (CORBA_Environment *ev);
void *CORBA_exception_value (CORBA_Environment *ev);
void CORBA_exception_init (CORBA_Environment *ev);
void CORBA_exception_free (CORBA_Environment *ev);
CORBA_any *CORBA_exception_as_any (CORBA_Environment *ev);

void CORBA_exception_set_system (CORBA_Environment *ev,
        const CORBA_char *except_repos_id,
        CORBA_completion_status completed);



typedef struct {
 const CORBA_TypeCode tc;

 void (*marshal) (GIOPSendBuffer *, CORBA_Environment *);
} ORBit_exception_marshal_info;

typedef struct {
 const CORBA_TypeCode tc;

 void (*demarshal) (GIOPRecvBuffer *, CORBA_Environment *);
} ORBit_exception_demarshal_info;

void ORBit_handle_system_exception (CORBA_Environment *ev,
        const CORBA_char *nom,
        CORBA_completion_status status,
        GIOPRecvBuffer *buf,
        GIOPSendBuffer *sendbuf);

void ORBit_handle_exception (GIOPRecvBuffer *buf,
        CORBA_Environment *ev,
        const ORBit_exception_demarshal_info *ex_info,
        CORBA_ORB orb);
GIOPConnection *
     ORBit_handle_location_forward (GIOPRecvBuffer *buf,
        CORBA_Object obj);

void ORBit_send_system_exception (GIOPSendBuffer *buf,
        CORBA_Environment *ev);

void ORBit_send_user_exception (GIOPSendBuffer *send_buffer,
        CORBA_Environment *ev,
        const ORBit_exception_marshal_info *user_exceptions);




# 13 "../../include/orbit/orb-core/orb-core.h" 2
# 1 "../../include/orbit/orb-core/corba-any.h" 1







void CORBA_any__copy (CORBA_any *out,
    const CORBA_any *in);
CORBA_any *CORBA_any__alloc (void);



gpointer CORBA_any__freekids (gpointer mem,
    gpointer data);




gpointer ORBit_copy_value (gconstpointer value,
     CORBA_TypeCode tc);

CORBA_boolean
  ORBit_any_equivalent (CORBA_any *obj,
     CORBA_any *any,
     CORBA_Environment *ev);



void ORBit_marshal_arg (GIOPSendBuffer *buf,
     gconstpointer val,
     CORBA_TypeCode tc);

void ORBit_marshal_any (GIOPSendBuffer *buf,
     const CORBA_any *val);

gpointer ORBit_demarshal_arg (GIOPRecvBuffer *buf,
     CORBA_TypeCode tc,
     CORBA_ORB orb);

gboolean ORBit_demarshal_any (GIOPRecvBuffer *buf,
     CORBA_any *retval,
     CORBA_ORB orb);

gboolean ORBit_demarshal_value (CORBA_TypeCode tc,
     gpointer *val,
     GIOPRecvBuffer *buf,
     CORBA_ORB orb);

void ORBit_marshal_value (GIOPSendBuffer *buf,
     gconstpointer *val,
     CORBA_TypeCode tc);

CORBA_boolean
  ORBit_value_equivalent (gpointer *a,
     gpointer *b,
     CORBA_TypeCode tc,
     CORBA_Environment *ev);

size_t ORBit_gather_alloc_info (CORBA_TypeCode tc);




# 14 "../../include/orbit/orb-core/orb-core.h" 2
# 1 "../../include/orbit/orb-core/corba-object-type.h" 1











typedef CORBA_sequence_CORBA_octet ORBit_ObjectKey;

struct CORBA_Object_type {
 struct ORBit_RootObject_struct parent;

 GIOPConnection *connection;
 GQuark type_qid;
 GSList *profile_list;
 GSList *forward_locations;
 ORBit_ObjectKey *object_key;
 struct _ORBitPolicy *invoke_policy;

 CORBA_ORB orb;
 ORBit_OAObject adaptor_obj;
};




# 15 "../../include/orbit/orb-core/orb-core.h" 2
# 1 "../../include/orbit/orb-core/corba-object.h" 1









GIOPConnection *ORBit_object_get_connection (CORBA_Object obj);
GIOPConnection *ORBit_object_peek_connection (CORBA_Object obj);


void ORBit_marshal_object (GIOPSendBuffer *buf,
          CORBA_Object obj);
gboolean ORBit_demarshal_object (CORBA_Object *obj,
          GIOPRecvBuffer *buf,
          CORBA_ORB orb);

CORBA_Object ORBit_objref_new (CORBA_ORB orb,
          ORBit_OAObject adaptor_obj,
          GQuark type_id);






typedef struct _ORBitPolicy ORBitPolicy;




GType ORBit_policy_ex_get_type (void) __attribute__((__const__));
ORBitPolicy *ORBit_policy_new (GType type,
           const char *first_prop,
           ...);
ORBitPolicy *ORBit_policy_ref (ORBitPolicy *p);
void ORBit_policy_unref (ORBitPolicy *p);
void ORBit_object_set_policy (CORBA_Object obj,
           ORBitPolicy *p);
ORBitPolicy *ORBit_object_get_policy (CORBA_Object obj);
void ORBit_policy_push (ORBitPolicy *p);
void ORBit_policy_pop (void);




# 1 "../../include/orbit/orb-core/orbit-interface.h" 1
# 50 "../../include/orbit/orb-core/corba-object.h" 2




extern ORBit_IInterface CORBA_Object__iinterface;
extern ORBit_IMethod CORBA_Object__imethods[];




# 16 "../../include/orbit/orb-core/orb-core.h" 2
# 1 "../../include/orbit/orb-core/corba-policy-type.h" 1









struct CORBA_Policy_type {
 struct ORBit_RootObject_struct parent;

 CORBA_unsigned_long type;
 CORBA_unsigned_long value;
};

CORBA_Policy ORBit_Policy_new (CORBA_unsigned_long type,
          CORBA_unsigned_long value);




# 17 "../../include/orbit/orb-core/orb-core.h" 2
# 1 "../../include/orbit/orb-core/corba-context.h" 1









struct CORBA_Context_type {
 struct ORBit_RootObject_struct parent;

 GHashTable *mappings;
 GSList *children;

 gchar *the_name;

 CORBA_Context parent_ctx;
};

void ORBit_Context_marshal (CORBA_Context ctx,
        const ORBit_ContextMarshalItem *mlist,
        CORBA_unsigned_long nitems,
        GIOPSendBuffer *buf);

gboolean ORBit_Context_demarshal (CORBA_Context parent,
        CORBA_Context initme,
        GIOPRecvBuffer *recv_buffer);

void ORBit_Context_server_free (CORBA_Context ctx);




# 18 "../../include/orbit/orb-core/orb-core.h" 2

# 1 "../../include/orbit/orb-core/orbit-small.h" 1







# 1 "../../include/orbit/orb-core/orbit-interface.h" 1
# 9 "../../include/orbit/orb-core/orbit-small.h" 2



typedef struct {
 CORBA_unsigned_long version;
 ORBit_IInterface **interfaces;
 CORBA_sequence_CORBA_TypeCode types;
} ORBit_IModule;

const char *ORBit_get_safe_tmp (void);


gpointer ORBit_small_alloc (CORBA_TypeCode tc);
gpointer ORBit_small_allocbuf (CORBA_TypeCode tc,
     CORBA_unsigned_long length);
void ORBit_small_freekids (CORBA_TypeCode tc,
     gpointer p,
     gpointer d);


gpointer ORBit_sequence_alloc (CORBA_TypeCode sequence_tc,
     CORBA_unsigned_long length);
void ORBit_sequence_append (gpointer sequence,
     gconstpointer element);
void ORBit_sequence_set_size (gpointer sequence,
     CORBA_unsigned_long length);

void ORBit_sequence_concat (gpointer sequence,
     gconstpointer append);
void ORBit_sequence_remove (gpointer sequence,
                                        guint idx);

typedef enum {
 ORBIT_CONNECTION_CONNECTED,
 ORBIT_CONNECTION_CONNECTING,
 ORBIT_CONNECTION_DISCONNECTED,
 ORBIT_CONNECTION_IN_PROC
} ORBitConnectionStatus;

gpointer ORBit_small_get_servant (CORBA_Object obj);
ORBitConnectionStatus ORBit_small_get_connection_status (CORBA_Object obj);
ORBitConnectionStatus ORBit_small_listen_for_broken (CORBA_Object obj,
           GCallback fn,
           gpointer user_data);
ORBitConnectionStatus ORBit_small_unlisten_for_broken_full (CORBA_Object obj,
           GCallback fn,
           gpointer user_data);

ORBitConnectionStatus ORBit_small_unlisten_for_broken (CORBA_Object obj,
           GCallback fn);

typedef struct _ORBitConnection ORBitConnection;

ORBitConnection *ORBit_small_get_connection (CORBA_Object obj);
ORBitConnection *ORBit_small_get_connection_ref (CORBA_Object obj);
void ORBit_small_connection_unref (ORBitConnection *cnx);
void ORBit_connection_set_max_buffer (ORBitConnection *cnx,
        gulong max_buffer_bytes);






extern int ORBit_small_flags;


void ORBit_small_invoke_stub (CORBA_Object object,
     ORBit_IMethod *m_data,
     gpointer ret,
     gpointer *args,
     CORBA_Context ctx,
     CORBA_Environment *ev);


void ORBit_small_invoke_stub_n (CORBA_Object object,
       ORBit_IMethods *methods,
       glong index,
       gpointer ret,
       gpointer *args,
       CORBA_Context ctx,
       CORBA_Environment *ev);







void ORBit_small_invoke_adaptor (ORBit_OAObject adaptor_obj,
        GIOPRecvBuffer *recv_buffer,
        ORBit_IMethod *m_data,
        gpointer data,
        CORBA_Environment *ev);




CORBA_char *ORBit_small_get_type_id (CORBA_Object object,
         CORBA_Environment *ev);
ORBit_IInterface *ORBit_small_get_iinterface (CORBA_Object opt_object,
                const CORBA_char *repo_id,
         CORBA_Environment *ev);
gboolean ORBit_small_load_typelib (const char *libname);
CORBA_sequence_CORBA_TypeCode *
                  ORBit_small_get_types (const char *name);
CORBA_sequence_ORBit_IInterface *
                  ORBit_small_get_iinterfaces (const char *name);

typedef struct _ORBitAsyncQueueEntry ORBitAsyncQueueEntry;

typedef void (*ORBitAsyncInvokeFunc) (CORBA_Object object,
          ORBit_IMethod *m_data,
          ORBitAsyncQueueEntry *aqe,
          gpointer user_data,
          CORBA_Environment *ev);


void ORBit_small_invoke_async (CORBA_Object obj,
          ORBit_IMethod *m_data,
          ORBitAsyncInvokeFunc fn,
          gpointer user_data,
          gpointer *args,
          CORBA_Context ctx,
          CORBA_Environment *ev);

void ORBit_small_demarshal_async (ORBitAsyncQueueEntry *aqe,
          gpointer ret,
          gpointer *args,
          CORBA_Environment *ev);


# 20 "../../include/orbit/orb-core/orb-core.h" 2
# 18 "../../include/orbit/orbit.h" 2
# 1 "../../include/orbit/poa/poa.h" 1



# 1 "../../include/orbit/poa/poa-defs.h" 1
# 73 "../../include/orbit/poa/poa-defs.h"
typedef CORBA_sequence_CORBA_Object CORBA_sequence_PortableServer_POA;
# 87 "../../include/orbit/poa/poa-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_PortableServer_POA_struct;
# 100 "../../include/orbit/poa/poa-defs.h"
typedef CORBA_sequence_PortableServer_POA PortableServer_POAList;
# 115 "../../include/orbit/poa/poa-defs.h"
extern

const struct CORBA_TypeCode_struct TC_PortableServer_POAList_struct;
# 130 "../../include/orbit/poa/poa-defs.h"
typedef CORBA_OctetSeq PortableServer_ObjectId;
# 145 "../../include/orbit/poa/poa-defs.h"
extern

const struct CORBA_TypeCode_struct TC_PortableServer_ObjectId_struct;
# 158 "../../include/orbit/poa/poa-defs.h"
typedef struct PortableServer_ForwardRequest_type PortableServer_ForwardRequest;
struct PortableServer_ForwardRequest_type {
CORBA_Object forward_reference;
};
# 175 "../../include/orbit/poa/poa-defs.h"
extern

const struct CORBA_TypeCode_struct TC_PortableServer_ForwardRequest_struct;
# 213 "../../include/orbit/poa/poa-defs.h"
typedef enum {
  PortableServer_ORB_CTRL_MODEL,
  PortableServer_SINGLE_THREAD_MODEL,
  PortableServer_MAIN_THREAD_MODEL
} PortableServer_ThreadPolicyValue;
# 230 "../../include/orbit/poa/poa-defs.h"
extern

const struct CORBA_TypeCode_struct TC_PortableServer_ThreadPolicyValue_struct;






typedef struct PortableServer_ThreadPolicy_type *PortableServer_ThreadPolicy;






typedef enum {
  PortableServer_TRANSIENT,
  PortableServer_PERSISTENT
} PortableServer_LifespanPolicyValue;
# 262 "../../include/orbit/poa/poa-defs.h"
extern

const struct CORBA_TypeCode_struct TC_PortableServer_LifespanPolicyValue_struct;






typedef struct PortableServer_LifespanPolicy_type *PortableServer_LifespanPolicy;






typedef enum {
  PortableServer_UNIQUE_ID,
  PortableServer_MULTIPLE_ID
} PortableServer_IdUniquenessPolicyValue;
# 294 "../../include/orbit/poa/poa-defs.h"
extern

const struct CORBA_TypeCode_struct TC_PortableServer_IdUniquenessPolicyValue_struct;






typedef struct PortableServer_IdUniquenessPolicy_type *PortableServer_IdUniquenessPolicy;






typedef enum {
  PortableServer_USER_ID,
  PortableServer_SYSTEM_ID
} PortableServer_IdAssignmentPolicyValue;
# 326 "../../include/orbit/poa/poa-defs.h"
extern

const struct CORBA_TypeCode_struct TC_PortableServer_IdAssignmentPolicyValue_struct;






typedef struct PortableServer_IdAssignmentPolicy_type *PortableServer_IdAssignmentPolicy;






typedef enum {
  PortableServer_IMPLICIT_ACTIVATION,
  PortableServer_NO_IMPLICIT_ACTIVATION
} PortableServer_ImplicitActivationPolicyValue;
# 358 "../../include/orbit/poa/poa-defs.h"
extern

const struct CORBA_TypeCode_struct TC_PortableServer_ImplicitActivationPolicyValue_struct;






typedef struct PortableServer_ImplicitActivationPolicy_type *PortableServer_ImplicitActivationPolicy;






typedef enum {
  PortableServer_RETAIN,
  PortableServer_NON_RETAIN
} PortableServer_ServantRetentionPolicyValue;
# 390 "../../include/orbit/poa/poa-defs.h"
extern

const struct CORBA_TypeCode_struct TC_PortableServer_ServantRetentionPolicyValue_struct;






typedef struct PortableServer_ServantRetentionPolicy_type *PortableServer_ServantRetentionPolicy;






typedef enum {
  PortableServer_USE_ACTIVE_OBJECT_MAP_ONLY,
  PortableServer_USE_DEFAULT_SERVANT,
  PortableServer_USE_SERVANT_MANAGER
} PortableServer_RequestProcessingPolicyValue;
# 423 "../../include/orbit/poa/poa-defs.h"
extern

const struct CORBA_TypeCode_struct TC_PortableServer_RequestProcessingPolicyValue_struct;






typedef struct PortableServer_RequestProcessingPolicy_type *PortableServer_RequestProcessingPolicy;







typedef struct PortableServer_POAManager_type *PortableServer_POAManager;
# 449 "../../include/orbit/poa/poa-defs.h"
typedef struct PortableServer_POAManager_AdapterInactive_type PortableServer_POAManager_AdapterInactive;
struct PortableServer_POAManager_AdapterInactive_type {
int dummy;
};
# 466 "../../include/orbit/poa/poa-defs.h"
extern

const struct CORBA_TypeCode_struct TC_PortableServer_POAManager_AdapterInactive_struct;







typedef enum {
  PortableServer_POAManager_HOLDING,
  PortableServer_POAManager_ACTIVE,
  PortableServer_POAManager_DISCARDING,
  PortableServer_POAManager_INACTIVE
} PortableServer_POAManager_State;
# 494 "../../include/orbit/poa/poa-defs.h"
extern

const struct CORBA_TypeCode_struct TC_PortableServer_POAManager_State_struct;






typedef struct PortableServer_POAManagerFactory_type *PortableServer_POAManagerFactory;
# 556 "../../include/orbit/poa/poa-defs.h"
typedef CORBA_sequence_CORBA_Object CORBA_sequence_PortableServer_POAManager;
# 570 "../../include/orbit/poa/poa-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_PortableServer_POAManager_struct;
# 583 "../../include/orbit/poa/poa-defs.h"
typedef CORBA_sequence_PortableServer_POAManager PortableServer_POAManagerFactory_POAManagerSeq;
# 598 "../../include/orbit/poa/poa-defs.h"
extern

const struct CORBA_TypeCode_struct TC_PortableServer_POAManagerFactory_POAManagerSeq_struct;
# 611 "../../include/orbit/poa/poa-defs.h"
typedef struct PortableServer_POAManagerFactory_ManagerAlreadyExists_type PortableServer_POAManagerFactory_ManagerAlreadyExists;
struct PortableServer_POAManagerFactory_ManagerAlreadyExists_type {
int dummy;
};
# 628 "../../include/orbit/poa/poa-defs.h"
extern

const struct CORBA_TypeCode_struct TC_PortableServer_POAManagerFactory_ManagerAlreadyExists_struct;
# 639 "../../include/orbit/poa/poa-defs.h"
typedef struct PortableServer_AdapterActivator_type *PortableServer_AdapterActivator;







typedef struct PortableServer_ServantManager_type *PortableServer_ServantManager;







typedef struct PortableServer_ServantActivator_type *PortableServer_ServantActivator;







typedef struct PortableServer_ServantLocator_type *PortableServer_ServantLocator;






typedef struct PortableServer_ServantLocator_Cookie_type *PortableServer_ServantLocator_Cookie;
# 684 "../../include/orbit/poa/poa-defs.h"
typedef struct PortableServer_POA_AdapterAlreadyExists_type PortableServer_POA_AdapterAlreadyExists;
struct PortableServer_POA_AdapterAlreadyExists_type {
int dummy;
};
# 701 "../../include/orbit/poa/poa-defs.h"
extern

const struct CORBA_TypeCode_struct TC_PortableServer_POA_AdapterAlreadyExists_struct;
# 713 "../../include/orbit/poa/poa-defs.h"
typedef struct PortableServer_POA_AdapterNonExistent_type PortableServer_POA_AdapterNonExistent;
struct PortableServer_POA_AdapterNonExistent_type {
int dummy;
};
# 730 "../../include/orbit/poa/poa-defs.h"
extern

const struct CORBA_TypeCode_struct TC_PortableServer_POA_AdapterNonExistent_struct;
# 742 "../../include/orbit/poa/poa-defs.h"
typedef struct PortableServer_POA_InvalidPolicy_type PortableServer_POA_InvalidPolicy;
struct PortableServer_POA_InvalidPolicy_type {
CORBA_unsigned_short index;
};
# 759 "../../include/orbit/poa/poa-defs.h"
extern

const struct CORBA_TypeCode_struct TC_PortableServer_POA_InvalidPolicy_struct;
# 771 "../../include/orbit/poa/poa-defs.h"
typedef struct PortableServer_POA_NoServant_type PortableServer_POA_NoServant;
struct PortableServer_POA_NoServant_type {
int dummy;
};
# 788 "../../include/orbit/poa/poa-defs.h"
extern

const struct CORBA_TypeCode_struct TC_PortableServer_POA_NoServant_struct;
# 800 "../../include/orbit/poa/poa-defs.h"
typedef struct PortableServer_POA_ObjectAlreadyActive_type PortableServer_POA_ObjectAlreadyActive;
struct PortableServer_POA_ObjectAlreadyActive_type {
int dummy;
};
# 817 "../../include/orbit/poa/poa-defs.h"
extern

const struct CORBA_TypeCode_struct TC_PortableServer_POA_ObjectAlreadyActive_struct;
# 829 "../../include/orbit/poa/poa-defs.h"
typedef struct PortableServer_POA_ObjectNotActive_type PortableServer_POA_ObjectNotActive;
struct PortableServer_POA_ObjectNotActive_type {
int dummy;
};
# 846 "../../include/orbit/poa/poa-defs.h"
extern

const struct CORBA_TypeCode_struct TC_PortableServer_POA_ObjectNotActive_struct;
# 858 "../../include/orbit/poa/poa-defs.h"
typedef struct PortableServer_POA_ServantAlreadyActive_type PortableServer_POA_ServantAlreadyActive;
struct PortableServer_POA_ServantAlreadyActive_type {
int dummy;
};
# 875 "../../include/orbit/poa/poa-defs.h"
extern

const struct CORBA_TypeCode_struct TC_PortableServer_POA_ServantAlreadyActive_struct;
# 887 "../../include/orbit/poa/poa-defs.h"
typedef struct PortableServer_POA_ServantNotActive_type PortableServer_POA_ServantNotActive;
struct PortableServer_POA_ServantNotActive_type {
int dummy;
};
# 904 "../../include/orbit/poa/poa-defs.h"
extern

const struct CORBA_TypeCode_struct TC_PortableServer_POA_ServantNotActive_struct;
# 916 "../../include/orbit/poa/poa-defs.h"
typedef struct PortableServer_POA_WrongAdapter_type PortableServer_POA_WrongAdapter;
struct PortableServer_POA_WrongAdapter_type {
int dummy;
};
# 933 "../../include/orbit/poa/poa-defs.h"
extern

const struct CORBA_TypeCode_struct TC_PortableServer_POA_WrongAdapter_struct;
# 945 "../../include/orbit/poa/poa-defs.h"
typedef struct PortableServer_POA_WrongPolicy_type PortableServer_POA_WrongPolicy;
struct PortableServer_POA_WrongPolicy_type {
int dummy;
};
# 962 "../../include/orbit/poa/poa-defs.h"
extern

const struct CORBA_TypeCode_struct TC_PortableServer_POA_WrongPolicy_struct;
# 973 "../../include/orbit/poa/poa-defs.h"
typedef struct PortableServer_Current_type *PortableServer_Current;
# 982 "../../include/orbit/poa/poa-defs.h"
typedef struct PortableServer_Current_NoContext_type PortableServer_Current_NoContext;
struct PortableServer_Current_NoContext_type {
int dummy;
};
# 999 "../../include/orbit/poa/poa-defs.h"
extern

const struct CORBA_TypeCode_struct TC_PortableServer_Current_NoContext_struct;
# 1012 "../../include/orbit/poa/poa-defs.h"
PortableServer_ThreadPolicyValue PortableServer_ThreadPolicy__get_value(PortableServer_ThreadPolicy _obj, CORBA_Environment *ev);



PortableServer_LifespanPolicyValue PortableServer_LifespanPolicy__get_value(PortableServer_LifespanPolicy _obj, CORBA_Environment *ev);



PortableServer_IdUniquenessPolicyValue PortableServer_IdUniquenessPolicy__get_value(PortableServer_IdUniquenessPolicy _obj, CORBA_Environment *ev);



PortableServer_IdAssignmentPolicyValue PortableServer_IdAssignmentPolicy__get_value(PortableServer_IdAssignmentPolicy _obj, CORBA_Environment *ev);



PortableServer_ImplicitActivationPolicyValue PortableServer_ImplicitActivationPolicy__get_value(PortableServer_ImplicitActivationPolicy _obj, CORBA_Environment *ev);



PortableServer_ServantRetentionPolicyValue PortableServer_ServantRetentionPolicy__get_value(PortableServer_ServantRetentionPolicy _obj, CORBA_Environment *ev);



PortableServer_RequestProcessingPolicyValue PortableServer_RequestProcessingPolicy__get_value(PortableServer_RequestProcessingPolicy _obj, CORBA_Environment *ev);
void PortableServer_POAManager_activate(PortableServer_POAManager _obj, CORBA_Environment *ev);
void PortableServer_POAManager_hold_requests(PortableServer_POAManager _obj, const CORBA_boolean wait_for_completion, CORBA_Environment *ev);
void PortableServer_POAManager_discard_requests(PortableServer_POAManager _obj, const CORBA_boolean wait_for_completion, CORBA_Environment *ev);
void PortableServer_POAManager_deactivate(PortableServer_POAManager _obj, const CORBA_boolean etherealize_objects, const CORBA_boolean wait_for_completion, CORBA_Environment *ev);
PortableServer_POAManager_State PortableServer_POAManager_get_state(PortableServer_POAManager _obj, CORBA_Environment *ev);
CORBA_string PortableServer_POAManager_get_id(PortableServer_POAManager _obj, CORBA_Environment *ev);
PortableServer_POAManager PortableServer_POAManagerFactory_create_POAManager(PortableServer_POAManagerFactory _obj, const CORBA_char * id, const CORBA_PolicyList* policies, CORBA_Environment *ev);
PortableServer_POAManagerFactory_POAManagerSeq* PortableServer_POAManagerFactory_list(PortableServer_POAManagerFactory _obj, CORBA_Environment *ev);
PortableServer_POAManager PortableServer_POAManagerFactory_find(PortableServer_POAManagerFactory _obj, const CORBA_char * id, CORBA_Environment *ev);
CORBA_boolean PortableServer_AdapterActivator_unknown_adapter(PortableServer_AdapterActivator _obj, const PortableServer_POA parent, const CORBA_char * name, CORBA_Environment *ev);
PortableServer_Servant PortableServer_ServantActivator_incarnate(PortableServer_ServantActivator _obj, const PortableServer_ObjectId* oid, const PortableServer_POA adapter, CORBA_Environment *ev);
void PortableServer_ServantActivator_etherealize(PortableServer_ServantActivator _obj, const PortableServer_ObjectId* oid, const PortableServer_POA adapter, const PortableServer_Servant serv, const CORBA_boolean cleanup_in_progress, const CORBA_boolean remaining_activations, CORBA_Environment *ev);
PortableServer_Servant PortableServer_ServantLocator_preinvoke(PortableServer_ServantLocator _obj, const PortableServer_ObjectId* oid, const PortableServer_POA adapter, const CORBA_char * operation, PortableServer_ServantLocator_Cookie the_cookie, CORBA_Environment *ev);
void PortableServer_ServantLocator_postinvoke(PortableServer_ServantLocator _obj, const PortableServer_ObjectId* oid, const PortableServer_POA adapter, const CORBA_char * operation, const PortableServer_ServantLocator_Cookie the_cookie, const PortableServer_Servant the_servant, CORBA_Environment *ev);
PortableServer_POA PortableServer_POA_create_POA(PortableServer_POA _obj, const CORBA_char * adapter_name, const PortableServer_POAManager a_POAManager, const CORBA_PolicyList* policies, CORBA_Environment *ev);
PortableServer_POA PortableServer_POA_find_POA(PortableServer_POA _obj, const CORBA_char * adapter_name, const CORBA_boolean activate_it, CORBA_Environment *ev);
void PortableServer_POA_destroy(PortableServer_POA _obj, const CORBA_boolean etherealize_objects, const CORBA_boolean wait_for_completion, CORBA_Environment *ev);
PortableServer_ThreadPolicy PortableServer_POA_create_thread_policy(PortableServer_POA _obj, const PortableServer_ThreadPolicyValue value, CORBA_Environment *ev);
PortableServer_LifespanPolicy PortableServer_POA_create_lifespan_policy(PortableServer_POA _obj, const PortableServer_LifespanPolicyValue value, CORBA_Environment *ev);
PortableServer_IdUniquenessPolicy PortableServer_POA_create_id_uniqueness_policy(PortableServer_POA _obj, const PortableServer_IdUniquenessPolicyValue value, CORBA_Environment *ev);
PortableServer_IdAssignmentPolicy PortableServer_POA_create_id_assignment_policy(PortableServer_POA _obj, const PortableServer_IdAssignmentPolicyValue value, CORBA_Environment *ev);
PortableServer_ImplicitActivationPolicy PortableServer_POA_create_implicit_activation_policy(PortableServer_POA _obj, const PortableServer_ImplicitActivationPolicyValue value, CORBA_Environment *ev);
PortableServer_ServantRetentionPolicy PortableServer_POA_create_servant_retention_policy(PortableServer_POA _obj, const PortableServer_ServantRetentionPolicyValue value, CORBA_Environment *ev);
PortableServer_RequestProcessingPolicy PortableServer_POA_create_request_processing_policy(PortableServer_POA _obj, const PortableServer_RequestProcessingPolicyValue value, CORBA_Environment *ev);
CORBA_string PortableServer_POA__get_the_name(PortableServer_POA _obj, CORBA_Environment *ev);
PortableServer_POA PortableServer_POA__get_the_parent(PortableServer_POA _obj, CORBA_Environment *ev);
PortableServer_POAList* PortableServer_POA__get_the_children(PortableServer_POA _obj, CORBA_Environment *ev);
PortableServer_POAManager PortableServer_POA__get_the_POAManager(PortableServer_POA _obj, CORBA_Environment *ev);
PortableServer_AdapterActivator PortableServer_POA__get_the_activator(PortableServer_POA _obj, CORBA_Environment *ev);
void PortableServer_POA__set_the_activator(PortableServer_POA _obj, const PortableServer_AdapterActivator value, CORBA_Environment *ev);
PortableServer_ServantManager PortableServer_POA_get_servant_manager(PortableServer_POA _obj, CORBA_Environment *ev);
void PortableServer_POA_set_servant_manager(PortableServer_POA _obj, const PortableServer_ServantManager imgr, CORBA_Environment *ev);
PortableServer_Servant PortableServer_POA_get_servant(PortableServer_POA _obj, CORBA_Environment *ev);
void PortableServer_POA_set_servant(PortableServer_POA _obj, const PortableServer_Servant p_servant, CORBA_Environment *ev);
PortableServer_ObjectId* PortableServer_POA_activate_object(PortableServer_POA _obj, const PortableServer_Servant p_servant, CORBA_Environment *ev);
void PortableServer_POA_activate_object_with_id(PortableServer_POA _obj, const PortableServer_ObjectId* id, const PortableServer_Servant p_servant, CORBA_Environment *ev);
void PortableServer_POA_deactivate_object(PortableServer_POA _obj, const PortableServer_ObjectId* oid, CORBA_Environment *ev);
CORBA_Object PortableServer_POA_create_reference(PortableServer_POA _obj, const CORBA_char * intf, CORBA_Environment *ev);
CORBA_Object PortableServer_POA_create_reference_with_id(PortableServer_POA _obj, const PortableServer_ObjectId* oid, const CORBA_char * intf, CORBA_Environment *ev);
PortableServer_ObjectId* PortableServer_POA_servant_to_id(PortableServer_POA _obj, const PortableServer_Servant p_servant, CORBA_Environment *ev);
CORBA_Object PortableServer_POA_servant_to_reference(PortableServer_POA _obj, const PortableServer_Servant p_servant, CORBA_Environment *ev);
PortableServer_Servant PortableServer_POA_reference_to_servant(PortableServer_POA _obj, const CORBA_Object reference, CORBA_Environment *ev);
PortableServer_ObjectId* PortableServer_POA_reference_to_id(PortableServer_POA _obj, const CORBA_Object reference, CORBA_Environment *ev);
PortableServer_Servant PortableServer_POA_id_to_servant(PortableServer_POA _obj, const PortableServer_ObjectId* oid, CORBA_Environment *ev);
CORBA_Object PortableServer_POA_id_to_reference(PortableServer_POA _obj, const PortableServer_ObjectId* oid, CORBA_Environment *ev);
CORBA_OctetSeq* PortableServer_POA__get_id(PortableServer_POA _obj, CORBA_Environment *ev);
PortableServer_POAManagerFactory PortableServer_POA__get_the_POAManagerFactory(PortableServer_POA _obj, CORBA_Environment *ev);
PortableServer_POA PortableServer_Current_get_POA(PortableServer_Current _obj, CORBA_Environment *ev);
PortableServer_ObjectId* PortableServer_Current_get_object_id(PortableServer_Current _obj, CORBA_Environment *ev);
CORBA_Object PortableServer_Current_get_reference(PortableServer_Current _obj, CORBA_Environment *ev);
PortableServer_Servant PortableServer_Current_get_servant(PortableServer_Current _obj, CORBA_Environment *ev);
# 1098 "../../include/orbit/poa/poa-defs.h"
# 1 "../../include/orbit/orbit.h" 1
# 1099 "../../include/orbit/poa/poa-defs.h" 2
# 5 "../../include/orbit/poa/poa.h" 2
# 1 "../../include/orbit/poa/poa-types.h" 1



# 1 "../../include/orbit/poa/orbit-adaptor.h" 1








typedef enum {
 ORBIT_THREAD_HINT_NONE = 0,
 ORBIT_THREAD_HINT_PER_OBJECT,
 ORBIT_THREAD_HINT_PER_REQUEST,
 ORBIT_THREAD_HINT_PER_POA,
 ORBIT_THREAD_HINT_PER_CONNECTION,
 ORBIT_THREAD_HINT_ONEWAY_AT_IDLE,
 ORBIT_THREAD_HINT_ALL_AT_IDLE,
 ORBIT_THREAD_HINT_ON_CONTEXT
} ORBitThreadHint;

typedef struct ORBit_ObjectAdaptor_type *ORBit_ObjectAdaptor;

void ORBit_ObjectAdaptor_set_thread_hint (ORBit_ObjectAdaptor adaptor,
            ORBitThreadHint thread_hint,
            ...);
void ORBit_ObjectAdaptor_set_thread_hintv (ORBit_ObjectAdaptor adaptor,
            ORBitThreadHint thread_hint,
            va_list args);
ORBitThreadHint ORBit_ObjectAdaptor_get_thread_hint (ORBit_ObjectAdaptor adaptor);

void ORBit_ObjectAdaptor_object_bind_to_current_thread (CORBA_Object obj);




void ORBit_handle_locate_request (CORBA_ORB orb,
           GIOPRecvBuffer *recv_buffer);

void ORBit_handle_request (CORBA_ORB orb,
           GIOPRecvBuffer *recv_buffer);

void ORBit_small_handle_request (ORBit_OAObject adaptor_obj,
           CORBA_Identifier opname,
           gpointer ret,
           gpointer *args,
           CORBA_Context ctx,
           GIOPRecvBuffer *recv_buffer,
           CORBA_Environment *ev);

gboolean ORBit_OAObject_is_active (ORBit_OAObject adaptor_obj);

ORBit_ObjectKey *ORBit_OAObject_object_to_objkey (ORBit_OAObject adaptor_obj);

void ORBit_OAObject_invoke (ORBit_OAObject adaptor_obj,
           gpointer ret,
           gpointer *args,
           CORBA_Context ctx,
           gpointer data,
           CORBA_Environment *ev);




typedef gboolean (*ORBitStateCheckFunc) (ORBit_OAObject adaptor_obj);

typedef ORBit_ObjectKey *(*ORBitKeyGenFunc) (ORBit_OAObject adaptor_obj);

typedef void (*ORBitInvokeFunc) (ORBit_OAObject adaptor_obj,
          gpointer ret,
          gpointer *args,
          CORBA_Context ctx,
          gpointer data,
          CORBA_Environment *ev);

typedef void (*ORBitReqFunc) (ORBit_OAObject adaptor_obj,
          CORBA_Identifier opname,
          gpointer ret,
          gpointer *args,
          CORBA_Context ctx,
          GIOPRecvBuffer *recv_buffer,
          CORBA_Environment *ev);

typedef enum {
 ORBIT_ADAPTOR_POA = 1 << 0
} ORBit_Adaptor_type;

struct ORBit_OAObject_Interface_type {
 ORBit_Adaptor_type adaptor_type;

 ORBitStateCheckFunc is_active;
 ORBitKeyGenFunc object_to_objkey;
 ORBitInvokeFunc invoke;
 ORBitReqFunc handle_request;
};

typedef struct ORBit_OAObject_Interface_type *ORBit_OAObject_Interface;

struct ORBit_OAObject_type {
 struct ORBit_RootObject_struct parent;

 CORBA_Object objref;

 ORBit_OAObject_Interface interface;
};





typedef CORBA_sequence_CORBA_octet ORBit_AdaptorKey;

typedef void (*ORBitReqHandlerFunc) (ORBit_ObjectAdaptor adaptor,
         GIOPRecvBuffer *recv_buffer,
         ORBit_ObjectKey *objkey);

struct ORBit_ObjectAdaptor_type {
 struct ORBit_RootObject_struct parent;

 GMutex *lock;

 ORBitReqHandlerFunc handle_request;

 ORBit_AdaptorKey adaptor_key;

 ORBitThreadHint thread_hint;

 GMainContext *context;
};

int ORBit_adaptor_setup (ORBit_ObjectAdaptor adaptor, CORBA_ORB orb);




# 5 "../../include/orbit/poa/poa-types.h" 2





typedef struct {
 void (*dummy_padding) (void);
 ORBit_impl_finder impl_finder;
 const char *class_name;
 CORBA_unsigned_long *class_id;
 ORBit_VepvIdx *vepvmap;
 ORBit_IInterface *idata;
} PortableServer_ClassInfo;





struct ORBit_POAObject_type {
 struct ORBit_OAObject_type base;

 PortableServer_Servant servant;
 PortableServer_POA poa;
 PortableServer_ObjectId *object_id;

 ORBit_VepvIdx *vepvmap_cache;

 guint16 life_flags;
 guint16 use_cnt;

 ORBit_POAObject next;
};
# 57 "../../include/orbit/poa/poa-types.h"
void
ORBit_c_stub_invoke (CORBA_Object obj,
       ORBit_IMethods *methods,
       glong method_index,
       gpointer ret,
       gpointer args,
       CORBA_Context ctx,
       CORBA_Environment *ev,
       glong class_id,
       glong method_offset,
       ORBitSmallSkeleton skel_impl);
# 86 "../../include/orbit/poa/poa-types.h"

# 6 "../../include/orbit/poa/poa.h" 2



typedef struct {
 void *_private;
} POA_PortableServer_ServantManager__epv;

typedef struct {
 void *_private;

 PortableServer_Servant(*incarnate) (PortableServer_Servant _servant,
         const PortableServer_ObjectId *
         oid,
         const PortableServer_POA adapter,
         CORBA_Environment * ev);
 void (*etherealize) (PortableServer_Servant _servant,
        const PortableServer_ObjectId * oid,
        const PortableServer_POA adapter,
        const PortableServer_Servant serv,
        const CORBA_boolean cleanup_in_progress,
        const CORBA_boolean remaining_activations,
        CORBA_Environment * ev);
} POA_PortableServer_ServantActivator__epv;
typedef struct {
 PortableServer_ServantBase__epv *_base_epv;
 POA_PortableServer_ServantManager__epv
  *PortableServer_ServantManager_epv;
 POA_PortableServer_ServantActivator__epv
  *PortableServer_ServantActivator_epv;
} POA_PortableServer_ServantActivator__vepv;

typedef struct {
 void *_private;
 POA_PortableServer_ServantActivator__vepv *vepv;
} POA_PortableServer_ServantActivator;

typedef struct {
 void *_private;

 PortableServer_Servant(*preinvoke) (PortableServer_Servant _servant,
         const PortableServer_ObjectId *
         oid,
         const PortableServer_POA adapter,
         const CORBA_Identifier operation,
         PortableServer_ServantLocator_Cookie
         * the_cookie,
         CORBA_Environment * ev);
 void (*postinvoke) (PortableServer_Servant _servant,
       const PortableServer_ObjectId * oid,
       const PortableServer_POA adapter,
       const CORBA_Identifier operation,
       const PortableServer_ServantLocator_Cookie
       the_cookie,
       const PortableServer_Servant the_servant,
       CORBA_Environment * ev);
} POA_PortableServer_ServantLocator__epv;
typedef struct {
 PortableServer_ServantBase__epv *_base_epv;
 POA_PortableServer_ServantManager__epv
  *PortableServer_ServantManager_epv;
 POA_PortableServer_ServantLocator__epv
  *PortableServer_ServantLocator_epv;
} POA_PortableServer_ServantLocator__vepv;
typedef struct {
 void *_private;
 POA_PortableServer_ServantLocator__vepv *vepv;
} POA_PortableServer_ServantLocator;

# 1 "../../include/orbit/poa/portableserver-poa-type.h" 1









struct PortableServer_POAManager_type {
 struct ORBit_RootObject_struct parent;

 GSList *poa_collection;
 PortableServer_POAManager_State state;
 CORBA_ORB orb;
};

struct PortableServer_POA_type {
 struct ORBit_ObjectAdaptor_type base;

 guint16 use_cnt;
 guint16 life_flags;
 int poa_id;
 int next_sysid;
 char *name;
 CORBA_ORB orb;
 PortableServer_POA parent_poa;
 PortableServer_POAManager poa_manager;
 PortableServer_AdapterActivator the_activator;
 PortableServer_ServantManager servant_manager;
 PortableServer_Servant default_servant;

 GHashTable *oid_to_obj_map;
 CORBA_unsigned_long next_id;

 GSList *held_requests;
 GHashTable *child_poas;

 PortableServer_ThreadPolicyValue p_thread;
 PortableServer_LifespanPolicyValue p_lifespan;
 PortableServer_IdUniquenessPolicyValue p_id_uniqueness;
 PortableServer_IdAssignmentPolicyValue p_id_assignment;
 PortableServer_ImplicitActivationPolicyValue p_implicit_activation;
 PortableServer_ServantRetentionPolicyValue p_servant_retention;
 PortableServer_RequestProcessingPolicyValue p_request_processing;
};




# 75 "../../include/orbit/poa/poa.h" 2
# 1 "../../include/orbit/poa/portableserver-current-type.h" 1









struct PortableServer_Current_type {
        struct ORBit_RootObject_struct parent;

        CORBA_ORB orb;
};




# 76 "../../include/orbit/poa/poa.h" 2

void PortableServer_ServantBase__init (PortableServer_Servant servant,
      CORBA_Environment *ev);
void PortableServer_ServantBase__fini (PortableServer_Servant servant,
      CORBA_Environment *ev);

void PortableServer_RefCountServantBase__init (PortableServer_Servant servant,
      CORBA_Environment *ev);
void PortableServer_RefCountServantBase__fini (PortableServer_Servant servant,
      CORBA_Environment *ev);

void PortableServer_ServantBase__add_ref (PortableServer_Servant servant,
      CORBA_Environment *ev);
void PortableServer_ServantBase__remove_ref (PortableServer_Servant servant,
      CORBA_Environment *ev);

void PortableServer_RefCountServantBase__add_ref (PortableServer_Servant servant,
           CORBA_Environment *ev);
void PortableServer_RefCountServantBase__remove_ref (PortableServer_Servant servant,
           CORBA_Environment *ev);

PortableServer_POA
     PortableServer_ServantBase__default_POA (PortableServer_Servant servant,
      CORBA_Environment *ev);
CORBA_InterfaceDef
     PortableServer_ServantBase__get_interface (PortableServer_Servant servant,
      CORBA_Environment *ev);
CORBA_boolean
     PortableServer_ServantBase__is_a (PortableServer_Servant servant,
      const CORBA_char *logical_type_id,
      CORBA_Environment *ev);
# 115 "../../include/orbit/poa/poa.h"
PortableServer_ObjectId *PortableServer_string_to_ObjectId(CORBA_char *str,
                                                           CORBA_Environment *nv);

PortableServer_ObjectId *PortableServer_wstring_to_ObjectId(CORBA_wchar *str,
                                                            CORBA_Environment *ev);

CORBA_char *PortableServer_ObjectId_to_string(PortableServer_ObjectId *oid,
                                              CORBA_Environment *ev);

CORBA_wchar *PortableServer_ObjectId_to_wstring(PortableServer_ObjectId *oid,
                                                CORBA_Environment *ev);


PortableServer_POA ORBit_POA_new_from (CORBA_ORB orb,
           PortableServer_POA parent,
           const CORBA_char *adaptor_name,
           const CORBA_PolicyList *opt_policies,
           CORBA_Environment *ev);



void ORBit_skel_class_register (PortableServer_ClassInfo *ci,
    PortableServer_ServantBase *servant,
    void (*opt_finalize) (PortableServer_Servant,
            CORBA_Environment *),
    CORBA_unsigned_long class_offset,
    CORBA_unsigned_long first_parent_id,
    ...);


void ORBit_classinfo_register (PortableServer_ClassInfo *ci);
# 154 "../../include/orbit/poa/poa.h"
PortableServer_ClassInfo *ORBit_classinfo_lookup (const char *type_id);
void ORBit_POAObject_post_invoke (ORBit_POAObject obj);
gboolean ORBit_poa_allow_cross_thread_call (ORBit_POAObject pobj,
          ORBit_IMethodFlag method_flags);
void ORBit_recv_buffer_return_sys_exception (GIOPRecvBuffer *buf,
          CORBA_Environment *ev);
void ORBit_poa_init (void);




# 19 "../../include/orbit/orbit.h" 2
# 1 "../../include/orbit/dynamic/dynamic.h" 1
# 1 "../../include/orbit/dynamic/dynamic-defs.h" 1
# 20 "../../include/orbit/dynamic/dynamic-defs.h"
typedef struct DynamicAny_DynAny_type *DynamicAny_DynAny;
# 29 "../../include/orbit/dynamic/dynamic-defs.h"
typedef struct DynamicAny_DynAny_InvalidValue_type DynamicAny_DynAny_InvalidValue;
struct DynamicAny_DynAny_InvalidValue_type {
int dummy;
};
# 50 "../../include/orbit/dynamic/dynamic-defs.h"
extern

const struct CORBA_TypeCode_struct TC_DynamicAny_DynAny_InvalidValue_struct;
# 62 "../../include/orbit/dynamic/dynamic-defs.h"
typedef struct DynamicAny_DynAny_TypeMismatch_type DynamicAny_DynAny_TypeMismatch;
struct DynamicAny_DynAny_TypeMismatch_type {
int dummy;
};
# 83 "../../include/orbit/dynamic/dynamic-defs.h"
extern

const struct CORBA_TypeCode_struct TC_DynamicAny_DynAny_TypeMismatch_struct;
# 94 "../../include/orbit/dynamic/dynamic-defs.h"
typedef struct DynamicAny_DynFixed_type *DynamicAny_DynFixed;







typedef struct DynamicAny_DynEnum_type *DynamicAny_DynEnum;






typedef CORBA_string DynamicAny_FieldName;
# 128 "../../include/orbit/dynamic/dynamic-defs.h"
extern

const struct CORBA_TypeCode_struct TC_DynamicAny_FieldName_struct;







typedef struct DynamicAny_NameValuePair_type DynamicAny_NameValuePair;
struct DynamicAny_NameValuePair_type {
DynamicAny_FieldName id;
CORBA_any value;
};
# 160 "../../include/orbit/dynamic/dynamic-defs.h"
extern

const struct CORBA_TypeCode_struct TC_DynamicAny_NameValuePair_struct;
# 184 "../../include/orbit/dynamic/dynamic-defs.h"
typedef struct { CORBA_unsigned_long _maximum, _length; DynamicAny_NameValuePair* _buffer; CORBA_boolean _release; } CORBA_sequence_DynamicAny_NameValuePair;
# 202 "../../include/orbit/dynamic/dynamic-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_DynamicAny_NameValuePair_struct;
# 214 "../../include/orbit/dynamic/dynamic-defs.h"
typedef CORBA_sequence_DynamicAny_NameValuePair DynamicAny_NameValuePairSeq;
# 233 "../../include/orbit/dynamic/dynamic-defs.h"
extern

const struct CORBA_TypeCode_struct TC_DynamicAny_NameValuePairSeq_struct;
# 244 "../../include/orbit/dynamic/dynamic-defs.h"
typedef struct DynamicAny_NameDynAnyPair_type DynamicAny_NameDynAnyPair;
struct DynamicAny_NameDynAnyPair_type {
DynamicAny_FieldName id;
DynamicAny_DynAny value;
};
# 266 "../../include/orbit/dynamic/dynamic-defs.h"
extern

const struct CORBA_TypeCode_struct TC_DynamicAny_NameDynAnyPair_struct;
# 290 "../../include/orbit/dynamic/dynamic-defs.h"
typedef struct { CORBA_unsigned_long _maximum, _length; DynamicAny_NameDynAnyPair* _buffer; CORBA_boolean _release; } CORBA_sequence_DynamicAny_NameDynAnyPair;
# 308 "../../include/orbit/dynamic/dynamic-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_DynamicAny_NameDynAnyPair_struct;
# 320 "../../include/orbit/dynamic/dynamic-defs.h"
typedef CORBA_sequence_DynamicAny_NameDynAnyPair DynamicAny_NameDynAnyPairSeq;
# 339 "../../include/orbit/dynamic/dynamic-defs.h"
extern

const struct CORBA_TypeCode_struct TC_DynamicAny_NameDynAnyPairSeq_struct;
# 351 "../../include/orbit/dynamic/dynamic-defs.h"
typedef struct DynamicAny_DynStruct_type *DynamicAny_DynStruct;







typedef struct DynamicAny_DynUnion_type *DynamicAny_DynUnion;
# 410 "../../include/orbit/dynamic/dynamic-defs.h"
typedef CORBA_sequence_CORBA_any DynamicAny_AnySeq;
# 429 "../../include/orbit/dynamic/dynamic-defs.h"
extern

const struct CORBA_TypeCode_struct TC_DynamicAny_AnySeq_struct;
# 498 "../../include/orbit/dynamic/dynamic-defs.h"
typedef CORBA_sequence_CORBA_Object CORBA_sequence_DynamicAny_DynAny;
# 516 "../../include/orbit/dynamic/dynamic-defs.h"
extern

const struct CORBA_TypeCode_struct TC_CORBA_sequence_DynamicAny_DynAny_struct;
# 529 "../../include/orbit/dynamic/dynamic-defs.h"
typedef CORBA_sequence_DynamicAny_DynAny DynamicAny_DynAnySeq;
# 548 "../../include/orbit/dynamic/dynamic-defs.h"
extern

const struct CORBA_TypeCode_struct TC_DynamicAny_DynAnySeq_struct;
# 560 "../../include/orbit/dynamic/dynamic-defs.h"
typedef struct DynamicAny_DynSequence_type *DynamicAny_DynSequence;







typedef struct DynamicAny_DynArray_type *DynamicAny_DynArray;







typedef struct DynamicAny_DynValueCommon_type *DynamicAny_DynValueCommon;







typedef struct DynamicAny_DynValue_type *DynamicAny_DynValue;







typedef struct DynamicAny_DynValueBox_type *DynamicAny_DynValueBox;
# 601 "../../include/orbit/dynamic/dynamic-defs.h"
typedef struct DynamicAny_MustTruncate_type DynamicAny_MustTruncate;
struct DynamicAny_MustTruncate_type {
int dummy;
};
# 622 "../../include/orbit/dynamic/dynamic-defs.h"
extern

const struct CORBA_TypeCode_struct TC_DynamicAny_MustTruncate_struct;
# 633 "../../include/orbit/dynamic/dynamic-defs.h"
typedef struct DynamicAny_DynAnyFactory_type *DynamicAny_DynAnyFactory;
# 642 "../../include/orbit/dynamic/dynamic-defs.h"
typedef struct DynamicAny_DynAnyFactory_InconsistentTypeCode_type DynamicAny_DynAnyFactory_InconsistentTypeCode;
struct DynamicAny_DynAnyFactory_InconsistentTypeCode_type {
int dummy;
};
# 663 "../../include/orbit/dynamic/dynamic-defs.h"
extern

const struct CORBA_TypeCode_struct TC_DynamicAny_DynAnyFactory_InconsistentTypeCode_struct;







CORBA_TypeCode DynamicAny_DynAny_type(DynamicAny_DynAny _obj, CORBA_Environment *ev);
void DynamicAny_DynAny_assign(DynamicAny_DynAny _obj, const DynamicAny_DynAny dyn_any, CORBA_Environment *ev);
void DynamicAny_DynAny_from_any(DynamicAny_DynAny _obj, const CORBA_any* value, CORBA_Environment *ev);
CORBA_any* DynamicAny_DynAny_to_any(DynamicAny_DynAny _obj, CORBA_Environment *ev);
CORBA_boolean DynamicAny_DynAny_equal(DynamicAny_DynAny _obj, const DynamicAny_DynAny dyn_any, CORBA_Environment *ev);
void DynamicAny_DynAny_destroy(DynamicAny_DynAny _obj, CORBA_Environment *ev);
DynamicAny_DynAny DynamicAny_DynAny_copy(DynamicAny_DynAny _obj, CORBA_Environment *ev);
void DynamicAny_DynAny_insert_boolean(DynamicAny_DynAny _obj, const CORBA_boolean value, CORBA_Environment *ev);
void DynamicAny_DynAny_insert_octet(DynamicAny_DynAny _obj, const CORBA_octet value, CORBA_Environment *ev);
void DynamicAny_DynAny_insert_char(DynamicAny_DynAny _obj, const CORBA_char value, CORBA_Environment *ev);
void DynamicAny_DynAny_insert_short(DynamicAny_DynAny _obj, const CORBA_short value, CORBA_Environment *ev);
void DynamicAny_DynAny_insert_ushort(DynamicAny_DynAny _obj, const CORBA_unsigned_short value, CORBA_Environment *ev);
void DynamicAny_DynAny_insert_long(DynamicAny_DynAny _obj, const CORBA_long value, CORBA_Environment *ev);
void DynamicAny_DynAny_insert_ulong(DynamicAny_DynAny _obj, const CORBA_unsigned_long value, CORBA_Environment *ev);
void DynamicAny_DynAny_insert_float(DynamicAny_DynAny _obj, const CORBA_float value, CORBA_Environment *ev);
void DynamicAny_DynAny_insert_double(DynamicAny_DynAny _obj, const CORBA_double value, CORBA_Environment *ev);
void DynamicAny_DynAny_insert_string(DynamicAny_DynAny _obj, const CORBA_char * value, CORBA_Environment *ev);
void DynamicAny_DynAny_insert_reference(DynamicAny_DynAny _obj, const CORBA_Object value, CORBA_Environment *ev);
void DynamicAny_DynAny_insert_typecode(DynamicAny_DynAny _obj, const CORBA_TypeCode value, CORBA_Environment *ev);
void DynamicAny_DynAny_insert_longlong(DynamicAny_DynAny _obj, const CORBA_long_long value, CORBA_Environment *ev);
void DynamicAny_DynAny_insert_ulonglong(DynamicAny_DynAny _obj, const CORBA_unsigned_long_long value, CORBA_Environment *ev);
void DynamicAny_DynAny_insert_longdouble(DynamicAny_DynAny _obj, const CORBA_long_double value, CORBA_Environment *ev);
void DynamicAny_DynAny_insert_wchar(DynamicAny_DynAny _obj, const CORBA_wchar value, CORBA_Environment *ev);
void DynamicAny_DynAny_insert_wstring(DynamicAny_DynAny _obj, const CORBA_wstring value, CORBA_Environment *ev);
void DynamicAny_DynAny_insert_any(DynamicAny_DynAny _obj, const CORBA_any* value, CORBA_Environment *ev);
void DynamicAny_DynAny_insert_dyn_any(DynamicAny_DynAny _obj, const DynamicAny_DynAny value, CORBA_Environment *ev);
CORBA_boolean DynamicAny_DynAny_get_boolean(DynamicAny_DynAny _obj, CORBA_Environment *ev);
CORBA_octet DynamicAny_DynAny_get_octet(DynamicAny_DynAny _obj, CORBA_Environment *ev);
CORBA_char DynamicAny_DynAny_get_char(DynamicAny_DynAny _obj, CORBA_Environment *ev);
CORBA_short DynamicAny_DynAny_get_short(DynamicAny_DynAny _obj, CORBA_Environment *ev);
CORBA_unsigned_short DynamicAny_DynAny_get_ushort(DynamicAny_DynAny _obj, CORBA_Environment *ev);
CORBA_long DynamicAny_DynAny_get_long(DynamicAny_DynAny _obj, CORBA_Environment *ev);
CORBA_unsigned_long DynamicAny_DynAny_get_ulong(DynamicAny_DynAny _obj, CORBA_Environment *ev);
CORBA_float DynamicAny_DynAny_get_float(DynamicAny_DynAny _obj, CORBA_Environment *ev);
CORBA_double DynamicAny_DynAny_get_double(DynamicAny_DynAny _obj, CORBA_Environment *ev);
CORBA_string DynamicAny_DynAny_get_string(DynamicAny_DynAny _obj, CORBA_Environment *ev);
CORBA_Object DynamicAny_DynAny_get_reference(DynamicAny_DynAny _obj, CORBA_Environment *ev);
CORBA_TypeCode DynamicAny_DynAny_get_typecode(DynamicAny_DynAny _obj, CORBA_Environment *ev);
CORBA_long_long DynamicAny_DynAny_get_longlong(DynamicAny_DynAny _obj, CORBA_Environment *ev);
CORBA_unsigned_long_long DynamicAny_DynAny_get_ulonglong(DynamicAny_DynAny _obj, CORBA_Environment *ev);
CORBA_long_double DynamicAny_DynAny_get_longdouble(DynamicAny_DynAny _obj, CORBA_Environment *ev);
CORBA_wchar DynamicAny_DynAny_get_wchar(DynamicAny_DynAny _obj, CORBA_Environment *ev);
CORBA_wstring DynamicAny_DynAny_get_wstring(DynamicAny_DynAny _obj, CORBA_Environment *ev);
CORBA_any* DynamicAny_DynAny_get_any(DynamicAny_DynAny _obj, CORBA_Environment *ev);
DynamicAny_DynAny DynamicAny_DynAny_get_dyn_any(DynamicAny_DynAny _obj, CORBA_Environment *ev);
CORBA_boolean DynamicAny_DynAny_seek(DynamicAny_DynAny _obj, const CORBA_long index, CORBA_Environment *ev);
void DynamicAny_DynAny_rewind(DynamicAny_DynAny _obj, CORBA_Environment *ev);
CORBA_boolean DynamicAny_DynAny_next(DynamicAny_DynAny _obj, CORBA_Environment *ev);
CORBA_unsigned_long DynamicAny_DynAny_component_count(DynamicAny_DynAny _obj, CORBA_Environment *ev);
DynamicAny_DynAny DynamicAny_DynAny_current_component(DynamicAny_DynAny _obj, CORBA_Environment *ev);
void DynamicAny_DynAny_insert_abstract(DynamicAny_DynAny _obj, const CORBA_AbstractBase value, CORBA_Environment *ev);
CORBA_AbstractBase DynamicAny_DynAny_get_abstract(DynamicAny_DynAny _obj, CORBA_Environment *ev);
void DynamicAny_DynAny_insert_boolean_seq(DynamicAny_DynAny _obj, const CORBA_BooleanSeq* value, CORBA_Environment *ev);
void DynamicAny_DynAny_insert_octet_seq(DynamicAny_DynAny _obj, const CORBA_OctetSeq* value, CORBA_Environment *ev);
void DynamicAny_DynAny_insert_char_seq(DynamicAny_DynAny _obj, const CORBA_CharSeq* value, CORBA_Environment *ev);
void DynamicAny_DynAny_insert_short_seq(DynamicAny_DynAny _obj, const CORBA_ShortSeq* value, CORBA_Environment *ev);
void DynamicAny_DynAny_insert_ushort_seq(DynamicAny_DynAny _obj, const CORBA_UShortSeq* value, CORBA_Environment *ev);
void DynamicAny_DynAny_insert_long_seq(DynamicAny_DynAny _obj, const CORBA_LongSeq* value, CORBA_Environment *ev);
void DynamicAny_DynAny_insert_ulong_seq(DynamicAny_DynAny _obj, const CORBA_ULongSeq* value, CORBA_Environment *ev);
void DynamicAny_DynAny_insert_float_seq(DynamicAny_DynAny _obj, const CORBA_FloatSeq* value, CORBA_Environment *ev);
void DynamicAny_DynAny_insert_double_seq(DynamicAny_DynAny _obj, const CORBA_DoubleSeq* value, CORBA_Environment *ev);
void DynamicAny_DynAny_insert_longlong_seq(DynamicAny_DynAny _obj, const CORBA_LongLongSeq* value, CORBA_Environment *ev);
void DynamicAny_DynAny_insert_ulonglong_seq(DynamicAny_DynAny _obj, const CORBA_ULongLongSeq* value, CORBA_Environment *ev);
void DynamicAny_DynAny_insert_longdouble_seq(DynamicAny_DynAny _obj, const CORBA_LongDoubleSeq* value, CORBA_Environment *ev);
void DynamicAny_DynAny_insert_wchar_seq(DynamicAny_DynAny _obj, const CORBA_WCharSeq* value, CORBA_Environment *ev);
CORBA_BooleanSeq* DynamicAny_DynAny_get_boolean_seq(DynamicAny_DynAny _obj, CORBA_Environment *ev);
CORBA_OctetSeq* DynamicAny_DynAny_get_octet_seq(DynamicAny_DynAny _obj, CORBA_Environment *ev);
CORBA_CharSeq* DynamicAny_DynAny_get_char_seq(DynamicAny_DynAny _obj, CORBA_Environment *ev);
CORBA_ShortSeq* DynamicAny_DynAny_get_short_seq(DynamicAny_DynAny _obj, CORBA_Environment *ev);
CORBA_UShortSeq* DynamicAny_DynAny_get_ushort_seq(DynamicAny_DynAny _obj, CORBA_Environment *ev);
CORBA_LongSeq* DynamicAny_DynAny_get_long_seq(DynamicAny_DynAny _obj, CORBA_Environment *ev);
CORBA_ULongSeq* DynamicAny_DynAny_get_ulong_seq(DynamicAny_DynAny _obj, CORBA_Environment *ev);
CORBA_FloatSeq* DynamicAny_DynAny_get_float_seq(DynamicAny_DynAny _obj, CORBA_Environment *ev);
CORBA_DoubleSeq* DynamicAny_DynAny_get_double_seq(DynamicAny_DynAny _obj, CORBA_Environment *ev);
CORBA_LongLongSeq* DynamicAny_DynAny_get_longlong_seq(DynamicAny_DynAny _obj, CORBA_Environment *ev);
CORBA_ULongLongSeq* DynamicAny_DynAny_get_ulonglong_seq(DynamicAny_DynAny _obj, CORBA_Environment *ev);
CORBA_LongDoubleSeq* DynamicAny_DynAny_get_longdouble_seq(DynamicAny_DynAny _obj, CORBA_Environment *ev);
CORBA_WCharSeq* DynamicAny_DynAny_get_wchar_seq(DynamicAny_DynAny _obj, CORBA_Environment *ev);
# 829 "../../include/orbit/dynamic/dynamic-defs.h"
CORBA_string DynamicAny_DynFixed_get_value(DynamicAny_DynFixed _obj, CORBA_Environment *ev);
CORBA_boolean DynamicAny_DynFixed_set_value(DynamicAny_DynFixed _obj, const CORBA_char * val, CORBA_Environment *ev);
# 909 "../../include/orbit/dynamic/dynamic-defs.h"
CORBA_string DynamicAny_DynEnum_get_as_string(DynamicAny_DynEnum _obj, CORBA_Environment *ev);
void DynamicAny_DynEnum_set_as_string(DynamicAny_DynEnum _obj, const CORBA_char * value, CORBA_Environment *ev);
CORBA_unsigned_long DynamicAny_DynEnum_get_as_ulong(DynamicAny_DynEnum _obj, CORBA_Environment *ev);
void DynamicAny_DynEnum_set_as_ulong(DynamicAny_DynEnum _obj, const CORBA_unsigned_long value, CORBA_Environment *ev);
# 991 "../../include/orbit/dynamic/dynamic-defs.h"
DynamicAny_FieldName DynamicAny_DynStruct_current_member_name(DynamicAny_DynStruct _obj, CORBA_Environment *ev);
CORBA_TCKind DynamicAny_DynStruct_current_member_kind(DynamicAny_DynStruct _obj, CORBA_Environment *ev);
DynamicAny_NameValuePairSeq* DynamicAny_DynStruct_get_members(DynamicAny_DynStruct _obj, CORBA_Environment *ev);
void DynamicAny_DynStruct_set_members(DynamicAny_DynStruct _obj, const DynamicAny_NameValuePairSeq* value, CORBA_Environment *ev);
DynamicAny_NameDynAnyPairSeq* DynamicAny_DynStruct_get_members_as_dyn_any(DynamicAny_DynStruct _obj, CORBA_Environment *ev);
void DynamicAny_DynStruct_set_members_as_dyn_any(DynamicAny_DynStruct _obj, const DynamicAny_NameDynAnyPairSeq* value, CORBA_Environment *ev);
# 1075 "../../include/orbit/dynamic/dynamic-defs.h"
DynamicAny_DynAny DynamicAny_DynUnion_get_discriminator(DynamicAny_DynUnion _obj, CORBA_Environment *ev);
void DynamicAny_DynUnion_set_discriminator(DynamicAny_DynUnion _obj, const DynamicAny_DynAny d, CORBA_Environment *ev);
void DynamicAny_DynUnion_set_to_default_member(DynamicAny_DynUnion _obj, CORBA_Environment *ev);
void DynamicAny_DynUnion_set_to_no_active_member(DynamicAny_DynUnion _obj, CORBA_Environment *ev);
CORBA_boolean DynamicAny_DynUnion_has_no_active_member(DynamicAny_DynUnion _obj, CORBA_Environment *ev);
CORBA_TCKind DynamicAny_DynUnion_discriminator_kind(DynamicAny_DynUnion _obj, CORBA_Environment *ev);
DynamicAny_DynAny DynamicAny_DynUnion_member(DynamicAny_DynUnion _obj, CORBA_Environment *ev);
DynamicAny_FieldName DynamicAny_DynUnion_member_name(DynamicAny_DynUnion _obj, CORBA_Environment *ev);
CORBA_TCKind DynamicAny_DynUnion_member_kind(DynamicAny_DynUnion _obj, CORBA_Environment *ev);
# 1162 "../../include/orbit/dynamic/dynamic-defs.h"
CORBA_unsigned_long DynamicAny_DynSequence_get_length(DynamicAny_DynSequence _obj, CORBA_Environment *ev);
void DynamicAny_DynSequence_set_length(DynamicAny_DynSequence _obj, const CORBA_unsigned_long len, CORBA_Environment *ev);
DynamicAny_AnySeq* DynamicAny_DynSequence_get_elements(DynamicAny_DynSequence _obj, CORBA_Environment *ev);
void DynamicAny_DynSequence_set_elements(DynamicAny_DynSequence _obj, const DynamicAny_AnySeq* value, CORBA_Environment *ev);
DynamicAny_DynAnySeq* DynamicAny_DynSequence_get_elements_as_dyn_any(DynamicAny_DynSequence _obj, CORBA_Environment *ev);
void DynamicAny_DynSequence_set_elements_as_dyn_any(DynamicAny_DynSequence _obj, const DynamicAny_DynAnySeq* value, CORBA_Environment *ev);
# 1246 "../../include/orbit/dynamic/dynamic-defs.h"
DynamicAny_AnySeq* DynamicAny_DynArray_get_elements(DynamicAny_DynArray _obj, CORBA_Environment *ev);
void DynamicAny_DynArray_set_elements(DynamicAny_DynArray _obj, const DynamicAny_AnySeq* value, CORBA_Environment *ev);
DynamicAny_DynAnySeq* DynamicAny_DynArray_get_elements_as_dyn_any(DynamicAny_DynArray _obj, CORBA_Environment *ev);
void DynamicAny_DynArray_set_elements_as_dyn_any(DynamicAny_DynArray _obj, const DynamicAny_DynAnySeq* value, CORBA_Environment *ev);
# 1328 "../../include/orbit/dynamic/dynamic-defs.h"
CORBA_boolean DynamicAny_DynValueCommon_is_null(DynamicAny_DynValueCommon _obj, CORBA_Environment *ev);
void DynamicAny_DynValueCommon_set_to_null(DynamicAny_DynValueCommon _obj, CORBA_Environment *ev);
void DynamicAny_DynValueCommon_set_to_value(DynamicAny_DynValueCommon _obj, CORBA_Environment *ev);
# 1412 "../../include/orbit/dynamic/dynamic-defs.h"
DynamicAny_FieldName DynamicAny_DynValue_current_member_name(DynamicAny_DynValue _obj, CORBA_Environment *ev);
CORBA_TCKind DynamicAny_DynValue_current_member_kind(DynamicAny_DynValue _obj, CORBA_Environment *ev);
DynamicAny_NameValuePairSeq* DynamicAny_DynValue_get_members(DynamicAny_DynValue _obj, CORBA_Environment *ev);
void DynamicAny_DynValue_set_members(DynamicAny_DynValue _obj, const DynamicAny_NameValuePairSeq* value, CORBA_Environment *ev);
DynamicAny_NameDynAnyPairSeq* DynamicAny_DynValue_get_members_as_dyn_any(DynamicAny_DynValue _obj, CORBA_Environment *ev);
void DynamicAny_DynValue_set_members_as_dyn_any(DynamicAny_DynValue _obj, const DynamicAny_NameDynAnyPairSeq* value, CORBA_Environment *ev);
# 1499 "../../include/orbit/dynamic/dynamic-defs.h"
CORBA_any* DynamicAny_DynValueBox_get_boxed_value(DynamicAny_DynValueBox _obj, CORBA_Environment *ev);
void DynamicAny_DynValueBox_set_boxed_value(DynamicAny_DynValueBox _obj, const CORBA_any* boxed, CORBA_Environment *ev);
DynamicAny_DynAny DynamicAny_DynValueBox_get_boxed_value_as_dyn_any(DynamicAny_DynValueBox _obj, CORBA_Environment *ev);
void DynamicAny_DynValueBox_set_boxed_value_as_dyn_any(DynamicAny_DynValueBox _obj, const DynamicAny_DynAny boxed, CORBA_Environment *ev);
DynamicAny_DynAny DynamicAny_DynAnyFactory_create_dyn_any(DynamicAny_DynAnyFactory _obj, const CORBA_any* value, CORBA_Environment *ev);
DynamicAny_DynAny DynamicAny_DynAnyFactory_create_dyn_any_from_type_code(DynamicAny_DynAnyFactory _obj, const CORBA_TypeCode type, CORBA_Environment *ev);
DynamicAny_DynAny DynamicAny_DynAnyFactory_create_dyn_any_without_truncation(DynamicAny_DynAnyFactory _obj, const CORBA_any* value, CORBA_Environment *ev);
DynamicAny_DynAnySeq* DynamicAny_DynAnyFactory_create_multiple_dyn_anys(DynamicAny_DynAnyFactory _obj, const DynamicAny_AnySeq* values, const CORBA_boolean allow_truncate, CORBA_Environment *ev);
DynamicAny_AnySeq* DynamicAny_DynAnyFactory_create_multiple_anys(DynamicAny_DynAnyFactory _obj, const DynamicAny_DynAnySeq* values, CORBA_Environment *ev);
# 1518 "../../include/orbit/dynamic/dynamic-defs.h"
# 1 "../../include/orbit/orbit.h" 1
# 1519 "../../include/orbit/dynamic/dynamic-defs.h" 2
# 2 "../../include/orbit/dynamic/dynamic.h" 2





gpointer ORBit_dynany_new_default (const CORBA_TypeCode tc);




# 20 "../../include/orbit/orbit.h" 2



extern const char *orbit_version;
extern unsigned int orbit_major_version;
extern unsigned int orbit_minor_version;
extern unsigned int orbit_micro_version;


# 739 "../../include/orbit/orb-core/orbit-interface.h" 2
# 2906 "everything.h" 2




extern

ORBit_IInterface test_TestFactory__iinterface;




extern

ORBit_IMethod test_TestFactory__imethods[18];



extern

ORBit_IInterface test_LifeCycleServer__iinterface;




extern

ORBit_IMethod test_LifeCycleServer__imethods[2];



extern

ORBit_IInterface test_DeadReferenceObj__iinterface;




extern

ORBit_IMethod test_DeadReferenceObj__imethods[1];



extern

ORBit_IInterface test_TransientObj__iinterface;




extern

ORBit_IMethod test_TransientObj__imethods[1];



extern

ORBit_IInterface test_SequenceServer__iinterface;




extern

ORBit_IMethod test_SequenceServer__imethods[4];



extern

ORBit_IInterface test_ArrayServer__iinterface;




extern

ORBit_IMethod test_ArrayServer__imethods[5];



extern

ORBit_IInterface test_BasicServer__iinterface;




extern

ORBit_IMethod test_BasicServer__imethods[17];



extern

ORBit_IInterface test_StructServer__iinterface;




extern

ORBit_IMethod test_StructServer__imethods[6];



extern

ORBit_IInterface test_BaseServer__iinterface;




extern

ORBit_IMethod test_BaseServer__imethods[3];



extern

ORBit_IInterface test_B1__iinterface;





extern

ORBit_IInterface test_B2__iinterface;





extern

ORBit_IInterface test_C1__iinterface;





extern

ORBit_IInterface test_DerivedServer__iinterface;





extern

ORBit_IInterface test_UnionServer__iinterface;




extern

ORBit_IMethod test_UnionServer__imethods[4];



extern

ORBit_IInterface test_AnyServer__iinterface;




extern

ORBit_IMethod test_AnyServer__imethods[5];



extern

ORBit_IInterface test_ContextServer__iinterface;




extern

ORBit_IMethod test_ContextServer__imethods[1];



extern

ORBit_IInterface test_PingPongServer__iinterface;




extern

ORBit_IMethod test_PingPongServer__imethods[7];





typedef enum {
 test_TestFactory_getBasicServer__imethods_index,
 test_TestFactory_getStructServer__imethods_index,
 test_TestFactory_getStructServerIOR__imethods_index,
 test_TestFactory_getSequenceServer__imethods_index,
 test_TestFactory_getUnionServer__imethods_index,
 test_TestFactory_getArrayServer__imethods_index,
 test_TestFactory_getAnyServer__imethods_index,
 test_TestFactory_getContextServer__imethods_index,
 test_TestFactory_segv__imethods_index,
 test_TestFactory_getBaseServer__imethods_index,
 test_TestFactory_getDerivedServer__imethods_index,
 test_TestFactory_getDerivedServerAsBaseServer__imethods_index,
 test_TestFactory_getDerivedServerAsB2__imethods_index,
 test_TestFactory_createTransientObj__imethods_index,
 test_TestFactory_createDeadReferenceObj__imethods_index,
 test_TestFactory_createPingPongServer__imethods_index,
 test_TestFactory_createLifeCycleServer__imethods_index,
 test_TestFactory_noOp__imethods_index
} test_TestFactory__imethods_index;




typedef enum {
 test_LifeCycleServer_deactivateOnReturn__imethods_index,
 test_LifeCycleServer_deactivateUnrefOnReturn__imethods_index
} test_LifeCycleServer__imethods_index;




typedef enum {
 test_DeadReferenceObj_test__imethods_index
} test_DeadReferenceObj__imethods_index;




typedef enum {
 test_TransientObj_remove__imethods_index
} test_TransientObj__imethods_index;




typedef enum {
 test_SequenceServer_opStrSeq__imethods_index,
 test_SequenceServer_opBoundedStructSeq__imethods_index,
 test_SequenceServer_opMassiveSeq__imethods_index,
 test_SequenceServer_opAnySeq__imethods_index
} test_SequenceServer__imethods_index;




typedef enum {
 test_ArrayServer_opLongArray__imethods_index,
 test_ArrayServer_opOctetArray__imethods_index,
 test_ArrayServer_opFixedLengthStructArray__imethods_index,
 test_ArrayServer_opStrArray__imethods_index,
 test_ArrayServer_opAlignHoleStructArray__imethods_index
} test_ArrayServer__imethods_index;




typedef enum {
 test_BasicServer__get_foo__imethods_index,
 test_BasicServer__set_foo__imethods_index,
 test_BasicServer__get_bah__imethods_index,
 test_BasicServer_opString__imethods_index,
 test_BasicServer_opLong__imethods_index,
 test_BasicServer_opLongLong__imethods_index,
 test_BasicServer_opFloat__imethods_index,
 test_BasicServer_opDouble__imethods_index,
 test_BasicServer_opLongDouble__imethods_index,
 test_BasicServer_opEnum__imethods_index,
 test_BasicServer_opException__imethods_index,
 test_BasicServer_opOneWay__imethods_index,
 test_BasicServer_noImplement__imethods_index,
 test_BasicServer_testLargeStringSeq__imethods_index,
 test_BasicServer_getObjectCount__imethods_index,
 test_BasicServer_getObject__imethods_index,
 test_BasicServer_testBoolString__imethods_index
} test_BasicServer__imethods_index;




typedef enum {
 test_StructServer_opFixed__imethods_index,
 test_StructServer_opVariable__imethods_index,
 test_StructServer_opCompound__imethods_index,
 test_StructServer_opAlignHole__imethods_index,
 test_StructServer_opObjectStruct__imethods_index,
 test_StructServer_opStructAny__imethods_index
} test_StructServer__imethods_index;




typedef enum {
 test_BaseServer_opPolymorphic__imethods_index,
 test_BaseServer__get_attribPolymorphic__imethods_index,
 test_BaseServer__set_attribPolymorphic__imethods_index
} test_BaseServer__imethods_index;




typedef enum {
 test_UnionServer_opFixed__imethods_index,
 test_UnionServer_opVariable__imethods_index,
 test_UnionServer_opMisc__imethods_index,
 test_UnionServer_opFixedLengthUnionArray__imethods_index
} test_UnionServer__imethods_index;




typedef enum {
 test_AnyServer_opAnyStrSeq__imethods_index,
 test_AnyServer_opAnyLong__imethods_index,
 test_AnyServer_opAnyString__imethods_index,
 test_AnyServer_opAnyStruct__imethods_index,
 test_AnyServer_opTypeCode__imethods_index
} test_AnyServer__imethods_index;




typedef enum {
 test_ContextServer_opWithContext__imethods_index
} test_ContextServer__imethods_index;




typedef enum {
 test_PingPongServer_opSleep__imethods_index,
 test_PingPongServer_opOneWay__imethods_index,
 test_PingPongServer_opOneWayCallback__imethods_index,
 test_PingPongServer_opRoundTrip__imethods_index,
 test_PingPongServer_pingPong__imethods_index,
 test_PingPongServer_set__imethods_index,
 test_PingPongServer_get__imethods_index
} test_PingPongServer__imethods_index;
# 3273 "everything.h"
# 1 "../../include/orbit/orbit.h" 1
# 3274 "everything.h" 2
# 27 "client.c" 2
# 1 "constants.h" 1
# 24 "constants.h"
# 1 "everything.h" 1
# 25 "constants.h" 2

const CORBA_char * constants_STRING_IN="In string";
const CORBA_char * constants_STRING_INOUT_IN="Inout in string";
const CORBA_char * constants_STRING_INOUT_OUT="Inout out string";
const CORBA_char * constants_STRING_OUT="Out string";
const CORBA_char * constants_STRING_RETN="Retn String";
# 63 "constants.h"
const CORBA_char constants_CHAR_IN=0x23;
const CORBA_char constants_CHAR_INOUT_IN=0x45;
const CORBA_char constants_CHAR_INOUT_OUT=0x67;
const CORBA_char constants_CHAR_OUT=0x89;
const CORBA_char constants_CHAR_RETN=0xAC;

const CORBA_octet constants_OCTET_IN=0x13;
const CORBA_octet constants_OCTET_INOUT_IN=0x35;
const CORBA_octet constants_OCTET_INOUT_OUT=0x57;
const CORBA_octet constants_OCTET_OUT=0x79;
const CORBA_octet constants_OCTET_RETN=0xBD;

const CORBA_short constants_SHORT_IN=0x1234;
const CORBA_short constants_SHORT_INOUT_IN=0x3456;
const CORBA_short constants_SHORT_INOUT_OUT=0x5678;
const CORBA_short constants_SHORT_OUT=0x7812;
const CORBA_short constants_SHORT_RETN=0xAABB;


const CORBA_char * constants_SEQ_STRING_IN[] = { "in1","in2","in3","in4" };
const CORBA_char * constants_SEQ_STRING_OUT[] = { "out1","out2","out3","out4" };
const CORBA_char * constants_SEQ_STRING_INOUT_IN[] = { "inout1","inout2","inout3","inout4" };
const CORBA_char * constants_SEQ_STRING_INOUT_OUT[] = { "inout21","inout22","inout23","inout24" };
const CORBA_char * constants_SEQ_STRING_RETN[] = { "retn1","retn2","retn3","retn4" };

const CORBA_long constants_SEQ_LONG_IN[] = { 0x12345678,0x34567812,15,7 };
const CORBA_long constants_SEQ_LONG_OUT[] = { 0x34567812, 0x56781234,15,7 };
const CORBA_long constants_SEQ_LONG_INOUT_IN[] = { 0x56781234, 0x78123456,7,15 };
const CORBA_long constants_SEQ_LONG_INOUT_OUT[] = { 0x78123456, 0xAABBCCDD,8,9 };
const CORBA_long constants_SEQ_LONG_RETN[] = { 0xAABBCCDD, 0x12345678,2,3 };

const CORBA_long constants_SEQ_OCTET_IN[] = { 1, 3, 5, 7 };
const CORBA_long constants_SEQ_OCTET_OUT[] = { 2, 7, 9, 255 };
const CORBA_long constants_SEQ_OCTET_INOUT_IN[] = { 1, 15, 8, 0 };
const CORBA_long constants_SEQ_OCTET_INOUT_OUT[] = { 73, 128, 173, 15 };
const CORBA_long constants_SEQ_OCTET_RETN[] = { 1, 3, 5, 7 };
# 28 "client.c" 2
# 1 "../../src/orb/orb-core/orb-core-private.h" 1



# 1 "../../include/orbit/orbit.h" 1
# 5 "../../src/orb/orb-core/orb-core-private.h" 2

CORBA_TypeCode ORBit_get_union_tag (CORBA_TypeCode union_tc,
     gconstpointer *val,
     gboolean update);
size_t ORBit_gather_alloc_info (CORBA_TypeCode tc);
void ORBit_copy_value_core (gconstpointer *val,
     gpointer *newval,
     CORBA_TypeCode tc);

void ORBit_register_objref (CORBA_Object obj);
CORBA_Object ORBit_objref_get_proxy (CORBA_Object obj);
void ORBit_start_servers (CORBA_ORB orb);

void ORBit_set_initial_reference (CORBA_ORB orb,
       gchar *identifier,
       gpointer objref);

CORBA_Object ORBit_object_by_corbaloc (CORBA_ORB orb,
           const gchar *corbaloc,
           CORBA_Environment *ev);

CORBA_char* ORBit_object_to_corbaloc (CORBA_Object obj,
           CORBA_Environment *ev);

CORBA_char* ORBit_corbaloc_from (GSList *profile_list,
           ORBit_ObjectKey *object_key);

GSList* ORBit_corbaloc_parse (const gchar *corbaloc);


GSList *IOP_start_profiles (CORBA_ORB orb);
void IOP_shutdown_profiles (GSList *profiles);
void IOP_delete_profiles (CORBA_ORB orb,
        GSList **profiles);
void IOP_generate_profiles (CORBA_Object obj);
void IOP_register_profiles (CORBA_Object obj,
        GSList *profiles);
ORBit_ObjectKey *IOP_profiles_sync_objkey (GSList *profiles);
ORBit_ObjectKey *IOP_ObjectKey_copy (ORBit_ObjectKey *src);
gboolean IOP_ObjectKey_equal (ORBit_ObjectKey *a,
        ORBit_ObjectKey *b);
guint IOP_ObjectKey_hash (ORBit_ObjectKey *k);
gboolean IOP_profile_get_info (CORBA_Object obj,
        gpointer *pinfo,
        GIOPVersion *iiop_version,
        char **proto,
        char **host,
        char **service,
        gboolean *ssl,
        char *tmpbuf);
void IOP_profile_hash (gpointer item,
        gpointer data);
gchar *IOP_profile_dump (CORBA_Object obj,
        gpointer p);
gboolean IOP_profile_equal (CORBA_Object obj1,
        CORBA_Object obj2,
        gpointer d1,
        gpointer d2);
void IOP_profile_marshal (CORBA_Object obj,
        GIOPSendBuffer *buf,
        gpointer *p);
GSList *IOP_profiles_copy (GSList *profile_list);


gboolean ORBit_demarshal_IOR (CORBA_ORB orb, GIOPRecvBuffer *buf,
         char **ret_type_id, GSList **ret_profiles);

int ORBit_RootObject_shutdown (gboolean moan);
char **ORBit_get_typelib_paths (void);
gboolean ORBit_proto_use (const char *name);
void _ORBit_object_init (void);

glong ORBit_get_giop_recv_limit (void);
# 29 "client.c" 2
# 1 "../../src/services/imodule/orbit-imodule.h" 1
# 28 "../../src/services/imodule/orbit-imodule.h"
# 1 "../../include/orbit/orb-core/orbit-interface.h" 1
# 29 "../../src/services/imodule/orbit-imodule.h" 2
# 1 "/usr/include/libIDL-2.0/libIDL/IDL.h" 1
# 32 "/usr/include/libIDL-2.0/libIDL/IDL.h"
# 1 "/usr/include/wchar.h" 1 3 4
# 48 "/usr/include/wchar.h" 3 4
# 1 "/usr/lib/gcc/i386-redhat-linux/4.1.0/include/stddef.h" 1 3 4
# 49 "/usr/include/wchar.h" 2 3 4
# 93 "/usr/include/wchar.h" 3 4


typedef __mbstate_t mbstate_t;

# 118 "/usr/include/wchar.h" 3 4





struct tm;









extern wchar_t *wcscpy (wchar_t *__restrict __dest,
   __const wchar_t *__restrict __src) __attribute__ ((__nothrow__));

extern wchar_t *wcsncpy (wchar_t *__restrict __dest,
    __const wchar_t *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__));


extern wchar_t *wcscat (wchar_t *__restrict __dest,
   __const wchar_t *__restrict __src) __attribute__ ((__nothrow__));

extern wchar_t *wcsncat (wchar_t *__restrict __dest,
    __const wchar_t *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__));


extern int wcscmp (__const wchar_t *__s1, __const wchar_t *__s2)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__));

extern int wcsncmp (__const wchar_t *__s1, __const wchar_t *__s2, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__));

# 175 "/usr/include/wchar.h" 3 4



extern int wcscoll (__const wchar_t *__s1, __const wchar_t *__s2) __attribute__ ((__nothrow__));



extern size_t wcsxfrm (wchar_t *__restrict __s1,
         __const wchar_t *__restrict __s2, size_t __n) __attribute__ ((__nothrow__));

# 205 "/usr/include/wchar.h" 3 4


extern wchar_t *wcschr (__const wchar_t *__wcs, wchar_t __wc)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__));

extern wchar_t *wcsrchr (__const wchar_t *__wcs, wchar_t __wc)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__));

# 221 "/usr/include/wchar.h" 3 4



extern size_t wcscspn (__const wchar_t *__wcs, __const wchar_t *__reject)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__));


extern size_t wcsspn (__const wchar_t *__wcs, __const wchar_t *__accept)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__));

extern wchar_t *wcspbrk (__const wchar_t *__wcs, __const wchar_t *__accept)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__));

extern wchar_t *wcsstr (__const wchar_t *__haystack, __const wchar_t *__needle)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__));


extern wchar_t *wcstok (wchar_t *__restrict __s,
   __const wchar_t *__restrict __delim,
   wchar_t **__restrict __ptr) __attribute__ ((__nothrow__));


extern size_t wcslen (__const wchar_t *__s) __attribute__ ((__nothrow__)) __attribute__ ((__pure__));

# 259 "/usr/include/wchar.h" 3 4


extern wchar_t *wmemchr (__const wchar_t *__s, wchar_t __c, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__));


extern int wmemcmp (__const wchar_t *__restrict __s1,
      __const wchar_t *__restrict __s2, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__));


extern wchar_t *wmemcpy (wchar_t *__restrict __s1,
    __const wchar_t *__restrict __s2, size_t __n) __attribute__ ((__nothrow__));



extern wchar_t *wmemmove (wchar_t *__s1, __const wchar_t *__s2, size_t __n)
     __attribute__ ((__nothrow__));


extern wchar_t *wmemset (wchar_t *__s, wchar_t __c, size_t __n) __attribute__ ((__nothrow__));

# 291 "/usr/include/wchar.h" 3 4



extern wint_t btowc (int __c) __attribute__ ((__nothrow__));



extern int wctob (wint_t __c) __attribute__ ((__nothrow__));



extern int mbsinit (__const mbstate_t *__ps) __attribute__ ((__nothrow__)) __attribute__ ((__pure__));



extern size_t mbrtowc (wchar_t *__restrict __pwc,
         __const char *__restrict __s, size_t __n,
         mbstate_t *__p) __attribute__ ((__nothrow__));


extern size_t wcrtomb (char *__restrict __s, wchar_t __wc,
         mbstate_t *__restrict __ps) __attribute__ ((__nothrow__));


extern size_t __mbrlen (__const char *__restrict __s, size_t __n,
   mbstate_t *__restrict __ps) __attribute__ ((__nothrow__));
extern size_t mbrlen (__const char *__restrict __s, size_t __n,
        mbstate_t *__restrict __ps) __attribute__ ((__nothrow__));








extern wint_t __btowc_alias (int __c) __asm ("btowc");
extern __inline wint_t
__attribute__ ((__nothrow__)) btowc (int __c)
{ return (__builtin_constant_p (__c) && __c >= '\0' && __c <= '\x7f'
   ? (wint_t) __c : __btowc_alias (__c)); }

extern int __wctob_alias (wint_t __c) __asm ("wctob");
extern __inline int
__attribute__ ((__nothrow__)) wctob (wint_t __wc)
{ return (__builtin_constant_p (__wc) && __wc >= L'\0' && __wc <= L'\x7f'
   ? (int) __wc : __wctob_alias (__wc)); }

extern __inline size_t
__attribute__ ((__nothrow__)) mbrlen (__const char *__restrict __s, size_t __n, mbstate_t *__restrict __ps)

{ return (__ps != ((void *)0)
   ? mbrtowc (((void *)0), __s, __n, __ps) : __mbrlen (__s, __n, ((void *)0))); }





extern size_t mbsrtowcs (wchar_t *__restrict __dst,
    __const char **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) __attribute__ ((__nothrow__));



extern size_t wcsrtombs (char *__restrict __dst,
    __const wchar_t **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) __attribute__ ((__nothrow__));

# 388 "/usr/include/wchar.h" 3 4



extern double wcstod (__const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr) __attribute__ ((__nothrow__));
# 405 "/usr/include/wchar.h" 3 4
extern long int wcstol (__const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, int __base) __attribute__ ((__nothrow__));



extern unsigned long int wcstoul (__const wchar_t *__restrict __nptr,
      wchar_t **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__));
# 429 "/usr/include/wchar.h" 3 4

# 500 "/usr/include/wchar.h" 3 4
extern double __wcstod_internal (__const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr, int __group)
     __attribute__ ((__nothrow__));
extern float __wcstof_internal (__const wchar_t *__restrict __nptr,
    wchar_t **__restrict __endptr, int __group)
     __attribute__ ((__nothrow__));
extern long double __wcstold_internal (__const wchar_t *__restrict __nptr,
           wchar_t **__restrict __endptr,
           int __group) __attribute__ ((__nothrow__));


extern long int __wcstol_internal (__const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       int __base, int __group) __attribute__ ((__nothrow__));



extern unsigned long int __wcstoul_internal (__const wchar_t *__restrict __npt,
          wchar_t **__restrict __endptr,
          int __base, int __group) __attribute__ ((__nothrow__));



__extension__
extern long long int __wcstoll_internal (__const wchar_t *__restrict __nptr,
      wchar_t **__restrict __endptr,
      int __base, int __group) __attribute__ ((__nothrow__));



__extension__
extern unsigned long long int __wcstoull_internal (__const wchar_t *
         __restrict __nptr,
         wchar_t **
         __restrict __endptr,
         int __base,
         int __group) __attribute__ ((__nothrow__));








extern __inline double
__attribute__ ((__nothrow__)) wcstod (__const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr)

{ return __wcstod_internal (__nptr, __endptr, 0); }
extern __inline long int
__attribute__ ((__nothrow__)) wcstol (__const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base)

{ return __wcstol_internal (__nptr, __endptr, __base, 0); }
extern __inline unsigned long int
__attribute__ ((__nothrow__)) wcstoul (__const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base)

{ return __wcstoul_internal (__nptr, __endptr, __base, 0); }

# 694 "/usr/include/wchar.h" 3 4





extern wint_t fgetwc (__FILE *__stream);
extern wint_t getwc (__FILE *__stream);





extern wint_t getwchar (void);






extern wint_t fputwc (wchar_t __wc, __FILE *__stream);
extern wint_t putwc (wchar_t __wc, __FILE *__stream);





extern wint_t putwchar (wchar_t __wc);







extern wchar_t *fgetws (wchar_t *__restrict __ws, int __n,
   __FILE *__restrict __stream);





extern int fputws (__const wchar_t *__restrict __ws,
     __FILE *__restrict __stream);






extern wint_t ungetwc (wint_t __wc, __FILE *__stream);

# 805 "/usr/include/wchar.h" 3 4




extern size_t wcsftime (wchar_t *__restrict __s, size_t __maxsize,
   __const wchar_t *__restrict __format,
   __const struct tm *__restrict __tp) __attribute__ ((__nothrow__));

# 845 "/usr/include/wchar.h" 3 4

# 33 "/usr/include/libIDL-2.0/libIDL/IDL.h" 2
# 108 "/usr/include/libIDL-2.0/libIDL/IDL.h"
typedef gint64 IDL_longlong_t;
typedef guint64 IDL_ulonglong_t;

typedef unsigned int IDL_declspec_t;
typedef struct _IDL_tree_node IDL_tree_node;
typedef struct _IDL_tree_node * IDL_tree;

struct _IDL_LIST {
 IDL_tree data;
 IDL_tree prev;
 IDL_tree next;
 IDL_tree _tail;
};


extern IDL_tree IDL_list_new (IDL_tree data);
extern IDL_tree IDL_list_concat (IDL_tree orig,
        IDL_tree append);
extern IDL_tree IDL_list_remove (IDL_tree list,
        IDL_tree p);
extern int IDL_list_length (IDL_tree list);
extern IDL_tree IDL_list_nth (IDL_tree list,
        int n);

struct _IDL_GENTREE {
 IDL_tree data;
 GHashTable *siblings;
 GHashTable *children;
 GHashFunc hash_func;
 GCompareFunc key_compare_func;
 IDL_tree _import;
 char *_cur_prefix;
};

extern IDL_tree IDL_gentree_new (GHashFunc hash_func,
        GCompareFunc key_compare_func,
        IDL_tree data);
extern IDL_tree IDL_gentree_new_sibling (IDL_tree from,
        IDL_tree data);
extern IDL_tree IDL_gentree_chain_sibling (IDL_tree from,
        IDL_tree data);
extern IDL_tree IDL_gentree_chain_child (IDL_tree from,
        IDL_tree data);

struct _IDL_INTEGER {
 IDL_longlong_t value;
};

extern IDL_tree IDL_integer_new (IDL_longlong_t value);

struct _IDL_STRING {
 char *value;
};

extern IDL_tree IDL_string_new (char *value);

struct _IDL_WIDE_STRING {
 wchar_t *value;
};

extern IDL_tree IDL_wide_string_new (wchar_t *value);

struct _IDL_CHAR {
 char *value;
};

extern IDL_tree IDL_char_new (char *value);

struct _IDL_WIDE_CHAR {
 wchar_t *value;
};

extern IDL_tree IDL_wide_char_new (wchar_t *value);

struct _IDL_FIXED {
 char *value;
};

extern IDL_tree IDL_fixed_new (char *value);

struct _IDL_FLOAT {
 double value;
};

extern IDL_tree IDL_float_new (double value);

struct _IDL_BOOLEAN {
 unsigned value;
};

extern IDL_tree IDL_boolean_new (unsigned value);

struct _IDL_IDENT {
 char *str;
 char *repo_id;
 GSList *comments;
 IDL_tree _ns_ref;
 unsigned _flags;

};



extern IDL_tree IDL_ident_new (char *str);
extern void IDL_queue_new_ident_comment (const char *str);

enum IDL_float_type {
 IDL_FLOAT_TYPE_FLOAT,
 IDL_FLOAT_TYPE_DOUBLE,
 IDL_FLOAT_TYPE_LONGDOUBLE
};

struct _IDL_TYPE_FLOAT {
 enum IDL_float_type f_type;
};

extern IDL_tree IDL_type_float_new (enum IDL_float_type f_type);

struct _IDL_TYPE_FIXED {
 IDL_tree positive_int_const;
 IDL_tree integer_lit;
};

extern IDL_tree IDL_type_fixed_new (IDL_tree positive_int_const,
        IDL_tree integer_lit);

enum IDL_integer_type {
 IDL_INTEGER_TYPE_SHORT,
 IDL_INTEGER_TYPE_LONG,
 IDL_INTEGER_TYPE_LONGLONG
};

struct _IDL_TYPE_INTEGER {
 unsigned f_signed : 1;
 enum IDL_integer_type f_type;
};

extern IDL_tree IDL_type_integer_new (unsigned f_signed,
        enum IDL_integer_type f_type);

extern IDL_tree IDL_type_char_new (void);
extern IDL_tree IDL_type_wide_char_new (void);
extern IDL_tree IDL_type_boolean_new (void);
extern IDL_tree IDL_type_octet_new (void);
extern IDL_tree IDL_type_any_new (void);
extern IDL_tree IDL_type_object_new (void);
extern IDL_tree IDL_type_typecode_new (void);

struct _IDL_TYPE_STRING {
 IDL_tree positive_int_const;
};

extern IDL_tree IDL_type_string_new (IDL_tree positive_int_const);

struct _IDL_TYPE_WIDE_STRING {
 IDL_tree positive_int_const;
};

extern IDL_tree IDL_type_wide_string_new (IDL_tree positive_int_const);

struct _IDL_TYPE_ENUM {
 IDL_tree ident;
 IDL_tree enumerator_list;
};

extern IDL_tree IDL_type_enum_new (IDL_tree ident,
        IDL_tree enumerator_list);

struct _IDL_TYPE_ARRAY {
 IDL_tree ident;
 IDL_tree size_list;
};

extern IDL_tree IDL_type_array_new (IDL_tree ident,
        IDL_tree size_list);

struct _IDL_TYPE_SEQUENCE {
 IDL_tree simple_type_spec;
 IDL_tree positive_int_const;
};

extern IDL_tree IDL_type_sequence_new (IDL_tree simple_type_spec,
        IDL_tree positive_int_const);

struct _IDL_TYPE_STRUCT {
 IDL_tree ident;
 IDL_tree member_list;
};

extern IDL_tree IDL_type_struct_new (IDL_tree ident,
        IDL_tree member_list);

struct _IDL_TYPE_UNION {
 IDL_tree ident;
 IDL_tree switch_type_spec;
 IDL_tree switch_body;
};

extern IDL_tree IDL_type_union_new (IDL_tree ident,
        IDL_tree switch_type_spec,
        IDL_tree switch_body);
struct _IDL_MEMBER {
 IDL_tree type_spec;
 IDL_tree dcls;
};

extern IDL_tree IDL_member_new (IDL_tree type_spec,
        IDL_tree dcls);

struct _IDL_NATIVE {
 IDL_tree ident;
 char *user_type;
};

extern IDL_tree IDL_native_new (IDL_tree ident);


struct _IDL_TYPE_DCL {
 IDL_tree type_spec;
 IDL_tree dcls;
};

extern IDL_tree IDL_type_dcl_new (IDL_tree type_spec,
        IDL_tree dcls);

struct _IDL_CONST_DCL {
 IDL_tree const_type;
 IDL_tree ident;
 IDL_tree const_exp;
};

extern IDL_tree IDL_const_dcl_new (IDL_tree const_type,
        IDL_tree ident,
        IDL_tree const_exp);

struct _IDL_EXCEPT_DCL {
 IDL_tree ident;
 IDL_tree members;
};

extern IDL_tree IDL_except_dcl_new (IDL_tree ident,
        IDL_tree members);

struct _IDL_ATTR_DCL {
 unsigned f_readonly : 1;
 IDL_tree param_type_spec;
 IDL_tree simple_declarations;
};

extern IDL_tree IDL_attr_dcl_new (unsigned f_readonly,
        IDL_tree param_type_spec,
        IDL_tree simple_declarations);

struct _IDL_OP_DCL {
 unsigned __f_noscript : 1;
 unsigned f_oneway : 1;

 unsigned f_varargs : 1;
 IDL_tree op_type_spec;
 IDL_tree ident;
 IDL_tree parameter_dcls;
 IDL_tree raises_expr;
 IDL_tree context_expr;
};

extern IDL_tree IDL_op_dcl_new (unsigned f_oneway,
        IDL_tree op_type_spec,
        IDL_tree ident,
        IDL_tree parameter_dcls,
        IDL_tree raises_expr,
        IDL_tree context_expr);

enum IDL_param_attr {
 IDL_PARAM_IN,
 IDL_PARAM_OUT,
 IDL_PARAM_INOUT
};

struct _IDL_PARAM_DCL {
 enum IDL_param_attr attr;
 IDL_tree param_type_spec;
 IDL_tree simple_declarator;
};

extern IDL_tree IDL_param_dcl_new (enum IDL_param_attr attr,
        IDL_tree param_type_spec,
        IDL_tree simple_declarator);

struct _IDL_CASE_STMT {
 IDL_tree labels;
 IDL_tree element_spec;
};

extern IDL_tree IDL_case_stmt_new (IDL_tree labels,
        IDL_tree element_spec);

struct _IDL_INTERFACE {
 IDL_tree ident;
 IDL_tree inheritance_spec;
 IDL_tree body;
};

extern IDL_tree IDL_interface_new (IDL_tree ident,
        IDL_tree inheritance_spec,
        IDL_tree body);

struct _IDL_FORWARD_DCL {
 IDL_tree ident;
};

extern IDL_tree IDL_forward_dcl_new (IDL_tree ident);

struct _IDL_MODULE {
 IDL_tree ident;
 IDL_tree definition_list;
};

extern IDL_tree IDL_module_new (IDL_tree ident,
        IDL_tree definition_list);

enum IDL_binop {
 IDL_BINOP_OR,
 IDL_BINOP_XOR,
 IDL_BINOP_AND,
 IDL_BINOP_SHR,
 IDL_BINOP_SHL,
 IDL_BINOP_ADD,
 IDL_BINOP_SUB,
 IDL_BINOP_MULT,
 IDL_BINOP_DIV,
 IDL_BINOP_MOD
};

struct _IDL_BINOP {
 enum IDL_binop op;
 IDL_tree left, right;
};

extern IDL_tree IDL_binop_new (enum IDL_binop op,
        IDL_tree left,
        IDL_tree right);

enum IDL_unaryop {
 IDL_UNARYOP_PLUS,
 IDL_UNARYOP_MINUS,
 IDL_UNARYOP_COMPLEMENT
};

struct _IDL_UNARYOP {
 enum IDL_unaryop op;
 IDL_tree operand;
};

extern IDL_tree IDL_unaryop_new (enum IDL_unaryop op,
        IDL_tree operand);


struct _IDL_CODEFRAG {
 char *desc;
 GSList *lines;
};

extern IDL_tree IDL_codefrag_new (char *desc,
        GSList *lines);


struct _IDL_SRCFILE {
 char *filename;
 int seenCnt;
 gboolean isTop;
 gboolean wasInhibit;
};

extern IDL_tree IDL_srcfile_new (char *filename, int seenCnt, gboolean isTop, gboolean wasInhibit);
# 491 "/usr/include/libIDL-2.0/libIDL/IDL.h"
typedef enum {
 IDLN_NONE,
 IDLN_ANY,

 IDLN_LIST,
 IDLN_GENTREE,
 IDLN_INTEGER,
 IDLN_STRING,
 IDLN_WIDE_STRING,
 IDLN_CHAR,
 IDLN_WIDE_CHAR,
 IDLN_FIXED,
 IDLN_FLOAT,
 IDLN_BOOLEAN,
 IDLN_IDENT,
 IDLN_TYPE_DCL,
 IDLN_CONST_DCL,
 IDLN_EXCEPT_DCL,
 IDLN_ATTR_DCL,
 IDLN_OP_DCL,
 IDLN_PARAM_DCL,
 IDLN_FORWARD_DCL,
 IDLN_TYPE_INTEGER,
 IDLN_TYPE_FLOAT,
 IDLN_TYPE_FIXED,
 IDLN_TYPE_CHAR,
 IDLN_TYPE_WIDE_CHAR,
 IDLN_TYPE_STRING,
 IDLN_TYPE_WIDE_STRING,
 IDLN_TYPE_BOOLEAN,
 IDLN_TYPE_OCTET,
 IDLN_TYPE_ANY,
 IDLN_TYPE_OBJECT,
 IDLN_TYPE_TYPECODE,
 IDLN_TYPE_ENUM,
 IDLN_TYPE_SEQUENCE,
 IDLN_TYPE_ARRAY,
 IDLN_TYPE_STRUCT,
 IDLN_TYPE_UNION,
 IDLN_MEMBER,
 IDLN_NATIVE,
 IDLN_CASE_STMT,
 IDLN_INTERFACE,
 IDLN_MODULE,
 IDLN_BINOP,
 IDLN_UNARYOP,
 IDLN_CODEFRAG,
 IDLN_SRCFILE,

 IDLN_LAST
} IDL_tree_type;
extern const char * IDL_tree_type_names[];

struct _IDL_tree_node {
 IDL_tree_type _type;
 IDL_tree up;
 IDL_declspec_t declspec;
 GHashTable *properties;
 int refs;
 char *_file;
 int _line;
 union {
  struct _IDL_LIST idl_list;
  struct _IDL_GENTREE idl_gentree;
  struct _IDL_INTEGER idl_integer;
  struct _IDL_STRING idl_string;
  struct _IDL_WIDE_STRING idl_wide_string;
  struct _IDL_CHAR idl_char;
  struct _IDL_WIDE_CHAR idl_wide_char;
  struct _IDL_FIXED idl_fixed;
  struct _IDL_FLOAT idl_float;
  struct _IDL_BOOLEAN idl_boolean;
  struct _IDL_IDENT idl_ident;
  struct _IDL_TYPE_DCL idl_type_dcl;
  struct _IDL_CONST_DCL idl_const_dcl;
  struct _IDL_EXCEPT_DCL idl_except_dcl;
  struct _IDL_ATTR_DCL idl_attr_dcl;
  struct _IDL_OP_DCL idl_op_dcl;
  struct _IDL_PARAM_DCL idl_param_dcl;
  struct _IDL_FORWARD_DCL idl_forward_dcl;
  struct _IDL_TYPE_FLOAT idl_type_float;
  struct _IDL_TYPE_FIXED idl_type_fixed;
  struct _IDL_TYPE_INTEGER idl_type_integer;
  struct _IDL_TYPE_ENUM idl_type_enum;
  struct _IDL_TYPE_STRING idl_type_string;
  struct _IDL_TYPE_WIDE_STRING idl_type_wide_string;
  struct _IDL_TYPE_SEQUENCE idl_type_sequence;
  struct _IDL_TYPE_ARRAY idl_type_array;
  struct _IDL_TYPE_STRUCT idl_type_struct;
  struct _IDL_TYPE_UNION idl_type_union;
  struct _IDL_MEMBER idl_member;
  struct _IDL_NATIVE idl_native;
  struct _IDL_CASE_STMT idl_case_stmt;
  struct _IDL_INTERFACE idl_interface;
  struct _IDL_MODULE idl_module;
  struct _IDL_BINOP idl_binop;
  struct _IDL_UNARYOP idl_unaryop;
  struct _IDL_CODEFRAG idl_codefrag;
  struct _IDL_SRCFILE idl_srcfile;
 } u;


 guint32 flags;
 gpointer data;
};
# 639 "/usr/include/libIDL-2.0/libIDL/IDL.h"
typedef struct _IDL_ns * IDL_ns;

struct _IDL_ns {
 IDL_tree global;
 IDL_tree file;
 IDL_tree current;
 GHashTable *inhibits;
 GHashTable *filename_hash;
};


typedef enum {
 IDL_INPUT_REASON_INIT,
 IDL_INPUT_REASON_FILL,
 IDL_INPUT_REASON_ABORT,
 IDL_INPUT_REASON_FINISH
} IDL_input_reason;

union IDL_input_data {
 struct {
  const char *filename;
 } init;
 struct {
  char *buffer;
  size_t max_size;
 } fill;
};

typedef int (*IDL_input_callback) (IDL_input_reason reason,
        union IDL_input_data *data,
        gpointer user_data);

typedef int (*IDL_msg_callback) (int level,
        int num,
        int line,
        const char *filename,
        const char *message);

typedef struct _IDL_tree_func_state IDL_tree_func_state;
typedef struct _IDL_tree_func_data IDL_tree_func_data;




struct _IDL_tree_func_state {
 IDL_tree_func_state *up;
 IDL_tree start;
 IDL_tree_func_data *bottom;
 glong flags;
};




struct _IDL_tree_func_data {
 IDL_tree_func_state *state;
 IDL_tree_func_data *up;
 IDL_tree tree;
 gint step;
 gpointer data;
 gint level;
};

typedef gboolean (*IDL_tree_func) (IDL_tree_func_data *tnfd,
        gpointer user_data);

extern IDL_tree IDL_check_type_cast (const IDL_tree var,
        IDL_tree_type type,
        const char *file,
        int line,
        const char *function);

extern const char * IDL_get_libver_string (void);

extern const char * IDL_get_IDLver_string (void);

extern int IDL_parse_filename (const char *filename,
        const char *cpp_args,
        IDL_msg_callback msg_cb,
        IDL_tree *tree, IDL_ns *ns,
        unsigned long parse_flags,
        int max_msg_level);

extern int IDL_parse_filename_with_input (const char *filename,
        IDL_input_callback input_cb,
        gpointer input_cb_user_data,
        IDL_msg_callback msg_cb,
        IDL_tree *tree, IDL_ns *ns,
        unsigned long parse_flags,
        int max_msg_level);

extern int IDL_ns_prefix (IDL_ns ns,
        const char *s);

extern void IDL_ns_ID (IDL_ns ns,
        const char *s);

extern void IDL_ns_version (IDL_ns ns,
        const char *s);

extern int IDL_inhibit_get (void);

extern void IDL_inhibit_push (void);

extern void IDL_inhibit_pop (void);

extern IDL_tree IDL_file_set (const char *filename,
        int line);

extern void IDL_file_get (const char **filename,
        int *line);

extern IDL_tree IDL_get_parent_node (IDL_tree p,
        IDL_tree_type type,
        int *scope_levels);

extern IDL_tree IDL_tree_get_scope (IDL_tree p);

extern int IDL_tree_get_node_info (IDL_tree tree,
        char **who,
        char **what);

extern void IDL_tree_error (IDL_tree p,
        const char *fmt,
        ...)
       __attribute__((__format__ (__printf__, 2, 3)));

extern void IDL_tree_warning (IDL_tree p,
        int level,
        const char *fmt,
        ...)
       __attribute__((__format__ (__printf__, 3, 4)));

extern const char * IDL_tree_property_get (IDL_tree tree,
        const char *key);

extern void IDL_tree_property_set (IDL_tree tree,
        const char *key,
        const char *value);

extern gboolean IDL_tree_property_remove (IDL_tree tree,
        const char *key);

extern void IDL_tree_properties_copy (IDL_tree from_tree,
        IDL_tree to_tree);

extern void IDL_tree_remove_inhibits (IDL_tree *tree,
        IDL_ns ns);

extern void IDL_tree_walk (IDL_tree p,
        IDL_tree_func_data *current,
        IDL_tree_func pre_tree_func,
        IDL_tree_func post_tree_func,
        gpointer user_data);

extern void IDL_tree_walk2 (IDL_tree p,
        IDL_tree_func_data *current,
        glong flags,
        IDL_tree_func pre_tree_func,
        IDL_tree_func post_tree_func,
        gpointer user_data);

extern void IDL_tree_walk_in_order (IDL_tree p,
        IDL_tree_func tree_func,
        gpointer user_data);

extern void IDL_tree_free (IDL_tree root);

extern void IDL_tree_to_IDL (IDL_tree p,
        IDL_ns ns,
        FILE *output,
        unsigned long output_flags);

extern GString * IDL_tree_to_IDL_string (IDL_tree p,
        IDL_ns ns,
        unsigned long output_flags);

extern gboolean IDL_tree_contains_node (IDL_tree p,
        IDL_tree searchNode);

extern gboolean IDL_tree_is_recursive (IDL_tree tree,
        gpointer dummy);

extern gchar * IDL_do_escapes (const char *s);

extern IDL_tree IDL_resolve_const_exp (IDL_tree p,
        IDL_tree_type type);

extern IDL_ns IDL_ns_new (void);

extern void IDL_ns_free (IDL_ns ns);

extern IDL_tree IDL_ns_resolve_this_scope_ident (IDL_ns ns,
        IDL_tree scope,
        IDL_tree ident);

extern IDL_tree IDL_ns_resolve_ident (IDL_ns ns,
        IDL_tree ident);

extern IDL_tree IDL_ns_lookup_this_scope (IDL_ns ns,
        IDL_tree scope,
        IDL_tree ident,
        gboolean *conflict);

extern IDL_tree IDL_ns_lookup_cur_scope (IDL_ns ns,
        IDL_tree ident,
        gboolean *conflict);

extern IDL_tree IDL_ns_place_new (IDL_ns ns,
        IDL_tree ident);

extern void IDL_ns_push_scope (IDL_ns ns,
        IDL_tree ident);

extern void IDL_ns_pop_scope (IDL_ns ns);

extern IDL_tree IDL_ns_qualified_ident_new (IDL_tree nsid);

extern gchar * IDL_ns_ident_to_qstring (IDL_tree ns_ident,
        const char *join,
        int scope_levels);

extern int IDL_ns_scope_levels_from_here (IDL_ns ns,
        IDL_tree ident,
        IDL_tree parent);

extern gchar * IDL_ns_ident_make_repo_id (IDL_ns ns,
        IDL_tree p,
        const char *p_prefix,
        int *major,
        int *minor);
# 30 "../../src/services/imodule/orbit-imodule.h" 2



ORBit_IInterfaces *ORBit_iinterfaces_from_file (const char *path,
      const char *cpp_args,
      CORBA_sequence_CORBA_TypeCode **typecodes_ret);

ORBit_IInterfaces *ORBit_iinterfaces_from_tree (IDL_tree tree,
      CORBA_sequence_CORBA_TypeCode **typecodes_ret);


# 30 "client.c" 2
# 1 "../../include/orbit/orbit.h" 1
# 31 "client.c" 2
# 43 "client.c"
extern CORBA_ORB global_orb;
gboolean in_proc;
gboolean thread_safe = (0);
gboolean thread_tests = (0);



# 1 "server.c" 1
# 23 "server.c"
# 1 "everything.h" 1
# 24 "server.c" 2







test_TestFactory getFactoryInstance(CORBA_Environment *ev);

typedef void (*init_fn_t) (PortableServer_Servant, CORBA_Environment *);

CORBA_Object create_object (PortableServer_POA poa,
       gpointer servant,
       CORBA_Environment *ev);

CORBA_ORB global_orb;
PortableServer_POA global_poa;

static void
simple_finalize (PortableServer_Servant servant,
   CORBA_Environment *ev)
{

 g_free (servant);
}

static gpointer
simple_servant_new (gpointer vepv, init_fn_t fn)
{
 CORBA_Environment ev[1];
 PortableServer_ClassInfo *class_info;
 PortableServer_ServantBase *servant =
  ((PortableServer_ServantBase *) g_malloc0 (((gsize) sizeof (PortableServer_ServantBase)) * ((gsize) (1))));

 servant->vepv = vepv;
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (servant->vepv[0] != ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "server.c", 59, __PRETTY_FUNCTION__, "servant->vepv[0] != NULL"); });

 CORBA_exception_init (ev);
 fn (servant, ev);
 if (ev->_major != CORBA_NO_EXCEPTION)
  g_log (((gchar*) 0), G_LOG_LEVEL_ERROR, "object__init failed: %d\n", ev->_major);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (( (PortableServer_ClassInfo*) ( ((PortableServer_ServantBase *)(servant))->vepv[0]->_private ) ) != ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "server.c", 65, __PRETTY_FUNCTION__, "ORBIT_SERVANT_TO_CLASSINFO (servant) != NULL"); });
 CORBA_exception_free (ev);

 class_info = ( (PortableServer_ClassInfo*) ( ((PortableServer_ServantBase *)(servant))->vepv[0]->_private ) );
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (class_info) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "server.c", 69, __PRETTY_FUNCTION__, "class_info"); });




 return servant;
}



PortableServer_ServantBase__epv Simple_base_epv = {((void *)0), simple_finalize, ((void *)0)};

# 1 "basicServer.c" 1
# 21 "basicServer.c"
# 1 "everything.h" 1
# 22 "basicServer.c" 2



extern int _orbit_debug_flags;

static CORBA_char *
BasicServer__get_foo (PortableServer_Servant servant,
        CORBA_Environment *ev)
{
 return CORBA_string_dup (constants_STRING_RETN);
}

static void
BasicServer__set_foo (PortableServer_Servant servant,
        const CORBA_char *val,
        CORBA_Environment *ev)
{
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (!__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (val) && __builtin_constant_p (constants_STRING_IN) && (__s1_len = strlen (val), __s2_len = strlen (constants_STRING_IN), (!((size_t)(const void *)((val) + 1) - (size_t)(const void *)(val) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((constants_STRING_IN) + 1) - (size_t)(const void *)(constants_STRING_IN) == 1) || __s2_len >= 4)) ? __builtin_strcmp (val, constants_STRING_IN) : (__builtin_constant_p (val) && ((size_t)(const void *)((val) + 1) - (size_t)(const void *)(val) == 1) && (__s1_len = strlen (val), __s1_len < 4) ? (__builtin_constant_p (constants_STRING_IN) && ((size_t)(const void *)((constants_STRING_IN) + 1) - (size_t)(const void *)(constants_STRING_IN) == 1) ? __builtin_strcmp (val, constants_STRING_IN) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (constants_STRING_IN); register int __result = (((__const unsigned char *) (__const char *) (val))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (val))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (val))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (val))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (constants_STRING_IN) && ((size_t)(const void *)((constants_STRING_IN) + 1) - (size_t)(const void *)(constants_STRING_IN) == 1) && (__s2_len = strlen (constants_STRING_IN), __s2_len < 4) ? (__builtin_constant_p (val) && ((size_t)(const void *)((val) + 1) - (size_t)(const void *)(val) == 1) ? __builtin_strcmp (val, constants_STRING_IN) : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (val); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (constants_STRING_IN))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (constants_STRING_IN))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (constants_STRING_IN))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (constants_STRING_IN))[3]); } } __result; }))) : __builtin_strcmp (val, constants_STRING_IN)))); })) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "basicServer.c", 39, __PRETTY_FUNCTION__, "!strcmp (val, constants_STRING_IN)"); });
}

static CORBA_long
BasicServer__get_bah (PortableServer_Servant servant,
        CORBA_Environment *ev)
{
 return 0xAABBCCDD;
}

static CORBA_char *
BasicServer_opString (PortableServer_Servant servant,
        const CORBA_char *inArg,
        CORBA_char **inoutArg,
        CORBA_char **outArg,
        CORBA_Environment *ev)
{
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (!__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (inArg) && __builtin_constant_p (constants_STRING_IN) && (__s1_len = strlen (inArg), __s2_len = strlen (constants_STRING_IN), (!((size_t)(const void *)((inArg) + 1) - (size_t)(const void *)(inArg) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((constants_STRING_IN) + 1) - (size_t)(const void *)(constants_STRING_IN) == 1) || __s2_len >= 4)) ? __builtin_strcmp (inArg, constants_STRING_IN) : (__builtin_constant_p (inArg) && ((size_t)(const void *)((inArg) + 1) - (size_t)(const void *)(inArg) == 1) && (__s1_len = strlen (inArg), __s1_len < 4) ? (__builtin_constant_p (constants_STRING_IN) && ((size_t)(const void *)((constants_STRING_IN) + 1) - (size_t)(const void *)(constants_STRING_IN) == 1) ? __builtin_strcmp (inArg, constants_STRING_IN) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (constants_STRING_IN); register int __result = (((__const unsigned char *) (__const char *) (inArg))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (inArg))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (inArg))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (inArg))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (constants_STRING_IN) && ((size_t)(const void *)((constants_STRING_IN) + 1) - (size_t)(const void *)(constants_STRING_IN) == 1) && (__s2_len = strlen (constants_STRING_IN), __s2_len < 4) ? (__builtin_constant_p (inArg) && ((size_t)(const void *)((inArg) + 1) - (size_t)(const void *)(inArg) == 1) ? __builtin_strcmp (inArg, constants_STRING_IN) : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (inArg); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (constants_STRING_IN))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (constants_STRING_IN))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (constants_STRING_IN))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (constants_STRING_IN))[3]); } } __result; }))) : __builtin_strcmp (inArg, constants_STRING_IN)))); })) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "basicServer.c", 56, __PRETTY_FUNCTION__, "!strcmp (inArg, constants_STRING_IN)"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (!__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (*inoutArg) && __builtin_constant_p (constants_STRING_INOUT_IN) && (__s1_len = strlen (*inoutArg), __s2_len = strlen (constants_STRING_INOUT_IN), (!((size_t)(const void *)((*inoutArg) + 1) - (size_t)(const void *)(*inoutArg) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((constants_STRING_INOUT_IN) + 1) - (size_t)(const void *)(constants_STRING_INOUT_IN) == 1) || __s2_len >= 4)) ? __builtin_strcmp (*inoutArg, constants_STRING_INOUT_IN) : (__builtin_constant_p (*inoutArg) && ((size_t)(const void *)((*inoutArg) + 1) - (size_t)(const void *)(*inoutArg) == 1) && (__s1_len = strlen (*inoutArg), __s1_len < 4) ? (__builtin_constant_p (constants_STRING_INOUT_IN) && ((size_t)(const void *)((constants_STRING_INOUT_IN) + 1) - (size_t)(const void *)(constants_STRING_INOUT_IN) == 1) ? __builtin_strcmp (*inoutArg, constants_STRING_INOUT_IN) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (constants_STRING_INOUT_IN); register int __result = (((__const unsigned char *) (__const char *) (*inoutArg))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (*inoutArg))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (*inoutArg))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (*inoutArg))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (constants_STRING_INOUT_IN) && ((size_t)(const void *)((constants_STRING_INOUT_IN) + 1) - (size_t)(const void *)(constants_STRING_INOUT_IN) == 1) && (__s2_len = strlen (constants_STRING_INOUT_IN), __s2_len < 4) ? (__builtin_constant_p (*inoutArg) && ((size_t)(const void *)((*inoutArg) + 1) - (size_t)(const void *)(*inoutArg) == 1) ? __builtin_strcmp (*inoutArg, constants_STRING_INOUT_IN) : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (*inoutArg); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (constants_STRING_INOUT_IN))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (constants_STRING_INOUT_IN))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (constants_STRING_INOUT_IN))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (constants_STRING_INOUT_IN))[3]); } } __result; }))) : __builtin_strcmp (*inoutArg, constants_STRING_INOUT_IN)))); })) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "basicServer.c", 57, __PRETTY_FUNCTION__, "!strcmp (*inoutArg, constants_STRING_INOUT_IN)"); });

 CORBA_free (*inoutArg);
 *inoutArg = CORBA_string_dup (constants_STRING_INOUT_OUT);
 *outArg = CORBA_string_dup (constants_STRING_OUT);

 return CORBA_string_dup (constants_STRING_RETN);
}

static CORBA_long
BasicServer_opLong (PortableServer_Servant servant,
      const CORBA_long inArg,
      CORBA_long *inoutArg,
      CORBA_long *outArg,
      CORBA_Environment *ev)
{
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inArg == 0x12345678) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "basicServer.c", 73, __PRETTY_FUNCTION__, "inArg == constants_LONG_IN"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (*inoutArg == 0x34567812) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "basicServer.c", 74, __PRETTY_FUNCTION__, "*inoutArg == constants_LONG_INOUT_IN"); });

 *inoutArg = 0x56781234;
 *outArg = 0x78123456;;

 return 0xAABBCCDD;
}

static CORBA_long_long
BasicServer_opLongLong (PortableServer_Servant servant,
   const CORBA_long_long inArg,
   CORBA_long_long *inoutArg,
   CORBA_long_long *outArg,
   CORBA_Environment *ev)
{
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inArg == 0x12345678) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "basicServer.c", 89, __PRETTY_FUNCTION__, "inArg == constants_LONG_LONG_IN"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (*inoutArg == 0x34567812) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "basicServer.c", 90, __PRETTY_FUNCTION__, "*inoutArg == constants_LONG_LONG_INOUT_IN"); });

 *inoutArg = 0x56781234;
 *outArg = 0x78123456;;

 return 0xAABBCCDD;
}

static CORBA_float
BasicServer_opFloat (PortableServer_Servant servant,
       const CORBA_float inArg,
       CORBA_float *inoutArg,
       CORBA_float *outArg,
       CORBA_Environment *ev)
{
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inArg == ((CORBA_float) 127.13534)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "basicServer.c", 105, __PRETTY_FUNCTION__, "inArg == constants_FLOAT_IN"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (*inoutArg == ((CORBA_float) 124.89432)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "basicServer.c", 106, __PRETTY_FUNCTION__, "*inoutArg == constants_FLOAT_INOUT_IN"); });

 *inoutArg = ((CORBA_float) 975.12694);
 *outArg = ((CORBA_float) 112.54575);;

 return ((CORBA_float) 354.23535);
}

static CORBA_double
BasicServer_opDouble (PortableServer_Servant servant,
        const CORBA_double inArg,
        CORBA_double *inoutArg,
        CORBA_double *outArg,
        CORBA_Environment *ev)
{
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inArg == ((CORBA_double) 127.13534)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "basicServer.c", 121, __PRETTY_FUNCTION__, "inArg == constants_DOUBLE_IN"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (*inoutArg == ((CORBA_double) 124.89432)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "basicServer.c", 122, __PRETTY_FUNCTION__, "*inoutArg == constants_DOUBLE_INOUT_IN"); });

 *inoutArg = ((CORBA_double) 975.12694);
 *outArg = ((CORBA_double) 112.54575);;

 return ((CORBA_double) 354.23535);
}

static CORBA_long_double
BasicServer_opLongDouble (PortableServer_Servant servant,
     const CORBA_long_double inArg,
     CORBA_long_double *inoutArg,
     CORBA_long_double *outArg,
     CORBA_Environment *ev)
{
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inArg == ((CORBA_long_double) 127.13534)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "basicServer.c", 137, __PRETTY_FUNCTION__, "inArg == constants_LONG_DOUBLE_IN"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (*inoutArg == ((CORBA_long_double) 124.89432)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "basicServer.c", 138, __PRETTY_FUNCTION__, "*inoutArg == constants_LONG_DOUBLE_INOUT_IN"); });

 *inoutArg = ((CORBA_long_double) 975.12694);
 *outArg = ((CORBA_long_double) 112.54575);;

 return ((CORBA_long_double) 354.23535);
}

static test_AnEnum
BasicServer_opEnum (PortableServer_Servant servant,
      const test_AnEnum inArg,
      test_AnEnum *inoutArg,
      test_AnEnum *outArg,
      CORBA_Environment *ev)
{
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inArg == test_ENUM_IN) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "basicServer.c", 153, __PRETTY_FUNCTION__, "inArg == test_ENUM_IN"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (*inoutArg == test_ENUM_INOUT_IN) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "basicServer.c", 154, __PRETTY_FUNCTION__, "*inoutArg == test_ENUM_INOUT_IN"); });

 *inoutArg = test_ENUM_INOUT_OUT;
 *outArg = test_ENUM_OUT;

 return test_ENUM_RETN;
}

static void
BasicServer_opException (PortableServer_Servant servant,
    CORBA_Environment *ev)
{
 test_TestException *ex = ((test_TestException *)ORBit_small_alloc (((CORBA_TypeCode)&TC_test_TestException_struct)));

 ex->reason = CORBA_string_dup (constants_STRING_IN);
 ex->number = 0x12345678;
 ex->aseq._buffer = ((CORBA_long*)ORBit_small_allocbuf (((CORBA_TypeCode)&TC_CORBA_sequence_CORBA_long_struct), (1)));
 ex->aseq._length = 1;
 ex->aseq._buffer [0] = 0x12345678;
 ex->factory = getFactoryInstance(ev);

 (&ex->aseq)->_release = CORBA_TRUE;

 CORBA_exception_set (
  ev, CORBA_USER_EXCEPTION, "IDL:orbit/test/TestException:1.0",ex);
}

static void
BasicServer_opOneWay (PortableServer_Servant servant,
        const CORBA_char *str,
        CORBA_Environment *ev)
{
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (!__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (str) && __builtin_constant_p (constants_STRING_IN) && (__s1_len = strlen (str), __s2_len = strlen (constants_STRING_IN), (!((size_t)(const void *)((str) + 1) - (size_t)(const void *)(str) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((constants_STRING_IN) + 1) - (size_t)(const void *)(constants_STRING_IN) == 1) || __s2_len >= 4)) ? __builtin_strcmp (str, constants_STRING_IN) : (__builtin_constant_p (str) && ((size_t)(const void *)((str) + 1) - (size_t)(const void *)(str) == 1) && (__s1_len = strlen (str), __s1_len < 4) ? (__builtin_constant_p (constants_STRING_IN) && ((size_t)(const void *)((constants_STRING_IN) + 1) - (size_t)(const void *)(constants_STRING_IN) == 1) ? __builtin_strcmp (str, constants_STRING_IN) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (constants_STRING_IN); register int __result = (((__const unsigned char *) (__const char *) (str))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (str))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (str))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (str))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (constants_STRING_IN) && ((size_t)(const void *)((constants_STRING_IN) + 1) - (size_t)(const void *)(constants_STRING_IN) == 1) && (__s2_len = strlen (constants_STRING_IN), __s2_len < 4) ? (__builtin_constant_p (str) && ((size_t)(const void *)((str) + 1) - (size_t)(const void *)(str) == 1) ? __builtin_strcmp (str, constants_STRING_IN) : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (str); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (constants_STRING_IN))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (constants_STRING_IN))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (constants_STRING_IN))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (constants_STRING_IN))[3]); } } __result; }))) : __builtin_strcmp (str, constants_STRING_IN)))); })) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "basicServer.c", 186, __PRETTY_FUNCTION__, "!strcmp (str, constants_STRING_IN)"); });
}

static void
BasicServer_testLargeStringSeq (PortableServer_Servant servant,
    const test_StrSeq *seq,
    CORBA_Environment *ev)
{
}


static char* iorstrings[] = {
  "IOR:010000001f00000049444c3a6f726269742f746573742f54657"
 "374466163746f72793a312e300000030000000054424f6400000001"
 "01020005000000554e495800000000160000006c6f63616c686f737"
 "42e6c6f63616c646f6d61696e0000002d0000002f746d702f6f7262"
 "69742d6d69636861656c2f6c696e632d363733322d302d373362323"
 "966373333316662390000000000000000caaedfba58000000010102"
 "002d0000002f746d702f6f726269742d6d69636861656c2f6c696e6"
 "32d363733322d302d37336232396637333331666239000000001c00"
 "000000000000331c40f8ba0fa828dc2928282828282808000000db7"
 "e269601000000480000000100000002000000050000001c00000000"
 "000000331c40f8ba0fa828dc2928282828282808000000db7e26960"
 "1000000140000000100000001000105000000000901010000000000",
  "IOR:000000000000002249444c3a4163636573736962696c6974792"
 "f4170706c69636174696f6e3a312e30000000000000010000000000"
 "000082000102000000000a3132372e302e302e3200837800000031a"
 "fabcb00000000200d3e1d2600000001000000000000000100000008"
 "526f6f74504f4100000000080000000100000000140000000000000"
 "2000000010000002000000000000100010000000205010001000100"
 "2000010109000000010001010000000026000000020002"
};

static CORBA_long
BasicServer_getObjectCount (PortableServer_Servant servant,
       CORBA_Environment *ev)
{
 return (sizeof (iorstrings) / sizeof ((iorstrings)[0])) + 1;
}

static CORBA_Object
BasicServer_getObject (PortableServer_Servant servant,
         const CORBA_long which,
         CORBA_Environment *ev)
{
 if (which < (sizeof (iorstrings) / sizeof ((iorstrings)[0])))
  return CORBA_ORB_string_to_object (global_orb, iorstrings[which], ev);
 else
  return ((void *)0);
}

static void
BasicServer_testBoolString (PortableServer_Servant servant,
       CORBA_boolean inBool,
       const char *inArg,
       char **inoutArg,
       CORBA_Environment *ev)
{
}


POA_test_BasicServer__epv BasicServer_epv = {
 ((void *)0),
 BasicServer__get_foo,
 BasicServer__set_foo,
 BasicServer__get_bah,
 BasicServer_opString,
 BasicServer_opLong,
 BasicServer_opLongLong,
 BasicServer_opFloat,
 BasicServer_opDouble,
 BasicServer_opLongDouble,
 BasicServer_opEnum,
 BasicServer_opException,
 BasicServer_opOneWay,
 ((void *)0),
 BasicServer_testLargeStringSeq,
 BasicServer_getObjectCount,
 BasicServer_getObject,
 BasicServer_testBoolString,
};

PortableServer_ServantBase__epv BasicServer_base_epv = {((void *)0), simple_finalize, ((void *)0)};
POA_test_BasicServer__vepv BasicServer_vepv = { &BasicServer_base_epv, &BasicServer_epv };
# 82 "server.c" 2
# 1 "structServer.c" 1
# 22 "structServer.c"
# 1 "everything.h" 1
# 23 "structServer.c" 2



static test_FixedLengthStruct
StructServer_opFixed (PortableServer_Servant servant,
        const test_FixedLengthStruct *inArg,
        test_FixedLengthStruct *inoutArg,
        test_FixedLengthStruct *outArg,
        CORBA_Environment *ev)
{
 test_FixedLengthStruct retval;
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inArg->a == constants_SHORT_IN) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "structServer.c", 34, __PRETTY_FUNCTION__, "inArg->a == constants_SHORT_IN"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inoutArg->a == constants_SHORT_INOUT_IN) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "structServer.c", 35, __PRETTY_FUNCTION__, "inoutArg->a == constants_SHORT_INOUT_IN"); });

 inoutArg->a = constants_SHORT_INOUT_OUT;
 outArg->a = constants_SHORT_OUT;
 retval.a = constants_SHORT_RETN;

 return retval;
}



static test_VariableLengthStruct*
StructServer_opVariable (PortableServer_Servant servant,
   const test_VariableLengthStruct *inArg,
   test_VariableLengthStruct *inoutArg,
   test_VariableLengthStruct **outArg,
   CORBA_Environment *ev)
{
 test_VariableLengthStruct *retval;
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (!__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (inArg->a) && __builtin_constant_p (constants_STRING_IN) && (__s1_len = strlen (inArg->a), __s2_len = strlen (constants_STRING_IN), (!((size_t)(const void *)((inArg->a) + 1) - (size_t)(const void *)(inArg->a) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((constants_STRING_IN) + 1) - (size_t)(const void *)(constants_STRING_IN) == 1) || __s2_len >= 4)) ? __builtin_strcmp (inArg->a, constants_STRING_IN) : (__builtin_constant_p (inArg->a) && ((size_t)(const void *)((inArg->a) + 1) - (size_t)(const void *)(inArg->a) == 1) && (__s1_len = strlen (inArg->a), __s1_len < 4) ? (__builtin_constant_p (constants_STRING_IN) && ((size_t)(const void *)((constants_STRING_IN) + 1) - (size_t)(const void *)(constants_STRING_IN) == 1) ? __builtin_strcmp (inArg->a, constants_STRING_IN) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (constants_STRING_IN); register int __result = (((__const unsigned char *) (__const char *) (inArg->a))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (inArg->a))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (inArg->a))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (inArg->a))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (constants_STRING_IN) && ((size_t)(const void *)((constants_STRING_IN) + 1) - (size_t)(const void *)(constants_STRING_IN) == 1) && (__s2_len = strlen (constants_STRING_IN), __s2_len < 4) ? (__builtin_constant_p (inArg->a) && ((size_t)(const void *)((inArg->a) + 1) - (size_t)(const void *)(inArg->a) == 1) ? __builtin_strcmp (inArg->a, constants_STRING_IN) : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (inArg->a); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (constants_STRING_IN))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (constants_STRING_IN))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (constants_STRING_IN))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (constants_STRING_IN))[3]); } } __result; }))) : __builtin_strcmp (inArg->a, constants_STRING_IN)))); })) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "structServer.c", 54, __PRETTY_FUNCTION__, "!strcmp (inArg->a,constants_STRING_IN)"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (!__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (inoutArg->a) && __builtin_constant_p (constants_STRING_INOUT_IN) && (__s1_len = strlen (inoutArg->a), __s2_len = strlen (constants_STRING_INOUT_IN), (!((size_t)(const void *)((inoutArg->a) + 1) - (size_t)(const void *)(inoutArg->a) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((constants_STRING_INOUT_IN) + 1) - (size_t)(const void *)(constants_STRING_INOUT_IN) == 1) || __s2_len >= 4)) ? __builtin_strcmp (inoutArg->a, constants_STRING_INOUT_IN) : (__builtin_constant_p (inoutArg->a) && ((size_t)(const void *)((inoutArg->a) + 1) - (size_t)(const void *)(inoutArg->a) == 1) && (__s1_len = strlen (inoutArg->a), __s1_len < 4) ? (__builtin_constant_p (constants_STRING_INOUT_IN) && ((size_t)(const void *)((constants_STRING_INOUT_IN) + 1) - (size_t)(const void *)(constants_STRING_INOUT_IN) == 1) ? __builtin_strcmp (inoutArg->a, constants_STRING_INOUT_IN) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (constants_STRING_INOUT_IN); register int __result = (((__const unsigned char *) (__const char *) (inoutArg->a))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (inoutArg->a))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (inoutArg->a))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (inoutArg->a))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (constants_STRING_INOUT_IN) && ((size_t)(const void *)((constants_STRING_INOUT_IN) + 1) - (size_t)(const void *)(constants_STRING_INOUT_IN) == 1) && (__s2_len = strlen (constants_STRING_INOUT_IN), __s2_len < 4) ? (__builtin_constant_p (inoutArg->a) && ((size_t)(const void *)((inoutArg->a) + 1) - (size_t)(const void *)(inoutArg->a) == 1) ? __builtin_strcmp (inoutArg->a, constants_STRING_INOUT_IN) : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (inoutArg->a); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (constants_STRING_INOUT_IN))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (constants_STRING_INOUT_IN))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (constants_STRING_INOUT_IN))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (constants_STRING_INOUT_IN))[3]); } } __result; }))) : __builtin_strcmp (inoutArg->a, constants_STRING_INOUT_IN)))); })) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "structServer.c", 55, __PRETTY_FUNCTION__, "!strcmp (inoutArg->a,constants_STRING_INOUT_IN)"); });

 *outArg = ((test_VariableLengthStruct *)ORBit_small_alloc (((CORBA_TypeCode)&TC_test_VariableLengthStruct_struct)));
 retval = ((test_VariableLengthStruct *)ORBit_small_alloc (((CORBA_TypeCode)&TC_test_VariableLengthStruct_struct)));

 CORBA_free (inoutArg->a);

 inoutArg->a = CORBA_string_dup (constants_STRING_INOUT_OUT);
 (*outArg)->a = CORBA_string_dup (constants_STRING_OUT);
 retval->a = CORBA_string_dup (constants_STRING_RETN);

 return retval;
}

static test_CompoundStruct *
StructServer_opCompound (PortableServer_Servant servant,
    const test_CompoundStruct *inArg,
    test_CompoundStruct *inoutArg,
    test_CompoundStruct **outArg,
    CORBA_Environment *ev)
{
 test_CompoundStruct *retval;
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (!__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (inArg->a.a) && __builtin_constant_p (constants_STRING_IN) && (__s1_len = strlen (inArg->a.a), __s2_len = strlen (constants_STRING_IN), (!((size_t)(const void *)((inArg->a.a) + 1) - (size_t)(const void *)(inArg->a.a) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((constants_STRING_IN) + 1) - (size_t)(const void *)(constants_STRING_IN) == 1) || __s2_len >= 4)) ? __builtin_strcmp (inArg->a.a, constants_STRING_IN) : (__builtin_constant_p (inArg->a.a) && ((size_t)(const void *)((inArg->a.a) + 1) - (size_t)(const void *)(inArg->a.a) == 1) && (__s1_len = strlen (inArg->a.a), __s1_len < 4) ? (__builtin_constant_p (constants_STRING_IN) && ((size_t)(const void *)((constants_STRING_IN) + 1) - (size_t)(const void *)(constants_STRING_IN) == 1) ? __builtin_strcmp (inArg->a.a, constants_STRING_IN) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (constants_STRING_IN); register int __result = (((__const unsigned char *) (__const char *) (inArg->a.a))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (inArg->a.a))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (inArg->a.a))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (inArg->a.a))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (constants_STRING_IN) && ((size_t)(const void *)((constants_STRING_IN) + 1) - (size_t)(const void *)(constants_STRING_IN) == 1) && (__s2_len = strlen (constants_STRING_IN), __s2_len < 4) ? (__builtin_constant_p (inArg->a.a) && ((size_t)(const void *)((inArg->a.a) + 1) - (size_t)(const void *)(inArg->a.a) == 1) ? __builtin_strcmp (inArg->a.a, constants_STRING_IN) : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (inArg->a.a); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (constants_STRING_IN))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (constants_STRING_IN))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (constants_STRING_IN))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (constants_STRING_IN))[3]); } } __result; }))) : __builtin_strcmp (inArg->a.a, constants_STRING_IN)))); })) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "structServer.c", 77, __PRETTY_FUNCTION__, "!strcmp (inArg->a.a,constants_STRING_IN)"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (!__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (inoutArg->a.a) && __builtin_constant_p (constants_STRING_INOUT_IN) && (__s1_len = strlen (inoutArg->a.a), __s2_len = strlen (constants_STRING_INOUT_IN), (!((size_t)(const void *)((inoutArg->a.a) + 1) - (size_t)(const void *)(inoutArg->a.a) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((constants_STRING_INOUT_IN) + 1) - (size_t)(const void *)(constants_STRING_INOUT_IN) == 1) || __s2_len >= 4)) ? __builtin_strcmp (inoutArg->a.a, constants_STRING_INOUT_IN) : (__builtin_constant_p (inoutArg->a.a) && ((size_t)(const void *)((inoutArg->a.a) + 1) - (size_t)(const void *)(inoutArg->a.a) == 1) && (__s1_len = strlen (inoutArg->a.a), __s1_len < 4) ? (__builtin_constant_p (constants_STRING_INOUT_IN) && ((size_t)(const void *)((constants_STRING_INOUT_IN) + 1) - (size_t)(const void *)(constants_STRING_INOUT_IN) == 1) ? __builtin_strcmp (inoutArg->a.a, constants_STRING_INOUT_IN) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (constants_STRING_INOUT_IN); register int __result = (((__const unsigned char *) (__const char *) (inoutArg->a.a))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (inoutArg->a.a))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (inoutArg->a.a))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (inoutArg->a.a))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (constants_STRING_INOUT_IN) && ((size_t)(const void *)((constants_STRING_INOUT_IN) + 1) - (size_t)(const void *)(constants_STRING_INOUT_IN) == 1) && (__s2_len = strlen (constants_STRING_INOUT_IN), __s2_len < 4) ? (__builtin_constant_p (inoutArg->a.a) && ((size_t)(const void *)((inoutArg->a.a) + 1) - (size_t)(const void *)(inoutArg->a.a) == 1) ? __builtin_strcmp (inoutArg->a.a, constants_STRING_INOUT_IN) : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (inoutArg->a.a); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (constants_STRING_INOUT_IN))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (constants_STRING_INOUT_IN))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (constants_STRING_INOUT_IN))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (constants_STRING_INOUT_IN))[3]); } } __result; }))) : __builtin_strcmp (inoutArg->a.a, constants_STRING_INOUT_IN)))); })) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "structServer.c", 78, __PRETTY_FUNCTION__, "!strcmp (inoutArg->a.a,constants_STRING_INOUT_IN)"); });

 *outArg = ((test_CompoundStruct *)ORBit_small_alloc (((CORBA_TypeCode)&TC_test_CompoundStruct_struct)));
 retval = ((test_CompoundStruct *)ORBit_small_alloc (((CORBA_TypeCode)&TC_test_CompoundStruct_struct)));

 CORBA_free (inoutArg->a.a);

 inoutArg->a.a = CORBA_string_dup (constants_STRING_INOUT_OUT);
 (*outArg)->a.a = CORBA_string_dup (constants_STRING_OUT);
 retval->a.a = CORBA_string_dup (constants_STRING_RETN);

 return retval;
}

static test_AlignHoleStruct
StructServer_opAlignHole (PortableServer_Servant servant,
    const test_AlignHoleStruct *inArg,
    test_AlignHoleStruct *inoutArg,
    test_AlignHoleStruct *outArg,
    CORBA_Environment *ev)
{
 test_AlignHoleStruct retval;
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inArg->a.a == ((CORBA_double) 127.13534)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "structServer.c", 100, __PRETTY_FUNCTION__, "inArg->a.a == constants_DOUBLE_IN"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inArg->a.b == constants_OCTET_IN) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "structServer.c", 101, __PRETTY_FUNCTION__, "inArg->a.b == constants_OCTET_IN"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inArg->b == constants_CHAR_IN) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "structServer.c", 102, __PRETTY_FUNCTION__, "inArg->b == constants_CHAR_IN"); });

 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inoutArg->a.a == ((CORBA_double) 124.89432)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "structServer.c", 104, __PRETTY_FUNCTION__, "inoutArg->a.a == constants_DOUBLE_INOUT_IN"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inoutArg->a.b == constants_OCTET_INOUT_IN) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "structServer.c", 105, __PRETTY_FUNCTION__, "inoutArg->a.b == constants_OCTET_INOUT_IN"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inoutArg->b == constants_CHAR_INOUT_IN) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "structServer.c", 106, __PRETTY_FUNCTION__, "inoutArg->b == constants_CHAR_INOUT_IN"); });

 inoutArg->a.a = ((CORBA_double) 975.12694);
 inoutArg->a.b = constants_OCTET_INOUT_OUT;
 inoutArg->b = constants_CHAR_INOUT_OUT;

 outArg->a.a = ((CORBA_double) 112.54575);
 outArg->a.b = constants_OCTET_OUT;
 outArg->b = constants_CHAR_OUT;

 retval.a.a = ((CORBA_double) 354.23535);
 retval.a.b = constants_OCTET_RETN;
 retval.b = constants_CHAR_RETN;

 return retval;
}

static void
StructServer_opObjectStruct (PortableServer_Servant servant,
        const test_ObjectStruct *inArg,
        CORBA_Environment *ev)
{
 CORBA_Object objref;
 test_StructAny *val;

 objref = CORBA_Object_duplicate (inArg->serv, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "structServer.c", 132, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 val = test_StructServer_opStructAny (inArg->serv, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "structServer.c", 135, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 CORBA_free (val);

 CORBA_Object_release (objref, ev);
}

static test_StructAny *
StructServer_opStructAny (PortableServer_Servant servant,
     CORBA_Environment *ev)
{
 test_StructAny *a = ((test_StructAny *)ORBit_small_alloc (((CORBA_TypeCode)&TC_test_StructAny_struct)));
 static CORBA_long l;

 a->a = CORBA_string_dup (constants_STRING_IN);

 l = 0x12345678;
 a->b._release = (0);
 a->b._value = &l;
 a->b._type = ((CORBA_TypeCode)&TC_CORBA_long_struct);

 return a;
}

POA_test_StructServer__epv StructServer_epv = {
 ((void *)0),
 StructServer_opFixed,
 StructServer_opVariable,
 StructServer_opCompound,
 StructServer_opAlignHole,
 StructServer_opObjectStruct,
 StructServer_opStructAny
};

PortableServer_ServantBase__epv StructServer_base_epv = {((void *)0), simple_finalize, ((void *)0)};
POA_test_StructServer__vepv StructServer_vepv = {&StructServer_base_epv,&BasicServer_epv,&StructServer_epv};

POA_test_StructServer StructServer_servant = {((void *)0),&StructServer_vepv};
# 83 "server.c" 2
# 1 "sequenceServer.c" 1
# 22 "sequenceServer.c"
# 1 "everything.h" 1
# 23 "sequenceServer.c" 2



static test_StrSeq *
SequenceServer_opStrSeq (PortableServer_Servant _servant,
    const test_StrSeq * inArg,
    test_StrSeq * inoutArg,
    test_StrSeq ** outArg,
    CORBA_Environment * ev)
{
 test_StrSeq *retn;
 guint i;
 for (i=0;i<inArg->_length;i++)
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (inArg->_buffer[i]) && __builtin_constant_p (constants_SEQ_STRING_IN[i]) && (__s1_len = strlen (inArg->_buffer[i]), __s2_len = strlen (constants_SEQ_STRING_IN[i]), (!((size_t)(const void *)((inArg->_buffer[i]) + 1) - (size_t)(const void *)(inArg->_buffer[i]) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((constants_SEQ_STRING_IN[i]) + 1) - (size_t)(const void *)(constants_SEQ_STRING_IN[i]) == 1) || __s2_len >= 4)) ? __builtin_strcmp (inArg->_buffer[i], constants_SEQ_STRING_IN[i]) : (__builtin_constant_p (inArg->_buffer[i]) && ((size_t)(const void *)((inArg->_buffer[i]) + 1) - (size_t)(const void *)(inArg->_buffer[i]) == 1) && (__s1_len = strlen (inArg->_buffer[i]), __s1_len < 4) ? (__builtin_constant_p (constants_SEQ_STRING_IN[i]) && ((size_t)(const void *)((constants_SEQ_STRING_IN[i]) + 1) - (size_t)(const void *)(constants_SEQ_STRING_IN[i]) == 1) ? __builtin_strcmp (inArg->_buffer[i], constants_SEQ_STRING_IN[i]) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (constants_SEQ_STRING_IN[i]); register int __result = (((__const unsigned char *) (__const char *) (inArg->_buffer[i]))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (inArg->_buffer[i]))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (inArg->_buffer[i]))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (inArg->_buffer[i]))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (constants_SEQ_STRING_IN[i]) && ((size_t)(const void *)((constants_SEQ_STRING_IN[i]) + 1) - (size_t)(const void *)(constants_SEQ_STRING_IN[i]) == 1) && (__s2_len = strlen (constants_SEQ_STRING_IN[i]), __s2_len < 4) ? (__builtin_constant_p (inArg->_buffer[i]) && ((size_t)(const void *)((inArg->_buffer[i]) + 1) - (size_t)(const void *)(inArg->_buffer[i]) == 1) ? __builtin_strcmp (inArg->_buffer[i], constants_SEQ_STRING_IN[i]) : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (inArg->_buffer[i]); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (constants_SEQ_STRING_IN[i]))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (constants_SEQ_STRING_IN[i]))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (constants_SEQ_STRING_IN[i]))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (constants_SEQ_STRING_IN[i]))[3]); } } __result; }))) : __builtin_strcmp (inArg->_buffer[i], constants_SEQ_STRING_IN[i])))); }) == 0) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "sequenceServer.c", 36, __PRETTY_FUNCTION__, "strcmp(inArg->_buffer[i],constants_SEQ_STRING_IN[i]) == 0"); });

 for (i=0;i<inoutArg->_length;i++)
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (inoutArg->_buffer[i]) && __builtin_constant_p (constants_SEQ_STRING_INOUT_IN[i]) && (__s1_len = strlen (inoutArg->_buffer[i]), __s2_len = strlen (constants_SEQ_STRING_INOUT_IN[i]), (!((size_t)(const void *)((inoutArg->_buffer[i]) + 1) - (size_t)(const void *)(inoutArg->_buffer[i]) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((constants_SEQ_STRING_INOUT_IN[i]) + 1) - (size_t)(const void *)(constants_SEQ_STRING_INOUT_IN[i]) == 1) || __s2_len >= 4)) ? __builtin_strcmp (inoutArg->_buffer[i], constants_SEQ_STRING_INOUT_IN[i]) : (__builtin_constant_p (inoutArg->_buffer[i]) && ((size_t)(const void *)((inoutArg->_buffer[i]) + 1) - (size_t)(const void *)(inoutArg->_buffer[i]) == 1) && (__s1_len = strlen (inoutArg->_buffer[i]), __s1_len < 4) ? (__builtin_constant_p (constants_SEQ_STRING_INOUT_IN[i]) && ((size_t)(const void *)((constants_SEQ_STRING_INOUT_IN[i]) + 1) - (size_t)(const void *)(constants_SEQ_STRING_INOUT_IN[i]) == 1) ? __builtin_strcmp (inoutArg->_buffer[i], constants_SEQ_STRING_INOUT_IN[i]) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (constants_SEQ_STRING_INOUT_IN[i]); register int __result = (((__const unsigned char *) (__const char *) (inoutArg->_buffer[i]))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (inoutArg->_buffer[i]))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (inoutArg->_buffer[i]))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (inoutArg->_buffer[i]))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (constants_SEQ_STRING_INOUT_IN[i]) && ((size_t)(const void *)((constants_SEQ_STRING_INOUT_IN[i]) + 1) - (size_t)(const void *)(constants_SEQ_STRING_INOUT_IN[i]) == 1) && (__s2_len = strlen (constants_SEQ_STRING_INOUT_IN[i]), __s2_len < 4) ? (__builtin_constant_p (inoutArg->_buffer[i]) && ((size_t)(const void *)((inoutArg->_buffer[i]) + 1) - (size_t)(const void *)(inoutArg->_buffer[i]) == 1) ? __builtin_strcmp (inoutArg->_buffer[i], constants_SEQ_STRING_INOUT_IN[i]) : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (inoutArg->_buffer[i]); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (constants_SEQ_STRING_INOUT_IN[i]))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (constants_SEQ_STRING_INOUT_IN[i]))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (constants_SEQ_STRING_INOUT_IN[i]))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (constants_SEQ_STRING_INOUT_IN[i]))[3]); } } __result; }))) : __builtin_strcmp (inoutArg->_buffer[i], constants_SEQ_STRING_INOUT_IN[i])))); }) == 0) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "sequenceServer.c", 39, __PRETTY_FUNCTION__, "strcmp(inoutArg->_buffer[i],constants_SEQ_STRING_INOUT_IN[i]) == 0"); });

 if ((inoutArg)->_release)
  CORBA_free(inoutArg->_buffer);

 inoutArg->_buffer = ((CORBA_string*)ORBit_small_allocbuf (((CORBA_TypeCode)&TC_CORBA_sequence_CORBA_string_struct), (2)));
 inoutArg->_length = 2;
 (inoutArg)->_release = CORBA_TRUE;

 for (i=0;i<inoutArg->_length;i++)
  inoutArg->_buffer[i] = CORBA_string_dup(constants_SEQ_STRING_INOUT_OUT[i]);

 *outArg = ((CORBA_sequence_CORBA_string *)ORBit_small_alloc (((CORBA_TypeCode)&TC_CORBA_sequence_CORBA_string_struct)));
 (*outArg)->_buffer = ((CORBA_string*)ORBit_small_allocbuf (((CORBA_TypeCode)&TC_CORBA_sequence_CORBA_string_struct), (2)));
 (*outArg)->_length = 2;
 (*outArg)->_release = CORBA_TRUE;

 for (i=0;i<(*outArg)->_length;i++)
  (*outArg)->_buffer[i] = CORBA_string_dup(constants_SEQ_STRING_OUT[i]);

 retn = ((CORBA_sequence_CORBA_string *)ORBit_small_alloc (((CORBA_TypeCode)&TC_CORBA_sequence_CORBA_string_struct)));
 retn->_buffer = ((CORBA_string*)ORBit_small_allocbuf (((CORBA_TypeCode)&TC_CORBA_sequence_CORBA_string_struct), (2)));
 retn->_length = 2;
 (retn)->_release = CORBA_TRUE;

 for (i=0;i<retn->_length;i++)
  retn->_buffer[i] = CORBA_string_dup(constants_SEQ_STRING_RETN[i]);

 return retn;
}

static test_BoundedStructSeq *
SequenceServer_opBoundedStructSeq (PortableServer_Servant _servant,
       const test_BoundedStructSeq * inArg,
       test_BoundedStructSeq * inoutArg,
       test_BoundedStructSeq ** outArg,
       CORBA_Environment * ev)
{
 test_BoundedStructSeq *retn;
 CORBA_long i;
 for (i = 0; i < inArg->_length; i++)
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (inArg->_buffer[i].a.a) && __builtin_constant_p (constants_SEQ_STRING_IN[i]) && (__s1_len = strlen (inArg->_buffer[i].a.a), __s2_len = strlen (constants_SEQ_STRING_IN[i]), (!((size_t)(const void *)((inArg->_buffer[i].a.a) + 1) - (size_t)(const void *)(inArg->_buffer[i].a.a) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((constants_SEQ_STRING_IN[i]) + 1) - (size_t)(const void *)(constants_SEQ_STRING_IN[i]) == 1) || __s2_len >= 4)) ? __builtin_strcmp (inArg->_buffer[i].a.a, constants_SEQ_STRING_IN[i]) : (__builtin_constant_p (inArg->_buffer[i].a.a) && ((size_t)(const void *)((inArg->_buffer[i].a.a) + 1) - (size_t)(const void *)(inArg->_buffer[i].a.a) == 1) && (__s1_len = strlen (inArg->_buffer[i].a.a), __s1_len < 4) ? (__builtin_constant_p (constants_SEQ_STRING_IN[i]) && ((size_t)(const void *)((constants_SEQ_STRING_IN[i]) + 1) - (size_t)(const void *)(constants_SEQ_STRING_IN[i]) == 1) ? __builtin_strcmp (inArg->_buffer[i].a.a, constants_SEQ_STRING_IN[i]) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (constants_SEQ_STRING_IN[i]); register int __result = (((__const unsigned char *) (__const char *) (inArg->_buffer[i].a.a))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (inArg->_buffer[i].a.a))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (inArg->_buffer[i].a.a))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (inArg->_buffer[i].a.a))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (constants_SEQ_STRING_IN[i]) && ((size_t)(const void *)((constants_SEQ_STRING_IN[i]) + 1) - (size_t)(const void *)(constants_SEQ_STRING_IN[i]) == 1) && (__s2_len = strlen (constants_SEQ_STRING_IN[i]), __s2_len < 4) ? (__builtin_constant_p (inArg->_buffer[i].a.a) && ((size_t)(const void *)((inArg->_buffer[i].a.a) + 1) - (size_t)(const void *)(inArg->_buffer[i].a.a) == 1) ? __builtin_strcmp (inArg->_buffer[i].a.a, constants_SEQ_STRING_IN[i]) : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (inArg->_buffer[i].a.a); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (constants_SEQ_STRING_IN[i]))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (constants_SEQ_STRING_IN[i]))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (constants_SEQ_STRING_IN[i]))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (constants_SEQ_STRING_IN[i]))[3]); } } __result; }))) : __builtin_strcmp (inArg->_buffer[i].a.a, constants_SEQ_STRING_IN[i])))); }) == 0) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "sequenceServer.c", 80, __PRETTY_FUNCTION__, "strcmp (inArg->_buffer[i].a.a, constants_SEQ_STRING_IN[i]) == 0"); });

 for (i = 0; i < inoutArg->_length; i++)
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (inoutArg->_buffer[i].a.a) && __builtin_constant_p (constants_SEQ_STRING_INOUT_IN[i]) && (__s1_len = strlen (inoutArg->_buffer[i].a.a), __s2_len = strlen (constants_SEQ_STRING_INOUT_IN[i]), (!((size_t)(const void *)((inoutArg->_buffer[i].a.a) + 1) - (size_t)(const void *)(inoutArg->_buffer[i].a.a) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((constants_SEQ_STRING_INOUT_IN[i]) + 1) - (size_t)(const void *)(constants_SEQ_STRING_INOUT_IN[i]) == 1) || __s2_len >= 4)) ? __builtin_strcmp (inoutArg->_buffer[i].a.a, constants_SEQ_STRING_INOUT_IN[i]) : (__builtin_constant_p (inoutArg->_buffer[i].a.a) && ((size_t)(const void *)((inoutArg->_buffer[i].a.a) + 1) - (size_t)(const void *)(inoutArg->_buffer[i].a.a) == 1) && (__s1_len = strlen (inoutArg->_buffer[i].a.a), __s1_len < 4) ? (__builtin_constant_p (constants_SEQ_STRING_INOUT_IN[i]) && ((size_t)(const void *)((constants_SEQ_STRING_INOUT_IN[i]) + 1) - (size_t)(const void *)(constants_SEQ_STRING_INOUT_IN[i]) == 1) ? __builtin_strcmp (inoutArg->_buffer[i].a.a, constants_SEQ_STRING_INOUT_IN[i]) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (constants_SEQ_STRING_INOUT_IN[i]); register int __result = (((__const unsigned char *) (__const char *) (inoutArg->_buffer[i].a.a))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (inoutArg->_buffer[i].a.a))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (inoutArg->_buffer[i].a.a))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (inoutArg->_buffer[i].a.a))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (constants_SEQ_STRING_INOUT_IN[i]) && ((size_t)(const void *)((constants_SEQ_STRING_INOUT_IN[i]) + 1) - (size_t)(const void *)(constants_SEQ_STRING_INOUT_IN[i]) == 1) && (__s2_len = strlen (constants_SEQ_STRING_INOUT_IN[i]), __s2_len < 4) ? (__builtin_constant_p (inoutArg->_buffer[i].a.a) && ((size_t)(const void *)((inoutArg->_buffer[i].a.a) + 1) - (size_t)(const void *)(inoutArg->_buffer[i].a.a) == 1) ? __builtin_strcmp (inoutArg->_buffer[i].a.a, constants_SEQ_STRING_INOUT_IN[i]) : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (inoutArg->_buffer[i].a.a); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (constants_SEQ_STRING_INOUT_IN[i]))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (constants_SEQ_STRING_INOUT_IN[i]))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (constants_SEQ_STRING_INOUT_IN[i]))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (constants_SEQ_STRING_INOUT_IN[i]))[3]); } } __result; }))) : __builtin_strcmp (inoutArg->_buffer[i].a.a, constants_SEQ_STRING_INOUT_IN[i])))); }) == 0) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "sequenceServer.c", 83, __PRETTY_FUNCTION__, "strcmp(inoutArg->_buffer[i].a.a,constants_SEQ_STRING_INOUT_IN[i]) == 0"); });

 if ((inoutArg)->_release)
  CORBA_free (inoutArg->_buffer);

 inoutArg->_buffer = ((test_CompoundStruct*)ORBit_small_allocbuf (((CORBA_TypeCode)&TC_CORBA_sequence_test_CompoundStruct_struct), (2)));
 inoutArg->_length = 2;
 (inoutArg)->_release = CORBA_TRUE;

 for (i = 0; i < inoutArg->_length; i++)
  inoutArg->_buffer[i].a.a = CORBA_string_dup (constants_SEQ_STRING_INOUT_OUT[i]);

 *outArg = ((CORBA_sequence_test_CompoundStruct *)ORBit_small_alloc (((CORBA_TypeCode)&TC_CORBA_sequence_test_CompoundStruct_struct)));
 (*outArg)->_buffer = ((test_CompoundStruct*)ORBit_small_allocbuf (((CORBA_TypeCode)&TC_CORBA_sequence_test_CompoundStruct_struct), (2)));
 (*outArg)->_length = 2;
 (*outArg)->_release = CORBA_TRUE;

 for (i = 0; i < (*outArg)->_length; i++)
  (*outArg)->_buffer[i].a.a = CORBA_string_dup (constants_SEQ_STRING_OUT[i]);


 retn = ((CORBA_sequence_test_CompoundStruct *)ORBit_small_alloc (((CORBA_TypeCode)&TC_CORBA_sequence_test_CompoundStruct_struct)));
 retn->_buffer = ((test_CompoundStruct*)ORBit_small_allocbuf (((CORBA_TypeCode)&TC_CORBA_sequence_test_CompoundStruct_struct), (2)));
 retn->_length = 2;
 (retn)->_release = CORBA_TRUE;

 for (i = 0; i < retn->_length; i++)
  retn->_buffer[i].a.a = CORBA_string_dup (constants_SEQ_STRING_RETN[i]);

 return retn;
}

static test_LongSeq *
SequenceServer_opMassiveSeq (PortableServer_Servant servant,
        CORBA_Environment *ev)
{
 test_LongSeq *retn;
 CORBA_long i;
 CORBA_long n = 400000;

 retn = ((test_LongSeq *)ORBit_small_alloc (((CORBA_TypeCode)&TC_CORBA_sequence_CORBA_long_struct)));
 retn->_buffer = ((CORBA_long*)ORBit_small_allocbuf (((CORBA_TypeCode)&TC_CORBA_sequence_CORBA_long_struct), (n)));
 retn->_length = n;
 (retn)->_release = CORBA_TRUE;

 for (i = 0; i < retn->_length; i++)
  retn->_buffer[i] = i;

 return retn;
}

static test_AnySeq *
SequenceServer_opAnySeq (PortableServer_Servant servant,
                         CORBA_Environment *ev)
{
 test_AnySeq *retn;
 CORBA_long i;
 CORBA_long n = 1000;

 retn = ((test_AnySeq *)ORBit_small_alloc (((CORBA_TypeCode)&TC_CORBA_sequence_CORBA_any_struct)));
 retn->_buffer = ((CORBA_any*)ORBit_small_allocbuf (((CORBA_TypeCode)&TC_CORBA_sequence_CORBA_any_struct), (n)));
 retn->_length = n;
 (retn)->_release = CORBA_TRUE;

 for (i = 0; i < retn->_length; i++) {
  if (i < 500)
   retn->_buffer[i]._type = ((CORBA_TypeCode)&TC_void_struct);
  else
   retn->_buffer[i]._type = ((CORBA_TypeCode)&TC_null_struct);
  retn->_buffer[i]._value = ((void *)0);
  retn->_buffer[i]._release = CORBA_FALSE;
        }
 return retn;
}

POA_test_SequenceServer__epv SequenceServer_epv = {
 ((void *)0),
 SequenceServer_opStrSeq,
 SequenceServer_opBoundedStructSeq,
 SequenceServer_opMassiveSeq,
 SequenceServer_opAnySeq,
};

PortableServer_ServantBase__epv SequenceServer_base_epv = {((void *)0), simple_finalize, ((void *)0)};
POA_test_SequenceServer__vepv SequenceServer_vepv = { &SequenceServer_base_epv, &SequenceServer_epv };
# 84 "server.c" 2
# 1 "unionServer.c" 1
# 24 "unionServer.c"
# 1 "everything.h" 1
# 25 "unionServer.c" 2


static
test_FixedLengthUnion
UnionServer_opFixed(PortableServer_Servant _servant,
      const test_FixedLengthUnion *inArg,
     test_FixedLengthUnion *inoutArg,
      test_FixedLengthUnion *outArg,
      CORBA_Environment * ev){
  test_FixedLengthUnion retval;
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inArg->_d == 'a') _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "unionServer.c", 35, __PRETTY_FUNCTION__, "inArg->_d == 'a'"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inArg->_u.x == 0x12345678) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "unionServer.c", 36, __PRETTY_FUNCTION__, "inArg->_u.x == constants_LONG_IN"); });

  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inoutArg->_d == 'b') _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "unionServer.c", 38, __PRETTY_FUNCTION__, "inoutArg->_d == 'b'"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inoutArg->_u.y == 't') _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "unionServer.c", 39, __PRETTY_FUNCTION__, "inoutArg->_u.y == 't'"); });

  inoutArg->_u.z = (!(0));
  inoutArg->_d = 'c';

  outArg->_u.x = 0x78123456;
  outArg->_d = 'a';

  retval._u.z = (0);
  retval._d = 'd';
  return retval;
}

static
test_VariableLengthUnion *
UnionServer_opVariable(PortableServer_Servant _servant,
        const test_VariableLengthUnion * inArg,
        test_VariableLengthUnion * inoutArg,
        test_VariableLengthUnion ** outArg,
        CORBA_Environment * ev){
  test_VariableLengthUnion *retval;

  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inArg->_d == 1) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "unionServer.c", 61, __PRETTY_FUNCTION__, "inArg->_d == 1"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inArg->_u.x == 0x12345678) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "unionServer.c", 62, __PRETTY_FUNCTION__, "inArg->_u.x == constants_LONG_IN"); });

  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inoutArg->_d == 2) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "unionServer.c", 64, __PRETTY_FUNCTION__, "inoutArg->_d == 2"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (inoutArg->_u.y) && __builtin_constant_p (constants_STRING_INOUT_IN) && (__s1_len = strlen (inoutArg->_u.y), __s2_len = strlen (constants_STRING_INOUT_IN), (!((size_t)(const void *)((inoutArg->_u.y) + 1) - (size_t)(const void *)(inoutArg->_u.y) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((constants_STRING_INOUT_IN) + 1) - (size_t)(const void *)(constants_STRING_INOUT_IN) == 1) || __s2_len >= 4)) ? __builtin_strcmp (inoutArg->_u.y, constants_STRING_INOUT_IN) : (__builtin_constant_p (inoutArg->_u.y) && ((size_t)(const void *)((inoutArg->_u.y) + 1) - (size_t)(const void *)(inoutArg->_u.y) == 1) && (__s1_len = strlen (inoutArg->_u.y), __s1_len < 4) ? (__builtin_constant_p (constants_STRING_INOUT_IN) && ((size_t)(const void *)((constants_STRING_INOUT_IN) + 1) - (size_t)(const void *)(constants_STRING_INOUT_IN) == 1) ? __builtin_strcmp (inoutArg->_u.y, constants_STRING_INOUT_IN) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (constants_STRING_INOUT_IN); register int __result = (((__const unsigned char *) (__const char *) (inoutArg->_u.y))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (inoutArg->_u.y))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (inoutArg->_u.y))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (inoutArg->_u.y))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (constants_STRING_INOUT_IN) && ((size_t)(const void *)((constants_STRING_INOUT_IN) + 1) - (size_t)(const void *)(constants_STRING_INOUT_IN) == 1) && (__s2_len = strlen (constants_STRING_INOUT_IN), __s2_len < 4) ? (__builtin_constant_p (inoutArg->_u.y) && ((size_t)(const void *)((inoutArg->_u.y) + 1) - (size_t)(const void *)(inoutArg->_u.y) == 1) ? __builtin_strcmp (inoutArg->_u.y, constants_STRING_INOUT_IN) : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (inoutArg->_u.y); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (constants_STRING_INOUT_IN))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (constants_STRING_INOUT_IN))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (constants_STRING_INOUT_IN))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (constants_STRING_INOUT_IN))[3]); } } __result; }))) : __builtin_strcmp (inoutArg->_u.y, constants_STRING_INOUT_IN)))); })==0) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "unionServer.c", 65, __PRETTY_FUNCTION__, "strcmp(inoutArg->_u.y,constants_STRING_INOUT_IN)==0"); });

  CORBA_free(inoutArg->_u.y);
  inoutArg->_u.z = (!(0));
  inoutArg->_d = 3;

  *outArg = ((test_VariableLengthUnion *)ORBit_small_alloc (((CORBA_TypeCode)&TC_test_VariableLengthUnion_struct)));
  (*outArg)->_u.x = 0x78123456;
  (*outArg)->_d = 1;

  retval = ((test_VariableLengthUnion *)ORBit_small_alloc (((CORBA_TypeCode)&TC_test_VariableLengthUnion_struct)));
  retval->_u.z = (0);
  retval->_d = 4;
  return retval;
}

static test_EnumUnion
UnionServer_opMisc (PortableServer_Servant servant,
      const test_unionSeq *inSeq,
      const test_BooleanUnion *inArg,
      test_ArrayUnion **outArg,
      CORBA_Environment *ev)
{
 test_EnumUnion retval;
 int i;

 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inSeq->_length == 3) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "unionServer.c", 91, __PRETTY_FUNCTION__, "inSeq->_length == 3"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inSeq->_buffer [0]._d == 4) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "unionServer.c", 92, __PRETTY_FUNCTION__, "inSeq->_buffer [0]._d == 4"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inSeq->_buffer [0]._u.z == CORBA_TRUE) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "unionServer.c", 93, __PRETTY_FUNCTION__, "inSeq->_buffer [0]._u.z == CORBA_TRUE"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inSeq->_buffer [1]._d == 2) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "unionServer.c", 94, __PRETTY_FUNCTION__, "inSeq->_buffer [1]._d == 2"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (!__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (inSeq->_buffer [1]._u.y) && __builtin_constant_p ("blah") && (__s1_len = strlen (inSeq->_buffer [1]._u.y), __s2_len = strlen ("blah"), (!((size_t)(const void *)((inSeq->_buffer [1]._u.y) + 1) - (size_t)(const void *)(inSeq->_buffer [1]._u.y) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("blah") + 1) - (size_t)(const void *)("blah") == 1) || __s2_len >= 4)) ? __builtin_strcmp (inSeq->_buffer [1]._u.y, "blah") : (__builtin_constant_p (inSeq->_buffer [1]._u.y) && ((size_t)(const void *)((inSeq->_buffer [1]._u.y) + 1) - (size_t)(const void *)(inSeq->_buffer [1]._u.y) == 1) && (__s1_len = strlen (inSeq->_buffer [1]._u.y), __s1_len < 4) ? (__builtin_constant_p ("blah") && ((size_t)(const void *)(("blah") + 1) - (size_t)(const void *)("blah") == 1) ? __builtin_strcmp (inSeq->_buffer [1]._u.y, "blah") : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) ("blah"); register int __result = (((__const unsigned char *) (__const char *) (inSeq->_buffer [1]._u.y))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (inSeq->_buffer [1]._u.y))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (inSeq->_buffer [1]._u.y))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (inSeq->_buffer [1]._u.y))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("blah") && ((size_t)(const void *)(("blah") + 1) - (size_t)(const void *)("blah") == 1) && (__s2_len = strlen ("blah"), __s2_len < 4) ? (__builtin_constant_p (inSeq->_buffer [1]._u.y) && ((size_t)(const void *)((inSeq->_buffer [1]._u.y) + 1) - (size_t)(const void *)(inSeq->_buffer [1]._u.y) == 1) ? __builtin_strcmp (inSeq->_buffer [1]._u.y, "blah") : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (inSeq->_buffer [1]._u.y); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) ("blah"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) ("blah"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) ("blah"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) ("blah"))[3]); } } __result; }))) : __builtin_strcmp (inSeq->_buffer [1]._u.y, "blah")))); })) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "unionServer.c", 95, __PRETTY_FUNCTION__, "!strcmp (inSeq->_buffer [1]._u.y, \"blah\")"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inSeq->_buffer [2]._d == 55) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "unionServer.c", 96, __PRETTY_FUNCTION__, "inSeq->_buffer [2]._d == 55"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inSeq->_buffer [2]._u.w == 0x12345678) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "unionServer.c", 97, __PRETTY_FUNCTION__, "inSeq->_buffer [2]._u.w == constants_LONG_IN"); });

 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inArg->_d == 1) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "unionServer.c", 99, __PRETTY_FUNCTION__, "inArg->_d == 1"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (!__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (inArg->_u.y) && __builtin_constant_p ("blah de blah") && (__s1_len = strlen (inArg->_u.y), __s2_len = strlen ("blah de blah"), (!((size_t)(const void *)((inArg->_u.y) + 1) - (size_t)(const void *)(inArg->_u.y) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("blah de blah") + 1) - (size_t)(const void *)("blah de blah") == 1) || __s2_len >= 4)) ? __builtin_strcmp (inArg->_u.y, "blah de blah") : (__builtin_constant_p (inArg->_u.y) && ((size_t)(const void *)((inArg->_u.y) + 1) - (size_t)(const void *)(inArg->_u.y) == 1) && (__s1_len = strlen (inArg->_u.y), __s1_len < 4) ? (__builtin_constant_p ("blah de blah") && ((size_t)(const void *)(("blah de blah") + 1) - (size_t)(const void *)("blah de blah") == 1) ? __builtin_strcmp (inArg->_u.y, "blah de blah") : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) ("blah de blah"); register int __result = (((__const unsigned char *) (__const char *) (inArg->_u.y))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (inArg->_u.y))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (inArg->_u.y))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (inArg->_u.y))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("blah de blah") && ((size_t)(const void *)(("blah de blah") + 1) - (size_t)(const void *)("blah de blah") == 1) && (__s2_len = strlen ("blah de blah"), __s2_len < 4) ? (__builtin_constant_p (inArg->_u.y) && ((size_t)(const void *)((inArg->_u.y) + 1) - (size_t)(const void *)(inArg->_u.y) == 1) ? __builtin_strcmp (inArg->_u.y, "blah de blah") : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (inArg->_u.y); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) ("blah de blah"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) ("blah de blah"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) ("blah de blah"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) ("blah de blah"))[3]); } } __result; }))) : __builtin_strcmp (inArg->_u.y, "blah de blah")))); })) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "unionServer.c", 100, __PRETTY_FUNCTION__, "!strcmp (inArg->_u.y, \"blah de blah\")"); });

 (*outArg) = ((test_ArrayUnion *)ORBit_small_alloc (((CORBA_TypeCode)&TC_test_ArrayUnion_struct)));
 (*outArg)->_d = 22;
 for (i = 0; i < 20; i++) {
  char *tmp;

  tmp = g_strdup_printf ("Numero %d", i);
  (*outArg)->_u.d [i] = CORBA_string_dup (tmp);
  g_free (tmp);
 }

 retval._d = test_EnumUnion_red;
 retval._u.x = 0x12345678;

 return retval;
}

static test_FixedLengthUnionArray_slice *
UnionServer_opFixedLengthUnionArray(PortableServer_Servant _servant,
        const test_FixedLengthUnionArray inArg,
        test_FixedLengthUnionArray inoutArg,
        test_FixedLengthUnionArray outArg,
        CORBA_Environment *ev)
{
  test_FixedLengthUnionArray_slice *retn;

  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inArg[0]._d == 'a') _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "unionServer.c", 127, __PRETTY_FUNCTION__, "inArg[0]._d == 'a'"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inArg[0]._u.x == 0x12345678) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "unionServer.c", 128, __PRETTY_FUNCTION__, "inArg[0]._u.x == constants_LONG_IN"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inArg[1]._d == 'b') _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "unionServer.c", 129, __PRETTY_FUNCTION__, "inArg[1]._d == 'b'"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inArg[1]._u.y == constants_CHAR_IN) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "unionServer.c", 130, __PRETTY_FUNCTION__, "inArg[1]._u.y == constants_CHAR_IN"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inArg[2]._d == 'c') _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "unionServer.c", 131, __PRETTY_FUNCTION__, "inArg[2]._d == 'c'"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inArg[3]._d == 'e') _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "unionServer.c", 132, __PRETTY_FUNCTION__, "inArg[3]._d == 'e'"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inArg[3]._u.v.a == constants_SHORT_IN) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "unionServer.c", 133, __PRETTY_FUNCTION__, "inArg[3]._u.v.a == constants_SHORT_IN"); });

  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inoutArg[0]._d == 'a') _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "unionServer.c", 135, __PRETTY_FUNCTION__, "inoutArg[0]._d == 'a'"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inoutArg[0]._u.x == 0x34567812) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "unionServer.c", 136, __PRETTY_FUNCTION__, "inoutArg[0]._u.x == constants_LONG_INOUT_IN"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inoutArg[1]._d == 'b') _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "unionServer.c", 137, __PRETTY_FUNCTION__, "inoutArg[1]._d == 'b'"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inoutArg[1]._u.y == constants_CHAR_INOUT_IN) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "unionServer.c", 138, __PRETTY_FUNCTION__, "inoutArg[1]._u.y == constants_CHAR_INOUT_IN"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inoutArg[2]._d == 'c') _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "unionServer.c", 139, __PRETTY_FUNCTION__, "inoutArg[2]._d == 'c'"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inoutArg[3]._d == 'e') _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "unionServer.c", 140, __PRETTY_FUNCTION__, "inoutArg[3]._d == 'e'"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inoutArg[3]._u.v.a == constants_SHORT_INOUT_IN) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "unionServer.c", 141, __PRETTY_FUNCTION__, "inoutArg[3]._u.v.a == constants_SHORT_INOUT_IN"); });

  inoutArg[0]._d = 'a';
  inoutArg[0]._u.x = 0x56781234;
  inoutArg[1]._d = 'b';
  inoutArg[1]._u.y = constants_CHAR_INOUT_OUT;
  inoutArg[2]._d = 'c';
  inoutArg[3]._d = 'e';
  inoutArg[3]._u.v.a = constants_SHORT_INOUT_OUT;

  outArg[0]._d = 'a';
  outArg[0]._u.x = 0x78123456;
  outArg[1]._d = 'b';
  outArg[1]._u.y = constants_CHAR_OUT;
  outArg[2]._d = 'c';
  outArg[3]._d = 'e';
  outArg[3]._u.v.a = constants_SHORT_OUT;

  retn = ((test_FixedLengthUnionArray_slice *)ORBit_small_alloc (((CORBA_TypeCode)&TC_test_FixedLengthUnionArray_struct)));

  retn[0]._d = 'a';
  retn[0]._u.x = 0xAABBCCDD;
  retn[1]._d = 'b';
  retn[1]._u.y = constants_CHAR_RETN;
  retn[2]._d = 'c';
  retn[3]._d = 'e';
  retn[3]._u.v.a = constants_SHORT_RETN;

  return retn;
}

PortableServer_ServantBase__epv UnionServer_base_epv = {((void *)0), simple_finalize, ((void *)0)};

POA_test_UnionServer__epv UnionServer_epv = {
 ((void *)0),
 UnionServer_opFixed,
 UnionServer_opVariable,
 UnionServer_opMisc,
 UnionServer_opFixedLengthUnionArray,
};

POA_test_UnionServer__vepv UnionServer_vepv = {&UnionServer_base_epv, &UnionServer_epv};

POA_test_UnionServer UnionServer_servant = {((void *)0), &UnionServer_vepv};
# 85 "server.c" 2
# 1 "arrayServer.c" 1
# 21 "arrayServer.c"
static test_LongArray_slice *
ArrayServer_opLongArray(PortableServer_Servant _servant,
      const test_LongArray inArg,
      test_LongArray inoutArg,
      test_LongArray outArg,
      CORBA_Environment * ev) {
  int i;
  test_LongArray_slice *retn;
  for(i=0;i<4;i++)
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inArg[i]==constants_SEQ_LONG_IN[i]) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "arrayServer.c", 30, __PRETTY_FUNCTION__, "inArg[i]==constants_SEQ_LONG_IN[i]"); });
  for(i=0;i<4;i++)
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inoutArg[i]==constants_SEQ_LONG_INOUT_IN[i]) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "arrayServer.c", 32, __PRETTY_FUNCTION__, "inoutArg[i]==constants_SEQ_LONG_INOUT_IN[i]"); });

  for(i=0;i<4;i++)
 inoutArg[i] = constants_SEQ_LONG_INOUT_OUT[i];

  for(i=0;i<4;i++)
 outArg[i] = constants_SEQ_LONG_OUT[i];

  retn = ((test_LongArray_slice *)ORBit_small_alloc (((CORBA_TypeCode)&TC_test_LongArray_struct)));

  for(i=0;i<4;i++)
 retn[i] = constants_SEQ_LONG_RETN[i];

  return retn;
}

static test_OctetArray_slice *
ArrayServer_opOctetArray (PortableServer_Servant _servant,
     const test_OctetArray inArg,
     test_OctetArray inoutArg,
     test_OctetArray outArg,
     CORBA_Environment *ev)
{
  int i;
  test_OctetArray_slice *retn;
  for(i=0;i<4;i++)
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inArg[i]==constants_SEQ_OCTET_IN[i]) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "arrayServer.c", 58, __PRETTY_FUNCTION__, "inArg[i]==constants_SEQ_OCTET_IN[i]"); });
  for(i=0;i<4;i++)
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inoutArg[i]==constants_SEQ_OCTET_INOUT_IN[i]) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "arrayServer.c", 60, __PRETTY_FUNCTION__, "inoutArg[i]==constants_SEQ_OCTET_INOUT_IN[i]"); });

  for(i=0;i<4;i++)
 inoutArg[i] = constants_SEQ_OCTET_INOUT_OUT[i];

  for(i=0;i<4;i++)
 outArg[i] = constants_SEQ_OCTET_OUT[i];

  retn = ((test_OctetArray_slice *)ORBit_small_alloc (((CORBA_TypeCode)&TC_test_OctetArray_struct)));

  for(i=0;i<4;i++)
 retn[i] = constants_SEQ_OCTET_RETN[i];

  return retn;
}

static test_FixedLengthStructArray_slice *
ArrayServer_opFixedLengthStructArray(PortableServer_Servant _servant,
         const test_FixedLengthStructArray inArg,
         test_FixedLengthStructArray inoutArg,
         test_FixedLengthStructArray outArg,
         CORBA_Environment *ev){
  int i;
  test_FixedLengthStructArray_slice *retn;

  for(i=0;i<4;i++)
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inArg[i].a==constants_SEQ_OCTET_IN[i]) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "arrayServer.c", 86, __PRETTY_FUNCTION__, "inArg[i].a==constants_SEQ_OCTET_IN[i]"); });

  for(i=0;i<4;i++)
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inoutArg[i].a==constants_SEQ_OCTET_INOUT_IN[i]) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "arrayServer.c", 89, __PRETTY_FUNCTION__, "inoutArg[i].a==constants_SEQ_OCTET_INOUT_IN[i]"); });

  for(i=0;i<4;i++)
 inoutArg[i].a = constants_SEQ_OCTET_INOUT_OUT[i];

  for(i=0;i<4;i++)
 outArg[i].a = constants_SEQ_OCTET_OUT[i];

  retn = ((test_FixedLengthStructArray_slice *)ORBit_small_alloc (((CORBA_TypeCode)&TC_test_FixedLengthStructArray_struct)));

  for(i=0;i<4;i++)
 retn[i].a = constants_SEQ_OCTET_RETN[i];

  return retn;
}

static test_StrArray_slice *
ArrayServer_opStrArray(PortableServer_Servant _servant,
        const test_StrArray inArg,
        test_StrArray inoutArg,
        test_StrArray_slice ** outArg,
        CORBA_Environment * ev)
{
  int i;
  test_StrArray_slice *retn;
  for(i=0;i<4;i++)
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (inArg[i]) && __builtin_constant_p (constants_SEQ_STRING_IN[i]) && (__s1_len = strlen (inArg[i]), __s2_len = strlen (constants_SEQ_STRING_IN[i]), (!((size_t)(const void *)((inArg[i]) + 1) - (size_t)(const void *)(inArg[i]) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((constants_SEQ_STRING_IN[i]) + 1) - (size_t)(const void *)(constants_SEQ_STRING_IN[i]) == 1) || __s2_len >= 4)) ? __builtin_strcmp (inArg[i], constants_SEQ_STRING_IN[i]) : (__builtin_constant_p (inArg[i]) && ((size_t)(const void *)((inArg[i]) + 1) - (size_t)(const void *)(inArg[i]) == 1) && (__s1_len = strlen (inArg[i]), __s1_len < 4) ? (__builtin_constant_p (constants_SEQ_STRING_IN[i]) && ((size_t)(const void *)((constants_SEQ_STRING_IN[i]) + 1) - (size_t)(const void *)(constants_SEQ_STRING_IN[i]) == 1) ? __builtin_strcmp (inArg[i], constants_SEQ_STRING_IN[i]) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (constants_SEQ_STRING_IN[i]); register int __result = (((__const unsigned char *) (__const char *) (inArg[i]))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (inArg[i]))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (inArg[i]))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (inArg[i]))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (constants_SEQ_STRING_IN[i]) && ((size_t)(const void *)((constants_SEQ_STRING_IN[i]) + 1) - (size_t)(const void *)(constants_SEQ_STRING_IN[i]) == 1) && (__s2_len = strlen (constants_SEQ_STRING_IN[i]), __s2_len < 4) ? (__builtin_constant_p (inArg[i]) && ((size_t)(const void *)((inArg[i]) + 1) - (size_t)(const void *)(inArg[i]) == 1) ? __builtin_strcmp (inArg[i], constants_SEQ_STRING_IN[i]) : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (inArg[i]); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (constants_SEQ_STRING_IN[i]))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (constants_SEQ_STRING_IN[i]))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (constants_SEQ_STRING_IN[i]))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (constants_SEQ_STRING_IN[i]))[3]); } } __result; }))) : __builtin_strcmp (inArg[i], constants_SEQ_STRING_IN[i])))); })==0) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "arrayServer.c", 115, __PRETTY_FUNCTION__, "strcmp(inArg[i],constants_SEQ_STRING_IN[i])==0"); });

  for(i=0;i<4;i++)
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (inoutArg[i]) && __builtin_constant_p (constants_SEQ_STRING_INOUT_IN[i]) && (__s1_len = strlen (inoutArg[i]), __s2_len = strlen (constants_SEQ_STRING_INOUT_IN[i]), (!((size_t)(const void *)((inoutArg[i]) + 1) - (size_t)(const void *)(inoutArg[i]) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((constants_SEQ_STRING_INOUT_IN[i]) + 1) - (size_t)(const void *)(constants_SEQ_STRING_INOUT_IN[i]) == 1) || __s2_len >= 4)) ? __builtin_strcmp (inoutArg[i], constants_SEQ_STRING_INOUT_IN[i]) : (__builtin_constant_p (inoutArg[i]) && ((size_t)(const void *)((inoutArg[i]) + 1) - (size_t)(const void *)(inoutArg[i]) == 1) && (__s1_len = strlen (inoutArg[i]), __s1_len < 4) ? (__builtin_constant_p (constants_SEQ_STRING_INOUT_IN[i]) && ((size_t)(const void *)((constants_SEQ_STRING_INOUT_IN[i]) + 1) - (size_t)(const void *)(constants_SEQ_STRING_INOUT_IN[i]) == 1) ? __builtin_strcmp (inoutArg[i], constants_SEQ_STRING_INOUT_IN[i]) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (constants_SEQ_STRING_INOUT_IN[i]); register int __result = (((__const unsigned char *) (__const char *) (inoutArg[i]))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (inoutArg[i]))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (inoutArg[i]))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (inoutArg[i]))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (constants_SEQ_STRING_INOUT_IN[i]) && ((size_t)(const void *)((constants_SEQ_STRING_INOUT_IN[i]) + 1) - (size_t)(const void *)(constants_SEQ_STRING_INOUT_IN[i]) == 1) && (__s2_len = strlen (constants_SEQ_STRING_INOUT_IN[i]), __s2_len < 4) ? (__builtin_constant_p (inoutArg[i]) && ((size_t)(const void *)((inoutArg[i]) + 1) - (size_t)(const void *)(inoutArg[i]) == 1) ? __builtin_strcmp (inoutArg[i], constants_SEQ_STRING_INOUT_IN[i]) : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (inoutArg[i]); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (constants_SEQ_STRING_INOUT_IN[i]))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (constants_SEQ_STRING_INOUT_IN[i]))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (constants_SEQ_STRING_INOUT_IN[i]))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (constants_SEQ_STRING_INOUT_IN[i]))[3]); } } __result; }))) : __builtin_strcmp (inoutArg[i], constants_SEQ_STRING_INOUT_IN[i])))); })==0) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "arrayServer.c", 118, __PRETTY_FUNCTION__, "strcmp(inoutArg[i],constants_SEQ_STRING_INOUT_IN[i])==0"); });

  for(i=0;i<4;i++){
 CORBA_free(inoutArg[i]);
 inoutArg[i] = CORBA_string_dup(constants_SEQ_STRING_INOUT_OUT[i]);
  }

  *outArg = ((test_StrArray_slice *)ORBit_small_alloc (((CORBA_TypeCode)&TC_test_StrArray_struct)));
  for(i=0;i<4;i++)
 (*outArg)[i] = CORBA_string_dup(constants_SEQ_STRING_OUT[i]);

  retn = ((test_StrArray_slice *)ORBit_small_alloc (((CORBA_TypeCode)&TC_test_StrArray_struct)));
  for(i=0;i<4;i++)
 retn[i] = CORBA_string_dup(constants_SEQ_STRING_RETN[i]);

  return retn;
}

static test_AlignHoleStructArray_slice *
ArrayServer_opAlignHoleStructArray(PortableServer_Servant _servant,
       const test_AlignHoleStructArray inArg,
       test_AlignHoleStructArray inoutArg,
       test_AlignHoleStructArray outArg,
       CORBA_Environment * ev)
{
  int i;
  test_AlignHoleStructArray_slice *retn;
  for(i=0;i<4;i++)
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inArg[i].a.a==constants_SEQ_OCTET_IN[i]) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "arrayServer.c", 146, __PRETTY_FUNCTION__, "inArg[i].a.a==constants_SEQ_OCTET_IN[i]"); });
  for(i=0;i<4;i++)
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inArg[i].a.b==constants_SEQ_OCTET_IN[i]) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "arrayServer.c", 148, __PRETTY_FUNCTION__, "inArg[i].a.b==constants_SEQ_OCTET_IN[i]"); });
  for(i=0;i<4;i++)
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inArg[i].b==constants_SEQ_OCTET_IN[i]) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "arrayServer.c", 150, __PRETTY_FUNCTION__, "inArg[i].b==constants_SEQ_OCTET_IN[i]"); });

  for(i=0;i<4;i++)
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inoutArg[i].a.a==constants_SEQ_OCTET_INOUT_IN[i]) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "arrayServer.c", 153, __PRETTY_FUNCTION__, "inoutArg[i].a.a==constants_SEQ_OCTET_INOUT_IN[i]"); });
  for(i=0;i<4;i++)
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inoutArg[i].a.b==constants_SEQ_OCTET_INOUT_IN[i]) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "arrayServer.c", 155, __PRETTY_FUNCTION__, "inoutArg[i].a.b==constants_SEQ_OCTET_INOUT_IN[i]"); });
  for(i=0;i<4;i++)
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inoutArg[i].b==constants_SEQ_OCTET_INOUT_IN[i]) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "arrayServer.c", 157, __PRETTY_FUNCTION__, "inoutArg[i].b==constants_SEQ_OCTET_INOUT_IN[i]"); });

  for(i=0;i<4;i++)
 inoutArg[i].a.a = constants_SEQ_OCTET_INOUT_OUT[i];
  for(i=0;i<4;i++)
 inoutArg[i].a.b = constants_SEQ_OCTET_INOUT_OUT[i];
  for(i=0;i<4;i++)
 inoutArg[i].b = constants_SEQ_OCTET_INOUT_OUT[i];

  for(i=0;i<4;i++)
 outArg[i].a.a = constants_SEQ_OCTET_OUT[i];
  for(i=0;i<4;i++)
 outArg[i].a.b = constants_SEQ_OCTET_OUT[i];
  for(i=0;i<4;i++)
 outArg[i].b = constants_SEQ_OCTET_OUT[i];

  retn = ((test_AlignHoleStructArray_slice *)ORBit_small_alloc (((CORBA_TypeCode)&TC_test_AlignHoleStructArray_struct)));

  for(i=0;i<4;i++)
 retn[i].a.a = constants_SEQ_OCTET_RETN[i];
  for(i=0;i<4;i++)
 retn[i].a.b = constants_SEQ_OCTET_RETN[i];
  for(i=0;i<4;i++)
 retn[i].b = constants_SEQ_OCTET_RETN[i];

  return retn;
}

POA_test_ArrayServer__epv ArrayServer_epv = {
  ((void *)0),
  ArrayServer_opLongArray,
  ArrayServer_opOctetArray,
  ArrayServer_opFixedLengthStructArray,
  ArrayServer_opStrArray,
  ArrayServer_opAlignHoleStructArray,
};

PortableServer_ServantBase__epv ArrayServer_base_epv = {((void *)0), simple_finalize, ((void *)0)};
POA_test_ArrayServer__vepv ArrayServer_vepv = { &ArrayServer_base_epv, &ArrayServer_epv };
# 86 "server.c" 2
# 1 "anyServer.c" 1
# 22 "anyServer.c"
# 1 "everything.h" 1
# 23 "anyServer.c" 2





static CORBA_long opAnyLong_inout = 0x56781234;
static CORBA_long opAnyLong_out = 0x78123456;
static CORBA_long opAnyLong_retn = 0xAABBCCDD;

static CORBA_any *
AnyServer_opAnyStrSeq (PortableServer_Servant _servant,
         CORBA_Environment * ev)
{
 CORBA_any *retn;
 test_StrSeq *seq;
 int i;

 seq = ((test_StrSeq *)ORBit_small_alloc (((CORBA_TypeCode)&TC_CORBA_sequence_CORBA_string_struct)));
 seq->_length = 16;
 seq->_buffer = ((CORBA_string*)ORBit_small_allocbuf (((CORBA_TypeCode)&TC_CORBA_sequence_CORBA_string_struct), (seq->_length)));
 seq->_release = (!(0));

 for (i = 0; i < seq->_length; i++)
  seq->_buffer [i] = CORBA_string_dup ("Foo");

 retn = CORBA_any__alloc ();
 retn->_type = (CORBA_TypeCode) CORBA_Object_duplicate (
  (CORBA_Object) ((CORBA_TypeCode)&TC_test_StrSeq_struct), ev);
 retn->_value = seq;
 retn->_release = (!(0));

 return retn;
}

static CORBA_any *
AnyServer_opAnyLong (PortableServer_Servant _servant,
       const CORBA_any * inArg,
       CORBA_any * inoutArg,
       CORBA_any ** outArg,
       CORBA_Environment * ev)
{
  CORBA_any *retn;

  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_TypeCode_equal(inArg->_type,((CORBA_TypeCode)&TC_CORBA_long_struct),ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "anyServer.c", 66, __PRETTY_FUNCTION__, "CORBA_TypeCode_equal(inArg->_type,TC_CORBA_long,ev)"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (*(CORBA_long*)inArg->_value == 0x12345678) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "anyServer.c", 67, __PRETTY_FUNCTION__, "*(CORBA_long*)inArg->_value == constants_LONG_IN"); });

  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_TypeCode_equal(inoutArg->_type,((CORBA_TypeCode)&TC_CORBA_long_struct),ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "anyServer.c", 69, __PRETTY_FUNCTION__, "CORBA_TypeCode_equal(inoutArg->_type,TC_CORBA_long,ev)"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (*(CORBA_long*)inoutArg->_value == 0x34567812) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "anyServer.c", 70, __PRETTY_FUNCTION__, "*(CORBA_long*)inoutArg->_value == constants_LONG_INOUT_IN"); });

  if((inoutArg)->_release){
 CORBA_free(inoutArg->_value);
 CORBA_Object_release((CORBA_Object)inoutArg->_type, ev);
  }


  inoutArg->_type = (CORBA_TypeCode)((CORBA_TypeCode)&TC_CORBA_long_struct);
  inoutArg->_value = &opAnyLong_inout;
  (inoutArg)->_release = CORBA_FALSE;

  *outArg = CORBA_any__alloc();
  (*outArg)->_type = (CORBA_TypeCode)((CORBA_TypeCode)&TC_CORBA_long_struct);
  (*outArg)->_value = &opAnyLong_out;
  (*outArg)->_release = CORBA_FALSE;

  retn = CORBA_any__alloc();
  retn->_type = (CORBA_TypeCode)((CORBA_TypeCode)&TC_CORBA_long_struct);
  retn->_value = &opAnyLong_retn;
  (retn)->_release = CORBA_FALSE;

  return retn;
}


static
CORBA_any *
AnyServer_opAnyString(PortableServer_Servant _servant,
       const CORBA_any * inArg,
       CORBA_any * inoutArg,
       CORBA_any ** outArg,
       CORBA_Environment * ev){
  CORBA_any *retn;

  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_TypeCode_equal(inArg->_type,((CORBA_TypeCode)&TC_CORBA_string_struct),ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "anyServer.c", 105, __PRETTY_FUNCTION__, "CORBA_TypeCode_equal(inArg->_type,TC_CORBA_string,ev)"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (*(CORBA_char **)inArg->_value) && __builtin_constant_p (constants_STRING_IN) && (__s1_len = strlen (*(CORBA_char **)inArg->_value), __s2_len = strlen (constants_STRING_IN), (!((size_t)(const void *)((*(CORBA_char **)inArg->_value) + 1) - (size_t)(const void *)(*(CORBA_char **)inArg->_value) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((constants_STRING_IN) + 1) - (size_t)(const void *)(constants_STRING_IN) == 1) || __s2_len >= 4)) ? __builtin_strcmp (*(CORBA_char **)inArg->_value, constants_STRING_IN) : (__builtin_constant_p (*(CORBA_char **)inArg->_value) && ((size_t)(const void *)((*(CORBA_char **)inArg->_value) + 1) - (size_t)(const void *)(*(CORBA_char **)inArg->_value) == 1) && (__s1_len = strlen (*(CORBA_char **)inArg->_value), __s1_len < 4) ? (__builtin_constant_p (constants_STRING_IN) && ((size_t)(const void *)((constants_STRING_IN) + 1) - (size_t)(const void *)(constants_STRING_IN) == 1) ? __builtin_strcmp (*(CORBA_char **)inArg->_value, constants_STRING_IN) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (constants_STRING_IN); register int __result = (((__const unsigned char *) (__const char *) (*(CORBA_char **)inArg->_value))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (*(CORBA_char **)inArg->_value))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (*(CORBA_char **)inArg->_value))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (*(CORBA_char **)inArg->_value))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (constants_STRING_IN) && ((size_t)(const void *)((constants_STRING_IN) + 1) - (size_t)(const void *)(constants_STRING_IN) == 1) && (__s2_len = strlen (constants_STRING_IN), __s2_len < 4) ? (__builtin_constant_p (*(CORBA_char **)inArg->_value) && ((size_t)(const void *)((*(CORBA_char **)inArg->_value) + 1) - (size_t)(const void *)(*(CORBA_char **)inArg->_value) == 1) ? __builtin_strcmp (*(CORBA_char **)inArg->_value, constants_STRING_IN) : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (*(CORBA_char **)inArg->_value); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (constants_STRING_IN))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (constants_STRING_IN))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (constants_STRING_IN))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (constants_STRING_IN))[3]); } } __result; }))) : __builtin_strcmp (*(CORBA_char **)inArg->_value, constants_STRING_IN)))); }) == 0) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "anyServer.c", 106, __PRETTY_FUNCTION__, "strcmp(*(CORBA_char **)inArg->_value,constants_STRING_IN) == 0"); });

  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_TypeCode_equal(inoutArg->_type,((CORBA_TypeCode)&TC_CORBA_string_struct),ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "anyServer.c", 108, __PRETTY_FUNCTION__, "CORBA_TypeCode_equal(inoutArg->_type,TC_CORBA_string,ev)"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (*(CORBA_char **)inoutArg->_value) && __builtin_constant_p (constants_STRING_INOUT_IN) && (__s1_len = strlen (*(CORBA_char **)inoutArg->_value), __s2_len = strlen (constants_STRING_INOUT_IN), (!((size_t)(const void *)((*(CORBA_char **)inoutArg->_value) + 1) - (size_t)(const void *)(*(CORBA_char **)inoutArg->_value) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((constants_STRING_INOUT_IN) + 1) - (size_t)(const void *)(constants_STRING_INOUT_IN) == 1) || __s2_len >= 4)) ? __builtin_strcmp (*(CORBA_char **)inoutArg->_value, constants_STRING_INOUT_IN) : (__builtin_constant_p (*(CORBA_char **)inoutArg->_value) && ((size_t)(const void *)((*(CORBA_char **)inoutArg->_value) + 1) - (size_t)(const void *)(*(CORBA_char **)inoutArg->_value) == 1) && (__s1_len = strlen (*(CORBA_char **)inoutArg->_value), __s1_len < 4) ? (__builtin_constant_p (constants_STRING_INOUT_IN) && ((size_t)(const void *)((constants_STRING_INOUT_IN) + 1) - (size_t)(const void *)(constants_STRING_INOUT_IN) == 1) ? __builtin_strcmp (*(CORBA_char **)inoutArg->_value, constants_STRING_INOUT_IN) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (constants_STRING_INOUT_IN); register int __result = (((__const unsigned char *) (__const char *) (*(CORBA_char **)inoutArg->_value))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (*(CORBA_char **)inoutArg->_value))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (*(CORBA_char **)inoutArg->_value))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (*(CORBA_char **)inoutArg->_value))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (constants_STRING_INOUT_IN) && ((size_t)(const void *)((constants_STRING_INOUT_IN) + 1) - (size_t)(const void *)(constants_STRING_INOUT_IN) == 1) && (__s2_len = strlen (constants_STRING_INOUT_IN), __s2_len < 4) ? (__builtin_constant_p (*(CORBA_char **)inoutArg->_value) && ((size_t)(const void *)((*(CORBA_char **)inoutArg->_value) + 1) - (size_t)(const void *)(*(CORBA_char **)inoutArg->_value) == 1) ? __builtin_strcmp (*(CORBA_char **)inoutArg->_value, constants_STRING_INOUT_IN) : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (*(CORBA_char **)inoutArg->_value); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (constants_STRING_INOUT_IN))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (constants_STRING_INOUT_IN))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (constants_STRING_INOUT_IN))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (constants_STRING_INOUT_IN))[3]); } } __result; }))) : __builtin_strcmp (*(CORBA_char **)inoutArg->_value, constants_STRING_INOUT_IN)))); }) == 0) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "anyServer.c", 109, __PRETTY_FUNCTION__, "strcmp(*(CORBA_char **)inoutArg->_value,constants_STRING_INOUT_IN) == 0"); });

  if((inoutArg)->_release){
 CORBA_free(inoutArg->_value);
 CORBA_Object_release((CORBA_Object)inoutArg->_type, ev);
  }

  inoutArg->_type = (CORBA_TypeCode)((CORBA_TypeCode)&TC_CORBA_string_struct);
  inoutArg->_value = &constants_STRING_INOUT_OUT;
  (inoutArg)->_release = CORBA_FALSE;

  *outArg = CORBA_any__alloc();
  (*outArg)->_type = (CORBA_TypeCode)((CORBA_TypeCode)&TC_CORBA_string_struct);
  (*outArg)->_value = &constants_STRING_OUT;
  (*outArg)->_release = CORBA_FALSE;

  retn = CORBA_any__alloc();
  retn->_type = (CORBA_TypeCode)((CORBA_TypeCode)&TC_CORBA_string_struct);
  retn->_value = &constants_STRING_RETN;
  (retn)->_release = CORBA_FALSE;

  return retn;
}


static test_VariableLengthStruct inoutArgStruct;
static test_VariableLengthStruct outArgStruct;
static test_VariableLengthStruct retnStruct;

static
CORBA_any *
AnyServer_opAnyStruct(PortableServer_Servant _servant,
       const CORBA_any * inArg,
       CORBA_any * inoutArg,
       CORBA_any ** outArg,
       CORBA_Environment * ev){
  CORBA_any *retn;

  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_TypeCode_equal(inArg->_type,((CORBA_TypeCode)&TC_test_VariableLengthStruct_struct),ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "anyServer.c", 147, __PRETTY_FUNCTION__, "CORBA_TypeCode_equal(inArg->_type,TC_test_VariableLengthStruct,ev)"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p ((*(test_VariableLengthStruct*)inArg->_value).a) && __builtin_constant_p (constants_STRING_IN) && (__s1_len = strlen ((*(test_VariableLengthStruct*)inArg->_value).a), __s2_len = strlen (constants_STRING_IN), (!((size_t)(const void *)(((*(test_VariableLengthStruct*)inArg->_value).a) + 1) - (size_t)(const void *)((*(test_VariableLengthStruct*)inArg->_value).a) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((constants_STRING_IN) + 1) - (size_t)(const void *)(constants_STRING_IN) == 1) || __s2_len >= 4)) ? __builtin_strcmp ((*(test_VariableLengthStruct*)inArg->_value).a, constants_STRING_IN) : (__builtin_constant_p ((*(test_VariableLengthStruct*)inArg->_value).a) && ((size_t)(const void *)(((*(test_VariableLengthStruct*)inArg->_value).a) + 1) - (size_t)(const void *)((*(test_VariableLengthStruct*)inArg->_value).a) == 1) && (__s1_len = strlen ((*(test_VariableLengthStruct*)inArg->_value).a), __s1_len < 4) ? (__builtin_constant_p (constants_STRING_IN) && ((size_t)(const void *)((constants_STRING_IN) + 1) - (size_t)(const void *)(constants_STRING_IN) == 1) ? __builtin_strcmp ((*(test_VariableLengthStruct*)inArg->_value).a, constants_STRING_IN) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (constants_STRING_IN); register int __result = (((__const unsigned char *) (__const char *) ((*(test_VariableLengthStruct*)inArg->_value).a))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) ((*(test_VariableLengthStruct*)inArg->_value).a))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) ((*(test_VariableLengthStruct*)inArg->_value).a))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) ((*(test_VariableLengthStruct*)inArg->_value).a))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (constants_STRING_IN) && ((size_t)(const void *)((constants_STRING_IN) + 1) - (size_t)(const void *)(constants_STRING_IN) == 1) && (__s2_len = strlen (constants_STRING_IN), __s2_len < 4) ? (__builtin_constant_p ((*(test_VariableLengthStruct*)inArg->_value).a) && ((size_t)(const void *)(((*(test_VariableLengthStruct*)inArg->_value).a) + 1) - (size_t)(const void *)((*(test_VariableLengthStruct*)inArg->_value).a) == 1) ? __builtin_strcmp ((*(test_VariableLengthStruct*)inArg->_value).a, constants_STRING_IN) : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) ((*(test_VariableLengthStruct*)inArg->_value).a); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (constants_STRING_IN))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (constants_STRING_IN))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (constants_STRING_IN))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (constants_STRING_IN))[3]); } } __result; }))) : __builtin_strcmp ((*(test_VariableLengthStruct*)inArg->_value).a, constants_STRING_IN)))); }) == 0) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "anyServer.c", 148, __PRETTY_FUNCTION__, "strcmp((*(test_VariableLengthStruct*)inArg->_value).a,constants_STRING_IN) == 0"); });

  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_TypeCode_equal(inoutArg->_type,((CORBA_TypeCode)&TC_test_VariableLengthStruct_struct),ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "anyServer.c", 150, __PRETTY_FUNCTION__, "CORBA_TypeCode_equal(inoutArg->_type,TC_test_VariableLengthStruct,ev)"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p ((*(test_VariableLengthStruct*)inoutArg->_value).a) && __builtin_constant_p (constants_STRING_INOUT_IN) && (__s1_len = strlen ((*(test_VariableLengthStruct*)inoutArg->_value).a), __s2_len = strlen (constants_STRING_INOUT_IN), (!((size_t)(const void *)(((*(test_VariableLengthStruct*)inoutArg->_value).a) + 1) - (size_t)(const void *)((*(test_VariableLengthStruct*)inoutArg->_value).a) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((constants_STRING_INOUT_IN) + 1) - (size_t)(const void *)(constants_STRING_INOUT_IN) == 1) || __s2_len >= 4)) ? __builtin_strcmp ((*(test_VariableLengthStruct*)inoutArg->_value).a, constants_STRING_INOUT_IN) : (__builtin_constant_p ((*(test_VariableLengthStruct*)inoutArg->_value).a) && ((size_t)(const void *)(((*(test_VariableLengthStruct*)inoutArg->_value).a) + 1) - (size_t)(const void *)((*(test_VariableLengthStruct*)inoutArg->_value).a) == 1) && (__s1_len = strlen ((*(test_VariableLengthStruct*)inoutArg->_value).a), __s1_len < 4) ? (__builtin_constant_p (constants_STRING_INOUT_IN) && ((size_t)(const void *)((constants_STRING_INOUT_IN) + 1) - (size_t)(const void *)(constants_STRING_INOUT_IN) == 1) ? __builtin_strcmp ((*(test_VariableLengthStruct*)inoutArg->_value).a, constants_STRING_INOUT_IN) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (constants_STRING_INOUT_IN); register int __result = (((__const unsigned char *) (__const char *) ((*(test_VariableLengthStruct*)inoutArg->_value).a))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) ((*(test_VariableLengthStruct*)inoutArg->_value).a))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) ((*(test_VariableLengthStruct*)inoutArg->_value).a))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) ((*(test_VariableLengthStruct*)inoutArg->_value).a))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (constants_STRING_INOUT_IN) && ((size_t)(const void *)((constants_STRING_INOUT_IN) + 1) - (size_t)(const void *)(constants_STRING_INOUT_IN) == 1) && (__s2_len = strlen (constants_STRING_INOUT_IN), __s2_len < 4) ? (__builtin_constant_p ((*(test_VariableLengthStruct*)inoutArg->_value).a) && ((size_t)(const void *)(((*(test_VariableLengthStruct*)inoutArg->_value).a) + 1) - (size_t)(const void *)((*(test_VariableLengthStruct*)inoutArg->_value).a) == 1) ? __builtin_strcmp ((*(test_VariableLengthStruct*)inoutArg->_value).a, constants_STRING_INOUT_IN) : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) ((*(test_VariableLengthStruct*)inoutArg->_value).a); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (constants_STRING_INOUT_IN))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (constants_STRING_INOUT_IN))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (constants_STRING_INOUT_IN))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (constants_STRING_INOUT_IN))[3]); } } __result; }))) : __builtin_strcmp ((*(test_VariableLengthStruct*)inoutArg->_value).a, constants_STRING_INOUT_IN)))); }) == 0) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "anyServer.c", 151, __PRETTY_FUNCTION__, "strcmp((*(test_VariableLengthStruct*)inoutArg->_value).a,constants_STRING_INOUT_IN) == 0"); });

  if((inoutArg)->_release){
 CORBA_free(inoutArg->_value);
 CORBA_Object_release((CORBA_Object)inoutArg->_type, ev);
  }

  inoutArg->_type = (CORBA_TypeCode)((CORBA_TypeCode)&TC_test_VariableLengthStruct_struct);
  inoutArgStruct.a = (char *)constants_STRING_INOUT_OUT;
  inoutArg->_value = &inoutArgStruct;
  (inoutArg)->_release = CORBA_FALSE;

  *outArg = CORBA_any__alloc();
  (*outArg)->_type = (CORBA_TypeCode)((CORBA_TypeCode)&TC_test_VariableLengthStruct_struct);
  outArgStruct.a = (char *)constants_STRING_OUT;
  (*outArg)->_value = &outArgStruct;
  (*outArg)->_release = CORBA_FALSE;

  retn = CORBA_any__alloc();
  retn->_type = (CORBA_TypeCode)((CORBA_TypeCode)&TC_test_VariableLengthStruct_struct);
  retnStruct.a = (char *)constants_STRING_RETN;
  retn->_value = &retnStruct;
  (retn)->_release = CORBA_FALSE;

  return retn;
}


CORBA_TypeCode retntypecode = ((CORBA_TypeCode)&TC_test_VariableLengthStruct_struct);

static
CORBA_TypeCode
AnyServer_opTypeCode (PortableServer_Servant servant,
        const CORBA_TypeCode inArg,
        CORBA_TypeCode *inoutArg,
        CORBA_TypeCode *outArg,
        CORBA_Environment *ev)
{
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_TypeCode_equal (inArg, ((CORBA_TypeCode)&TC_test_ArrayUnion_struct), ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "anyServer.c", 189, __PRETTY_FUNCTION__, "CORBA_TypeCode_equal (inArg, TC_test_ArrayUnion, ev)"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_TypeCode_equal (*inoutArg, ((CORBA_TypeCode)&TC_test_AnyServer_struct), ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "anyServer.c", 190, __PRETTY_FUNCTION__, "CORBA_TypeCode_equal (*inoutArg, TC_test_AnyServer, ev)"); });

 CORBA_Object_release ((CORBA_Object)*inoutArg, ev);
 *inoutArg = (CORBA_TypeCode) CORBA_Object_duplicate (
  (CORBA_Object) ((CORBA_TypeCode)&TC_test_TestException_struct), ev);
 *outArg = ((CORBA_TypeCode)&TC_test_AnEnum_struct);

 return ((CORBA_TypeCode)&TC_test_VariableLengthStruct_struct);
}

POA_test_AnyServer__epv AnyServer_epv = {
 ((void *)0),
 AnyServer_opAnyStrSeq,
 AnyServer_opAnyLong,
 AnyServer_opAnyString,
 AnyServer_opAnyStruct,
 AnyServer_opTypeCode,
};

PortableServer_ServantBase__epv AnyServer_base_epv = {((void *)0), simple_finalize, ((void *)0)};
POA_test_AnyServer__vepv AnyServer_vepv = { &AnyServer_base_epv, &AnyServer_epv };
# 87 "server.c" 2
# 1 "contextServer.c" 1
# 21 "contextServer.c"
# 1 "everything.h" 1
# 22 "contextServer.c" 2



static
CORBA_Object
ContextServer_opWithContext (PortableServer_Servant _servant,
        const CORBA_Object inArg,
        CORBA_Object *inoutArg,
        CORBA_Object *outArg,
        CORBA_Context ctx,
        CORBA_Environment *ev)
{
 CORBA_NVList nvout;
 CORBA_NamedValue *nv;
 char *val;
 int i;

 CORBA_Context_get_values (ctx, ((void *)0), 0, "", &nvout, ev);

 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "contextServer.c", 41, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (nvout->list->len == 2) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "contextServer.c", 42, __PRETTY_FUNCTION__, "nvout->list->len == 2"); });

 for (i = 0; i < nvout->list->len; i++) {
  nv = &(((CORBA_NamedValue*) (nvout->list)->data) [(0)]);

  if (!__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (nv->name) && __builtin_constant_p ("bar") && (__s1_len = strlen (nv->name), __s2_len = strlen ("bar"), (!((size_t)(const void *)((nv->name) + 1) - (size_t)(const void *)(nv->name) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("bar") + 1) - (size_t)(const void *)("bar") == 1) || __s2_len >= 4)) ? __builtin_strcmp (nv->name, "bar") : (__builtin_constant_p (nv->name) && ((size_t)(const void *)((nv->name) + 1) - (size_t)(const void *)(nv->name) == 1) && (__s1_len = strlen (nv->name), __s1_len < 4) ? (__builtin_constant_p ("bar") && ((size_t)(const void *)(("bar") + 1) - (size_t)(const void *)("bar") == 1) ? __builtin_strcmp (nv->name, "bar") : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) ("bar"); register int __result = (((__const unsigned char *) (__const char *) (nv->name))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (nv->name))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (nv->name))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (nv->name))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("bar") && ((size_t)(const void *)(("bar") + 1) - (size_t)(const void *)("bar") == 1) && (__s2_len = strlen ("bar"), __s2_len < 4) ? (__builtin_constant_p (nv->name) && ((size_t)(const void *)((nv->name) + 1) - (size_t)(const void *)(nv->name) == 1) ? __builtin_strcmp (nv->name, "bar") : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (nv->name); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) ("bar"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) ("bar"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) ("bar"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) ("bar"))[3]); } } __result; }))) : __builtin_strcmp (nv->name, "bar")))); })) {
   val = * (char **) nv->argument._value;
   (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (!__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (val) && __builtin_constant_p ("baaaa") && (__s1_len = strlen (val), __s2_len = strlen ("baaaa"), (!((size_t)(const void *)((val) + 1) - (size_t)(const void *)(val) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("baaaa") + 1) - (size_t)(const void *)("baaaa") == 1) || __s2_len >= 4)) ? __builtin_strcmp (val, "baaaa") : (__builtin_constant_p (val) && ((size_t)(const void *)((val) + 1) - (size_t)(const void *)(val) == 1) && (__s1_len = strlen (val), __s1_len < 4) ? (__builtin_constant_p ("baaaa") && ((size_t)(const void *)(("baaaa") + 1) - (size_t)(const void *)("baaaa") == 1) ? __builtin_strcmp (val, "baaaa") : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) ("baaaa"); register int __result = (((__const unsigned char *) (__const char *) (val))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (val))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (val))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (val))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("baaaa") && ((size_t)(const void *)(("baaaa") + 1) - (size_t)(const void *)("baaaa") == 1) && (__s2_len = strlen ("baaaa"), __s2_len < 4) ? (__builtin_constant_p (val) && ((size_t)(const void *)((val) + 1) - (size_t)(const void *)(val) == 1) ? __builtin_strcmp (val, "baaaa") : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (val); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) ("baaaa"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) ("baaaa"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) ("baaaa"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) ("baaaa"))[3]); } } __result; }))) : __builtin_strcmp (val, "baaaa")))); })) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "contextServer.c", 49, __PRETTY_FUNCTION__, "!strcmp (val, \"baaaa\")"); });
  } else if (!__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (nv->name) && __builtin_constant_p ("foo") && (__s1_len = strlen (nv->name), __s2_len = strlen ("foo"), (!((size_t)(const void *)((nv->name) + 1) - (size_t)(const void *)(nv->name) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("foo") + 1) - (size_t)(const void *)("foo") == 1) || __s2_len >= 4)) ? __builtin_strcmp (nv->name, "foo") : (__builtin_constant_p (nv->name) && ((size_t)(const void *)((nv->name) + 1) - (size_t)(const void *)(nv->name) == 1) && (__s1_len = strlen (nv->name), __s1_len < 4) ? (__builtin_constant_p ("foo") && ((size_t)(const void *)(("foo") + 1) - (size_t)(const void *)("foo") == 1) ? __builtin_strcmp (nv->name, "foo") : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) ("foo"); register int __result = (((__const unsigned char *) (__const char *) (nv->name))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (nv->name))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (nv->name))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (nv->name))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("foo") && ((size_t)(const void *)(("foo") + 1) - (size_t)(const void *)("foo") == 1) && (__s2_len = strlen ("foo"), __s2_len < 4) ? (__builtin_constant_p (nv->name) && ((size_t)(const void *)((nv->name) + 1) - (size_t)(const void *)(nv->name) == 1) ? __builtin_strcmp (nv->name, "foo") : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (nv->name); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) ("foo"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) ("foo"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) ("foo"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) ("foo"))[3]); } } __result; }))) : __builtin_strcmp (nv->name, "foo")))); })) {
   val = * (char **) nv->argument._value;
   (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (!__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (val) && __builtin_constant_p ("foo2") && (__s1_len = strlen (val), __s2_len = strlen ("foo2"), (!((size_t)(const void *)((val) + 1) - (size_t)(const void *)(val) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("foo2") + 1) - (size_t)(const void *)("foo2") == 1) || __s2_len >= 4)) ? __builtin_strcmp (val, "foo2") : (__builtin_constant_p (val) && ((size_t)(const void *)((val) + 1) - (size_t)(const void *)(val) == 1) && (__s1_len = strlen (val), __s1_len < 4) ? (__builtin_constant_p ("foo2") && ((size_t)(const void *)(("foo2") + 1) - (size_t)(const void *)("foo2") == 1) ? __builtin_strcmp (val, "foo2") : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) ("foo2"); register int __result = (((__const unsigned char *) (__const char *) (val))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (val))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (val))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (val))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("foo2") && ((size_t)(const void *)(("foo2") + 1) - (size_t)(const void *)("foo2") == 1) && (__s2_len = strlen ("foo2"), __s2_len < 4) ? (__builtin_constant_p (val) && ((size_t)(const void *)((val) + 1) - (size_t)(const void *)(val) == 1) ? __builtin_strcmp (val, "foo2") : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (val); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) ("foo2"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) ("foo2"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) ("foo2"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) ("foo2"))[3]); } } __result; }))) : __builtin_strcmp (val, "foo2")))); })) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "contextServer.c", 52, __PRETTY_FUNCTION__, "!strcmp (val, \"foo2\")"); });
  } else
   g_log (((gchar*) 0), G_LOG_LEVEL_ERROR, "Unknown context property '%s'", nv->name);
 }

 CORBA_NVList_free (nvout, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "contextServer.c", 58, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 *outArg = ((void *)0);

 return CORBA_Object_duplicate (inArg, ev);
}

POA_test_ContextServer__epv ContextServer_epv = {
 ((void *)0),
 ContextServer_opWithContext,
};

PortableServer_ServantBase__epv ContextServer_base_epv = {((void *)0), simple_finalize, ((void *)0)};
POA_test_ContextServer__vepv ContextServer_vepv = { &ContextServer_base_epv, &ContextServer_epv };
# 88 "server.c" 2
# 1 "deadReference.c" 1
# 21 "deadReference.c"
# 1 "everything.h" 1
# 22 "deadReference.c" 2

static void
DeadReferenceObj_test (PortableServer_Servant servant,
         CORBA_Environment *ev)
{
 PortableServer_Current poa_current;
 PortableServer_POA poa;
 CORBA_Object obj = ((void *)0);

 poa_current = (PortableServer_Current)
   CORBA_ORB_resolve_initial_references (global_orb,
             "POACurrent",
             ev);

 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "deadReference.c", 36, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 poa = PortableServer_Current_get_POA (poa_current, ev);

 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "deadReference.c", 40, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 obj = PortableServer_POA_servant_to_reference (poa, servant, ev);

 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "deadReference.c", 44, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (obj != ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "deadReference.c", 45, __PRETTY_FUNCTION__, "obj != CORBA_OBJECT_NIL"); });

 CORBA_Object_release ((CORBA_Object) obj, ev);
 CORBA_Object_release ((CORBA_Object) poa, ev);
 CORBA_Object_release ((CORBA_Object) poa_current, ev);
}

static POA_test_DeadReferenceObj__epv DeadReferenceObj_epv = {
 ((void *)0),
 DeadReferenceObj_test,
};

static PortableServer_ServantBase__epv DeadReferenceObj_base_epv = {
 ((void *)0),
 simple_finalize,
 ((void *)0)
};
static POA_test_DeadReferenceObj__vepv DeadReferenceObj_vepv = {
 &DeadReferenceObj_base_epv,
 &DeadReferenceObj_epv
};
# 89 "server.c" 2
# 1 "lifeCycle.c" 1
# 21 "lifeCycle.c"
# 1 "everything.h" 1
# 22 "lifeCycle.c" 2

static void
LifeCycleServer_deactivateOnReturn (PortableServer_Servant servant,
        CORBA_Environment *ev)
{
 PortableServer_ObjectId *oid;

 oid = PortableServer_POA_servant_to_id (global_poa, servant, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "lifeCycle.c", 30, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 PortableServer_POA_deactivate_object (global_poa, oid, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "lifeCycle.c", 33, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 CORBA_free (oid);
}

static void
LifeCycleServer_deactivateUnrefOnReturn (PortableServer_Servant servant,
      CORBA_Environment *ev)
{
 CORBA_Object self_ref;


 PortableServer_ObjectId *oid;

 oid = PortableServer_POA_servant_to_id (global_poa, servant, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "lifeCycle.c", 48, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 PortableServer_POA_deactivate_object (global_poa, oid, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "lifeCycle.c", 51, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 CORBA_free (oid);

 self_ref = PortableServer_POA_servant_to_reference (global_poa, servant, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "lifeCycle.c", 56, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 CORBA_Object_release (self_ref, ev);
 CORBA_Object_release (self_ref, ev);
}

static POA_test_LifeCycleServer__epv LifeCycleServer_epv = {
 ((void *)0),
 LifeCycleServer_deactivateOnReturn,
 LifeCycleServer_deactivateUnrefOnReturn
};

static PortableServer_ServantBase__epv LifeCycleServer_base_epv = {
 ((void *)0),
 simple_finalize,
 ((void *)0)
};
static POA_test_LifeCycleServer__vepv LifeCycleServer_vepv = {
 &LifeCycleServer_base_epv,
 &LifeCycleServer_epv
};
# 90 "server.c" 2
# 1 "pingServer.c" 1

# 1 "/usr/include/unistd.h" 1 3 4
# 28 "/usr/include/unistd.h" 3 4

# 171 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/bits/posix_opt.h" 1 3 4
# 172 "/usr/include/unistd.h" 2 3 4
# 195 "/usr/include/unistd.h" 3 4
# 1 "/usr/lib/gcc/i386-redhat-linux/4.1.0/include/stddef.h" 1 3 4
# 196 "/usr/include/unistd.h" 2 3 4
# 224 "/usr/include/unistd.h" 3 4
typedef __useconds_t useconds_t;
# 256 "/usr/include/unistd.h" 3 4
extern int access (__const char *__name, int __type) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
# 299 "/usr/include/unistd.h" 3 4
extern __off_t lseek (int __fd, __off_t __offset, int __whence) __attribute__ ((__nothrow__));
# 318 "/usr/include/unistd.h" 3 4
extern int close (int __fd);






extern ssize_t read (int __fd, void *__buf, size_t __nbytes) ;





extern ssize_t write (int __fd, __const void *__buf, size_t __n) ;
# 382 "/usr/include/unistd.h" 3 4
extern int pipe (int __pipedes[2]) __attribute__ ((__nothrow__)) ;
# 391 "/usr/include/unistd.h" 3 4
extern unsigned int alarm (unsigned int __seconds) __attribute__ ((__nothrow__));
# 403 "/usr/include/unistd.h" 3 4
extern unsigned int sleep (unsigned int __seconds);






extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     __attribute__ ((__nothrow__));






extern int usleep (__useconds_t __useconds);
# 427 "/usr/include/unistd.h" 3 4
extern int pause (void);



extern int chown (__const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;



extern int fchown (int __fd, __uid_t __owner, __gid_t __group) __attribute__ ((__nothrow__)) ;




extern int lchown (__const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;
# 455 "/usr/include/unistd.h" 3 4
extern int chdir (__const char *__path) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;



extern int fchdir (int __fd) __attribute__ ((__nothrow__)) ;
# 469 "/usr/include/unistd.h" 3 4
extern char *getcwd (char *__buf, size_t __size) __attribute__ ((__nothrow__)) ;
# 482 "/usr/include/unistd.h" 3 4
extern char *getwd (char *__buf)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__)) ;




extern int dup (int __fd) __attribute__ ((__nothrow__)) ;


extern int dup2 (int __fd, int __fd2) __attribute__ ((__nothrow__));


extern char **__environ;







extern int execve (__const char *__path, char *__const __argv[],
     char *__const __envp[]) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
# 514 "/usr/include/unistd.h" 3 4
extern int execv (__const char *__path, char *__const __argv[])
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern int execle (__const char *__path, __const char *__arg, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern int execl (__const char *__path, __const char *__arg, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern int execvp (__const char *__file, char *__const __argv[])
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));




extern int execlp (__const char *__file, __const char *__arg, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));




extern int nice (int __inc) __attribute__ ((__nothrow__)) ;




extern void _exit (int __status) __attribute__ ((__noreturn__));





# 1 "/usr/include/bits/confname.h" 1 3 4
# 26 "/usr/include/bits/confname.h" 3 4
enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };


enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,




    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,



    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG,


    _SC_LEVEL1_ICACHE_SIZE,

    _SC_LEVEL1_ICACHE_ASSOC,

    _SC_LEVEL1_ICACHE_LINESIZE,

    _SC_LEVEL1_DCACHE_SIZE,

    _SC_LEVEL1_DCACHE_ASSOC,

    _SC_LEVEL1_DCACHE_LINESIZE,

    _SC_LEVEL2_CACHE_SIZE,

    _SC_LEVEL2_CACHE_ASSOC,

    _SC_LEVEL2_CACHE_LINESIZE,

    _SC_LEVEL3_CACHE_SIZE,

    _SC_LEVEL3_CACHE_ASSOC,

    _SC_LEVEL3_CACHE_LINESIZE,

    _SC_LEVEL4_CACHE_SIZE,

    _SC_LEVEL4_CACHE_ASSOC,

    _SC_LEVEL4_CACHE_LINESIZE,



    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

    _SC_RAW_SOCKETS

  };


enum
  {
    _CS_PATH,


    _CS_V6_WIDTH_RESTRICTED_ENVS,


    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS

  };
# 553 "/usr/include/unistd.h" 2 3 4


extern long int pathconf (__const char *__path, int __name)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern long int fpathconf (int __fd, int __name) __attribute__ ((__nothrow__));


extern long int sysconf (int __name) __attribute__ ((__nothrow__)) __attribute__ ((__const__));



extern size_t confstr (int __name, char *__buf, size_t __len) __attribute__ ((__nothrow__));




extern __pid_t getpid (void) __attribute__ ((__nothrow__));


extern __pid_t getppid (void) __attribute__ ((__nothrow__));




extern __pid_t getpgrp (void) __attribute__ ((__nothrow__));
# 589 "/usr/include/unistd.h" 3 4
extern __pid_t __getpgid (__pid_t __pid) __attribute__ ((__nothrow__));
# 598 "/usr/include/unistd.h" 3 4
extern int setpgid (__pid_t __pid, __pid_t __pgid) __attribute__ ((__nothrow__));
# 615 "/usr/include/unistd.h" 3 4
extern int setpgrp (void) __attribute__ ((__nothrow__));
# 632 "/usr/include/unistd.h" 3 4
extern __pid_t setsid (void) __attribute__ ((__nothrow__));







extern __uid_t getuid (void) __attribute__ ((__nothrow__));


extern __uid_t geteuid (void) __attribute__ ((__nothrow__));


extern __gid_t getgid (void) __attribute__ ((__nothrow__));


extern __gid_t getegid (void) __attribute__ ((__nothrow__));




extern int getgroups (int __size, __gid_t __list[]) __attribute__ ((__nothrow__)) ;
# 665 "/usr/include/unistd.h" 3 4
extern int setuid (__uid_t __uid) __attribute__ ((__nothrow__));




extern int setreuid (__uid_t __ruid, __uid_t __euid) __attribute__ ((__nothrow__));




extern int seteuid (__uid_t __uid) __attribute__ ((__nothrow__));






extern int setgid (__gid_t __gid) __attribute__ ((__nothrow__));




extern int setregid (__gid_t __rgid, __gid_t __egid) __attribute__ ((__nothrow__));




extern int setegid (__gid_t __gid) __attribute__ ((__nothrow__));
# 721 "/usr/include/unistd.h" 3 4
extern __pid_t fork (void) __attribute__ ((__nothrow__));






extern __pid_t vfork (void) __attribute__ ((__nothrow__));





extern char *ttyname (int __fd) __attribute__ ((__nothrow__));



extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2))) ;



extern int isatty (int __fd) __attribute__ ((__nothrow__));





extern int ttyslot (void) __attribute__ ((__nothrow__));




extern int link (__const char *__from, __const char *__to)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2))) ;
# 767 "/usr/include/unistd.h" 3 4
extern int symlink (__const char *__from, __const char *__to)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2))) ;




extern int readlink (__const char *__restrict __path, char *__restrict __buf,
       size_t __len) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2))) ;
# 789 "/usr/include/unistd.h" 3 4
extern int unlink (__const char *__name) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
# 798 "/usr/include/unistd.h" 3 4
extern int rmdir (__const char *__path) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern __pid_t tcgetpgrp (int __fd) __attribute__ ((__nothrow__));


extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) __attribute__ ((__nothrow__));






extern char *getlogin (void);







extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)));




extern int setlogin (__const char *__name) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
# 834 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/getopt.h" 1 3 4
# 59 "/usr/include/getopt.h" 3 4
extern char *optarg;
# 73 "/usr/include/getopt.h" 3 4
extern int optind;




extern int opterr;



extern int optopt;
# 152 "/usr/include/getopt.h" 3 4
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
       __attribute__ ((__nothrow__));
# 835 "/usr/include/unistd.h" 2 3 4







extern int gethostname (char *__name, size_t __len) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));






extern int sethostname (__const char *__name, size_t __len)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;



extern int sethostid (long int __id) __attribute__ ((__nothrow__)) ;





extern int getdomainname (char *__name, size_t __len)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;
extern int setdomainname (__const char *__name, size_t __len)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;





extern int vhangup (void) __attribute__ ((__nothrow__));


extern int revoke (__const char *__file) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;







extern int profil (unsigned short int *__sample_buffer, size_t __size,
     size_t __offset, unsigned int __scale)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));





extern int acct (__const char *__name) __attribute__ ((__nothrow__));



extern char *getusershell (void) __attribute__ ((__nothrow__));
extern void endusershell (void) __attribute__ ((__nothrow__));
extern void setusershell (void) __attribute__ ((__nothrow__));





extern int daemon (int __nochdir, int __noclose) __attribute__ ((__nothrow__)) ;






extern int chroot (__const char *__path) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;



extern char *getpass (__const char *__prompt) __attribute__ ((__nonnull__ (1)));
# 920 "/usr/include/unistd.h" 3 4
extern int fsync (int __fd);






extern long int gethostid (void);


extern void sync (void) __attribute__ ((__nothrow__));




extern int getpagesize (void) __attribute__ ((__nothrow__)) __attribute__ ((__const__));




extern int getdtablesize (void) __attribute__ ((__nothrow__));




extern int truncate (__const char *__file, __off_t __length)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;
# 967 "/usr/include/unistd.h" 3 4
extern int ftruncate (int __fd, __off_t __length) __attribute__ ((__nothrow__)) ;
# 987 "/usr/include/unistd.h" 3 4
extern int brk (void *__addr) __attribute__ ((__nothrow__)) ;





extern void *sbrk (intptr_t __delta) __attribute__ ((__nothrow__));
# 1008 "/usr/include/unistd.h" 3 4
extern long int syscall (long int __sysno, ...) __attribute__ ((__nothrow__));
# 1031 "/usr/include/unistd.h" 3 4
extern int lockf (int __fd, int __cmd, __off_t __len) ;
# 1062 "/usr/include/unistd.h" 3 4
extern int fdatasync (int __fildes) __attribute__ ((__nothrow__));
# 1100 "/usr/include/unistd.h" 3 4

# 3 "pingServer.c" 2

# 1 "everything.h" 1
# 5 "pingServer.c" 2


extern PortableServer_POA global_poa;

typedef struct {
 POA_test_PingPongServer baseServant;

 CORBA_Object registered;
} test_PingPongServer_Servant;

static void
PingPongServer_set (PortableServer_Servant servant,
      CORBA_Object object,
      const CORBA_char *name,
      CORBA_Environment *ev)
{
 test_PingPongServer_Servant *this;

 this = (test_PingPongServer_Servant *) servant;

 this->registered = CORBA_Object_duplicate (object, ev);
}

static CORBA_Object
PingPongServer_get (PortableServer_Servant servant,
      const CORBA_char *name,
      CORBA_Environment *ev)
{
 test_PingPongServer_Servant *this;

 this = (test_PingPongServer_Servant *) servant;

 return CORBA_Object_duplicate (this->registered, ev);
}

static void
PingPongServer_opSleep (PortableServer_Servant servant,
   const char *large_string,
   CORBA_Environment *ev)
{

 g_usleep (10000);
}

static void
PingPongServer_opOneWay (PortableServer_Servant servant,
    const CORBA_long l,
    CORBA_Environment *ev)
{

 link_main_iteration ((0));
}

static void
PingPongServer_opOneWayCallback (PortableServer_Servant servant,
     test_PingPongServer remote_obj,
     CORBA_Environment *ev)
{
 static int depth = 0;

 depth++;
 if (depth % 400 == 0 && depth > 1)
  fprintf (stderr, " recursion depth %d\n", depth);

 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ORBit_small_get_connection_status (remote_obj) != ORBIT_CONNECTION_IN_PROC) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "pingServer.c", 70, __PRETTY_FUNCTION__, "ORBit_small_get_connection_status (remote_obj) != ORBIT_CONNECTION_IN_PROC"); });




 test_PingPongServer_opRoundTrip (remote_obj, ev);

 depth--;
}

static void
PingPongServer_opRoundTrip (PortableServer_Servant servant,
       CORBA_Environment *ev)
{

}

static CORBA_long
PingPongServer_pingPong (PortableServer_Servant servant,
    const test_PingPongServer replyTo,
    const CORBA_long idx,
    CORBA_Environment *ev)
{
 CORBA_long ret;
 CORBA_Object me;

 me = PortableServer_POA_servant_to_reference (
  global_poa, servant, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "pingServer.c", 97, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 test_PingPongServer_opOneWay (replyTo, 3, ev);

 if (idx > 0)
  ret = test_PingPongServer_pingPong (replyTo, me, idx - 1, ev);
 else
  ret = 0;

 CORBA_Object_release (me, ev);

 return ret;
}

static void
ping_pong_finalize (PortableServer_Servant servant,
      CORBA_Environment *ev)
{
 test_PingPongServer_Servant *this;

 this = (test_PingPongServer_Servant *) servant;

 CORBA_Object_release (this->registered, ev);

 g_free (servant);
}

PortableServer_ServantBase__epv PingPongServer_base_epv = {
 ((void *)0), ping_pong_finalize, ((void *)0)
};

POA_test_PingPongServer__epv PingPongServer_epv = {
 ((void *)0),
 PingPongServer_opSleep,
 PingPongServer_opOneWay,
 PingPongServer_opOneWayCallback,
 PingPongServer_opRoundTrip,
 PingPongServer_pingPong,
 PingPongServer_set,
 PingPongServer_get
};

POA_test_PingPongServer__vepv PingPongServer_vepv = {
 &PingPongServer_base_epv,
 &PingPongServer_epv
};

static POA_test_PingPongServer *
create_ping_pong_servant (void)
{
 CORBA_Environment ev[1];
 test_PingPongServer_Servant *servant;

 servant = ((test_PingPongServer_Servant *) g_malloc0 (((gsize) sizeof (test_PingPongServer_Servant)) * ((gsize) (1))));
 servant->baseServant.vepv = &PingPongServer_vepv;

 servant->registered = ((void *)0);

 CORBA_exception_init (ev);
 POA_test_PingPongServer__init (servant, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "pingServer.c", 157, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
 CORBA_exception_free (ev);

 return (POA_test_PingPongServer *) servant;
};
# 91 "server.c" 2
# 1 "derivedServer.c" 1
# 1 "everything.h" 1
# 2 "derivedServer.c" 2




POA_test_DerivedServer__epv DerivedServer_epv = { ((void *)0) };
POA_test_BaseServer__epv BaseServer_epv = {
 ((void *)0),
 ((void *)0),
 ((void *)0)
};
POA_test_B1__epv B1_epv = { ((void *)0) };
POA_test_B2__epv B2_epv = { ((void *)0) };
POA_test_C1__epv C1_epv = { ((void *)0) };
PortableServer_ServantBase__epv DerivedServer_base_epv = {((void *)0), simple_finalize, ((void *)0)};
POA_test_DerivedServer__vepv DerivedServer_vepv = {
 &DerivedServer_base_epv,
 &BaseServer_epv,
 &B1_epv,
 &B2_epv,
 &C1_epv,
 &DerivedServer_epv,
};
# 92 "server.c" 2

typedef struct {
 POA_test_TestFactory baseServant;

 test_BasicServer basicServerRef;
 test_StructServer structServerRef;
 test_SequenceServer sequenceServerRef;
 test_UnionServer unionServerRef;
 test_ArrayServer arrayServerRef;
 test_AnyServer anyServerRef;
 test_ContextServer contextServerRef;
 test_DerivedServer derivedServerRef;
 GSList *pingPongServerRefs;
} test_TestFactory_Servant;


static test_BasicServer
TestFactory_getBasicServer (PortableServer_Servant servant,
       CORBA_Environment *ev)
{
 test_TestFactory_Servant *this = (test_TestFactory_Servant *) servant;

 return CORBA_Object_duplicate (this->basicServerRef, ev);
}

static CORBA_char *
TestFactory_getStructServerIOR (PortableServer_Servant servant,
    CORBA_Environment *ev)
{
 test_TestFactory_Servant *this = (test_TestFactory_Servant *) servant;

 return CORBA_ORB_object_to_string (global_orb, this->structServerRef, ev);
}

static test_StructServer
TestFactory_getStructServer (PortableServer_Servant servant,
        CORBA_Environment *ev)
{
 test_TestFactory_Servant *this = (test_TestFactory_Servant*) servant;

 return CORBA_Object_duplicate (this->structServerRef, ev);
}

static
test_SequenceServer
TestFactory_getSequenceServer(PortableServer_Servant servant,
         CORBA_Environment *ev)
{
 test_TestFactory_Servant *this = (test_TestFactory_Servant*) servant;

 return CORBA_Object_duplicate(this->sequenceServerRef,ev);
}

static test_UnionServer
TestFactory_getUnionServer (PortableServer_Servant servant,
       CORBA_Environment *ev)
{
 test_TestFactory_Servant *this = (test_TestFactory_Servant*) servant;

 return CORBA_Object_duplicate (this->unionServerRef, ev);
}

static test_ArrayServer
TestFactory_getArrayServer (PortableServer_Servant servant,
       CORBA_Environment *ev)
{
 test_TestFactory_Servant *this = (test_TestFactory_Servant*) servant;

 return CORBA_Object_duplicate (this->arrayServerRef, ev);
}

static test_AnyServer
TestFactory_getAnyServer (PortableServer_Servant servant,
     CORBA_Environment *ev)
{
 test_TestFactory_Servant *this = (test_TestFactory_Servant*) servant;

 return CORBA_Object_duplicate (this->anyServerRef, ev);
}

static test_ContextServer
TestFactory_getContextServer (PortableServer_Servant servant,
         CORBA_Environment *ev)
{
 test_TestFactory_Servant *this = (test_TestFactory_Servant*) servant;

 return CORBA_Object_duplicate (this->contextServerRef, ev);
}

static test_DerivedServer
TestFactory_getDerivedServer (PortableServer_Servant servant,
         CORBA_Environment *ev)
{
 test_TestFactory_Servant *this = (test_TestFactory_Servant*) servant;

 return CORBA_Object_duplicate (this->derivedServerRef, ev);
}

static test_PingPongServer
TestFactory_createPingPongServer (PortableServer_Servant servant,
      CORBA_Environment *ev)
{
 test_PingPongServer obj;

 obj = create_object (
  global_poa, create_ping_pong_servant (), ev);

 if (servant) {
  test_TestFactory_Servant *this;

  this = (test_TestFactory_Servant*) servant;

  this->pingPongServerRefs = g_slist_prepend (
   this->pingPongServerRefs, obj);
 }

 return CORBA_Object_duplicate (obj, ev);
}

static void
TestFactory_noOp (PortableServer_Servant servant,
    CORBA_Environment *ev)
{

}

static test_DeadReferenceObj
TestFactory_createDeadReferenceObj (PortableServer_Servant servant,
        CORBA_Environment *ev)
{
 PortableServer_Current poa_current;
        PortableServer_POA poa;
 CORBA_Object obj;

        poa_current = (PortableServer_Current)
   CORBA_ORB_resolve_initial_references (global_orb,
             "POACurrent",
             ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "server.c", 230, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

        poa = PortableServer_Current_get_POA (poa_current, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "server.c", 233, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 obj = create_object (poa, (simple_servant_new (&(DeadReferenceObj_vepv), POA_test_DeadReferenceObj__init)), ev);

 CORBA_Object_release ((CORBA_Object) poa, ev);
 CORBA_Object_release ((CORBA_Object) poa_current, ev);



 return obj;
}

static test_LifeCycleServer
TestFactory_createLifeCycleServer (PortableServer_Servant servant,
       CORBA_Environment *ev)
{
 CORBA_Object obj = create_object (global_poa, (simple_servant_new (&(LifeCycleServer_vepv), POA_test_LifeCycleServer__init)), ev);
 return obj;
}

static void
TestFactory_segv (PortableServer_Servant servant,
    const CORBA_char *when,
    CORBA_Environment *ev)
{




 CORBA_ORB_shutdown (global_orb, (!(0)), ev);

}

static void
test_TestFactory__fini (PortableServer_Servant servant,
   CORBA_Environment *ev)
{
 GSList *l;
 test_TestFactory_Servant *this;

 this = (test_TestFactory_Servant*) servant;

 CORBA_Object_release (this->basicServerRef, ev);
 CORBA_Object_release (this->structServerRef, ev);
 CORBA_Object_release (this->sequenceServerRef, ev);
 CORBA_Object_release (this->unionServerRef, ev);
 CORBA_Object_release (this->arrayServerRef, ev);
 CORBA_Object_release (this->anyServerRef, ev);
 CORBA_Object_release (this->contextServerRef, ev);
 CORBA_Object_release (this->derivedServerRef, ev);

 for (l = this->pingPongServerRefs; l; l = l->next)
  CORBA_Object_release (l->data, ev);
 g_slist_free (this->pingPongServerRefs);

 g_free (servant);
}


static PortableServer_ServantBase__epv TestFactory_base_epv = {
 ((void *)0),
 test_TestFactory__fini,
 ((void *)0)
};

static POA_test_TestFactory__epv TestFactory_epv = {
 ((void *)0),
 TestFactory_getBasicServer,
 TestFactory_getStructServer,
 TestFactory_getStructServerIOR,
 TestFactory_getSequenceServer,
 TestFactory_getUnionServer,
 TestFactory_getArrayServer,
 TestFactory_getAnyServer,
 TestFactory_getContextServer,
 TestFactory_segv,
 ((void *)0),
 TestFactory_getDerivedServer,
 ((void *)0),
 ((void *)0),
 ((void *)0),
 TestFactory_createDeadReferenceObj,
 TestFactory_createPingPongServer,
 TestFactory_createLifeCycleServer,
 TestFactory_noOp
};

static POA_test_TestFactory__vepv TestFactory_vepv = {
 &TestFactory_base_epv,
 &TestFactory_epv
};

static PortableServer_POA
start_poa (CORBA_ORB orb, CORBA_Environment *ev)
{
 PortableServer_POAManager mgr;
 PortableServer_POA the_poa;

 the_poa = (PortableServer_POA) CORBA_ORB_resolve_initial_references (
  orb, "RootPOA", ev);

 mgr = PortableServer_POA__get_the_POAManager (the_poa, ev);
 PortableServer_POAManager_activate (mgr, ev);
 CORBA_Object_release ((CORBA_Object) mgr, ev);

 return the_poa;
}

CORBA_Object
create_object (PortableServer_POA poa,
        gpointer servant,
        CORBA_Environment *ev)
{
 CORBA_Object object;
 PortableServer_ObjectId *objid;

 objid = PortableServer_POA_activate_object (
  poa, servant, ev);

 if (ev->_major != CORBA_NO_EXCEPTION)
  g_log (((gchar*) 0), G_LOG_LEVEL_ERROR, "activate_object failed: %d\n", ev->_major);

 object = PortableServer_POA_servant_to_reference (
  poa, servant, ev);
 if (ev->_major != CORBA_NO_EXCEPTION)
  g_log (((gchar*) 0), G_LOG_LEVEL_ERROR, "servant_to_reference failed: %d\n", ev->_major);

 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ORBit_small_get_servant (object) == servant) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "server.c", 360, __PRETTY_FUNCTION__, "ORBit_small_get_servant (object) == servant"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (( (PortableServer_ClassInfo*) ( ((PortableServer_ServantBase *)(servant))->vepv[0]->_private ) ) != ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "server.c", 361, __PRETTY_FUNCTION__, "ORBIT_SERVANT_TO_CLASSINFO (servant) != NULL"); });

 CORBA_free (objid);

 return object;
}


static void
test_TestFactory__init (PortableServer_Servant servant,
   PortableServer_POA poa,
   CORBA_Environment *ev)
{
 test_TestFactory_Servant *this = (test_TestFactory_Servant*)servant;
 this->baseServant._private = ((void *)0);
 this->baseServant.vepv = &TestFactory_vepv;

 this->basicServerRef = create_object (
  poa, (simple_servant_new (&(BasicServer_vepv), POA_test_BasicServer__init)), ev);

 this->structServerRef = create_object (
  poa, (simple_servant_new (&(StructServer_vepv), POA_test_StructServer__init)), ev);

 this->sequenceServerRef = create_object (
  poa, (simple_servant_new (&(SequenceServer_vepv), POA_test_SequenceServer__init)), ev);

 this->unionServerRef = create_object (
  poa, (simple_servant_new (&(UnionServer_vepv), POA_test_UnionServer__init)), ev);

 this->arrayServerRef = create_object (
  poa, (simple_servant_new (&(ArrayServer_vepv), POA_test_ArrayServer__init)), ev);

 this->anyServerRef = create_object (
  poa, (simple_servant_new (&(AnyServer_vepv), POA_test_AnyServer__init)), ev);

 this->contextServerRef = create_object (
  poa, (simple_servant_new (&(ContextServer_vepv), POA_test_ContextServer__init)), ev);

 this->derivedServerRef = create_object (
  poa, (simple_servant_new (&(DerivedServer_vepv), POA_test_DerivedServer__init)), ev);

 this->pingPongServerRefs = ((void *)0);

 POA_test_TestFactory__init (
  (PortableServer_ServantBase *) servant, ev);
}

static test_TestFactory factory;

test_TestFactory
getFactoryInstance (CORBA_Environment *ev)
{
 return CORBA_Object_duplicate (factory, ev);
}
# 441 "server.c"
static CORBA_Object
create_TestFactory (PortableServer_POA poa,
      CORBA_Environment *ev)
{
 CORBA_Object object;
 PortableServer_ObjectId *objid;
 test_TestFactory_Servant *servant = ((test_TestFactory_Servant *) g_malloc0 (((gsize) sizeof (test_TestFactory_Servant)) * ((gsize) (1))));

 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "server.c", 449, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
 test_TestFactory__init (servant, poa, ev);
 if (ev->_major != CORBA_NO_EXCEPTION)
  g_log (((gchar*) 0), G_LOG_LEVEL_ERROR, "object__init failed: %d\n", ev->_major);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (( (PortableServer_ClassInfo*) ( ((PortableServer_ServantBase *)(servant))->vepv[0]->_private ) ) != ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "server.c", 453, __PRETTY_FUNCTION__, "ORBIT_SERVANT_TO_CLASSINFO (servant) != NULL"); });

 objid = PortableServer_POA_activate_object (
  poa, servant, ev);
 if (ev->_major != CORBA_NO_EXCEPTION)
  g_log (((gchar*) 0), G_LOG_LEVEL_ERROR, "activate_object failed: %d\n", ev->_major);

 object = PortableServer_POA_servant_to_reference (
  poa, servant, ev);
 if (ev->_major != CORBA_NO_EXCEPTION)
  g_log (((gchar*) 0), G_LOG_LEVEL_ERROR, "servant_to_reference failed: %d\n", ev->_major);

 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ORBit_small_get_servant (object) == servant) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "server.c", 465, __PRETTY_FUNCTION__, "ORBit_small_get_servant (object) == servant"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (( (PortableServer_ClassInfo*) ( ((PortableServer_ServantBase *)(servant))->vepv[0]->_private ) ) != ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "server.c", 466, __PRETTY_FUNCTION__, "ORBIT_SERVANT_TO_CLASSINFO (servant) != NULL"); });

 CORBA_free (objid);

 return object;
}

static void
init_iinterfaces (ORBit_IInterfaces *interfaces,
    CORBA_Environment *ev)
{
 int i = 0;
# 487 "server.c"
 (void) __extension__ ( { (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_TypeCode_equal ( interfaces->_buffer[i].tc, (test_TestFactory__iinterface).tc, ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "server.c", 487, __PRETTY_FUNCTION__, "CORBA_TypeCode_equal ( interfaces->_buffer[i].tc, (test_TestFactory__iinterface).tc, ev)"); }); (test_TestFactory__iinterface) = interfaces->_buffer [i]; i++; } );
 (void) __extension__ ( { (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_TypeCode_equal ( interfaces->_buffer[i].tc, (test_LifeCycleServer__iinterface).tc, ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "server.c", 488, __PRETTY_FUNCTION__, "CORBA_TypeCode_equal ( interfaces->_buffer[i].tc, (test_LifeCycleServer__iinterface).tc, ev)"); }); (test_LifeCycleServer__iinterface) = interfaces->_buffer [i]; i++; } );
 (void) __extension__ ( { (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_TypeCode_equal ( interfaces->_buffer[i].tc, (test_DeadReferenceObj__iinterface).tc, ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "server.c", 489, __PRETTY_FUNCTION__, "CORBA_TypeCode_equal ( interfaces->_buffer[i].tc, (test_DeadReferenceObj__iinterface).tc, ev)"); }); (test_DeadReferenceObj__iinterface) = interfaces->_buffer [i]; i++; } );
 (void) __extension__ ( { (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_TypeCode_equal ( interfaces->_buffer[i].tc, (test_TransientObj__iinterface).tc, ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "server.c", 490, __PRETTY_FUNCTION__, "CORBA_TypeCode_equal ( interfaces->_buffer[i].tc, (test_TransientObj__iinterface).tc, ev)"); }); (test_TransientObj__iinterface) = interfaces->_buffer [i]; i++; } );
 (void) __extension__ ( { (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_TypeCode_equal ( interfaces->_buffer[i].tc, (test_SequenceServer__iinterface).tc, ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "server.c", 491, __PRETTY_FUNCTION__, "CORBA_TypeCode_equal ( interfaces->_buffer[i].tc, (test_SequenceServer__iinterface).tc, ev)"); }); (test_SequenceServer__iinterface) = interfaces->_buffer [i]; i++; } );
 (void) __extension__ ( { (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_TypeCode_equal ( interfaces->_buffer[i].tc, (test_ArrayServer__iinterface).tc, ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "server.c", 492, __PRETTY_FUNCTION__, "CORBA_TypeCode_equal ( interfaces->_buffer[i].tc, (test_ArrayServer__iinterface).tc, ev)"); }); (test_ArrayServer__iinterface) = interfaces->_buffer [i]; i++; } );
 (void) __extension__ ( { (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_TypeCode_equal ( interfaces->_buffer[i].tc, (test_BasicServer__iinterface).tc, ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "server.c", 493, __PRETTY_FUNCTION__, "CORBA_TypeCode_equal ( interfaces->_buffer[i].tc, (test_BasicServer__iinterface).tc, ev)"); }); (test_BasicServer__iinterface) = interfaces->_buffer [i]; i++; } );
 (void) __extension__ ( { (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_TypeCode_equal ( interfaces->_buffer[i].tc, (test_StructServer__iinterface).tc, ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "server.c", 494, __PRETTY_FUNCTION__, "CORBA_TypeCode_equal ( interfaces->_buffer[i].tc, (test_StructServer__iinterface).tc, ev)"); }); (test_StructServer__iinterface) = interfaces->_buffer [i]; i++; } );
 (void) __extension__ ( { (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_TypeCode_equal ( interfaces->_buffer[i].tc, (test_BaseServer__iinterface).tc, ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "server.c", 495, __PRETTY_FUNCTION__, "CORBA_TypeCode_equal ( interfaces->_buffer[i].tc, (test_BaseServer__iinterface).tc, ev)"); }); (test_BaseServer__iinterface) = interfaces->_buffer [i]; i++; } );
 (void) __extension__ ( { (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_TypeCode_equal ( interfaces->_buffer[i].tc, (test_B1__iinterface).tc, ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "server.c", 496, __PRETTY_FUNCTION__, "CORBA_TypeCode_equal ( interfaces->_buffer[i].tc, (test_B1__iinterface).tc, ev)"); }); (test_B1__iinterface) = interfaces->_buffer [i]; i++; } );
 (void) __extension__ ( { (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_TypeCode_equal ( interfaces->_buffer[i].tc, (test_B2__iinterface).tc, ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "server.c", 497, __PRETTY_FUNCTION__, "CORBA_TypeCode_equal ( interfaces->_buffer[i].tc, (test_B2__iinterface).tc, ev)"); }); (test_B2__iinterface) = interfaces->_buffer [i]; i++; } );
 (void) __extension__ ( { (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_TypeCode_equal ( interfaces->_buffer[i].tc, (test_C1__iinterface).tc, ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "server.c", 498, __PRETTY_FUNCTION__, "CORBA_TypeCode_equal ( interfaces->_buffer[i].tc, (test_C1__iinterface).tc, ev)"); }); (test_C1__iinterface) = interfaces->_buffer [i]; i++; } );
 (void) __extension__ ( { (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_TypeCode_equal ( interfaces->_buffer[i].tc, (test_DerivedServer__iinterface).tc, ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "server.c", 499, __PRETTY_FUNCTION__, "CORBA_TypeCode_equal ( interfaces->_buffer[i].tc, (test_DerivedServer__iinterface).tc, ev)"); }); (test_DerivedServer__iinterface) = interfaces->_buffer [i]; i++; } );
 (void) __extension__ ( { (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_TypeCode_equal ( interfaces->_buffer[i].tc, (test_UnionServer__iinterface).tc, ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "server.c", 500, __PRETTY_FUNCTION__, "CORBA_TypeCode_equal ( interfaces->_buffer[i].tc, (test_UnionServer__iinterface).tc, ev)"); }); (test_UnionServer__iinterface) = interfaces->_buffer [i]; i++; } );
 (void) __extension__ ( { (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_TypeCode_equal ( interfaces->_buffer[i].tc, (test_AnyServer__iinterface).tc, ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "server.c", 501, __PRETTY_FUNCTION__, "CORBA_TypeCode_equal ( interfaces->_buffer[i].tc, (test_AnyServer__iinterface).tc, ev)"); }); (test_AnyServer__iinterface) = interfaces->_buffer [i]; i++; } );
 (void) __extension__ ( { (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_TypeCode_equal ( interfaces->_buffer[i].tc, (test_ContextServer__iinterface).tc, ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "server.c", 502, __PRETTY_FUNCTION__, "CORBA_TypeCode_equal ( interfaces->_buffer[i].tc, (test_ContextServer__iinterface).tc, ev)"); }); (test_ContextServer__iinterface) = interfaces->_buffer [i]; i++; } );
 (void) __extension__ ( { (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_TypeCode_equal ( interfaces->_buffer[i].tc, (test_PingPongServer__iinterface).tc, ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "server.c", 503, __PRETTY_FUNCTION__, "CORBA_TypeCode_equal ( interfaces->_buffer[i].tc, (test_PingPongServer__iinterface).tc, ev)"); }); (test_PingPongServer__iinterface) = interfaces->_buffer [i]; i++; } );

}





  static CORBA_Object
  get_server (CORBA_ORB orb,
       CORBA_Environment *ev)

{
 test_BasicServer objref;
# 563 "server.c"
 global_poa = start_poa (global_orb, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "server.c", 564, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 factory = create_TestFactory (global_poa, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (factory != ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "server.c", 567, __PRETTY_FUNCTION__, "factory != CORBA_OBJECT_NIL"); });


 objref = test_TestFactory_getBasicServer (factory, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "server.c", 571, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (objref != ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "server.c", 572, __PRETTY_FUNCTION__, "objref != CORBA_OBJECT_NIL"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_Object_is_a (objref, "IDL:orbit/test/BasicServer:1.0", ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "server.c", 573, __PRETTY_FUNCTION__, "CORBA_Object_is_a (objref, \"IDL:orbit/test/BasicServer:1.0\", ev)"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "server.c", 574, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
 CORBA_Object_release (objref, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "server.c", 576, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
 fprintf (stderr, "Local server test passed\n");
# 602 "server.c"
 return factory;

}
# 51 "client.c" 2


static void
testConst (void)
{
 if (!thread_tests) g_print("Testing constants...\n");
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if ('\x74' == 't') _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 57, __PRETTY_FUNCTION__, "test_CONST_CHAR == 't'"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (305419896 == 0x12345678) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 58, __PRETTY_FUNCTION__, "test_CONST_LONG == 0x12345678"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (305419896 == 0x12345678) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 59, __PRETTY_FUNCTION__, "test_CONST_LONG_LONG == 0x12345678"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (!__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p ("ConstString") && __builtin_constant_p ("ConstString") && (__s1_len = strlen ("ConstString"), __s2_len = strlen ("ConstString"), (!((size_t)(const void *)(("ConstString") + 1) - (size_t)(const void *)("ConstString") == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("ConstString") + 1) - (size_t)(const void *)("ConstString") == 1) || __s2_len >= 4)) ? __builtin_strcmp ("ConstString", "ConstString") : (__builtin_constant_p ("ConstString") && ((size_t)(const void *)(("ConstString") + 1) - (size_t)(const void *)("ConstString") == 1) && (__s1_len = strlen ("ConstString"), __s1_len < 4) ? (__builtin_constant_p ("ConstString") && ((size_t)(const void *)(("ConstString") + 1) - (size_t)(const void *)("ConstString") == 1) ? __builtin_strcmp ("ConstString", "ConstString") : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) ("ConstString"); register int __result = (((__const unsigned char *) (__const char *) ("ConstString"))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) ("ConstString"))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) ("ConstString"))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) ("ConstString"))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("ConstString") && ((size_t)(const void *)(("ConstString") + 1) - (size_t)(const void *)("ConstString") == 1) && (__s2_len = strlen ("ConstString"), __s2_len < 4) ? (__builtin_constant_p ("ConstString") && ((size_t)(const void *)(("ConstString") + 1) - (size_t)(const void *)("ConstString") == 1) ? __builtin_strcmp ("ConstString", "ConstString") : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) ("ConstString"); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) ("ConstString"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) ("ConstString"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) ("ConstString"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) ("ConstString"))[3]); } } __result; }))) : __builtin_strcmp ("ConstString", "ConstString")))); })) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 60, __PRETTY_FUNCTION__, "!strcmp (test_CONST_STRING, \"ConstString\")"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (1234.560000 == 1234.56) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 61, __PRETTY_FUNCTION__, "test_CONST_FLOAT == 1234.56"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (1234.567800 == 1234.5678) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 62, __PRETTY_FUNCTION__, "test_CONST_DOUBLE == 1234.5678"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (1234.567891 == 1234.567891) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 63, __PRETTY_FUNCTION__, "test_CONST_LONG_DOUBLE == 1234.567891"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (test_veggie == test_veggie) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 64, __PRETTY_FUNCTION__, "test_FAVORITE_SOUP == test_veggie"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (test_oxtail == test_oxtail) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 65, __PRETTY_FUNCTION__, "test_HORRIBLE_SOUP == test_oxtail"); });
}

static void
testSequenceHelpers (void)
{
 CORBA_long l = 0;
 test_BoundedLongSeq *lseq = ((void *)0);

 if (!thread_tests) g_print("Testing ORBit_sequence helpers...\n");

 lseq = ORBit_sequence_alloc (((CORBA_TypeCode)&TC_test_BoundedLongSeq_struct), 2);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (lseq != ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 77, __PRETTY_FUNCTION__, "lseq != NULL"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (lseq->_length == 2) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 78, __PRETTY_FUNCTION__, "lseq->_length == 2"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (lseq->_maximum >= 2) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 79, __PRETTY_FUNCTION__, "lseq->_maximum >= 2"); });

 (lseq)->_buffer[(0)] = 0;
 (lseq)->_buffer[(1)] = 0;

 l = 1;
 ORBit_sequence_append (lseq, &l);
 l++;
 ORBit_sequence_append (lseq, &l);

 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (lseq->_length == 4) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 89, __PRETTY_FUNCTION__, "lseq->_length == 4"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if ((lseq)->_buffer[(2)] == 1) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 90, __PRETTY_FUNCTION__, "ORBit_sequence_index (lseq, 2) == 1"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if ((lseq)->_buffer[(3)] == 2) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 91, __PRETTY_FUNCTION__, "ORBit_sequence_index (lseq, 3) == 2"); });

        ORBit_sequence_remove(lseq, 2);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (lseq->_length == 3) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 94, __PRETTY_FUNCTION__, "lseq->_length == 3"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if ((lseq)->_buffer[(2)] == 2) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 95, __PRETTY_FUNCTION__, "ORBit_sequence_index (lseq, 2) == 2"); });

 ORBit_sequence_set_size (lseq, 100);
 ORBit_sequence_set_size (lseq, 0);

 CORBA_free (lseq);


 {
  CORBA_long i = 0;
  CORBA_long j = 0;


  CORBA_long MAX_APPEND = 1<<16;

  CORBA_sequence_CORBA_octet *oseq = ((void *)0);

  oseq = ORBit_sequence_alloc (((CORBA_TypeCode)&TC_CORBA_sequence_CORBA_octet_struct), 0);

  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (oseq != ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 114, __PRETTY_FUNCTION__, "oseq != NULL"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (oseq->_length == 0) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 115, __PRETTY_FUNCTION__, "oseq->_length == 0"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (oseq->_maximum >= 0) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 116, __PRETTY_FUNCTION__, "oseq->_maximum >= 0"); });

  for (i = 0; i < MAX_APPEND; ++i)
  {
   CORBA_octet oct = (CORBA_octet) (i % 109);

   ORBit_sequence_append (oseq, &oct);
   (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (i+1==oseq->_length) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 123, __PRETTY_FUNCTION__, "i+1==oseq->_length"); });



   if (i % 367 == 0)
   for (j = 0; j < oseq->_length; ++j )
   {
    CORBA_octet j_check = (CORBA_octet) (j % 109);
    CORBA_octet j_value = (oseq)->_buffer[(j)];
    (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (j_value==j_check) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 132, __PRETTY_FUNCTION__, "j_value==j_check"); });
   }
  }

  CORBA_free (oseq);
 }




 {
  CORBA_octet oct = 0;
  CORBA_long i = 0;
  CORBA_long j = 0;
  CORBA_long a = 0;
  CORBA_long b = 0;
  CORBA_sequence_CORBA_octet *aseq = ((void *)0);
  CORBA_sequence_CORBA_octet *bseq = ((void *)0);

  aseq = ORBit_sequence_alloc (((CORBA_TypeCode)&TC_CORBA_sequence_CORBA_octet_struct), 0);
  bseq = ORBit_sequence_alloc (((CORBA_TypeCode)&TC_CORBA_sequence_CORBA_octet_struct), 0);

  for (b = 0; b < 200; ++b) {
   ORBit_sequence_concat (aseq, bseq);

   a = 0;
   for (i = 0; i < b; ++i)
    for (j = 0; j < i; ++j, ++a)
     (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if ((aseq)->_buffer[(a)] == j % 128) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 160, __PRETTY_FUNCTION__, "ORBit_sequence_index (aseq, a) == j % 128"); });

   oct = b % 128;
   ORBit_sequence_append (bseq, &oct);
  }

  CORBA_free (aseq);
  CORBA_free (bseq);
 }

}

static void
testAttribute (test_BasicServer objref,
        CORBA_Environment *ev)
{
 CORBA_char *val;
 CORBA_long lval;

 if (!thread_tests) g_print("Testing attributes...\n");

 val = test_BasicServer__get_foo (objref, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 182, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (val) && __builtin_constant_p (constants_STRING_RETN) && (__s1_len = strlen (val), __s2_len = strlen (constants_STRING_RETN), (!((size_t)(const void *)((val) + 1) - (size_t)(const void *)(val) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((constants_STRING_RETN) + 1) - (size_t)(const void *)(constants_STRING_RETN) == 1) || __s2_len >= 4)) ? __builtin_strcmp (val, constants_STRING_RETN) : (__builtin_constant_p (val) && ((size_t)(const void *)((val) + 1) - (size_t)(const void *)(val) == 1) && (__s1_len = strlen (val), __s1_len < 4) ? (__builtin_constant_p (constants_STRING_RETN) && ((size_t)(const void *)((constants_STRING_RETN) + 1) - (size_t)(const void *)(constants_STRING_RETN) == 1) ? __builtin_strcmp (val, constants_STRING_RETN) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (constants_STRING_RETN); register int __result = (((__const unsigned char *) (__const char *) (val))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (val))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (val))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (val))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (constants_STRING_RETN) && ((size_t)(const void *)((constants_STRING_RETN) + 1) - (size_t)(const void *)(constants_STRING_RETN) == 1) && (__s2_len = strlen (constants_STRING_RETN), __s2_len < 4) ? (__builtin_constant_p (val) && ((size_t)(const void *)((val) + 1) - (size_t)(const void *)(val) == 1) ? __builtin_strcmp (val, constants_STRING_RETN) : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (val); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (constants_STRING_RETN))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (constants_STRING_RETN))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (constants_STRING_RETN))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (constants_STRING_RETN))[3]); } } __result; }))) : __builtin_strcmp (val, constants_STRING_RETN)))); })==0) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 183, __PRETTY_FUNCTION__, "strcmp (val, constants_STRING_RETN)==0"); });
 CORBA_free (val);

 test_BasicServer__set_foo (objref, constants_STRING_IN, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 187, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 lval = test_BasicServer__get_bah (objref, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 190, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (lval == 0xAABBCCDD) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 191, __PRETTY_FUNCTION__, "lval == constants_LONG_RETN"); });
}

static void
testString (test_BasicServer objref,
     CORBA_Environment *ev)
{
 const CORBA_char *in;
 CORBA_char *inout, *out, *retn;

 if (!thread_tests) g_print("Testing strings...\n");

 in = constants_STRING_IN;
 inout = CORBA_string_dup (constants_STRING_INOUT_IN);
 retn = test_BasicServer_opString (objref, in, &inout, &out, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 206, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (out) && __builtin_constant_p (constants_STRING_OUT) && (__s1_len = strlen (out), __s2_len = strlen (constants_STRING_OUT), (!((size_t)(const void *)((out) + 1) - (size_t)(const void *)(out) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((constants_STRING_OUT) + 1) - (size_t)(const void *)(constants_STRING_OUT) == 1) || __s2_len >= 4)) ? __builtin_strcmp (out, constants_STRING_OUT) : (__builtin_constant_p (out) && ((size_t)(const void *)((out) + 1) - (size_t)(const void *)(out) == 1) && (__s1_len = strlen (out), __s1_len < 4) ? (__builtin_constant_p (constants_STRING_OUT) && ((size_t)(const void *)((constants_STRING_OUT) + 1) - (size_t)(const void *)(constants_STRING_OUT) == 1) ? __builtin_strcmp (out, constants_STRING_OUT) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (constants_STRING_OUT); register int __result = (((__const unsigned char *) (__const char *) (out))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (out))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (out))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (out))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (constants_STRING_OUT) && ((size_t)(const void *)((constants_STRING_OUT) + 1) - (size_t)(const void *)(constants_STRING_OUT) == 1) && (__s2_len = strlen (constants_STRING_OUT), __s2_len < 4) ? (__builtin_constant_p (out) && ((size_t)(const void *)((out) + 1) - (size_t)(const void *)(out) == 1) ? __builtin_strcmp (out, constants_STRING_OUT) : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (out); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (constants_STRING_OUT))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (constants_STRING_OUT))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (constants_STRING_OUT))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (constants_STRING_OUT))[3]); } } __result; }))) : __builtin_strcmp (out, constants_STRING_OUT)))); })==0) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 208, __PRETTY_FUNCTION__, "strcmp (out, constants_STRING_OUT)==0"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (retn) && __builtin_constant_p (constants_STRING_RETN) && (__s1_len = strlen (retn), __s2_len = strlen (constants_STRING_RETN), (!((size_t)(const void *)((retn) + 1) - (size_t)(const void *)(retn) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((constants_STRING_RETN) + 1) - (size_t)(const void *)(constants_STRING_RETN) == 1) || __s2_len >= 4)) ? __builtin_strcmp (retn, constants_STRING_RETN) : (__builtin_constant_p (retn) && ((size_t)(const void *)((retn) + 1) - (size_t)(const void *)(retn) == 1) && (__s1_len = strlen (retn), __s1_len < 4) ? (__builtin_constant_p (constants_STRING_RETN) && ((size_t)(const void *)((constants_STRING_RETN) + 1) - (size_t)(const void *)(constants_STRING_RETN) == 1) ? __builtin_strcmp (retn, constants_STRING_RETN) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (constants_STRING_RETN); register int __result = (((__const unsigned char *) (__const char *) (retn))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (retn))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (retn))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (retn))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (constants_STRING_RETN) && ((size_t)(const void *)((constants_STRING_RETN) + 1) - (size_t)(const void *)(constants_STRING_RETN) == 1) && (__s2_len = strlen (constants_STRING_RETN), __s2_len < 4) ? (__builtin_constant_p (retn) && ((size_t)(const void *)((retn) + 1) - (size_t)(const void *)(retn) == 1) ? __builtin_strcmp (retn, constants_STRING_RETN) : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (retn); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (constants_STRING_RETN))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (constants_STRING_RETN))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (constants_STRING_RETN))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (constants_STRING_RETN))[3]); } } __result; }))) : __builtin_strcmp (retn, constants_STRING_RETN)))); })==0) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 209, __PRETTY_FUNCTION__, "strcmp (retn, constants_STRING_RETN)==0"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (in) && __builtin_constant_p (constants_STRING_IN) && (__s1_len = strlen (in), __s2_len = strlen (constants_STRING_IN), (!((size_t)(const void *)((in) + 1) - (size_t)(const void *)(in) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((constants_STRING_IN) + 1) - (size_t)(const void *)(constants_STRING_IN) == 1) || __s2_len >= 4)) ? __builtin_strcmp (in, constants_STRING_IN) : (__builtin_constant_p (in) && ((size_t)(const void *)((in) + 1) - (size_t)(const void *)(in) == 1) && (__s1_len = strlen (in), __s1_len < 4) ? (__builtin_constant_p (constants_STRING_IN) && ((size_t)(const void *)((constants_STRING_IN) + 1) - (size_t)(const void *)(constants_STRING_IN) == 1) ? __builtin_strcmp (in, constants_STRING_IN) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (constants_STRING_IN); register int __result = (((__const unsigned char *) (__const char *) (in))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (in))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (in))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (in))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (constants_STRING_IN) && ((size_t)(const void *)((constants_STRING_IN) + 1) - (size_t)(const void *)(constants_STRING_IN) == 1) && (__s2_len = strlen (constants_STRING_IN), __s2_len < 4) ? (__builtin_constant_p (in) && ((size_t)(const void *)((in) + 1) - (size_t)(const void *)(in) == 1) ? __builtin_strcmp (in, constants_STRING_IN) : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (in); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (constants_STRING_IN))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (constants_STRING_IN))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (constants_STRING_IN))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (constants_STRING_IN))[3]); } } __result; }))) : __builtin_strcmp (in, constants_STRING_IN)))); })==0) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 210, __PRETTY_FUNCTION__, "strcmp (in, constants_STRING_IN)==0"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (inout) && __builtin_constant_p (constants_STRING_INOUT_OUT) && (__s1_len = strlen (inout), __s2_len = strlen (constants_STRING_INOUT_OUT), (!((size_t)(const void *)((inout) + 1) - (size_t)(const void *)(inout) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((constants_STRING_INOUT_OUT) + 1) - (size_t)(const void *)(constants_STRING_INOUT_OUT) == 1) || __s2_len >= 4)) ? __builtin_strcmp (inout, constants_STRING_INOUT_OUT) : (__builtin_constant_p (inout) && ((size_t)(const void *)((inout) + 1) - (size_t)(const void *)(inout) == 1) && (__s1_len = strlen (inout), __s1_len < 4) ? (__builtin_constant_p (constants_STRING_INOUT_OUT) && ((size_t)(const void *)((constants_STRING_INOUT_OUT) + 1) - (size_t)(const void *)(constants_STRING_INOUT_OUT) == 1) ? __builtin_strcmp (inout, constants_STRING_INOUT_OUT) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (constants_STRING_INOUT_OUT); register int __result = (((__const unsigned char *) (__const char *) (inout))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (inout))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (inout))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (inout))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (constants_STRING_INOUT_OUT) && ((size_t)(const void *)((constants_STRING_INOUT_OUT) + 1) - (size_t)(const void *)(constants_STRING_INOUT_OUT) == 1) && (__s2_len = strlen (constants_STRING_INOUT_OUT), __s2_len < 4) ? (__builtin_constant_p (inout) && ((size_t)(const void *)((inout) + 1) - (size_t)(const void *)(inout) == 1) ? __builtin_strcmp (inout, constants_STRING_INOUT_OUT) : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (inout); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (constants_STRING_INOUT_OUT))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (constants_STRING_INOUT_OUT))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (constants_STRING_INOUT_OUT))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (constants_STRING_INOUT_OUT))[3]); } } __result; }))) : __builtin_strcmp (inout, constants_STRING_INOUT_OUT)))); })==0) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 211, __PRETTY_FUNCTION__, "strcmp (inout, constants_STRING_INOUT_OUT)==0"); });

 test_BasicServer_opOneWay (objref, constants_STRING_IN, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 214, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 CORBA_free (inout);
 CORBA_free (out);
 CORBA_free (retn);
}

static void
testLong (test_BasicServer objref,
   CORBA_Environment *ev)
{
 CORBA_long inArg, inoutArg, outArg, retn;

 if (!thread_tests) g_print("Testing longs...\n");

 inArg = 0x12345678;
 inoutArg = 0x34567812;
 retn = test_BasicServer_opLong (objref, inArg, &inoutArg, &outArg, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 232, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inArg == 0x12345678) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 233, __PRETTY_FUNCTION__, "inArg == constants_LONG_IN"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inoutArg == 0x56781234) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 234, __PRETTY_FUNCTION__, "inoutArg == constants_LONG_INOUT_OUT"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (outArg == 0x78123456) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 235, __PRETTY_FUNCTION__, "outArg == constants_LONG_OUT"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (retn == 0xAABBCCDD) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 236, __PRETTY_FUNCTION__, "retn == constants_LONG_RETN"); });
}

static void
testLongLong (test_BasicServer objref,
       CORBA_Environment *ev)
{
 CORBA_long_long inArg, inoutArg, outArg, retn;

 if (!thread_tests) g_print("Testing long longs...\n");

 inArg = 0x12345678;
 inoutArg = 0x34567812;
 retn = test_BasicServer_opLongLong (objref, inArg, &inoutArg, &outArg, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 250, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inArg == 0x12345678) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 251, __PRETTY_FUNCTION__, "inArg == constants_LONG_LONG_IN"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inoutArg == 0x56781234) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 252, __PRETTY_FUNCTION__, "inoutArg == constants_LONG_LONG_INOUT_OUT"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (outArg == 0x78123456) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 253, __PRETTY_FUNCTION__, "outArg == constants_LONG_LONG_OUT"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (retn == 0xAABBCCDD) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 254, __PRETTY_FUNCTION__, "retn == constants_LONG_LONG_RETN"); });
}

static void
testFloat (test_BasicServer objref,
    CORBA_Environment *ev)
{
 CORBA_float inArg, inoutArg, outArg, retn;

 if (!thread_tests) g_print("Testing floats...\n");

 inArg = ((CORBA_float) 127.13534);
 inoutArg = ((CORBA_float) 124.89432);
 retn = test_BasicServer_opFloat (objref, inArg, &inoutArg, &outArg, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 268, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inArg == ((CORBA_float) 127.13534)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 269, __PRETTY_FUNCTION__, "inArg == constants_FLOAT_IN"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inoutArg == ((CORBA_float) 975.12694)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 270, __PRETTY_FUNCTION__, "inoutArg == constants_FLOAT_INOUT_OUT"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (outArg == ((CORBA_float) 112.54575)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 271, __PRETTY_FUNCTION__, "outArg == constants_FLOAT_OUT"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (retn == ((CORBA_float) 354.23535)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 272, __PRETTY_FUNCTION__, "retn == constants_FLOAT_RETN"); });
}

static void
testDouble (test_BasicServer objref,
     CORBA_Environment *ev)
{
 CORBA_double inArg, inoutArg, outArg, retn;

 if (!thread_tests) g_print("Testing doubles...\n");

 inArg = ((CORBA_double) 127.13534);
 inoutArg = ((CORBA_double) 124.89432);
 retn = test_BasicServer_opDouble (objref, inArg, &inoutArg, &outArg, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 286, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inArg == ((CORBA_double) 127.13534)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 287, __PRETTY_FUNCTION__, "inArg == constants_DOUBLE_IN"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inoutArg == ((CORBA_double) 975.12694)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 288, __PRETTY_FUNCTION__, "inoutArg == constants_DOUBLE_INOUT_OUT"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (outArg == ((CORBA_double) 112.54575)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 289, __PRETTY_FUNCTION__, "outArg == constants_DOUBLE_OUT"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (retn == ((CORBA_double) 354.23535)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 290, __PRETTY_FUNCTION__, "retn == constants_DOUBLE_RETN"); });
}

static void
testLongDouble (test_BasicServer objref,
  CORBA_Environment *ev)
{
 CORBA_long_double inArg, inoutArg, outArg, retn;

 if (!thread_tests) g_print("Testing long doubles...\n");

 inArg = ((CORBA_long_double) 127.13534);
 inoutArg = ((CORBA_long_double) 124.89432);
 retn = test_BasicServer_opLongDouble (objref, inArg, &inoutArg, &outArg, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 304, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inArg == ((CORBA_long_double) 127.13534)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 305, __PRETTY_FUNCTION__, "inArg == constants_LONG_DOUBLE_IN"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inoutArg == ((CORBA_long_double) 975.12694)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 306, __PRETTY_FUNCTION__, "inoutArg == constants_LONG_DOUBLE_INOUT_OUT"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (outArg == ((CORBA_long_double) 112.54575)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 307, __PRETTY_FUNCTION__, "outArg == constants_LONG_DOUBLE_OUT"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (retn == ((CORBA_long_double) 354.23535)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 308, __PRETTY_FUNCTION__, "retn == constants_LONG_DOUBLE_RETN"); });
}

static void
testEnum (test_BasicServer objref,
   CORBA_Environment *ev)
{
 test_AnEnum inArg, inoutArg, outArg, retn;

 if (!thread_tests) g_print("Testing enums...\n");

 inArg = test_ENUM_IN;
 inoutArg = test_ENUM_INOUT_IN;
 retn = test_BasicServer_opEnum (objref, inArg, &inoutArg, &outArg, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 322, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inArg == test_ENUM_IN) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 323, __PRETTY_FUNCTION__, "inArg == test_ENUM_IN"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inoutArg == test_ENUM_INOUT_OUT) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 324, __PRETTY_FUNCTION__, "inoutArg == test_ENUM_INOUT_OUT"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (outArg == test_ENUM_OUT) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 325, __PRETTY_FUNCTION__, "outArg == test_ENUM_OUT"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (retn == test_ENUM_RETN) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 326, __PRETTY_FUNCTION__, "retn == test_ENUM_RETN"); });
}

static void
testException (test_BasicServer objref,
        CORBA_Environment *ev)
{
 test_TestException *ex;
 CORBA_Environment *cpyev;

 if (!thread_tests) g_print("Testing exceptions...\n");

 test_BasicServer_opException (((void *)0), ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_SYSTEM_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 339, __PRETTY_FUNCTION__, "ev->_major == CORBA_SYSTEM_EXCEPTION"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (CORBA_exception_id (ev)) && __builtin_constant_p ("IDL:omg.org/CORBA/INV_OBJREF:1.0") && (__s1_len = strlen (CORBA_exception_id (ev)), __s2_len = strlen ("IDL:omg.org/CORBA/INV_OBJREF:1.0"), (!((size_t)(const void *)((CORBA_exception_id (ev)) + 1) - (size_t)(const void *)(CORBA_exception_id (ev)) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("IDL:omg.org/CORBA/INV_OBJREF:1.0") + 1) - (size_t)(const void *)("IDL:omg.org/CORBA/INV_OBJREF:1.0") == 1) || __s2_len >= 4)) ? __builtin_strcmp (CORBA_exception_id (ev), "IDL:omg.org/CORBA/INV_OBJREF:1.0") : (__builtin_constant_p (CORBA_exception_id (ev)) && ((size_t)(const void *)((CORBA_exception_id (ev)) + 1) - (size_t)(const void *)(CORBA_exception_id (ev)) == 1) && (__s1_len = strlen (CORBA_exception_id (ev)), __s1_len < 4) ? (__builtin_constant_p ("IDL:omg.org/CORBA/INV_OBJREF:1.0") && ((size_t)(const void *)(("IDL:omg.org/CORBA/INV_OBJREF:1.0") + 1) - (size_t)(const void *)("IDL:omg.org/CORBA/INV_OBJREF:1.0") == 1) ? __builtin_strcmp (CORBA_exception_id (ev), "IDL:omg.org/CORBA/INV_OBJREF:1.0") : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) ("IDL:omg.org/CORBA/INV_OBJREF:1.0"); register int __result = (((__const unsigned char *) (__const char *) (CORBA_exception_id (ev)))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (CORBA_exception_id (ev)))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (CORBA_exception_id (ev)))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (CORBA_exception_id (ev)))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("IDL:omg.org/CORBA/INV_OBJREF:1.0") && ((size_t)(const void *)(("IDL:omg.org/CORBA/INV_OBJREF:1.0") + 1) - (size_t)(const void *)("IDL:omg.org/CORBA/INV_OBJREF:1.0") == 1) && (__s2_len = strlen ("IDL:omg.org/CORBA/INV_OBJREF:1.0"), __s2_len < 4) ? (__builtin_constant_p (CORBA_exception_id (ev)) && ((size_t)(const void *)((CORBA_exception_id (ev)) + 1) - (size_t)(const void *)(CORBA_exception_id (ev)) == 1) ? __builtin_strcmp (CORBA_exception_id (ev), "IDL:omg.org/CORBA/INV_OBJREF:1.0") : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (CORBA_exception_id (ev)); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) ("IDL:omg.org/CORBA/INV_OBJREF:1.0"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) ("IDL:omg.org/CORBA/INV_OBJREF:1.0"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) ("IDL:omg.org/CORBA/INV_OBJREF:1.0"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) ("IDL:omg.org/CORBA/INV_OBJREF:1.0"))[3]); } } __result; }))) : __builtin_strcmp (CORBA_exception_id (ev), "IDL:omg.org/CORBA/INV_OBJREF:1.0")))); }) == 0) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 340, __PRETTY_FUNCTION__, "strcmp (CORBA_exception_id (ev), ex_CORBA_INV_OBJREF) == 0"); });
 CORBA_exception_free (ev);

 test_BasicServer_opException (objref, ev);

 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_USER_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 345, __PRETTY_FUNCTION__, "ev->_major == CORBA_USER_EXCEPTION"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (CORBA_exception_id (ev)) && __builtin_constant_p ("IDL:orbit/test/TestException:1.0") && (__s1_len = strlen (CORBA_exception_id (ev)), __s2_len = strlen ("IDL:orbit/test/TestException:1.0"), (!((size_t)(const void *)((CORBA_exception_id (ev)) + 1) - (size_t)(const void *)(CORBA_exception_id (ev)) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("IDL:orbit/test/TestException:1.0") + 1) - (size_t)(const void *)("IDL:orbit/test/TestException:1.0") == 1) || __s2_len >= 4)) ? __builtin_strcmp (CORBA_exception_id (ev), "IDL:orbit/test/TestException:1.0") : (__builtin_constant_p (CORBA_exception_id (ev)) && ((size_t)(const void *)((CORBA_exception_id (ev)) + 1) - (size_t)(const void *)(CORBA_exception_id (ev)) == 1) && (__s1_len = strlen (CORBA_exception_id (ev)), __s1_len < 4) ? (__builtin_constant_p ("IDL:orbit/test/TestException:1.0") && ((size_t)(const void *)(("IDL:orbit/test/TestException:1.0") + 1) - (size_t)(const void *)("IDL:orbit/test/TestException:1.0") == 1) ? __builtin_strcmp (CORBA_exception_id (ev), "IDL:orbit/test/TestException:1.0") : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) ("IDL:orbit/test/TestException:1.0"); register int __result = (((__const unsigned char *) (__const char *) (CORBA_exception_id (ev)))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (CORBA_exception_id (ev)))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (CORBA_exception_id (ev)))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (CORBA_exception_id (ev)))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("IDL:orbit/test/TestException:1.0") && ((size_t)(const void *)(("IDL:orbit/test/TestException:1.0") + 1) - (size_t)(const void *)("IDL:orbit/test/TestException:1.0") == 1) && (__s2_len = strlen ("IDL:orbit/test/TestException:1.0"), __s2_len < 4) ? (__builtin_constant_p (CORBA_exception_id (ev)) && ((size_t)(const void *)((CORBA_exception_id (ev)) + 1) - (size_t)(const void *)(CORBA_exception_id (ev)) == 1) ? __builtin_strcmp (CORBA_exception_id (ev), "IDL:orbit/test/TestException:1.0") : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (CORBA_exception_id (ev)); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) ("IDL:orbit/test/TestException:1.0"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) ("IDL:orbit/test/TestException:1.0"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) ("IDL:orbit/test/TestException:1.0"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) ("IDL:orbit/test/TestException:1.0"))[3]); } } __result; }))) : __builtin_strcmp (CORBA_exception_id (ev), "IDL:orbit/test/TestException:1.0")))); }) == 0) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 346, __PRETTY_FUNCTION__, "strcmp (CORBA_exception_id (ev), ex_test_TestException) == 0"); });
 ex = CORBA_exception_value (ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (ex->reason) && __builtin_constant_p (constants_STRING_IN) && (__s1_len = strlen (ex->reason), __s2_len = strlen (constants_STRING_IN), (!((size_t)(const void *)((ex->reason) + 1) - (size_t)(const void *)(ex->reason) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((constants_STRING_IN) + 1) - (size_t)(const void *)(constants_STRING_IN) == 1) || __s2_len >= 4)) ? __builtin_strcmp (ex->reason, constants_STRING_IN) : (__builtin_constant_p (ex->reason) && ((size_t)(const void *)((ex->reason) + 1) - (size_t)(const void *)(ex->reason) == 1) && (__s1_len = strlen (ex->reason), __s1_len < 4) ? (__builtin_constant_p (constants_STRING_IN) && ((size_t)(const void *)((constants_STRING_IN) + 1) - (size_t)(const void *)(constants_STRING_IN) == 1) ? __builtin_strcmp (ex->reason, constants_STRING_IN) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (constants_STRING_IN); register int __result = (((__const unsigned char *) (__const char *) (ex->reason))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (ex->reason))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (ex->reason))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (ex->reason))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (constants_STRING_IN) && ((size_t)(const void *)((constants_STRING_IN) + 1) - (size_t)(const void *)(constants_STRING_IN) == 1) && (__s2_len = strlen (constants_STRING_IN), __s2_len < 4) ? (__builtin_constant_p (ex->reason) && ((size_t)(const void *)((ex->reason) + 1) - (size_t)(const void *)(ex->reason) == 1) ? __builtin_strcmp (ex->reason, constants_STRING_IN) : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (ex->reason); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (constants_STRING_IN))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (constants_STRING_IN))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (constants_STRING_IN))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (constants_STRING_IN))[3]); } } __result; }))) : __builtin_strcmp (ex->reason, constants_STRING_IN)))); }) == 0) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 348, __PRETTY_FUNCTION__, "strcmp (ex->reason, constants_STRING_IN) == 0"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ex->number == 0x12345678) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 349, __PRETTY_FUNCTION__, "ex->number == constants_LONG_IN"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ex->aseq._length == 1) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 350, __PRETTY_FUNCTION__, "ex->aseq._length == 1"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ex->aseq._buffer[0] == 0x12345678) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 351, __PRETTY_FUNCTION__, "ex->aseq._buffer[0] == constants_LONG_IN"); });

 cpyev = CORBA_exception__copy (ev);
 CORBA_exception_free (ev);
 ev = cpyev;

 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_USER_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 357, __PRETTY_FUNCTION__, "ev->_major == CORBA_USER_EXCEPTION"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (CORBA_exception_id (ev)) && __builtin_constant_p ("IDL:orbit/test/TestException:1.0") && (__s1_len = strlen (CORBA_exception_id (ev)), __s2_len = strlen ("IDL:orbit/test/TestException:1.0"), (!((size_t)(const void *)((CORBA_exception_id (ev)) + 1) - (size_t)(const void *)(CORBA_exception_id (ev)) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("IDL:orbit/test/TestException:1.0") + 1) - (size_t)(const void *)("IDL:orbit/test/TestException:1.0") == 1) || __s2_len >= 4)) ? __builtin_strcmp (CORBA_exception_id (ev), "IDL:orbit/test/TestException:1.0") : (__builtin_constant_p (CORBA_exception_id (ev)) && ((size_t)(const void *)((CORBA_exception_id (ev)) + 1) - (size_t)(const void *)(CORBA_exception_id (ev)) == 1) && (__s1_len = strlen (CORBA_exception_id (ev)), __s1_len < 4) ? (__builtin_constant_p ("IDL:orbit/test/TestException:1.0") && ((size_t)(const void *)(("IDL:orbit/test/TestException:1.0") + 1) - (size_t)(const void *)("IDL:orbit/test/TestException:1.0") == 1) ? __builtin_strcmp (CORBA_exception_id (ev), "IDL:orbit/test/TestException:1.0") : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) ("IDL:orbit/test/TestException:1.0"); register int __result = (((__const unsigned char *) (__const char *) (CORBA_exception_id (ev)))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (CORBA_exception_id (ev)))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (CORBA_exception_id (ev)))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (CORBA_exception_id (ev)))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("IDL:orbit/test/TestException:1.0") && ((size_t)(const void *)(("IDL:orbit/test/TestException:1.0") + 1) - (size_t)(const void *)("IDL:orbit/test/TestException:1.0") == 1) && (__s2_len = strlen ("IDL:orbit/test/TestException:1.0"), __s2_len < 4) ? (__builtin_constant_p (CORBA_exception_id (ev)) && ((size_t)(const void *)((CORBA_exception_id (ev)) + 1) - (size_t)(const void *)(CORBA_exception_id (ev)) == 1) ? __builtin_strcmp (CORBA_exception_id (ev), "IDL:orbit/test/TestException:1.0") : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (CORBA_exception_id (ev)); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) ("IDL:orbit/test/TestException:1.0"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) ("IDL:orbit/test/TestException:1.0"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) ("IDL:orbit/test/TestException:1.0"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) ("IDL:orbit/test/TestException:1.0"))[3]); } } __result; }))) : __builtin_strcmp (CORBA_exception_id (ev), "IDL:orbit/test/TestException:1.0")))); }) == 0) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 358, __PRETTY_FUNCTION__, "strcmp (CORBA_exception_id (ev), ex_test_TestException) == 0"); });
# 368 "client.c"
 CORBA_free (cpyev);
}

static void
testBoolAlign (test_BasicServer objref,
        CORBA_Environment *ev)
{
 char *inoutArg;

 if (!thread_tests) g_print("Testing bool arg. alignment ...\n");

 inoutArg = CORBA_string_dup("foo");
 test_BasicServer_testBoolString (objref, (!(0)), "retout", &inoutArg, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 381, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
}

static CORBA_TypeCode
find_tc (CORBA_sequence_CORBA_TypeCode *tcs,
  const char *repo_id)
{
 int i;

 for (i = 0; i < tcs->_length; i++)
  if (!__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (tcs->_buffer [i]->repo_id) && __builtin_constant_p (repo_id) && (__s1_len = strlen (tcs->_buffer [i]->repo_id), __s2_len = strlen (repo_id), (!((size_t)(const void *)((tcs->_buffer [i]->repo_id) + 1) - (size_t)(const void *)(tcs->_buffer [i]->repo_id) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((repo_id) + 1) - (size_t)(const void *)(repo_id) == 1) || __s2_len >= 4)) ? __builtin_strcmp (tcs->_buffer [i]->repo_id, repo_id) : (__builtin_constant_p (tcs->_buffer [i]->repo_id) && ((size_t)(const void *)((tcs->_buffer [i]->repo_id) + 1) - (size_t)(const void *)(tcs->_buffer [i]->repo_id) == 1) && (__s1_len = strlen (tcs->_buffer [i]->repo_id), __s1_len < 4) ? (__builtin_constant_p (repo_id) && ((size_t)(const void *)((repo_id) + 1) - (size_t)(const void *)(repo_id) == 1) ? __builtin_strcmp (tcs->_buffer [i]->repo_id, repo_id) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (repo_id); register int __result = (((__const unsigned char *) (__const char *) (tcs->_buffer [i]->repo_id))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (tcs->_buffer [i]->repo_id))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (tcs->_buffer [i]->repo_id))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (tcs->_buffer [i]->repo_id))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (repo_id) && ((size_t)(const void *)((repo_id) + 1) - (size_t)(const void *)(repo_id) == 1) && (__s2_len = strlen (repo_id), __s2_len < 4) ? (__builtin_constant_p (tcs->_buffer [i]->repo_id) && ((size_t)(const void *)((tcs->_buffer [i]->repo_id) + 1) - (size_t)(const void *)(tcs->_buffer [i]->repo_id) == 1) ? __builtin_strcmp (tcs->_buffer [i]->repo_id, repo_id) : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (tcs->_buffer [i]->repo_id); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (repo_id))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (repo_id))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (repo_id))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (repo_id))[3]); } } __result; }))) : __builtin_strcmp (tcs->_buffer [i]->repo_id, repo_id)))); }))
   return tcs->_buffer [i];

 return ((void *)0);
}

static void
testIInterface (test_TestFactory factory,
  CORBA_Environment *ev)
{
 CORBA_TypeCode tc;
 test_StructServer objref;
 CORBA_char *type_id;
 ORBit_IInterface *iinterface;
 CORBA_sequence_CORBA_TypeCode *tcs;

 if (!thread_tests) g_print("Testing IInterface code...\n");
 objref = test_TestFactory_getStructServer (factory, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 409, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });


 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_Object_is_nil (((void *)0), ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 412, __PRETTY_FUNCTION__, "CORBA_Object_is_nil (CORBA_OBJECT_NIL, ev)"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 413, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (!CORBA_Object_is_nil (objref, ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 414, __PRETTY_FUNCTION__, "!CORBA_Object_is_nil (objref, ev)"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 415, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });


 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (!CORBA_Object_non_existent (objref, ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 418, __PRETTY_FUNCTION__, "!CORBA_Object_non_existent (objref, ev)"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 419, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });


 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_Object_is_a (objref, "IDL:orbit/test/StructServer:1.0", ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 422, __PRETTY_FUNCTION__, "CORBA_Object_is_a (objref, \"IDL:orbit/test/StructServer:1.0\", ev)"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 423, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_Object_is_a (objref, "IDL:orbit/test/BasicServer:1.0", ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 424, __PRETTY_FUNCTION__, "CORBA_Object_is_a (objref, \"IDL:orbit/test/BasicServer:1.0\", ev)"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 425, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });




 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if ((type_id = ORBit_small_get_type_id (objref, ev))) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 430, __PRETTY_FUNCTION__, "(type_id = ORBit_small_get_type_id (objref, ev))"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 431, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (!__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (type_id) && __builtin_constant_p ("IDL:orbit/test/StructServer:1.0") && (__s1_len = strlen (type_id), __s2_len = strlen ("IDL:orbit/test/StructServer:1.0"), (!((size_t)(const void *)((type_id) + 1) - (size_t)(const void *)(type_id) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("IDL:orbit/test/StructServer:1.0") + 1) - (size_t)(const void *)("IDL:orbit/test/StructServer:1.0") == 1) || __s2_len >= 4)) ? __builtin_strcmp (type_id, "IDL:orbit/test/StructServer:1.0") : (__builtin_constant_p (type_id) && ((size_t)(const void *)((type_id) + 1) - (size_t)(const void *)(type_id) == 1) && (__s1_len = strlen (type_id), __s1_len < 4) ? (__builtin_constant_p ("IDL:orbit/test/StructServer:1.0") && ((size_t)(const void *)(("IDL:orbit/test/StructServer:1.0") + 1) - (size_t)(const void *)("IDL:orbit/test/StructServer:1.0") == 1) ? __builtin_strcmp (type_id, "IDL:orbit/test/StructServer:1.0") : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) ("IDL:orbit/test/StructServer:1.0"); register int __result = (((__const unsigned char *) (__const char *) (type_id))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (type_id))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (type_id))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (type_id))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("IDL:orbit/test/StructServer:1.0") && ((size_t)(const void *)(("IDL:orbit/test/StructServer:1.0") + 1) - (size_t)(const void *)("IDL:orbit/test/StructServer:1.0") == 1) && (__s2_len = strlen ("IDL:orbit/test/StructServer:1.0"), __s2_len < 4) ? (__builtin_constant_p (type_id) && ((size_t)(const void *)((type_id) + 1) - (size_t)(const void *)(type_id) == 1) ? __builtin_strcmp (type_id, "IDL:orbit/test/StructServer:1.0") : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (type_id); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) ("IDL:orbit/test/StructServer:1.0"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) ("IDL:orbit/test/StructServer:1.0"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) ("IDL:orbit/test/StructServer:1.0"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) ("IDL:orbit/test/StructServer:1.0"))[3]); } } __result; }))) : __builtin_strcmp (type_id, "IDL:orbit/test/StructServer:1.0")))); })) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 432, __PRETTY_FUNCTION__, "!strcmp (type_id, \"IDL:orbit/test/StructServer:1.0\")"); });
 CORBA_free (type_id);


 iinterface = ORBit_small_get_iinterface (
  objref, "foo_bar_jelly", ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major != CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 438, __PRETTY_FUNCTION__, "ev->_major != CORBA_NO_EXCEPTION"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (iinterface == ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 439, __PRETTY_FUNCTION__, "iinterface == NULL"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (!__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (ev->_id) && __builtin_constant_p ("IDL:ORBit/NoIInterface:1.0") && (__s1_len = strlen (ev->_id), __s2_len = strlen ("IDL:ORBit/NoIInterface:1.0"), (!((size_t)(const void *)((ev->_id) + 1) - (size_t)(const void *)(ev->_id) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("IDL:ORBit/NoIInterface:1.0") + 1) - (size_t)(const void *)("IDL:ORBit/NoIInterface:1.0") == 1) || __s2_len >= 4)) ? __builtin_strcmp (ev->_id, "IDL:ORBit/NoIInterface:1.0") : (__builtin_constant_p (ev->_id) && ((size_t)(const void *)((ev->_id) + 1) - (size_t)(const void *)(ev->_id) == 1) && (__s1_len = strlen (ev->_id), __s1_len < 4) ? (__builtin_constant_p ("IDL:ORBit/NoIInterface:1.0") && ((size_t)(const void *)(("IDL:ORBit/NoIInterface:1.0") + 1) - (size_t)(const void *)("IDL:ORBit/NoIInterface:1.0") == 1) ? __builtin_strcmp (ev->_id, "IDL:ORBit/NoIInterface:1.0") : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) ("IDL:ORBit/NoIInterface:1.0"); register int __result = (((__const unsigned char *) (__const char *) (ev->_id))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (ev->_id))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (ev->_id))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (ev->_id))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("IDL:ORBit/NoIInterface:1.0") && ((size_t)(const void *)(("IDL:ORBit/NoIInterface:1.0") + 1) - (size_t)(const void *)("IDL:ORBit/NoIInterface:1.0") == 1) && (__s2_len = strlen ("IDL:ORBit/NoIInterface:1.0"), __s2_len < 4) ? (__builtin_constant_p (ev->_id) && ((size_t)(const void *)((ev->_id) + 1) - (size_t)(const void *)(ev->_id) == 1) ? __builtin_strcmp (ev->_id, "IDL:ORBit/NoIInterface:1.0") : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (ev->_id); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) ("IDL:ORBit/NoIInterface:1.0"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) ("IDL:ORBit/NoIInterface:1.0"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) ("IDL:ORBit/NoIInterface:1.0"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) ("IDL:ORBit/NoIInterface:1.0"))[3]); } } __result; }))) : __builtin_strcmp (ev->_id, "IDL:ORBit/NoIInterface:1.0")))); })) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 440, __PRETTY_FUNCTION__, "!strcmp (ev->_id, ex_ORBit_NoIInterface)"); });
 CORBA_exception_free (ev);

 iinterface = ORBit_small_get_iinterface (
  objref, "IDL:orbit/test/StructServer:1.0", ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 445, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (iinterface != ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 446, __PRETTY_FUNCTION__, "iinterface != NULL"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (!__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (iinterface->tc->repo_id) && __builtin_constant_p ("IDL:orbit/test/StructServer:1.0") && (__s1_len = strlen (iinterface->tc->repo_id), __s2_len = strlen ("IDL:orbit/test/StructServer:1.0"), (!((size_t)(const void *)((iinterface->tc->repo_id) + 1) - (size_t)(const void *)(iinterface->tc->repo_id) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("IDL:orbit/test/StructServer:1.0") + 1) - (size_t)(const void *)("IDL:orbit/test/StructServer:1.0") == 1) || __s2_len >= 4)) ? __builtin_strcmp (iinterface->tc->repo_id, "IDL:orbit/test/StructServer:1.0") : (__builtin_constant_p (iinterface->tc->repo_id) && ((size_t)(const void *)((iinterface->tc->repo_id) + 1) - (size_t)(const void *)(iinterface->tc->repo_id) == 1) && (__s1_len = strlen (iinterface->tc->repo_id), __s1_len < 4) ? (__builtin_constant_p ("IDL:orbit/test/StructServer:1.0") && ((size_t)(const void *)(("IDL:orbit/test/StructServer:1.0") + 1) - (size_t)(const void *)("IDL:orbit/test/StructServer:1.0") == 1) ? __builtin_strcmp (iinterface->tc->repo_id, "IDL:orbit/test/StructServer:1.0") : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) ("IDL:orbit/test/StructServer:1.0"); register int __result = (((__const unsigned char *) (__const char *) (iinterface->tc->repo_id))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (iinterface->tc->repo_id))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (iinterface->tc->repo_id))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (iinterface->tc->repo_id))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("IDL:orbit/test/StructServer:1.0") && ((size_t)(const void *)(("IDL:orbit/test/StructServer:1.0") + 1) - (size_t)(const void *)("IDL:orbit/test/StructServer:1.0") == 1) && (__s2_len = strlen ("IDL:orbit/test/StructServer:1.0"), __s2_len < 4) ? (__builtin_constant_p (iinterface->tc->repo_id) && ((size_t)(const void *)((iinterface->tc->repo_id) + 1) - (size_t)(const void *)(iinterface->tc->repo_id) == 1) ? __builtin_strcmp (iinterface->tc->repo_id, "IDL:orbit/test/StructServer:1.0") : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (iinterface->tc->repo_id); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) ("IDL:orbit/test/StructServer:1.0"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) ("IDL:orbit/test/StructServer:1.0"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) ("IDL:orbit/test/StructServer:1.0"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) ("IDL:orbit/test/StructServer:1.0"))[3]); } } __result; }))) : __builtin_strcmp (iinterface->tc->repo_id, "IDL:orbit/test/StructServer:1.0")))); })) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 447, __PRETTY_FUNCTION__, "!strcmp (iinterface->tc->repo_id, \"IDL:orbit/test/StructServer:1.0\")"); });
 CORBA_free (iinterface);

 CORBA_Object_release (objref, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 451, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });



 if (!ORBit_small_load_typelib ("./Everything_module"))
  g_log (((gchar*) 0), G_LOG_LEVEL_WARNING, "Failed to load '" "./Everything_module" "'");
 iinterface = ORBit_small_get_iinterface (
  objref, "IDL:orbit/test/StructServer:1.0", ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 459, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (iinterface != ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 460, __PRETTY_FUNCTION__, "iinterface != NULL"); });
 CORBA_free (iinterface);

 tcs = ORBit_small_get_types ("./Everything_module");
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (find_tc (tcs, "IDL:orbit/test/Soup:1.0")) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 464, __PRETTY_FUNCTION__, "find_tc (tcs, \"IDL:orbit/test/Soup:1.0\")"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (find_tc (tcs, "IDL:orbit/test/EnumUnion/Colour:1.0")) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 465, __PRETTY_FUNCTION__, "find_tc (tcs, \"IDL:orbit/test/EnumUnion/Colour:1.0\")"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (find_tc (tcs, "IDL:orbit/test/ArrayUnion:1.0")) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 466, __PRETTY_FUNCTION__, "find_tc (tcs, \"IDL:orbit/test/ArrayUnion:1.0\")"); });

 tc = find_tc (tcs, "IDL:orbit/test/StrSeq:1.0");
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (!__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (tc->repo_id) && __builtin_constant_p ("IDL:orbit/test/StrSeq:1.0") && (__s1_len = strlen (tc->repo_id), __s2_len = strlen ("IDL:orbit/test/StrSeq:1.0"), (!((size_t)(const void *)((tc->repo_id) + 1) - (size_t)(const void *)(tc->repo_id) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("IDL:orbit/test/StrSeq:1.0") + 1) - (size_t)(const void *)("IDL:orbit/test/StrSeq:1.0") == 1) || __s2_len >= 4)) ? __builtin_strcmp (tc->repo_id, "IDL:orbit/test/StrSeq:1.0") : (__builtin_constant_p (tc->repo_id) && ((size_t)(const void *)((tc->repo_id) + 1) - (size_t)(const void *)(tc->repo_id) == 1) && (__s1_len = strlen (tc->repo_id), __s1_len < 4) ? (__builtin_constant_p ("IDL:orbit/test/StrSeq:1.0") && ((size_t)(const void *)(("IDL:orbit/test/StrSeq:1.0") + 1) - (size_t)(const void *)("IDL:orbit/test/StrSeq:1.0") == 1) ? __builtin_strcmp (tc->repo_id, "IDL:orbit/test/StrSeq:1.0") : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) ("IDL:orbit/test/StrSeq:1.0"); register int __result = (((__const unsigned char *) (__const char *) (tc->repo_id))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (tc->repo_id))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (tc->repo_id))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (tc->repo_id))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("IDL:orbit/test/StrSeq:1.0") && ((size_t)(const void *)(("IDL:orbit/test/StrSeq:1.0") + 1) - (size_t)(const void *)("IDL:orbit/test/StrSeq:1.0") == 1) && (__s2_len = strlen ("IDL:orbit/test/StrSeq:1.0"), __s2_len < 4) ? (__builtin_constant_p (tc->repo_id) && ((size_t)(const void *)((tc->repo_id) + 1) - (size_t)(const void *)(tc->repo_id) == 1) ? __builtin_strcmp (tc->repo_id, "IDL:orbit/test/StrSeq:1.0") : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (tc->repo_id); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) ("IDL:orbit/test/StrSeq:1.0"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) ("IDL:orbit/test/StrSeq:1.0"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) ("IDL:orbit/test/StrSeq:1.0"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) ("IDL:orbit/test/StrSeq:1.0"))[3]); } } __result; }))) : __builtin_strcmp (tc->repo_id, "IDL:orbit/test/StrSeq:1.0")))); })) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 469, __PRETTY_FUNCTION__, "!strcmp (tc->repo_id, \"IDL:orbit/test/StrSeq:1.0\")"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (tc->kind == CORBA_tk_alias) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 470, __PRETTY_FUNCTION__, "tc->kind == CORBA_tk_alias"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (tc->subtypes[0]->kind) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 471, __PRETTY_FUNCTION__, "tc->subtypes[0]->kind"); });

 CORBA_free (tcs);



 tc = ((CORBA_TypeCode)&TC_test_FixedLengthUnion_struct);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (tc->sub_parts == 5) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 478, __PRETTY_FUNCTION__, "tc->sub_parts == 5"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (!__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (tc->subnames[0]) && __builtin_constant_p ("x") && (__s1_len = strlen (tc->subnames[0]), __s2_len = strlen ("x"), (!((size_t)(const void *)((tc->subnames[0]) + 1) - (size_t)(const void *)(tc->subnames[0]) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("x") + 1) - (size_t)(const void *)("x") == 1) || __s2_len >= 4)) ? __builtin_strcmp (tc->subnames[0], "x") : (__builtin_constant_p (tc->subnames[0]) && ((size_t)(const void *)((tc->subnames[0]) + 1) - (size_t)(const void *)(tc->subnames[0]) == 1) && (__s1_len = strlen (tc->subnames[0]), __s1_len < 4) ? (__builtin_constant_p ("x") && ((size_t)(const void *)(("x") + 1) - (size_t)(const void *)("x") == 1) ? __builtin_strcmp (tc->subnames[0], "x") : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) ("x"); register int __result = (((__const unsigned char *) (__const char *) (tc->subnames[0]))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (tc->subnames[0]))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (tc->subnames[0]))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (tc->subnames[0]))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("x") && ((size_t)(const void *)(("x") + 1) - (size_t)(const void *)("x") == 1) && (__s2_len = strlen ("x"), __s2_len < 4) ? (__builtin_constant_p (tc->subnames[0]) && ((size_t)(const void *)((tc->subnames[0]) + 1) - (size_t)(const void *)(tc->subnames[0]) == 1) ? __builtin_strcmp (tc->subnames[0], "x") : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (tc->subnames[0]); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) ("x"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) ("x"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) ("x"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) ("x"))[3]); } } __result; }))) : __builtin_strcmp (tc->subnames[0], "x")))); })) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 479, __PRETTY_FUNCTION__, "!strcmp(tc->subnames[0], \"x\")"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (!__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (tc->subnames[1]) && __builtin_constant_p ("y") && (__s1_len = strlen (tc->subnames[1]), __s2_len = strlen ("y"), (!((size_t)(const void *)((tc->subnames[1]) + 1) - (size_t)(const void *)(tc->subnames[1]) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("y") + 1) - (size_t)(const void *)("y") == 1) || __s2_len >= 4)) ? __builtin_strcmp (tc->subnames[1], "y") : (__builtin_constant_p (tc->subnames[1]) && ((size_t)(const void *)((tc->subnames[1]) + 1) - (size_t)(const void *)(tc->subnames[1]) == 1) && (__s1_len = strlen (tc->subnames[1]), __s1_len < 4) ? (__builtin_constant_p ("y") && ((size_t)(const void *)(("y") + 1) - (size_t)(const void *)("y") == 1) ? __builtin_strcmp (tc->subnames[1], "y") : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) ("y"); register int __result = (((__const unsigned char *) (__const char *) (tc->subnames[1]))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (tc->subnames[1]))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (tc->subnames[1]))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (tc->subnames[1]))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("y") && ((size_t)(const void *)(("y") + 1) - (size_t)(const void *)("y") == 1) && (__s2_len = strlen ("y"), __s2_len < 4) ? (__builtin_constant_p (tc->subnames[1]) && ((size_t)(const void *)((tc->subnames[1]) + 1) - (size_t)(const void *)(tc->subnames[1]) == 1) ? __builtin_strcmp (tc->subnames[1], "y") : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (tc->subnames[1]); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) ("y"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) ("y"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) ("y"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) ("y"))[3]); } } __result; }))) : __builtin_strcmp (tc->subnames[1], "y")))); })) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 480, __PRETTY_FUNCTION__, "!strcmp(tc->subnames[1], \"y\")"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (!__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (tc->subnames[2]) && __builtin_constant_p ("z") && (__s1_len = strlen (tc->subnames[2]), __s2_len = strlen ("z"), (!((size_t)(const void *)((tc->subnames[2]) + 1) - (size_t)(const void *)(tc->subnames[2]) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("z") + 1) - (size_t)(const void *)("z") == 1) || __s2_len >= 4)) ? __builtin_strcmp (tc->subnames[2], "z") : (__builtin_constant_p (tc->subnames[2]) && ((size_t)(const void *)((tc->subnames[2]) + 1) - (size_t)(const void *)(tc->subnames[2]) == 1) && (__s1_len = strlen (tc->subnames[2]), __s1_len < 4) ? (__builtin_constant_p ("z") && ((size_t)(const void *)(("z") + 1) - (size_t)(const void *)("z") == 1) ? __builtin_strcmp (tc->subnames[2], "z") : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) ("z"); register int __result = (((__const unsigned char *) (__const char *) (tc->subnames[2]))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (tc->subnames[2]))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (tc->subnames[2]))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (tc->subnames[2]))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("z") && ((size_t)(const void *)(("z") + 1) - (size_t)(const void *)("z") == 1) && (__s2_len = strlen ("z"), __s2_len < 4) ? (__builtin_constant_p (tc->subnames[2]) && ((size_t)(const void *)((tc->subnames[2]) + 1) - (size_t)(const void *)(tc->subnames[2]) == 1) ? __builtin_strcmp (tc->subnames[2], "z") : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (tc->subnames[2]); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) ("z"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) ("z"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) ("z"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) ("z"))[3]); } } __result; }))) : __builtin_strcmp (tc->subnames[2], "z")))); })) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 481, __PRETTY_FUNCTION__, "!strcmp(tc->subnames[2], \"z\")"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (!__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (tc->subnames[3]) && __builtin_constant_p ("z") && (__s1_len = strlen (tc->subnames[3]), __s2_len = strlen ("z"), (!((size_t)(const void *)((tc->subnames[3]) + 1) - (size_t)(const void *)(tc->subnames[3]) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("z") + 1) - (size_t)(const void *)("z") == 1) || __s2_len >= 4)) ? __builtin_strcmp (tc->subnames[3], "z") : (__builtin_constant_p (tc->subnames[3]) && ((size_t)(const void *)((tc->subnames[3]) + 1) - (size_t)(const void *)(tc->subnames[3]) == 1) && (__s1_len = strlen (tc->subnames[3]), __s1_len < 4) ? (__builtin_constant_p ("z") && ((size_t)(const void *)(("z") + 1) - (size_t)(const void *)("z") == 1) ? __builtin_strcmp (tc->subnames[3], "z") : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) ("z"); register int __result = (((__const unsigned char *) (__const char *) (tc->subnames[3]))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (tc->subnames[3]))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (tc->subnames[3]))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (tc->subnames[3]))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("z") && ((size_t)(const void *)(("z") + 1) - (size_t)(const void *)("z") == 1) && (__s2_len = strlen ("z"), __s2_len < 4) ? (__builtin_constant_p (tc->subnames[3]) && ((size_t)(const void *)((tc->subnames[3]) + 1) - (size_t)(const void *)(tc->subnames[3]) == 1) ? __builtin_strcmp (tc->subnames[3], "z") : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (tc->subnames[3]); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) ("z"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) ("z"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) ("z"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) ("z"))[3]); } } __result; }))) : __builtin_strcmp (tc->subnames[3], "z")))); })) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 482, __PRETTY_FUNCTION__, "!strcmp(tc->subnames[3], \"z\")"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (!__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (tc->subnames[4]) && __builtin_constant_p ("v") && (__s1_len = strlen (tc->subnames[4]), __s2_len = strlen ("v"), (!((size_t)(const void *)((tc->subnames[4]) + 1) - (size_t)(const void *)(tc->subnames[4]) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("v") + 1) - (size_t)(const void *)("v") == 1) || __s2_len >= 4)) ? __builtin_strcmp (tc->subnames[4], "v") : (__builtin_constant_p (tc->subnames[4]) && ((size_t)(const void *)((tc->subnames[4]) + 1) - (size_t)(const void *)(tc->subnames[4]) == 1) && (__s1_len = strlen (tc->subnames[4]), __s1_len < 4) ? (__builtin_constant_p ("v") && ((size_t)(const void *)(("v") + 1) - (size_t)(const void *)("v") == 1) ? __builtin_strcmp (tc->subnames[4], "v") : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) ("v"); register int __result = (((__const unsigned char *) (__const char *) (tc->subnames[4]))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (tc->subnames[4]))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (tc->subnames[4]))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (tc->subnames[4]))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("v") && ((size_t)(const void *)(("v") + 1) - (size_t)(const void *)("v") == 1) && (__s2_len = strlen ("v"), __s2_len < 4) ? (__builtin_constant_p (tc->subnames[4]) && ((size_t)(const void *)((tc->subnames[4]) + 1) - (size_t)(const void *)(tc->subnames[4]) == 1) ? __builtin_strcmp (tc->subnames[4], "v") : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (tc->subnames[4]); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) ("v"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) ("v"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) ("v"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) ("v"))[3]); } } __result; }))) : __builtin_strcmp (tc->subnames[4], "v")))); })) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 483, __PRETTY_FUNCTION__, "!strcmp(tc->subnames[4], \"v\")"); });
}

static void
testIsA (test_TestFactory factory,
  CORBA_Environment *ev)
{
 test_DerivedServer ds;

 if (!thread_tests) g_print("Testing is_a ...\n");

 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_Object_is_a (factory, "IDL:CORBA/Object:1.0", ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 494, __PRETTY_FUNCTION__, "CORBA_Object_is_a (factory, \"IDL:CORBA/Object:1.0\", ev)"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 495, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_Object_is_a (factory, "IDL:omg.org/CORBA/Object:1.0", ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 496, __PRETTY_FUNCTION__, "CORBA_Object_is_a (factory, \"IDL:omg.org/CORBA/Object:1.0\", ev)"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 497, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 ds = test_TestFactory_getDerivedServer (factory, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 500, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_Object_is_a (ds, "IDL:orbit/test/DerivedServer:1.0", ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 502, __PRETTY_FUNCTION__, "CORBA_Object_is_a (ds, \"IDL:orbit/test/DerivedServer:1.0\", ev)"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 503, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_Object_is_a (ds, "IDL:orbit/test/C1:1.0", ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 504, __PRETTY_FUNCTION__, "CORBA_Object_is_a (ds, \"IDL:orbit/test/C1:1.0\", ev)"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 505, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_Object_is_a (ds, "IDL:orbit/test/B1:1.0", ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 506, __PRETTY_FUNCTION__, "CORBA_Object_is_a (ds, \"IDL:orbit/test/B1:1.0\", ev)"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 507, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_Object_is_a (ds, "IDL:orbit/test/B2:1.0", ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 508, __PRETTY_FUNCTION__, "CORBA_Object_is_a (ds, \"IDL:orbit/test/B2:1.0\", ev)"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 509, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_Object_is_a (ds, "IDL:orbit/test/BaseServer:1.0", ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 510, __PRETTY_FUNCTION__, "CORBA_Object_is_a (ds, \"IDL:orbit/test/BaseServer:1.0\", ev)"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 511, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_Object_is_a (factory, "IDL:CORBA/Object:1.0", ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 512, __PRETTY_FUNCTION__, "CORBA_Object_is_a (factory, \"IDL:CORBA/Object:1.0\", ev)"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 513, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 CORBA_Object_release (ds, ev);
}

static void
testFixedLengthStruct (test_TestFactory factory,
         CORBA_Environment *ev)
{
 test_StructServer objref;
 test_FixedLengthStruct inArg, inoutArg, outArg, retn;
 CORBA_char *ior;

 if (!thread_tests) g_print("Testing struct code ...\n");
 ior = test_TestFactory_getStructServerIOR (factory, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 528, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 objref = CORBA_ORB_string_to_object (global_orb, ior, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 531, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (objref != ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 532, __PRETTY_FUNCTION__, "objref != CORBA_OBJECT_NIL"); });
 CORBA_free (ior);


 inArg.a = constants_SHORT_IN;
 inoutArg.a = constants_SHORT_INOUT_IN;

 retn = test_StructServer_opFixed (objref, &inArg, &inoutArg, &outArg, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 540, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inArg.a == constants_SHORT_IN) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 542, __PRETTY_FUNCTION__, "inArg.a == constants_SHORT_IN"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inoutArg.a == constants_SHORT_INOUT_OUT) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 543, __PRETTY_FUNCTION__, "inoutArg.a == constants_SHORT_INOUT_OUT"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (outArg.a == constants_SHORT_OUT) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 544, __PRETTY_FUNCTION__, "outArg.a == constants_SHORT_OUT"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (retn.a == constants_SHORT_RETN) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 545, __PRETTY_FUNCTION__, "retn.a == constants_SHORT_RETN"); });
 CORBA_Object_release (objref, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 547, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
}

static void
testVariableLengthStruct (test_TestFactory factory,
     CORBA_Environment *ev)
{
  test_StructServer objref;
  test_VariableLengthStruct inArg, inoutArg, *outArg, *retn;
  if (!thread_tests) g_print("Testing variable length structs...\n");
  objref = test_TestFactory_getStructServer (factory, ev);
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 558, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

  inArg.a = (CORBA_char*)constants_STRING_IN;
  inoutArg.a = CORBA_string_dup (constants_STRING_INOUT_IN);

  retn = test_StructServer_opVariable (objref, &inArg, &inoutArg, &outArg, ev);
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 564, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (inArg.a) && __builtin_constant_p (constants_STRING_IN) && (__s1_len = strlen (inArg.a), __s2_len = strlen (constants_STRING_IN), (!((size_t)(const void *)((inArg.a) + 1) - (size_t)(const void *)(inArg.a) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((constants_STRING_IN) + 1) - (size_t)(const void *)(constants_STRING_IN) == 1) || __s2_len >= 4)) ? __builtin_strcmp (inArg.a, constants_STRING_IN) : (__builtin_constant_p (inArg.a) && ((size_t)(const void *)((inArg.a) + 1) - (size_t)(const void *)(inArg.a) == 1) && (__s1_len = strlen (inArg.a), __s1_len < 4) ? (__builtin_constant_p (constants_STRING_IN) && ((size_t)(const void *)((constants_STRING_IN) + 1) - (size_t)(const void *)(constants_STRING_IN) == 1) ? __builtin_strcmp (inArg.a, constants_STRING_IN) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (constants_STRING_IN); register int __result = (((__const unsigned char *) (__const char *) (inArg.a))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (inArg.a))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (inArg.a))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (inArg.a))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (constants_STRING_IN) && ((size_t)(const void *)((constants_STRING_IN) + 1) - (size_t)(const void *)(constants_STRING_IN) == 1) && (__s2_len = strlen (constants_STRING_IN), __s2_len < 4) ? (__builtin_constant_p (inArg.a) && ((size_t)(const void *)((inArg.a) + 1) - (size_t)(const void *)(inArg.a) == 1) ? __builtin_strcmp (inArg.a, constants_STRING_IN) : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (inArg.a); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (constants_STRING_IN))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (constants_STRING_IN))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (constants_STRING_IN))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (constants_STRING_IN))[3]); } } __result; }))) : __builtin_strcmp (inArg.a, constants_STRING_IN)))); })==0) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 566, __PRETTY_FUNCTION__, "strcmp (inArg.a, constants_STRING_IN)==0"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (inoutArg.a) && __builtin_constant_p (constants_STRING_INOUT_OUT) && (__s1_len = strlen (inoutArg.a), __s2_len = strlen (constants_STRING_INOUT_OUT), (!((size_t)(const void *)((inoutArg.a) + 1) - (size_t)(const void *)(inoutArg.a) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((constants_STRING_INOUT_OUT) + 1) - (size_t)(const void *)(constants_STRING_INOUT_OUT) == 1) || __s2_len >= 4)) ? __builtin_strcmp (inoutArg.a, constants_STRING_INOUT_OUT) : (__builtin_constant_p (inoutArg.a) && ((size_t)(const void *)((inoutArg.a) + 1) - (size_t)(const void *)(inoutArg.a) == 1) && (__s1_len = strlen (inoutArg.a), __s1_len < 4) ? (__builtin_constant_p (constants_STRING_INOUT_OUT) && ((size_t)(const void *)((constants_STRING_INOUT_OUT) + 1) - (size_t)(const void *)(constants_STRING_INOUT_OUT) == 1) ? __builtin_strcmp (inoutArg.a, constants_STRING_INOUT_OUT) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (constants_STRING_INOUT_OUT); register int __result = (((__const unsigned char *) (__const char *) (inoutArg.a))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (inoutArg.a))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (inoutArg.a))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (inoutArg.a))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (constants_STRING_INOUT_OUT) && ((size_t)(const void *)((constants_STRING_INOUT_OUT) + 1) - (size_t)(const void *)(constants_STRING_INOUT_OUT) == 1) && (__s2_len = strlen (constants_STRING_INOUT_OUT), __s2_len < 4) ? (__builtin_constant_p (inoutArg.a) && ((size_t)(const void *)((inoutArg.a) + 1) - (size_t)(const void *)(inoutArg.a) == 1) ? __builtin_strcmp (inoutArg.a, constants_STRING_INOUT_OUT) : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (inoutArg.a); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (constants_STRING_INOUT_OUT))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (constants_STRING_INOUT_OUT))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (constants_STRING_INOUT_OUT))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (constants_STRING_INOUT_OUT))[3]); } } __result; }))) : __builtin_strcmp (inoutArg.a, constants_STRING_INOUT_OUT)))); })==0) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 567, __PRETTY_FUNCTION__, "strcmp (inoutArg.a, constants_STRING_INOUT_OUT)==0"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (outArg->a) && __builtin_constant_p (constants_STRING_OUT) && (__s1_len = strlen (outArg->a), __s2_len = strlen (constants_STRING_OUT), (!((size_t)(const void *)((outArg->a) + 1) - (size_t)(const void *)(outArg->a) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((constants_STRING_OUT) + 1) - (size_t)(const void *)(constants_STRING_OUT) == 1) || __s2_len >= 4)) ? __builtin_strcmp (outArg->a, constants_STRING_OUT) : (__builtin_constant_p (outArg->a) && ((size_t)(const void *)((outArg->a) + 1) - (size_t)(const void *)(outArg->a) == 1) && (__s1_len = strlen (outArg->a), __s1_len < 4) ? (__builtin_constant_p (constants_STRING_OUT) && ((size_t)(const void *)((constants_STRING_OUT) + 1) - (size_t)(const void *)(constants_STRING_OUT) == 1) ? __builtin_strcmp (outArg->a, constants_STRING_OUT) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (constants_STRING_OUT); register int __result = (((__const unsigned char *) (__const char *) (outArg->a))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (outArg->a))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (outArg->a))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (outArg->a))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (constants_STRING_OUT) && ((size_t)(const void *)((constants_STRING_OUT) + 1) - (size_t)(const void *)(constants_STRING_OUT) == 1) && (__s2_len = strlen (constants_STRING_OUT), __s2_len < 4) ? (__builtin_constant_p (outArg->a) && ((size_t)(const void *)((outArg->a) + 1) - (size_t)(const void *)(outArg->a) == 1) ? __builtin_strcmp (outArg->a, constants_STRING_OUT) : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (outArg->a); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (constants_STRING_OUT))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (constants_STRING_OUT))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (constants_STRING_OUT))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (constants_STRING_OUT))[3]); } } __result; }))) : __builtin_strcmp (outArg->a, constants_STRING_OUT)))); })==0) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 568, __PRETTY_FUNCTION__, "strcmp (outArg->a, constants_STRING_OUT)==0"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (retn->a) && __builtin_constant_p (constants_STRING_RETN) && (__s1_len = strlen (retn->a), __s2_len = strlen (constants_STRING_RETN), (!((size_t)(const void *)((retn->a) + 1) - (size_t)(const void *)(retn->a) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((constants_STRING_RETN) + 1) - (size_t)(const void *)(constants_STRING_RETN) == 1) || __s2_len >= 4)) ? __builtin_strcmp (retn->a, constants_STRING_RETN) : (__builtin_constant_p (retn->a) && ((size_t)(const void *)((retn->a) + 1) - (size_t)(const void *)(retn->a) == 1) && (__s1_len = strlen (retn->a), __s1_len < 4) ? (__builtin_constant_p (constants_STRING_RETN) && ((size_t)(const void *)((constants_STRING_RETN) + 1) - (size_t)(const void *)(constants_STRING_RETN) == 1) ? __builtin_strcmp (retn->a, constants_STRING_RETN) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (constants_STRING_RETN); register int __result = (((__const unsigned char *) (__const char *) (retn->a))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (retn->a))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (retn->a))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (retn->a))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (constants_STRING_RETN) && ((size_t)(const void *)((constants_STRING_RETN) + 1) - (size_t)(const void *)(constants_STRING_RETN) == 1) && (__s2_len = strlen (constants_STRING_RETN), __s2_len < 4) ? (__builtin_constant_p (retn->a) && ((size_t)(const void *)((retn->a) + 1) - (size_t)(const void *)(retn->a) == 1) ? __builtin_strcmp (retn->a, constants_STRING_RETN) : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (retn->a); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (constants_STRING_RETN))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (constants_STRING_RETN))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (constants_STRING_RETN))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (constants_STRING_RETN))[3]); } } __result; }))) : __builtin_strcmp (retn->a, constants_STRING_RETN)))); })==0) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 569, __PRETTY_FUNCTION__, "strcmp (retn->a, constants_STRING_RETN)==0"); });

  CORBA_free (inoutArg.a);
  CORBA_free (outArg);
  CORBA_free (retn);
  CORBA_Object_release (objref, ev);
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 575, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
}


static void
testCompoundStruct (test_TestFactory factory,
      CORBA_Environment *ev)
{
  test_StructServer objref;
  test_CompoundStruct inArg, inoutArg, *outArg, *retn;
  if (!thread_tests) g_print("Testing compound structs...\n");
  objref = test_TestFactory_getStructServer (factory, ev);
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 587, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

  inArg.a.a = CORBA_string_dup (constants_STRING_IN);
  inoutArg.a.a = CORBA_string_dup (constants_STRING_INOUT_IN);

  retn = test_StructServer_opCompound (objref, &inArg, &inoutArg, &outArg, ev);
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 593, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (inArg.a.a) && __builtin_constant_p (constants_STRING_IN) && (__s1_len = strlen (inArg.a.a), __s2_len = strlen (constants_STRING_IN), (!((size_t)(const void *)((inArg.a.a) + 1) - (size_t)(const void *)(inArg.a.a) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((constants_STRING_IN) + 1) - (size_t)(const void *)(constants_STRING_IN) == 1) || __s2_len >= 4)) ? __builtin_strcmp (inArg.a.a, constants_STRING_IN) : (__builtin_constant_p (inArg.a.a) && ((size_t)(const void *)((inArg.a.a) + 1) - (size_t)(const void *)(inArg.a.a) == 1) && (__s1_len = strlen (inArg.a.a), __s1_len < 4) ? (__builtin_constant_p (constants_STRING_IN) && ((size_t)(const void *)((constants_STRING_IN) + 1) - (size_t)(const void *)(constants_STRING_IN) == 1) ? __builtin_strcmp (inArg.a.a, constants_STRING_IN) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (constants_STRING_IN); register int __result = (((__const unsigned char *) (__const char *) (inArg.a.a))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (inArg.a.a))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (inArg.a.a))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (inArg.a.a))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (constants_STRING_IN) && ((size_t)(const void *)((constants_STRING_IN) + 1) - (size_t)(const void *)(constants_STRING_IN) == 1) && (__s2_len = strlen (constants_STRING_IN), __s2_len < 4) ? (__builtin_constant_p (inArg.a.a) && ((size_t)(const void *)((inArg.a.a) + 1) - (size_t)(const void *)(inArg.a.a) == 1) ? __builtin_strcmp (inArg.a.a, constants_STRING_IN) : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (inArg.a.a); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (constants_STRING_IN))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (constants_STRING_IN))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (constants_STRING_IN))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (constants_STRING_IN))[3]); } } __result; }))) : __builtin_strcmp (inArg.a.a, constants_STRING_IN)))); })==0) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 595, __PRETTY_FUNCTION__, "strcmp (inArg.a.a, constants_STRING_IN)==0"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (inoutArg.a.a) && __builtin_constant_p (constants_STRING_INOUT_OUT) && (__s1_len = strlen (inoutArg.a.a), __s2_len = strlen (constants_STRING_INOUT_OUT), (!((size_t)(const void *)((inoutArg.a.a) + 1) - (size_t)(const void *)(inoutArg.a.a) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((constants_STRING_INOUT_OUT) + 1) - (size_t)(const void *)(constants_STRING_INOUT_OUT) == 1) || __s2_len >= 4)) ? __builtin_strcmp (inoutArg.a.a, constants_STRING_INOUT_OUT) : (__builtin_constant_p (inoutArg.a.a) && ((size_t)(const void *)((inoutArg.a.a) + 1) - (size_t)(const void *)(inoutArg.a.a) == 1) && (__s1_len = strlen (inoutArg.a.a), __s1_len < 4) ? (__builtin_constant_p (constants_STRING_INOUT_OUT) && ((size_t)(const void *)((constants_STRING_INOUT_OUT) + 1) - (size_t)(const void *)(constants_STRING_INOUT_OUT) == 1) ? __builtin_strcmp (inoutArg.a.a, constants_STRING_INOUT_OUT) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (constants_STRING_INOUT_OUT); register int __result = (((__const unsigned char *) (__const char *) (inoutArg.a.a))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (inoutArg.a.a))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (inoutArg.a.a))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (inoutArg.a.a))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (constants_STRING_INOUT_OUT) && ((size_t)(const void *)((constants_STRING_INOUT_OUT) + 1) - (size_t)(const void *)(constants_STRING_INOUT_OUT) == 1) && (__s2_len = strlen (constants_STRING_INOUT_OUT), __s2_len < 4) ? (__builtin_constant_p (inoutArg.a.a) && ((size_t)(const void *)((inoutArg.a.a) + 1) - (size_t)(const void *)(inoutArg.a.a) == 1) ? __builtin_strcmp (inoutArg.a.a, constants_STRING_INOUT_OUT) : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (inoutArg.a.a); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (constants_STRING_INOUT_OUT))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (constants_STRING_INOUT_OUT))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (constants_STRING_INOUT_OUT))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (constants_STRING_INOUT_OUT))[3]); } } __result; }))) : __builtin_strcmp (inoutArg.a.a, constants_STRING_INOUT_OUT)))); })==0) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 596, __PRETTY_FUNCTION__, "strcmp (inoutArg.a.a, constants_STRING_INOUT_OUT)==0"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (outArg->a.a) && __builtin_constant_p (constants_STRING_OUT) && (__s1_len = strlen (outArg->a.a), __s2_len = strlen (constants_STRING_OUT), (!((size_t)(const void *)((outArg->a.a) + 1) - (size_t)(const void *)(outArg->a.a) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((constants_STRING_OUT) + 1) - (size_t)(const void *)(constants_STRING_OUT) == 1) || __s2_len >= 4)) ? __builtin_strcmp (outArg->a.a, constants_STRING_OUT) : (__builtin_constant_p (outArg->a.a) && ((size_t)(const void *)((outArg->a.a) + 1) - (size_t)(const void *)(outArg->a.a) == 1) && (__s1_len = strlen (outArg->a.a), __s1_len < 4) ? (__builtin_constant_p (constants_STRING_OUT) && ((size_t)(const void *)((constants_STRING_OUT) + 1) - (size_t)(const void *)(constants_STRING_OUT) == 1) ? __builtin_strcmp (outArg->a.a, constants_STRING_OUT) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (constants_STRING_OUT); register int __result = (((__const unsigned char *) (__const char *) (outArg->a.a))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (outArg->a.a))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (outArg->a.a))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (outArg->a.a))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (constants_STRING_OUT) && ((size_t)(const void *)((constants_STRING_OUT) + 1) - (size_t)(const void *)(constants_STRING_OUT) == 1) && (__s2_len = strlen (constants_STRING_OUT), __s2_len < 4) ? (__builtin_constant_p (outArg->a.a) && ((size_t)(const void *)((outArg->a.a) + 1) - (size_t)(const void *)(outArg->a.a) == 1) ? __builtin_strcmp (outArg->a.a, constants_STRING_OUT) : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (outArg->a.a); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (constants_STRING_OUT))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (constants_STRING_OUT))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (constants_STRING_OUT))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (constants_STRING_OUT))[3]); } } __result; }))) : __builtin_strcmp (outArg->a.a, constants_STRING_OUT)))); })==0) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 597, __PRETTY_FUNCTION__, "strcmp (outArg->a.a, constants_STRING_OUT)==0"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (retn->a.a) && __builtin_constant_p (constants_STRING_RETN) && (__s1_len = strlen (retn->a.a), __s2_len = strlen (constants_STRING_RETN), (!((size_t)(const void *)((retn->a.a) + 1) - (size_t)(const void *)(retn->a.a) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((constants_STRING_RETN) + 1) - (size_t)(const void *)(constants_STRING_RETN) == 1) || __s2_len >= 4)) ? __builtin_strcmp (retn->a.a, constants_STRING_RETN) : (__builtin_constant_p (retn->a.a) && ((size_t)(const void *)((retn->a.a) + 1) - (size_t)(const void *)(retn->a.a) == 1) && (__s1_len = strlen (retn->a.a), __s1_len < 4) ? (__builtin_constant_p (constants_STRING_RETN) && ((size_t)(const void *)((constants_STRING_RETN) + 1) - (size_t)(const void *)(constants_STRING_RETN) == 1) ? __builtin_strcmp (retn->a.a, constants_STRING_RETN) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (constants_STRING_RETN); register int __result = (((__const unsigned char *) (__const char *) (retn->a.a))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (retn->a.a))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (retn->a.a))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (retn->a.a))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (constants_STRING_RETN) && ((size_t)(const void *)((constants_STRING_RETN) + 1) - (size_t)(const void *)(constants_STRING_RETN) == 1) && (__s2_len = strlen (constants_STRING_RETN), __s2_len < 4) ? (__builtin_constant_p (retn->a.a) && ((size_t)(const void *)((retn->a.a) + 1) - (size_t)(const void *)(retn->a.a) == 1) ? __builtin_strcmp (retn->a.a, constants_STRING_RETN) : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (retn->a.a); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (constants_STRING_RETN))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (constants_STRING_RETN))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (constants_STRING_RETN))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (constants_STRING_RETN))[3]); } } __result; }))) : __builtin_strcmp (retn->a.a, constants_STRING_RETN)))); })==0) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 598, __PRETTY_FUNCTION__, "strcmp (retn->a.a, constants_STRING_RETN)==0"); });

  CORBA_free (inArg.a.a);
  CORBA_free (inoutArg.a.a);
  CORBA_free (outArg);
  CORBA_free (retn);
  CORBA_Object_release (objref, ev);
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 605, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
}

static void
testAlignHoleStruct (test_TestFactory factory,
      CORBA_Environment *ev)
{
  test_StructServer objref;
  test_AlignHoleStruct inArg, inoutArg, outArg, retn;
  if (!thread_tests) g_print("Testing structs with aligning holes...\n");
  objref = test_TestFactory_getStructServer (factory, ev);
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 616, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

  inArg.a.a = ((CORBA_double) 127.13534);
  inArg.a.b = constants_OCTET_IN;
  inArg.b = constants_CHAR_IN;

  inoutArg.a.a = ((CORBA_double) 124.89432);
  inoutArg.a.b = constants_OCTET_INOUT_IN;
  inoutArg.b = constants_CHAR_INOUT_IN;

  memset(&outArg, 0, sizeof(outArg));

  retn = test_StructServer_opAlignHole (objref, &inArg, &inoutArg, &outArg, ev);
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 629, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inArg.a.a == ((CORBA_double) 127.13534)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 631, __PRETTY_FUNCTION__, "inArg.a.a == constants_DOUBLE_IN"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inArg.a.b == constants_OCTET_IN) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 632, __PRETTY_FUNCTION__, "inArg.a.b == constants_OCTET_IN"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inArg.b == constants_CHAR_IN) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 633, __PRETTY_FUNCTION__, "inArg.b == constants_CHAR_IN"); });

  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inoutArg.a.a == ((CORBA_double) 975.12694)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 635, __PRETTY_FUNCTION__, "inoutArg.a.a == constants_DOUBLE_INOUT_OUT"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inoutArg.a.b == constants_OCTET_INOUT_OUT) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 636, __PRETTY_FUNCTION__, "inoutArg.a.b == constants_OCTET_INOUT_OUT"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inoutArg.b == constants_CHAR_INOUT_OUT) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 637, __PRETTY_FUNCTION__, "inoutArg.b == constants_CHAR_INOUT_OUT"); });

  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (outArg.a.a == ((CORBA_double) 112.54575)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 639, __PRETTY_FUNCTION__, "outArg.a.a == constants_DOUBLE_OUT"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (outArg.a.b == constants_OCTET_OUT) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 640, __PRETTY_FUNCTION__, "outArg.a.b == constants_OCTET_OUT"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (outArg.b == constants_CHAR_OUT) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 641, __PRETTY_FUNCTION__, "outArg.b == constants_CHAR_OUT"); });

  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (retn.a.a == ((CORBA_double) 354.23535)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 643, __PRETTY_FUNCTION__, "retn.a.a == constants_DOUBLE_RETN"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (retn.a.b == constants_OCTET_RETN) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 644, __PRETTY_FUNCTION__, "retn.a.b == constants_OCTET_RETN"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (retn.b == constants_CHAR_RETN) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 645, __PRETTY_FUNCTION__, "retn.b == constants_CHAR_RETN"); });

  CORBA_Object_release (objref, ev);
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 648, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
}

static void
testObjectStruct (test_TestFactory factory,
    CORBA_Environment *ev)
{
  test_StructServer objref;
  test_ObjectStruct inArg;

  if (!thread_tests) g_print("Testing object structs...\n");
  objref = test_TestFactory_getStructServer (factory, ev);
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 660, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

  inArg.serv = objref;

  test_StructServer_opObjectStruct (objref, &inArg, ev);
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 665, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

  CORBA_Object_release (objref, ev);
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 668, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

}

static void
testStructAny (test_TestFactory factory,
        CORBA_Environment *ev)
{
 test_StructServer objref;
 test_StructAny *a;

 if (!thread_tests) g_print("Testing 'any' structs...\n");
 objref = test_TestFactory_getStructServer (factory, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 681, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 a = test_StructServer_opStructAny (objref, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 684, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (!__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (a->a) && __builtin_constant_p (constants_STRING_IN) && (__s1_len = strlen (a->a), __s2_len = strlen (constants_STRING_IN), (!((size_t)(const void *)((a->a) + 1) - (size_t)(const void *)(a->a) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((constants_STRING_IN) + 1) - (size_t)(const void *)(constants_STRING_IN) == 1) || __s2_len >= 4)) ? __builtin_strcmp (a->a, constants_STRING_IN) : (__builtin_constant_p (a->a) && ((size_t)(const void *)((a->a) + 1) - (size_t)(const void *)(a->a) == 1) && (__s1_len = strlen (a->a), __s1_len < 4) ? (__builtin_constant_p (constants_STRING_IN) && ((size_t)(const void *)((constants_STRING_IN) + 1) - (size_t)(const void *)(constants_STRING_IN) == 1) ? __builtin_strcmp (a->a, constants_STRING_IN) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (constants_STRING_IN); register int __result = (((__const unsigned char *) (__const char *) (a->a))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (a->a))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (a->a))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (a->a))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (constants_STRING_IN) && ((size_t)(const void *)((constants_STRING_IN) + 1) - (size_t)(const void *)(constants_STRING_IN) == 1) && (__s2_len = strlen (constants_STRING_IN), __s2_len < 4) ? (__builtin_constant_p (a->a) && ((size_t)(const void *)((a->a) + 1) - (size_t)(const void *)(a->a) == 1) ? __builtin_strcmp (a->a, constants_STRING_IN) : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (a->a); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (constants_STRING_IN))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (constants_STRING_IN))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (constants_STRING_IN))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (constants_STRING_IN))[3]); } } __result; }))) : __builtin_strcmp (a->a, constants_STRING_IN)))); })) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 686, __PRETTY_FUNCTION__, "!strcmp (a->a, constants_STRING_IN)"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (* (CORBA_long *)a->b._value == 0x12345678) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 687, __PRETTY_FUNCTION__, "* (CORBA_long *)a->b._value == constants_LONG_IN"); });

 CORBA_free (a);

 CORBA_Object_release (objref, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 692, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
}

static void
testUnboundedSequence (test_TestFactory factory,
         CORBA_Environment *ev)
{
  test_SequenceServer objref;
  test_StrSeq *outArg = ((void *)0), inArg, inoutArg, *retn;

  guint i;
  if (!thread_tests) g_print("Testing unbounded sequences...\n");
  objref = test_TestFactory_getSequenceServer (factory, ev);
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 705, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

  inArg._buffer = ((CORBA_string*)ORBit_small_allocbuf (((CORBA_TypeCode)&TC_CORBA_sequence_CORBA_string_struct), (2)));
  inArg._length = 2;
  (&inArg)->_release = CORBA_TRUE;

  for (i=0;i<inArg._length;i++){
 inArg._buffer[i] = CORBA_string_dup (constants_SEQ_STRING_IN[i]);
  }

  inoutArg._buffer = ((CORBA_string*)ORBit_small_allocbuf (((CORBA_TypeCode)&TC_CORBA_sequence_CORBA_string_struct), (2)));
  inoutArg._length = 2;
  (&inoutArg)->_release = CORBA_TRUE;

  for (i=0;i<inoutArg._length;i++){
 inoutArg._buffer[i] = CORBA_string_dup (constants_SEQ_STRING_INOUT_IN[i]);
  }

  retn = test_SequenceServer_opStrSeq (objref, &inArg, &inoutArg, &outArg, ev);
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 724, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

  for (i=0;i<inArg._length;i++)
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (inArg._buffer[i]) && __builtin_constant_p (constants_SEQ_STRING_IN[i]) && (__s1_len = strlen (inArg._buffer[i]), __s2_len = strlen (constants_SEQ_STRING_IN[i]), (!((size_t)(const void *)((inArg._buffer[i]) + 1) - (size_t)(const void *)(inArg._buffer[i]) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((constants_SEQ_STRING_IN[i]) + 1) - (size_t)(const void *)(constants_SEQ_STRING_IN[i]) == 1) || __s2_len >= 4)) ? __builtin_strcmp (inArg._buffer[i], constants_SEQ_STRING_IN[i]) : (__builtin_constant_p (inArg._buffer[i]) && ((size_t)(const void *)((inArg._buffer[i]) + 1) - (size_t)(const void *)(inArg._buffer[i]) == 1) && (__s1_len = strlen (inArg._buffer[i]), __s1_len < 4) ? (__builtin_constant_p (constants_SEQ_STRING_IN[i]) && ((size_t)(const void *)((constants_SEQ_STRING_IN[i]) + 1) - (size_t)(const void *)(constants_SEQ_STRING_IN[i]) == 1) ? __builtin_strcmp (inArg._buffer[i], constants_SEQ_STRING_IN[i]) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (constants_SEQ_STRING_IN[i]); register int __result = (((__const unsigned char *) (__const char *) (inArg._buffer[i]))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (inArg._buffer[i]))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (inArg._buffer[i]))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (inArg._buffer[i]))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (constants_SEQ_STRING_IN[i]) && ((size_t)(const void *)((constants_SEQ_STRING_IN[i]) + 1) - (size_t)(const void *)(constants_SEQ_STRING_IN[i]) == 1) && (__s2_len = strlen (constants_SEQ_STRING_IN[i]), __s2_len < 4) ? (__builtin_constant_p (inArg._buffer[i]) && ((size_t)(const void *)((inArg._buffer[i]) + 1) - (size_t)(const void *)(inArg._buffer[i]) == 1) ? __builtin_strcmp (inArg._buffer[i], constants_SEQ_STRING_IN[i]) : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (inArg._buffer[i]); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (constants_SEQ_STRING_IN[i]))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (constants_SEQ_STRING_IN[i]))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (constants_SEQ_STRING_IN[i]))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (constants_SEQ_STRING_IN[i]))[3]); } } __result; }))) : __builtin_strcmp (inArg._buffer[i], constants_SEQ_STRING_IN[i])))); }) == 0) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 727, __PRETTY_FUNCTION__, "strcmp (inArg._buffer[i], constants_SEQ_STRING_IN[i]) == 0"); });

  for (i=0;i<inoutArg._length;i++)
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (inoutArg._buffer[i]) && __builtin_constant_p (constants_SEQ_STRING_INOUT_OUT[i]) && (__s1_len = strlen (inoutArg._buffer[i]), __s2_len = strlen (constants_SEQ_STRING_INOUT_OUT[i]), (!((size_t)(const void *)((inoutArg._buffer[i]) + 1) - (size_t)(const void *)(inoutArg._buffer[i]) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((constants_SEQ_STRING_INOUT_OUT[i]) + 1) - (size_t)(const void *)(constants_SEQ_STRING_INOUT_OUT[i]) == 1) || __s2_len >= 4)) ? __builtin_strcmp (inoutArg._buffer[i], constants_SEQ_STRING_INOUT_OUT[i]) : (__builtin_constant_p (inoutArg._buffer[i]) && ((size_t)(const void *)((inoutArg._buffer[i]) + 1) - (size_t)(const void *)(inoutArg._buffer[i]) == 1) && (__s1_len = strlen (inoutArg._buffer[i]), __s1_len < 4) ? (__builtin_constant_p (constants_SEQ_STRING_INOUT_OUT[i]) && ((size_t)(const void *)((constants_SEQ_STRING_INOUT_OUT[i]) + 1) - (size_t)(const void *)(constants_SEQ_STRING_INOUT_OUT[i]) == 1) ? __builtin_strcmp (inoutArg._buffer[i], constants_SEQ_STRING_INOUT_OUT[i]) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (constants_SEQ_STRING_INOUT_OUT[i]); register int __result = (((__const unsigned char *) (__const char *) (inoutArg._buffer[i]))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (inoutArg._buffer[i]))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (inoutArg._buffer[i]))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (inoutArg._buffer[i]))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (constants_SEQ_STRING_INOUT_OUT[i]) && ((size_t)(const void *)((constants_SEQ_STRING_INOUT_OUT[i]) + 1) - (size_t)(const void *)(constants_SEQ_STRING_INOUT_OUT[i]) == 1) && (__s2_len = strlen (constants_SEQ_STRING_INOUT_OUT[i]), __s2_len < 4) ? (__builtin_constant_p (inoutArg._buffer[i]) && ((size_t)(const void *)((inoutArg._buffer[i]) + 1) - (size_t)(const void *)(inoutArg._buffer[i]) == 1) ? __builtin_strcmp (inoutArg._buffer[i], constants_SEQ_STRING_INOUT_OUT[i]) : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (inoutArg._buffer[i]); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (constants_SEQ_STRING_INOUT_OUT[i]))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (constants_SEQ_STRING_INOUT_OUT[i]))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (constants_SEQ_STRING_INOUT_OUT[i]))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (constants_SEQ_STRING_INOUT_OUT[i]))[3]); } } __result; }))) : __builtin_strcmp (inoutArg._buffer[i], constants_SEQ_STRING_INOUT_OUT[i])))); }) == 0) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 730, __PRETTY_FUNCTION__, "strcmp (inoutArg._buffer[i], constants_SEQ_STRING_INOUT_OUT[i]) == 0"); });

  for (i=0;i<outArg->_length;i++)
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (outArg->_buffer[i]) && __builtin_constant_p (constants_SEQ_STRING_OUT[i]) && (__s1_len = strlen (outArg->_buffer[i]), __s2_len = strlen (constants_SEQ_STRING_OUT[i]), (!((size_t)(const void *)((outArg->_buffer[i]) + 1) - (size_t)(const void *)(outArg->_buffer[i]) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((constants_SEQ_STRING_OUT[i]) + 1) - (size_t)(const void *)(constants_SEQ_STRING_OUT[i]) == 1) || __s2_len >= 4)) ? __builtin_strcmp (outArg->_buffer[i], constants_SEQ_STRING_OUT[i]) : (__builtin_constant_p (outArg->_buffer[i]) && ((size_t)(const void *)((outArg->_buffer[i]) + 1) - (size_t)(const void *)(outArg->_buffer[i]) == 1) && (__s1_len = strlen (outArg->_buffer[i]), __s1_len < 4) ? (__builtin_constant_p (constants_SEQ_STRING_OUT[i]) && ((size_t)(const void *)((constants_SEQ_STRING_OUT[i]) + 1) - (size_t)(const void *)(constants_SEQ_STRING_OUT[i]) == 1) ? __builtin_strcmp (outArg->_buffer[i], constants_SEQ_STRING_OUT[i]) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (constants_SEQ_STRING_OUT[i]); register int __result = (((__const unsigned char *) (__const char *) (outArg->_buffer[i]))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (outArg->_buffer[i]))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (outArg->_buffer[i]))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (outArg->_buffer[i]))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (constants_SEQ_STRING_OUT[i]) && ((size_t)(const void *)((constants_SEQ_STRING_OUT[i]) + 1) - (size_t)(const void *)(constants_SEQ_STRING_OUT[i]) == 1) && (__s2_len = strlen (constants_SEQ_STRING_OUT[i]), __s2_len < 4) ? (__builtin_constant_p (outArg->_buffer[i]) && ((size_t)(const void *)((outArg->_buffer[i]) + 1) - (size_t)(const void *)(outArg->_buffer[i]) == 1) ? __builtin_strcmp (outArg->_buffer[i], constants_SEQ_STRING_OUT[i]) : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (outArg->_buffer[i]); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (constants_SEQ_STRING_OUT[i]))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (constants_SEQ_STRING_OUT[i]))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (constants_SEQ_STRING_OUT[i]))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (constants_SEQ_STRING_OUT[i]))[3]); } } __result; }))) : __builtin_strcmp (outArg->_buffer[i], constants_SEQ_STRING_OUT[i])))); }) == 0) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 733, __PRETTY_FUNCTION__, "strcmp (outArg->_buffer[i], constants_SEQ_STRING_OUT[i]) == 0"); });

  for (i=0;i<retn->_length;i++)
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (retn->_buffer[i]) && __builtin_constant_p (constants_SEQ_STRING_RETN[i]) && (__s1_len = strlen (retn->_buffer[i]), __s2_len = strlen (constants_SEQ_STRING_RETN[i]), (!((size_t)(const void *)((retn->_buffer[i]) + 1) - (size_t)(const void *)(retn->_buffer[i]) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((constants_SEQ_STRING_RETN[i]) + 1) - (size_t)(const void *)(constants_SEQ_STRING_RETN[i]) == 1) || __s2_len >= 4)) ? __builtin_strcmp (retn->_buffer[i], constants_SEQ_STRING_RETN[i]) : (__builtin_constant_p (retn->_buffer[i]) && ((size_t)(const void *)((retn->_buffer[i]) + 1) - (size_t)(const void *)(retn->_buffer[i]) == 1) && (__s1_len = strlen (retn->_buffer[i]), __s1_len < 4) ? (__builtin_constant_p (constants_SEQ_STRING_RETN[i]) && ((size_t)(const void *)((constants_SEQ_STRING_RETN[i]) + 1) - (size_t)(const void *)(constants_SEQ_STRING_RETN[i]) == 1) ? __builtin_strcmp (retn->_buffer[i], constants_SEQ_STRING_RETN[i]) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (constants_SEQ_STRING_RETN[i]); register int __result = (((__const unsigned char *) (__const char *) (retn->_buffer[i]))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (retn->_buffer[i]))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (retn->_buffer[i]))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (retn->_buffer[i]))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (constants_SEQ_STRING_RETN[i]) && ((size_t)(const void *)((constants_SEQ_STRING_RETN[i]) + 1) - (size_t)(const void *)(constants_SEQ_STRING_RETN[i]) == 1) && (__s2_len = strlen (constants_SEQ_STRING_RETN[i]), __s2_len < 4) ? (__builtin_constant_p (retn->_buffer[i]) && ((size_t)(const void *)((retn->_buffer[i]) + 1) - (size_t)(const void *)(retn->_buffer[i]) == 1) ? __builtin_strcmp (retn->_buffer[i], constants_SEQ_STRING_RETN[i]) : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (retn->_buffer[i]); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (constants_SEQ_STRING_RETN[i]))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (constants_SEQ_STRING_RETN[i]))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (constants_SEQ_STRING_RETN[i]))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (constants_SEQ_STRING_RETN[i]))[3]); } } __result; }))) : __builtin_strcmp (retn->_buffer[i], constants_SEQ_STRING_RETN[i])))); }) == 0) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 736, __PRETTY_FUNCTION__, "strcmp (retn->_buffer[i], constants_SEQ_STRING_RETN[i]) == 0"); });

  g_log (((gchar*) 0), G_LOG_LEVEL_WARNING, "FIXME: opMassiveSeq fails - due to max. size check");




  CORBA_free (inArg._buffer);
  CORBA_free (inoutArg._buffer);
  CORBA_free (outArg);
  CORBA_free (retn);

  CORBA_Object_release (objref, ev);
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 749, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
}

static void
testAnySequence (test_TestFactory factory,
                 CORBA_Environment *ev)
{
    test_AnySeq *any_retn, *copy;
    test_SequenceServer objref;

    if (!thread_tests) g_print("Testing sequence<any>...\n");
    objref = test_TestFactory_getSequenceServer (factory, ev);
    (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 761, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

    any_retn = test_SequenceServer_opAnySeq (objref, ev);
    (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 764, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
    copy = ORBit_copy_value (any_retn, ((CORBA_TypeCode)&TC_test_AnySeq_struct));
    CORBA_free (any_retn);

    CORBA_Object_release (objref, ev);
    (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 769, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
}

static void
testBoundedSequence (test_TestFactory factory,
       CORBA_Environment *ev)
{
  test_SequenceServer objref;
  test_BoundedStructSeq inArg, inoutArg, *outArg, *retn;
  guint i;
  if (!thread_tests) g_print("Testing bounded sequences...\n");
  objref = test_TestFactory_getSequenceServer (factory, ev);
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 781, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });


  inArg._buffer = ((test_CompoundStruct*)ORBit_small_allocbuf (((CORBA_TypeCode)&TC_CORBA_sequence_test_CompoundStruct_struct), (2)));
  inArg._length = 2;
  inArg._maximum = 2;
  (&inoutArg)->_release = CORBA_TRUE;

  for (i=0;i<inArg._length;i++){
 inArg._buffer[i].a.a = CORBA_string_dup (constants_SEQ_STRING_IN[i]);
  }

  inoutArg._buffer = ((test_CompoundStruct*)ORBit_small_allocbuf (((CORBA_TypeCode)&TC_CORBA_sequence_test_CompoundStruct_struct), (2)));
  inoutArg._length = 2;
  inoutArg._maximum = 2;
  (&inoutArg)->_release = CORBA_TRUE;

  for (i=0;i<inoutArg._length;i++){
 inoutArg._buffer[i].a.a = CORBA_string_dup (constants_SEQ_STRING_INOUT_IN[i]);
  }

  retn = test_SequenceServer_opBoundedStructSeq (objref, &inArg, &inoutArg, &outArg, ev);
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 803, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });


  for (i=0;i<inArg._length;i++){
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (inArg._buffer[i].a.a) && __builtin_constant_p (constants_SEQ_STRING_IN[i]) && (__s1_len = strlen (inArg._buffer[i].a.a), __s2_len = strlen (constants_SEQ_STRING_IN[i]), (!((size_t)(const void *)((inArg._buffer[i].a.a) + 1) - (size_t)(const void *)(inArg._buffer[i].a.a) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((constants_SEQ_STRING_IN[i]) + 1) - (size_t)(const void *)(constants_SEQ_STRING_IN[i]) == 1) || __s2_len >= 4)) ? __builtin_strcmp (inArg._buffer[i].a.a, constants_SEQ_STRING_IN[i]) : (__builtin_constant_p (inArg._buffer[i].a.a) && ((size_t)(const void *)((inArg._buffer[i].a.a) + 1) - (size_t)(const void *)(inArg._buffer[i].a.a) == 1) && (__s1_len = strlen (inArg._buffer[i].a.a), __s1_len < 4) ? (__builtin_constant_p (constants_SEQ_STRING_IN[i]) && ((size_t)(const void *)((constants_SEQ_STRING_IN[i]) + 1) - (size_t)(const void *)(constants_SEQ_STRING_IN[i]) == 1) ? __builtin_strcmp (inArg._buffer[i].a.a, constants_SEQ_STRING_IN[i]) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (constants_SEQ_STRING_IN[i]); register int __result = (((__const unsigned char *) (__const char *) (inArg._buffer[i].a.a))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (inArg._buffer[i].a.a))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (inArg._buffer[i].a.a))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (inArg._buffer[i].a.a))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (constants_SEQ_STRING_IN[i]) && ((size_t)(const void *)((constants_SEQ_STRING_IN[i]) + 1) - (size_t)(const void *)(constants_SEQ_STRING_IN[i]) == 1) && (__s2_len = strlen (constants_SEQ_STRING_IN[i]), __s2_len < 4) ? (__builtin_constant_p (inArg._buffer[i].a.a) && ((size_t)(const void *)((inArg._buffer[i].a.a) + 1) - (size_t)(const void *)(inArg._buffer[i].a.a) == 1) ? __builtin_strcmp (inArg._buffer[i].a.a, constants_SEQ_STRING_IN[i]) : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (inArg._buffer[i].a.a); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (constants_SEQ_STRING_IN[i]))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (constants_SEQ_STRING_IN[i]))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (constants_SEQ_STRING_IN[i]))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (constants_SEQ_STRING_IN[i]))[3]); } } __result; }))) : __builtin_strcmp (inArg._buffer[i].a.a, constants_SEQ_STRING_IN[i])))); }) == 0) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 807, __PRETTY_FUNCTION__, "strcmp (inArg._buffer[i].a.a, constants_SEQ_STRING_IN[i]) == 0"); });
  }

  for (i=0;i<inoutArg._length;i++){
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (inoutArg._buffer[i].a.a) && __builtin_constant_p (constants_SEQ_STRING_INOUT_OUT[i]) && (__s1_len = strlen (inoutArg._buffer[i].a.a), __s2_len = strlen (constants_SEQ_STRING_INOUT_OUT[i]), (!((size_t)(const void *)((inoutArg._buffer[i].a.a) + 1) - (size_t)(const void *)(inoutArg._buffer[i].a.a) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((constants_SEQ_STRING_INOUT_OUT[i]) + 1) - (size_t)(const void *)(constants_SEQ_STRING_INOUT_OUT[i]) == 1) || __s2_len >= 4)) ? __builtin_strcmp (inoutArg._buffer[i].a.a, constants_SEQ_STRING_INOUT_OUT[i]) : (__builtin_constant_p (inoutArg._buffer[i].a.a) && ((size_t)(const void *)((inoutArg._buffer[i].a.a) + 1) - (size_t)(const void *)(inoutArg._buffer[i].a.a) == 1) && (__s1_len = strlen (inoutArg._buffer[i].a.a), __s1_len < 4) ? (__builtin_constant_p (constants_SEQ_STRING_INOUT_OUT[i]) && ((size_t)(const void *)((constants_SEQ_STRING_INOUT_OUT[i]) + 1) - (size_t)(const void *)(constants_SEQ_STRING_INOUT_OUT[i]) == 1) ? __builtin_strcmp (inoutArg._buffer[i].a.a, constants_SEQ_STRING_INOUT_OUT[i]) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (constants_SEQ_STRING_INOUT_OUT[i]); register int __result = (((__const unsigned char *) (__const char *) (inoutArg._buffer[i].a.a))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (inoutArg._buffer[i].a.a))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (inoutArg._buffer[i].a.a))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (inoutArg._buffer[i].a.a))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (constants_SEQ_STRING_INOUT_OUT[i]) && ((size_t)(const void *)((constants_SEQ_STRING_INOUT_OUT[i]) + 1) - (size_t)(const void *)(constants_SEQ_STRING_INOUT_OUT[i]) == 1) && (__s2_len = strlen (constants_SEQ_STRING_INOUT_OUT[i]), __s2_len < 4) ? (__builtin_constant_p (inoutArg._buffer[i].a.a) && ((size_t)(const void *)((inoutArg._buffer[i].a.a) + 1) - (size_t)(const void *)(inoutArg._buffer[i].a.a) == 1) ? __builtin_strcmp (inoutArg._buffer[i].a.a, constants_SEQ_STRING_INOUT_OUT[i]) : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (inoutArg._buffer[i].a.a); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (constants_SEQ_STRING_INOUT_OUT[i]))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (constants_SEQ_STRING_INOUT_OUT[i]))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (constants_SEQ_STRING_INOUT_OUT[i]))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (constants_SEQ_STRING_INOUT_OUT[i]))[3]); } } __result; }))) : __builtin_strcmp (inoutArg._buffer[i].a.a, constants_SEQ_STRING_INOUT_OUT[i])))); }) == 0) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 811, __PRETTY_FUNCTION__, "strcmp (inoutArg._buffer[i].a.a, constants_SEQ_STRING_INOUT_OUT[i]) == 0"); });
  }

  for (i=0;i<outArg->_length;i++){
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (outArg->_buffer[i].a.a) && __builtin_constant_p (constants_SEQ_STRING_OUT[i]) && (__s1_len = strlen (outArg->_buffer[i].a.a), __s2_len = strlen (constants_SEQ_STRING_OUT[i]), (!((size_t)(const void *)((outArg->_buffer[i].a.a) + 1) - (size_t)(const void *)(outArg->_buffer[i].a.a) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((constants_SEQ_STRING_OUT[i]) + 1) - (size_t)(const void *)(constants_SEQ_STRING_OUT[i]) == 1) || __s2_len >= 4)) ? __builtin_strcmp (outArg->_buffer[i].a.a, constants_SEQ_STRING_OUT[i]) : (__builtin_constant_p (outArg->_buffer[i].a.a) && ((size_t)(const void *)((outArg->_buffer[i].a.a) + 1) - (size_t)(const void *)(outArg->_buffer[i].a.a) == 1) && (__s1_len = strlen (outArg->_buffer[i].a.a), __s1_len < 4) ? (__builtin_constant_p (constants_SEQ_STRING_OUT[i]) && ((size_t)(const void *)((constants_SEQ_STRING_OUT[i]) + 1) - (size_t)(const void *)(constants_SEQ_STRING_OUT[i]) == 1) ? __builtin_strcmp (outArg->_buffer[i].a.a, constants_SEQ_STRING_OUT[i]) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (constants_SEQ_STRING_OUT[i]); register int __result = (((__const unsigned char *) (__const char *) (outArg->_buffer[i].a.a))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (outArg->_buffer[i].a.a))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (outArg->_buffer[i].a.a))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (outArg->_buffer[i].a.a))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (constants_SEQ_STRING_OUT[i]) && ((size_t)(const void *)((constants_SEQ_STRING_OUT[i]) + 1) - (size_t)(const void *)(constants_SEQ_STRING_OUT[i]) == 1) && (__s2_len = strlen (constants_SEQ_STRING_OUT[i]), __s2_len < 4) ? (__builtin_constant_p (outArg->_buffer[i].a.a) && ((size_t)(const void *)((outArg->_buffer[i].a.a) + 1) - (size_t)(const void *)(outArg->_buffer[i].a.a) == 1) ? __builtin_strcmp (outArg->_buffer[i].a.a, constants_SEQ_STRING_OUT[i]) : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (outArg->_buffer[i].a.a); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (constants_SEQ_STRING_OUT[i]))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (constants_SEQ_STRING_OUT[i]))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (constants_SEQ_STRING_OUT[i]))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (constants_SEQ_STRING_OUT[i]))[3]); } } __result; }))) : __builtin_strcmp (outArg->_buffer[i].a.a, constants_SEQ_STRING_OUT[i])))); }) == 0) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 815, __PRETTY_FUNCTION__, "strcmp (outArg->_buffer[i].a.a, constants_SEQ_STRING_OUT[i]) == 0"); });
  }

  for (i=0;i<retn->_length;i++){
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (retn->_buffer[i].a.a) && __builtin_constant_p (constants_SEQ_STRING_RETN[i]) && (__s1_len = strlen (retn->_buffer[i].a.a), __s2_len = strlen (constants_SEQ_STRING_RETN[i]), (!((size_t)(const void *)((retn->_buffer[i].a.a) + 1) - (size_t)(const void *)(retn->_buffer[i].a.a) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((constants_SEQ_STRING_RETN[i]) + 1) - (size_t)(const void *)(constants_SEQ_STRING_RETN[i]) == 1) || __s2_len >= 4)) ? __builtin_strcmp (retn->_buffer[i].a.a, constants_SEQ_STRING_RETN[i]) : (__builtin_constant_p (retn->_buffer[i].a.a) && ((size_t)(const void *)((retn->_buffer[i].a.a) + 1) - (size_t)(const void *)(retn->_buffer[i].a.a) == 1) && (__s1_len = strlen (retn->_buffer[i].a.a), __s1_len < 4) ? (__builtin_constant_p (constants_SEQ_STRING_RETN[i]) && ((size_t)(const void *)((constants_SEQ_STRING_RETN[i]) + 1) - (size_t)(const void *)(constants_SEQ_STRING_RETN[i]) == 1) ? __builtin_strcmp (retn->_buffer[i].a.a, constants_SEQ_STRING_RETN[i]) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (constants_SEQ_STRING_RETN[i]); register int __result = (((__const unsigned char *) (__const char *) (retn->_buffer[i].a.a))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (retn->_buffer[i].a.a))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (retn->_buffer[i].a.a))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (retn->_buffer[i].a.a))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (constants_SEQ_STRING_RETN[i]) && ((size_t)(const void *)((constants_SEQ_STRING_RETN[i]) + 1) - (size_t)(const void *)(constants_SEQ_STRING_RETN[i]) == 1) && (__s2_len = strlen (constants_SEQ_STRING_RETN[i]), __s2_len < 4) ? (__builtin_constant_p (retn->_buffer[i].a.a) && ((size_t)(const void *)((retn->_buffer[i].a.a) + 1) - (size_t)(const void *)(retn->_buffer[i].a.a) == 1) ? __builtin_strcmp (retn->_buffer[i].a.a, constants_SEQ_STRING_RETN[i]) : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (retn->_buffer[i].a.a); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (constants_SEQ_STRING_RETN[i]))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (constants_SEQ_STRING_RETN[i]))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (constants_SEQ_STRING_RETN[i]))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (constants_SEQ_STRING_RETN[i]))[3]); } } __result; }))) : __builtin_strcmp (retn->_buffer[i].a.a, constants_SEQ_STRING_RETN[i])))); }) == 0) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 819, __PRETTY_FUNCTION__, "strcmp (retn->_buffer[i].a.a, constants_SEQ_STRING_RETN[i]) == 0"); });
  }

  CORBA_free (inArg._buffer);
  CORBA_free (inoutArg._buffer);
  CORBA_free (outArg);
  CORBA_free (retn);
  CORBA_Object_release (objref, ev);
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 827, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
}

static void
testFixedLengthUnion (test_TestFactory factory,
        CORBA_Environment *ev)
{
  test_UnionServer objref;
  test_FixedLengthUnion inArg, inoutArg, outArg, retn;
  if (!thread_tests) g_print("Testing fixed length unions...\n");
  objref = test_TestFactory_getUnionServer (factory, ev);
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 838, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

  inArg._u.x = 0x12345678;
  inArg._d = 'a';

  inoutArg._u.y = 't';
  inoutArg._d = 'b';

  retn = test_UnionServer_opFixed (objref, &inArg, &inoutArg, &outArg, ev);
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 847, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inArg._d == 'a') _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 849, __PRETTY_FUNCTION__, "inArg._d == 'a'"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inArg._u.x == 0x12345678) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 850, __PRETTY_FUNCTION__, "inArg._u.x == constants_LONG_IN"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inoutArg._d == 'c') _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 851, __PRETTY_FUNCTION__, "inoutArg._d == 'c'"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inoutArg._u.z == (!(0))) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 852, __PRETTY_FUNCTION__, "inoutArg._u.z == TRUE"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (outArg._d == 'a') _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 853, __PRETTY_FUNCTION__, "outArg._d == 'a'"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (outArg._u.x == 0x78123456) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 854, __PRETTY_FUNCTION__, "outArg._u.x == constants_LONG_OUT"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (retn._d == 'd') _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 855, __PRETTY_FUNCTION__, "retn._d == 'd'"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (retn._u.z == (0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 856, __PRETTY_FUNCTION__, "retn._u.z == FALSE"); });

  CORBA_Object_release (objref, ev);
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 859, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
}

static void
testVariableLengthUnion (test_TestFactory factory,
    CORBA_Environment *ev)
{
  test_UnionServer objref;
  test_VariableLengthUnion inArg, inoutArg, *outArg, *retn;
  if (!thread_tests) g_print("Testing variable length unions...\n");
  objref = test_TestFactory_getUnionServer (factory, ev);
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 870, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

  inArg._u.x = 0x12345678;
  inArg._d = 1;

  inoutArg._u.y = CORBA_string_dup (constants_STRING_INOUT_IN);
  inoutArg._d = 2;

  retn = test_UnionServer_opVariable (objref, &inArg, &inoutArg, &outArg, ev);
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 879, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inArg._d == 1) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 881, __PRETTY_FUNCTION__, "inArg._d == 1"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inArg._u.x == 0x12345678) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 882, __PRETTY_FUNCTION__, "inArg._u.x == constants_LONG_IN"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inoutArg._d == 3) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 883, __PRETTY_FUNCTION__, "inoutArg._d == 3"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inoutArg._u.z == (!(0))) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 884, __PRETTY_FUNCTION__, "inoutArg._u.z == TRUE"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (outArg->_d == 1) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 885, __PRETTY_FUNCTION__, "outArg->_d == 1"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (outArg->_u.x == 0x78123456) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 886, __PRETTY_FUNCTION__, "outArg->_u.x == constants_LONG_OUT"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (retn->_d == 4) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 887, __PRETTY_FUNCTION__, "retn->_d == 4"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (retn->_u.z == (0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 888, __PRETTY_FUNCTION__, "retn->_u.z == FALSE"); });

  CORBA_free (outArg);
  CORBA_free (retn);

  CORBA_Object_release (objref, ev);
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 894, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
}

static void
testMiscUnions (test_TestFactory factory,
         CORBA_Environment *ev)
{
 test_UnionServer obj;
 test_EnumUnion retn;
 test_unionSeq inSeq;
 test_VariableLengthUnion inSeq_buffer[3];
 test_BooleanUnion inArg;
 test_ArrayUnion *outArg;
 int i;

 if (!thread_tests) g_print("Testing misc type unions...\n");
 obj = test_TestFactory_getUnionServer (factory, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 911, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 inSeq._length = inSeq._maximum = 3;
 inSeq._buffer = inSeq_buffer;
 inSeq._release = CORBA_FALSE;
 inSeq._buffer [0]._d = 4;
 inSeq._buffer [0]._u.z = CORBA_TRUE;
 inSeq._buffer [1]._d = 2;
 inSeq._buffer [1]._u.y = "blah";
 inSeq._buffer [2]._d = 55;
 inSeq._buffer [2]._u.w = 0x12345678;

 inArg._d = 1;
 inArg._u.y = "blah de blah";

 retn = test_UnionServer_opMisc (obj, &inSeq, &inArg, &outArg, ev);

 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inSeq._length == 3) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 928, __PRETTY_FUNCTION__, "inSeq._length == 3"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inSeq._buffer [0]._d == 4) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 929, __PRETTY_FUNCTION__, "inSeq._buffer [0]._d == 4"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inSeq._buffer [0]._u.z == CORBA_TRUE) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 930, __PRETTY_FUNCTION__, "inSeq._buffer [0]._u.z == CORBA_TRUE"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inSeq._buffer [1]._d == 2) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 931, __PRETTY_FUNCTION__, "inSeq._buffer [1]._d == 2"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (!__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (inSeq._buffer [1]._u.y) && __builtin_constant_p ("blah") && (__s1_len = strlen (inSeq._buffer [1]._u.y), __s2_len = strlen ("blah"), (!((size_t)(const void *)((inSeq._buffer [1]._u.y) + 1) - (size_t)(const void *)(inSeq._buffer [1]._u.y) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("blah") + 1) - (size_t)(const void *)("blah") == 1) || __s2_len >= 4)) ? __builtin_strcmp (inSeq._buffer [1]._u.y, "blah") : (__builtin_constant_p (inSeq._buffer [1]._u.y) && ((size_t)(const void *)((inSeq._buffer [1]._u.y) + 1) - (size_t)(const void *)(inSeq._buffer [1]._u.y) == 1) && (__s1_len = strlen (inSeq._buffer [1]._u.y), __s1_len < 4) ? (__builtin_constant_p ("blah") && ((size_t)(const void *)(("blah") + 1) - (size_t)(const void *)("blah") == 1) ? __builtin_strcmp (inSeq._buffer [1]._u.y, "blah") : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) ("blah"); register int __result = (((__const unsigned char *) (__const char *) (inSeq._buffer [1]._u.y))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (inSeq._buffer [1]._u.y))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (inSeq._buffer [1]._u.y))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (inSeq._buffer [1]._u.y))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("blah") && ((size_t)(const void *)(("blah") + 1) - (size_t)(const void *)("blah") == 1) && (__s2_len = strlen ("blah"), __s2_len < 4) ? (__builtin_constant_p (inSeq._buffer [1]._u.y) && ((size_t)(const void *)((inSeq._buffer [1]._u.y) + 1) - (size_t)(const void *)(inSeq._buffer [1]._u.y) == 1) ? __builtin_strcmp (inSeq._buffer [1]._u.y, "blah") : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (inSeq._buffer [1]._u.y); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) ("blah"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) ("blah"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) ("blah"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) ("blah"))[3]); } } __result; }))) : __builtin_strcmp (inSeq._buffer [1]._u.y, "blah")))); })) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 932, __PRETTY_FUNCTION__, "!strcmp (inSeq._buffer [1]._u.y, \"blah\")"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inSeq._buffer [2]._d == 55) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 933, __PRETTY_FUNCTION__, "inSeq._buffer [2]._d == 55"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inSeq._buffer [2]._u.w == 0x12345678) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 934, __PRETTY_FUNCTION__, "inSeq._buffer [2]._u.w == constants_LONG_IN"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inArg._d == 1) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 935, __PRETTY_FUNCTION__, "inArg._d == 1"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (!__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (inArg._u.y) && __builtin_constant_p ("blah de blah") && (__s1_len = strlen (inArg._u.y), __s2_len = strlen ("blah de blah"), (!((size_t)(const void *)((inArg._u.y) + 1) - (size_t)(const void *)(inArg._u.y) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("blah de blah") + 1) - (size_t)(const void *)("blah de blah") == 1) || __s2_len >= 4)) ? __builtin_strcmp (inArg._u.y, "blah de blah") : (__builtin_constant_p (inArg._u.y) && ((size_t)(const void *)((inArg._u.y) + 1) - (size_t)(const void *)(inArg._u.y) == 1) && (__s1_len = strlen (inArg._u.y), __s1_len < 4) ? (__builtin_constant_p ("blah de blah") && ((size_t)(const void *)(("blah de blah") + 1) - (size_t)(const void *)("blah de blah") == 1) ? __builtin_strcmp (inArg._u.y, "blah de blah") : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) ("blah de blah"); register int __result = (((__const unsigned char *) (__const char *) (inArg._u.y))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (inArg._u.y))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (inArg._u.y))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (inArg._u.y))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("blah de blah") && ((size_t)(const void *)(("blah de blah") + 1) - (size_t)(const void *)("blah de blah") == 1) && (__s2_len = strlen ("blah de blah"), __s2_len < 4) ? (__builtin_constant_p (inArg._u.y) && ((size_t)(const void *)((inArg._u.y) + 1) - (size_t)(const void *)(inArg._u.y) == 1) ? __builtin_strcmp (inArg._u.y, "blah de blah") : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (inArg._u.y); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) ("blah de blah"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) ("blah de blah"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) ("blah de blah"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) ("blah de blah"))[3]); } } __result; }))) : __builtin_strcmp (inArg._u.y, "blah de blah")))); })) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 936, __PRETTY_FUNCTION__, "!strcmp (inArg._u.y, \"blah de blah\")"); });

 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (outArg->_d == 22) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 938, __PRETTY_FUNCTION__, "outArg->_d == 22"); });
 for (i = 0; i < 20; i++) {
  char *tmp;

  tmp = g_strdup_printf ("Numero %d", i);
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (!__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (outArg->_u.d [i]) && __builtin_constant_p (tmp) && (__s1_len = strlen (outArg->_u.d [i]), __s2_len = strlen (tmp), (!((size_t)(const void *)((outArg->_u.d [i]) + 1) - (size_t)(const void *)(outArg->_u.d [i]) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((tmp) + 1) - (size_t)(const void *)(tmp) == 1) || __s2_len >= 4)) ? __builtin_strcmp (outArg->_u.d [i], tmp) : (__builtin_constant_p (outArg->_u.d [i]) && ((size_t)(const void *)((outArg->_u.d [i]) + 1) - (size_t)(const void *)(outArg->_u.d [i]) == 1) && (__s1_len = strlen (outArg->_u.d [i]), __s1_len < 4) ? (__builtin_constant_p (tmp) && ((size_t)(const void *)((tmp) + 1) - (size_t)(const void *)(tmp) == 1) ? __builtin_strcmp (outArg->_u.d [i], tmp) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (tmp); register int __result = (((__const unsigned char *) (__const char *) (outArg->_u.d [i]))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (outArg->_u.d [i]))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (outArg->_u.d [i]))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (outArg->_u.d [i]))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (tmp) && ((size_t)(const void *)((tmp) + 1) - (size_t)(const void *)(tmp) == 1) && (__s2_len = strlen (tmp), __s2_len < 4) ? (__builtin_constant_p (outArg->_u.d [i]) && ((size_t)(const void *)((outArg->_u.d [i]) + 1) - (size_t)(const void *)(outArg->_u.d [i]) == 1) ? __builtin_strcmp (outArg->_u.d [i], tmp) : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (outArg->_u.d [i]); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (tmp))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (tmp))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (tmp))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (tmp))[3]); } } __result; }))) : __builtin_strcmp (outArg->_u.d [i], tmp)))); })) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 943, __PRETTY_FUNCTION__, "!strcmp (outArg->_u.d [i], tmp)"); });
  g_free (tmp);
 }

 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (retn._d == test_EnumUnion_red) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 947, __PRETTY_FUNCTION__, "retn._d == test_EnumUnion_red"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (retn._u.x == 0x12345678) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 948, __PRETTY_FUNCTION__, "retn._u.x == constants_LONG_IN"); });

 CORBA_free (outArg);

 CORBA_Object_release (obj, ev);
   (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 953, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
}

static void
testUnionArray (test_TestFactory factory,
         CORBA_Environment *ev)
{
 test_UnionServer obj;
 test_FixedLengthUnionArray_slice *retn;
 test_FixedLengthUnionArray inArg;
 test_FixedLengthUnionArray inoutArg;
 test_FixedLengthUnionArray outArg;

 if (!thread_tests) g_print("Testing union array...\n");
 obj = test_TestFactory_getUnionServer (factory, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 968, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 inArg[0]._d = 'a';
 inArg[0]._u.x = 0x12345678;
 inArg[1]._d = 'b';
 inArg[1]._u.y = constants_CHAR_IN;
 inArg[2]._d = 'c';
 inArg[3]._d = 'e';
 inArg[3]._u.v.a = constants_SHORT_IN;

 inoutArg[0]._d = 'a';
 inoutArg[0]._u.x = 0x34567812;
 inoutArg[1]._d = 'b';
 inoutArg[1]._u.y = constants_CHAR_INOUT_IN;
 inoutArg[2]._d = 'c';
 inoutArg[3]._d = 'e';
 inoutArg[3]._u.v.a = constants_SHORT_INOUT_IN;

 retn = test_UnionServer_opFixedLengthUnionArray (obj, inArg, inoutArg, outArg, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 987, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inArg[0]._d == 'a') _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 989, __PRETTY_FUNCTION__, "inArg[0]._d == 'a'"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inArg[0]._u.x == 0x12345678) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 990, __PRETTY_FUNCTION__, "inArg[0]._u.x == constants_LONG_IN"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inArg[1]._d == 'b') _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 991, __PRETTY_FUNCTION__, "inArg[1]._d == 'b'"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inArg[1]._u.y == constants_CHAR_IN) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 992, __PRETTY_FUNCTION__, "inArg[1]._u.y == constants_CHAR_IN"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inArg[2]._d == 'c') _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 993, __PRETTY_FUNCTION__, "inArg[2]._d == 'c'"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inArg[3]._d == 'e') _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 994, __PRETTY_FUNCTION__, "inArg[3]._d == 'e'"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inArg[3]._u.v.a == constants_SHORT_IN) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 995, __PRETTY_FUNCTION__, "inArg[3]._u.v.a == constants_SHORT_IN"); });

 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inoutArg[0]._d == 'a') _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 997, __PRETTY_FUNCTION__, "inoutArg[0]._d == 'a'"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inoutArg[0]._u.x == 0x56781234) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 998, __PRETTY_FUNCTION__, "inoutArg[0]._u.x == constants_LONG_INOUT_OUT"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inoutArg[1]._d == 'b') _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 999, __PRETTY_FUNCTION__, "inoutArg[1]._d == 'b'"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inoutArg[1]._u.y == constants_CHAR_INOUT_OUT) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1000, __PRETTY_FUNCTION__, "inoutArg[1]._u.y == constants_CHAR_INOUT_OUT"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inoutArg[2]._d == 'c') _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1001, __PRETTY_FUNCTION__, "inoutArg[2]._d == 'c'"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inoutArg[3]._d == 'e') _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1002, __PRETTY_FUNCTION__, "inoutArg[3]._d == 'e'"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inoutArg[3]._u.v.a == constants_SHORT_INOUT_OUT) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1003, __PRETTY_FUNCTION__, "inoutArg[3]._u.v.a == constants_SHORT_INOUT_OUT"); });

 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (outArg[0]._d == 'a') _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1005, __PRETTY_FUNCTION__, "outArg[0]._d == 'a'"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (outArg[0]._u.x == 0x78123456) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1006, __PRETTY_FUNCTION__, "outArg[0]._u.x == constants_LONG_OUT"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (outArg[1]._d == 'b') _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1007, __PRETTY_FUNCTION__, "outArg[1]._d == 'b'"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (outArg[1]._u.y == constants_CHAR_OUT) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1008, __PRETTY_FUNCTION__, "outArg[1]._u.y == constants_CHAR_OUT"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (outArg[2]._d == 'c') _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1009, __PRETTY_FUNCTION__, "outArg[2]._d == 'c'"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (outArg[3]._d == 'e') _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1010, __PRETTY_FUNCTION__, "outArg[3]._d == 'e'"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (outArg[3]._u.v.a == constants_SHORT_OUT) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1011, __PRETTY_FUNCTION__, "outArg[3]._u.v.a == constants_SHORT_OUT"); });

 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (retn[0]._d == 'a') _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1013, __PRETTY_FUNCTION__, "retn[0]._d == 'a'"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (retn[0]._u.x == 0xAABBCCDD) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1014, __PRETTY_FUNCTION__, "retn[0]._u.x == constants_LONG_RETN"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (retn[1]._d == 'b') _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1015, __PRETTY_FUNCTION__, "retn[1]._d == 'b'"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (retn[1]._u.y == constants_CHAR_RETN) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1016, __PRETTY_FUNCTION__, "retn[1]._u.y == constants_CHAR_RETN"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (retn[2]._d == 'c') _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1017, __PRETTY_FUNCTION__, "retn[2]._d == 'c'"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (retn[3]._d == 'e') _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1018, __PRETTY_FUNCTION__, "retn[3]._d == 'e'"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (retn[3]._u.v.a == constants_SHORT_RETN) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1019, __PRETTY_FUNCTION__, "retn[3]._u.v.a == constants_SHORT_RETN"); });

 CORBA_free (retn);

 CORBA_Object_release (obj, ev);
   (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1024, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
}

static void
testLongArray (test_ArrayServer objref,
        CORBA_Environment *ev)
{
  int i;
  test_LongArray inArg, inoutArg, outArg;
  test_LongArray_slice *retn;

  for (i=0;i<4;i++)
 inArg[i] = constants_SEQ_LONG_IN[i];

  for (i=0;i<4;i++)
 inoutArg[i] = constants_SEQ_LONG_INOUT_IN[i];

  retn = test_ArrayServer_opLongArray (objref, inArg, inoutArg, outArg, ev);
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1042, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

  for (i=0;i<4;i++)
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inArg[i]==constants_SEQ_LONG_IN[i]) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1045, __PRETTY_FUNCTION__, "inArg[i]==constants_SEQ_LONG_IN[i]"); });
  for (i=0;i<4;i++)
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inoutArg[i]==constants_SEQ_LONG_INOUT_OUT[i]) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1047, __PRETTY_FUNCTION__, "inoutArg[i]==constants_SEQ_LONG_INOUT_OUT[i]"); });
  for (i=0;i<4;i++)
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (outArg[i]==constants_SEQ_LONG_OUT[i]) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1049, __PRETTY_FUNCTION__, "outArg[i]==constants_SEQ_LONG_OUT[i]"); });
  for (i=0;i<4;i++)
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (retn[i]==constants_SEQ_LONG_RETN[i]) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1051, __PRETTY_FUNCTION__, "retn[i]==constants_SEQ_LONG_RETN[i]"); });

  CORBA_free (retn);
}

static void
testOctetArray (test_ArrayServer objref,
  CORBA_Environment *ev)
{
  int i;
  test_OctetArray inArg, inoutArg, outArg;
  test_OctetArray_slice *retn;

  for (i=0;i<4;i++)
 inArg[i] = constants_SEQ_OCTET_IN[i];

  for (i=0;i<4;i++)
 inoutArg[i] = constants_SEQ_OCTET_INOUT_IN[i];

  retn = test_ArrayServer_opOctetArray (objref, inArg, inoutArg, outArg, ev);
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1071, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

  for (i=0;i<4;i++)
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inArg[i]==constants_SEQ_OCTET_IN[i]) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1074, __PRETTY_FUNCTION__, "inArg[i]==constants_SEQ_OCTET_IN[i]"); });
  for (i=0;i<4;i++)
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inoutArg[i]==constants_SEQ_OCTET_INOUT_OUT[i]) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1076, __PRETTY_FUNCTION__, "inoutArg[i]==constants_SEQ_OCTET_INOUT_OUT[i]"); });
  for (i=0;i<4;i++)
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (outArg[i]==constants_SEQ_OCTET_OUT[i]) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1078, __PRETTY_FUNCTION__, "outArg[i]==constants_SEQ_OCTET_OUT[i]"); });
  for (i=0;i<4;i++)
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (retn[i]==constants_SEQ_OCTET_RETN[i]) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1080, __PRETTY_FUNCTION__, "retn[i]==constants_SEQ_OCTET_RETN[i]"); });

  CORBA_free (retn);
}

static void
testFixedLengthStructArray (test_ArrayServer objref,
       CORBA_Environment *ev)
{
  int i;
  test_FixedLengthStructArray inArg, inoutArg, outArg;
  test_FixedLengthStructArray_slice *retn;

  for (i=0;i<4;i++)
 inArg[i].a = constants_SEQ_OCTET_IN[i];

  for (i=0;i<4;i++)
 inoutArg[i].a = constants_SEQ_OCTET_INOUT_IN[i];

  retn = test_ArrayServer_opFixedLengthStructArray (objref, inArg, inoutArg, outArg, ev);
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1100, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

  for (i=0;i<4;i++)
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inArg[i].a==constants_SEQ_OCTET_IN[i]) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1103, __PRETTY_FUNCTION__, "inArg[i].a==constants_SEQ_OCTET_IN[i]"); });
  for (i=0;i<4;i++)
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inoutArg[i].a==constants_SEQ_OCTET_INOUT_OUT[i]) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1105, __PRETTY_FUNCTION__, "inoutArg[i].a==constants_SEQ_OCTET_INOUT_OUT[i]"); });
  for (i=0;i<4;i++)
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (outArg[i].a==constants_SEQ_OCTET_OUT[i]) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1107, __PRETTY_FUNCTION__, "outArg[i].a==constants_SEQ_OCTET_OUT[i]"); });
  for (i=0;i<4;i++)
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (retn[i].a==constants_SEQ_OCTET_RETN[i]) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1109, __PRETTY_FUNCTION__, "retn[i].a==constants_SEQ_OCTET_RETN[i]"); });

  CORBA_free (retn);
}

static void
testFixedLengthArray (test_TestFactory factory,
        CORBA_Environment *ev)
{

  test_ArrayServer objref;
  if (!thread_tests) g_print("Testing arrays with fixed length members...\n");
  objref = test_TestFactory_getArrayServer (factory, ev);
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1122, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

  testLongArray (objref, ev);
  testOctetArray (objref, ev);
  testFixedLengthStructArray (objref, ev);

  CORBA_Object_release (objref, ev);
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1129, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
}

static void
testStrArray (test_ArrayServer objref,
       CORBA_Environment *ev)
{
  test_StrArray inArg, inoutArg;
  test_StrArray_slice *outArg, *retn;
  test_StrArrayMultiDimensional_slice *multidim;
  int i, n0, n1, n2;

  for (i=0;i<4;i++)
 inArg[i] = CORBA_string_dup (constants_SEQ_STRING_IN[i]);

  for (i=0;i<4;i++)
 inoutArg[i] = CORBA_string_dup (constants_SEQ_STRING_INOUT_IN[i]);

  retn = test_ArrayServer_opStrArray (objref, inArg, inoutArg, &outArg, ev);
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1148, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

  for (i=0;i<4;i++)
 CORBA_free (inArg[i]);

  for (i=0;i<4;i++)
        CORBA_free (inoutArg[i]);

  CORBA_free (outArg);
  CORBA_free (retn);

  multidim = ((test_StrArrayMultiDimensional_slice *)ORBit_small_alloc (((CORBA_TypeCode)&TC_test_StrArrayMultiDimensional_struct)));
  for (n0 = 0; n0 < 2; n0++) {
 for (n1 = 0; n1 < 3; n1++) {
   for (n2 = 0; n2 < 5; n2++) {
  multidim[n0][n1][n2] = CORBA_string_dup (constants_SEQ_STRING_INOUT_IN[0]);
   }
 }
  }
  CORBA_free (multidim);

}

static void
testAlignHoleStructArray (test_ArrayServer objref,
     CORBA_Environment *ev)
{
  int i;
  test_AlignHoleStructArray inArg, inoutArg, outArg;
  test_AlignHoleStructArray_slice *retn;

  for (i=0;i<4;i++)
 inArg[i].a.a = constants_SEQ_OCTET_IN[i];
  for (i=0;i<4;i++)
 inArg[i].a.b = constants_SEQ_OCTET_IN[i];
  for (i=0;i<4;i++)
 inArg[i].b = constants_SEQ_OCTET_IN[i];

  for (i=0;i<4;i++)
 inoutArg[i].a.a = constants_SEQ_OCTET_INOUT_IN[i];
  for (i=0;i<4;i++)
 inoutArg[i].a.b = constants_SEQ_OCTET_INOUT_IN[i];
  for (i=0;i<4;i++)
 inoutArg[i].b = constants_SEQ_OCTET_INOUT_IN[i];

  retn = test_ArrayServer_opAlignHoleStructArray (objref, inArg, inoutArg, outArg, ev);
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1194, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

  for (i=0;i<4;i++)
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inArg[i].a.a==constants_SEQ_OCTET_IN[i]) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1197, __PRETTY_FUNCTION__, "inArg[i].a.a==constants_SEQ_OCTET_IN[i]"); });
  for (i=0;i<4;i++)
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inArg[i].a.b==constants_SEQ_OCTET_IN[i]) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1199, __PRETTY_FUNCTION__, "inArg[i].a.b==constants_SEQ_OCTET_IN[i]"); });
  for (i=0;i<4;i++)
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inArg[i].b==(CORBA_char)constants_SEQ_OCTET_IN[i]) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1201, __PRETTY_FUNCTION__, "inArg[i].b==(CORBA_char)constants_SEQ_OCTET_IN[i]"); });

  for (i=0;i<4;i++)
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inoutArg[i].a.a==constants_SEQ_OCTET_INOUT_OUT[i]) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1204, __PRETTY_FUNCTION__, "inoutArg[i].a.a==constants_SEQ_OCTET_INOUT_OUT[i]"); });
  for (i=0;i<4;i++)
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inoutArg[i].a.b==constants_SEQ_OCTET_INOUT_OUT[i]) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1206, __PRETTY_FUNCTION__, "inoutArg[i].a.b==constants_SEQ_OCTET_INOUT_OUT[i]"); });
  for (i=0;i<4;i++)
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (inoutArg[i].b==(CORBA_char)constants_SEQ_OCTET_INOUT_OUT[i]) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1208, __PRETTY_FUNCTION__, "inoutArg[i].b==(CORBA_char)constants_SEQ_OCTET_INOUT_OUT[i]"); });

  for (i=0;i<4;i++)
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (outArg[i].a.a==constants_SEQ_OCTET_OUT[i]) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1211, __PRETTY_FUNCTION__, "outArg[i].a.a==constants_SEQ_OCTET_OUT[i]"); });
  for (i=0;i<4;i++)
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (outArg[i].a.b==constants_SEQ_OCTET_OUT[i]) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1213, __PRETTY_FUNCTION__, "outArg[i].a.b==constants_SEQ_OCTET_OUT[i]"); });
  for (i=0;i<4;i++)
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (outArg[i].b==(CORBA_char)constants_SEQ_OCTET_OUT[i]) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1215, __PRETTY_FUNCTION__, "outArg[i].b==(CORBA_char)constants_SEQ_OCTET_OUT[i]"); });

  for (i=0;i<4;i++)
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (retn[i].a.a==constants_SEQ_OCTET_RETN[i]) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1218, __PRETTY_FUNCTION__, "retn[i].a.a==constants_SEQ_OCTET_RETN[i]"); });
  for (i=0;i<4;i++)
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (retn[i].a.b==constants_SEQ_OCTET_RETN[i]) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1220, __PRETTY_FUNCTION__, "retn[i].a.b==constants_SEQ_OCTET_RETN[i]"); });
  for (i=0;i<4;i++)
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (retn[i].b==(CORBA_char)constants_SEQ_OCTET_RETN[i]) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1222, __PRETTY_FUNCTION__, "retn[i].b==(CORBA_char)constants_SEQ_OCTET_RETN[i]"); });

  CORBA_free (retn);
}

static void
testVariableLengthArray (test_TestFactory factory,
    CORBA_Environment *ev)
{
  test_ArrayServer objref;

  if (!thread_tests) g_print("Testing arrays with variable length members...\n");
  objref = test_TestFactory_getArrayServer (factory, ev);
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1235, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

  testStrArray (objref, ev);
  testAlignHoleStructArray (objref, ev);

  CORBA_Object_release (objref, ev);
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1241, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
}

static void
testAnyLong (test_TestFactory factory,
      CORBA_Environment *ev)
{
  test_AnyServer objref;
  CORBA_any inArg, inoutArg, *outArg, *retn;
  CORBA_long tmp, tmp1;

  if (!thread_tests) g_print("Testing any with longs...\n");
  objref = test_TestFactory_getAnyServer (factory, ev);
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1254, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

  tmp = 0x12345678;
  inArg._type = (CORBA_TypeCode)((CORBA_TypeCode)&TC_CORBA_long_struct);
  inArg._value = &tmp;
  (&inArg)->_release = CORBA_FALSE;

  inoutArg._type = (CORBA_TypeCode)((CORBA_TypeCode)&TC_CORBA_long_struct);
  tmp1 = 0x34567812;
  inoutArg._value = &tmp1;
  (&inoutArg)->_release = CORBA_FALSE;

  retn = test_AnyServer_opAnyLong (objref, &inArg, &inoutArg, &outArg, ev);
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1267, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_TypeCode_equal (inArg._type, ((CORBA_TypeCode)&TC_CORBA_long_struct), ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1269, __PRETTY_FUNCTION__, "CORBA_TypeCode_equal (inArg._type, TC_CORBA_long, ev)"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (* (CORBA_long*)inArg._value == 0x12345678) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1270, __PRETTY_FUNCTION__, "* (CORBA_long*)inArg._value == constants_LONG_IN"); });

  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_TypeCode_equal (inoutArg._type, ((CORBA_TypeCode)&TC_CORBA_long_struct), ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1272, __PRETTY_FUNCTION__, "CORBA_TypeCode_equal (inoutArg._type, TC_CORBA_long, ev)"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (* (CORBA_long*)inoutArg._value == 0x56781234) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1273, __PRETTY_FUNCTION__, "* (CORBA_long*)inoutArg._value == constants_LONG_INOUT_OUT"); });

  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_TypeCode_equal (outArg->_type, ((CORBA_TypeCode)&TC_CORBA_long_struct), ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1275, __PRETTY_FUNCTION__, "CORBA_TypeCode_equal (outArg->_type, TC_CORBA_long, ev)"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (* (CORBA_long*)outArg->_value == 0x78123456) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1276, __PRETTY_FUNCTION__, "* (CORBA_long*)outArg->_value == constants_LONG_OUT"); });

  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_TypeCode_equal (retn->_type, ((CORBA_TypeCode)&TC_CORBA_long_struct), ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1278, __PRETTY_FUNCTION__, "CORBA_TypeCode_equal (retn->_type, TC_CORBA_long, ev)"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (* (CORBA_long*)retn->_value == 0xAABBCCDD) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1279, __PRETTY_FUNCTION__, "* (CORBA_long*)retn->_value == constants_LONG_RETN"); });

  if ((&inArg)->_release){
 CORBA_free (inArg._value);
 CORBA_Object_release ((CORBA_Object)inArg._type, ev);
  }

  if ((&inoutArg)->_release){
 CORBA_free (inoutArg._value);
 CORBA_Object_release ((CORBA_Object)inoutArg._type, ev);
  }

  CORBA_free (outArg);
  CORBA_free (retn);

  CORBA_Object_release (objref, ev);
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1295, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
}

static void
testAnyString (test_TestFactory factory,
        CORBA_Environment *ev)
{
 test_AnyServer objref;
 CORBA_any inArg, inoutArg, *outArg, *retn;

 if (!thread_tests) g_print("Testing any with strings...\n");
 objref = test_TestFactory_getAnyServer (factory, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1307, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 inArg._type = (CORBA_TypeCode)((CORBA_TypeCode)&TC_CORBA_string_struct);
 inArg._value = &constants_STRING_IN;
 (&inArg)->_release = CORBA_FALSE;

 inoutArg._type = (CORBA_TypeCode)((CORBA_TypeCode)&TC_CORBA_string_struct);
 inoutArg._value = &constants_STRING_INOUT_IN;
 (&inoutArg)->_release = CORBA_FALSE;

 retn = test_AnyServer_opAnyString (objref, &inArg, &inoutArg, &outArg, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1318, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_TypeCode_equal (inArg._type, ((CORBA_TypeCode)&TC_CORBA_string_struct), ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1320, __PRETTY_FUNCTION__, "CORBA_TypeCode_equal (inArg._type, TC_CORBA_string, ev)"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (* (CORBA_char **)inArg._value) && __builtin_constant_p (constants_STRING_IN) && (__s1_len = strlen (* (CORBA_char **)inArg._value), __s2_len = strlen (constants_STRING_IN), (!((size_t)(const void *)((* (CORBA_char **)inArg._value) + 1) - (size_t)(const void *)(* (CORBA_char **)inArg._value) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((constants_STRING_IN) + 1) - (size_t)(const void *)(constants_STRING_IN) == 1) || __s2_len >= 4)) ? __builtin_strcmp (* (CORBA_char **)inArg._value, constants_STRING_IN) : (__builtin_constant_p (* (CORBA_char **)inArg._value) && ((size_t)(const void *)((* (CORBA_char **)inArg._value) + 1) - (size_t)(const void *)(* (CORBA_char **)inArg._value) == 1) && (__s1_len = strlen (* (CORBA_char **)inArg._value), __s1_len < 4) ? (__builtin_constant_p (constants_STRING_IN) && ((size_t)(const void *)((constants_STRING_IN) + 1) - (size_t)(const void *)(constants_STRING_IN) == 1) ? __builtin_strcmp (* (CORBA_char **)inArg._value, constants_STRING_IN) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (constants_STRING_IN); register int __result = (((__const unsigned char *) (__const char *) (* (CORBA_char **)inArg._value))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (* (CORBA_char **)inArg._value))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (* (CORBA_char **)inArg._value))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (* (CORBA_char **)inArg._value))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (constants_STRING_IN) && ((size_t)(const void *)((constants_STRING_IN) + 1) - (size_t)(const void *)(constants_STRING_IN) == 1) && (__s2_len = strlen (constants_STRING_IN), __s2_len < 4) ? (__builtin_constant_p (* (CORBA_char **)inArg._value) && ((size_t)(const void *)((* (CORBA_char **)inArg._value) + 1) - (size_t)(const void *)(* (CORBA_char **)inArg._value) == 1) ? __builtin_strcmp (* (CORBA_char **)inArg._value, constants_STRING_IN) : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (* (CORBA_char **)inArg._value); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (constants_STRING_IN))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (constants_STRING_IN))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (constants_STRING_IN))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (constants_STRING_IN))[3]); } } __result; }))) : __builtin_strcmp (* (CORBA_char **)inArg._value, constants_STRING_IN)))); }) == 0) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1321, __PRETTY_FUNCTION__, "strcmp (* (CORBA_char **)inArg._value, constants_STRING_IN) == 0"); });

 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_TypeCode_equal (inoutArg._type, ((CORBA_TypeCode)&TC_CORBA_string_struct), ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1323, __PRETTY_FUNCTION__, "CORBA_TypeCode_equal (inoutArg._type, TC_CORBA_string, ev)"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (* (CORBA_char **)inoutArg._value) && __builtin_constant_p (constants_STRING_INOUT_OUT) && (__s1_len = strlen (* (CORBA_char **)inoutArg._value), __s2_len = strlen (constants_STRING_INOUT_OUT), (!((size_t)(const void *)((* (CORBA_char **)inoutArg._value) + 1) - (size_t)(const void *)(* (CORBA_char **)inoutArg._value) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((constants_STRING_INOUT_OUT) + 1) - (size_t)(const void *)(constants_STRING_INOUT_OUT) == 1) || __s2_len >= 4)) ? __builtin_strcmp (* (CORBA_char **)inoutArg._value, constants_STRING_INOUT_OUT) : (__builtin_constant_p (* (CORBA_char **)inoutArg._value) && ((size_t)(const void *)((* (CORBA_char **)inoutArg._value) + 1) - (size_t)(const void *)(* (CORBA_char **)inoutArg._value) == 1) && (__s1_len = strlen (* (CORBA_char **)inoutArg._value), __s1_len < 4) ? (__builtin_constant_p (constants_STRING_INOUT_OUT) && ((size_t)(const void *)((constants_STRING_INOUT_OUT) + 1) - (size_t)(const void *)(constants_STRING_INOUT_OUT) == 1) ? __builtin_strcmp (* (CORBA_char **)inoutArg._value, constants_STRING_INOUT_OUT) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (constants_STRING_INOUT_OUT); register int __result = (((__const unsigned char *) (__const char *) (* (CORBA_char **)inoutArg._value))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (* (CORBA_char **)inoutArg._value))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (* (CORBA_char **)inoutArg._value))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (* (CORBA_char **)inoutArg._value))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (constants_STRING_INOUT_OUT) && ((size_t)(const void *)((constants_STRING_INOUT_OUT) + 1) - (size_t)(const void *)(constants_STRING_INOUT_OUT) == 1) && (__s2_len = strlen (constants_STRING_INOUT_OUT), __s2_len < 4) ? (__builtin_constant_p (* (CORBA_char **)inoutArg._value) && ((size_t)(const void *)((* (CORBA_char **)inoutArg._value) + 1) - (size_t)(const void *)(* (CORBA_char **)inoutArg._value) == 1) ? __builtin_strcmp (* (CORBA_char **)inoutArg._value, constants_STRING_INOUT_OUT) : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (* (CORBA_char **)inoutArg._value); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (constants_STRING_INOUT_OUT))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (constants_STRING_INOUT_OUT))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (constants_STRING_INOUT_OUT))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (constants_STRING_INOUT_OUT))[3]); } } __result; }))) : __builtin_strcmp (* (CORBA_char **)inoutArg._value, constants_STRING_INOUT_OUT)))); }) == 0) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1324, __PRETTY_FUNCTION__, "strcmp (* (CORBA_char **)inoutArg._value, constants_STRING_INOUT_OUT) == 0"); });

 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_TypeCode_equal (outArg->_type, ((CORBA_TypeCode)&TC_CORBA_string_struct), ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1326, __PRETTY_FUNCTION__, "CORBA_TypeCode_equal (outArg->_type, TC_CORBA_string, ev)"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (* (CORBA_char **)outArg->_value) && __builtin_constant_p (constants_STRING_OUT) && (__s1_len = strlen (* (CORBA_char **)outArg->_value), __s2_len = strlen (constants_STRING_OUT), (!((size_t)(const void *)((* (CORBA_char **)outArg->_value) + 1) - (size_t)(const void *)(* (CORBA_char **)outArg->_value) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((constants_STRING_OUT) + 1) - (size_t)(const void *)(constants_STRING_OUT) == 1) || __s2_len >= 4)) ? __builtin_strcmp (* (CORBA_char **)outArg->_value, constants_STRING_OUT) : (__builtin_constant_p (* (CORBA_char **)outArg->_value) && ((size_t)(const void *)((* (CORBA_char **)outArg->_value) + 1) - (size_t)(const void *)(* (CORBA_char **)outArg->_value) == 1) && (__s1_len = strlen (* (CORBA_char **)outArg->_value), __s1_len < 4) ? (__builtin_constant_p (constants_STRING_OUT) && ((size_t)(const void *)((constants_STRING_OUT) + 1) - (size_t)(const void *)(constants_STRING_OUT) == 1) ? __builtin_strcmp (* (CORBA_char **)outArg->_value, constants_STRING_OUT) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (constants_STRING_OUT); register int __result = (((__const unsigned char *) (__const char *) (* (CORBA_char **)outArg->_value))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (* (CORBA_char **)outArg->_value))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (* (CORBA_char **)outArg->_value))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (* (CORBA_char **)outArg->_value))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (constants_STRING_OUT) && ((size_t)(const void *)((constants_STRING_OUT) + 1) - (size_t)(const void *)(constants_STRING_OUT) == 1) && (__s2_len = strlen (constants_STRING_OUT), __s2_len < 4) ? (__builtin_constant_p (* (CORBA_char **)outArg->_value) && ((size_t)(const void *)((* (CORBA_char **)outArg->_value) + 1) - (size_t)(const void *)(* (CORBA_char **)outArg->_value) == 1) ? __builtin_strcmp (* (CORBA_char **)outArg->_value, constants_STRING_OUT) : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (* (CORBA_char **)outArg->_value); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (constants_STRING_OUT))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (constants_STRING_OUT))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (constants_STRING_OUT))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (constants_STRING_OUT))[3]); } } __result; }))) : __builtin_strcmp (* (CORBA_char **)outArg->_value, constants_STRING_OUT)))); }) == 0) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1327, __PRETTY_FUNCTION__, "strcmp (* (CORBA_char **)outArg->_value, constants_STRING_OUT) == 0"); });

 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_TypeCode_equal (retn->_type, ((CORBA_TypeCode)&TC_CORBA_string_struct), ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1329, __PRETTY_FUNCTION__, "CORBA_TypeCode_equal (retn->_type, TC_CORBA_string, ev)"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (* (CORBA_char **)retn->_value) && __builtin_constant_p (constants_STRING_RETN) && (__s1_len = strlen (* (CORBA_char **)retn->_value), __s2_len = strlen (constants_STRING_RETN), (!((size_t)(const void *)((* (CORBA_char **)retn->_value) + 1) - (size_t)(const void *)(* (CORBA_char **)retn->_value) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((constants_STRING_RETN) + 1) - (size_t)(const void *)(constants_STRING_RETN) == 1) || __s2_len >= 4)) ? __builtin_strcmp (* (CORBA_char **)retn->_value, constants_STRING_RETN) : (__builtin_constant_p (* (CORBA_char **)retn->_value) && ((size_t)(const void *)((* (CORBA_char **)retn->_value) + 1) - (size_t)(const void *)(* (CORBA_char **)retn->_value) == 1) && (__s1_len = strlen (* (CORBA_char **)retn->_value), __s1_len < 4) ? (__builtin_constant_p (constants_STRING_RETN) && ((size_t)(const void *)((constants_STRING_RETN) + 1) - (size_t)(const void *)(constants_STRING_RETN) == 1) ? __builtin_strcmp (* (CORBA_char **)retn->_value, constants_STRING_RETN) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (constants_STRING_RETN); register int __result = (((__const unsigned char *) (__const char *) (* (CORBA_char **)retn->_value))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (* (CORBA_char **)retn->_value))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (* (CORBA_char **)retn->_value))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (* (CORBA_char **)retn->_value))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (constants_STRING_RETN) && ((size_t)(const void *)((constants_STRING_RETN) + 1) - (size_t)(const void *)(constants_STRING_RETN) == 1) && (__s2_len = strlen (constants_STRING_RETN), __s2_len < 4) ? (__builtin_constant_p (* (CORBA_char **)retn->_value) && ((size_t)(const void *)((* (CORBA_char **)retn->_value) + 1) - (size_t)(const void *)(* (CORBA_char **)retn->_value) == 1) ? __builtin_strcmp (* (CORBA_char **)retn->_value, constants_STRING_RETN) : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (* (CORBA_char **)retn->_value); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (constants_STRING_RETN))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (constants_STRING_RETN))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (constants_STRING_RETN))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (constants_STRING_RETN))[3]); } } __result; }))) : __builtin_strcmp (* (CORBA_char **)retn->_value, constants_STRING_RETN)))); }) == 0) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1330, __PRETTY_FUNCTION__, "strcmp (* (CORBA_char **)retn->_value, constants_STRING_RETN) == 0"); });

 if ((&inArg)->_release){
  CORBA_free (inArg._value);
  CORBA_Object_release ((CORBA_Object)inArg._type, ev);
 }

 if ((&inoutArg)->_release){
  CORBA_free (inoutArg._value);
  CORBA_Object_release ((CORBA_Object)inoutArg._type, ev);
 }

 CORBA_free (outArg);
 CORBA_free (retn);

 CORBA_Object_release (objref, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1346, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
}

static void
testAnyStrSeq (test_TestFactory factory,
        CORBA_Environment *ev)
{
 test_AnyServer objref;
 CORBA_any *retn;

 if (!thread_tests) g_print("Testing any with string sequences ...\n");

 objref = test_TestFactory_getAnyServer(factory,ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1359, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 retn = test_AnyServer_opAnyStrSeq (objref, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1362, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 CORBA_free (retn);

 CORBA_Object_release (objref, ev);
}

static void
testAnyStruct (test_TestFactory factory,
        CORBA_Environment *ev)
{
 test_AnyServer objref;
 CORBA_any inArg, inoutArg, *outArg, *retn;
 test_VariableLengthStruct inArgStruct;
 test_VariableLengthStruct * inoutArgStruct;

 if (!thread_tests) g_print("Testing any with structs...\n");

 objref = test_TestFactory_getAnyServer (factory, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1381, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 inoutArgStruct = ((test_VariableLengthStruct *)ORBit_small_alloc (((CORBA_TypeCode)&TC_test_VariableLengthStruct_struct)));
 inArgStruct.a= (CORBA_char*)constants_STRING_IN;
 inArg._type = (CORBA_TypeCode)((CORBA_TypeCode)&TC_test_VariableLengthStruct_struct);
 inArg._value = &inArgStruct;
 (&inArg)->_release = CORBA_FALSE;


 inoutArgStruct->a = CORBA_string_dup (constants_STRING_INOUT_IN);
 inoutArg._type = (CORBA_TypeCode)((CORBA_TypeCode)&TC_test_VariableLengthStruct_struct);
 inoutArg._value = inoutArgStruct;
 (&inoutArg)->_release = CORBA_TRUE;

 retn = test_AnyServer_opAnyStruct (objref, &inArg, &inoutArg, &outArg, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1396, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });


 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_TypeCode_equal (inArg._type, ((CORBA_TypeCode)&TC_test_VariableLengthStruct_struct), ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1399, __PRETTY_FUNCTION__, "CORBA_TypeCode_equal (inArg._type, TC_test_VariableLengthStruct, ev)"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p ((* (test_VariableLengthStruct*)inArg._value).a) && __builtin_constant_p (constants_STRING_IN) && (__s1_len = strlen ((* (test_VariableLengthStruct*)inArg._value).a), __s2_len = strlen (constants_STRING_IN), (!((size_t)(const void *)(((* (test_VariableLengthStruct*)inArg._value).a) + 1) - (size_t)(const void *)((* (test_VariableLengthStruct*)inArg._value).a) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((constants_STRING_IN) + 1) - (size_t)(const void *)(constants_STRING_IN) == 1) || __s2_len >= 4)) ? __builtin_strcmp ((* (test_VariableLengthStruct*)inArg._value).a, constants_STRING_IN) : (__builtin_constant_p ((* (test_VariableLengthStruct*)inArg._value).a) && ((size_t)(const void *)(((* (test_VariableLengthStruct*)inArg._value).a) + 1) - (size_t)(const void *)((* (test_VariableLengthStruct*)inArg._value).a) == 1) && (__s1_len = strlen ((* (test_VariableLengthStruct*)inArg._value).a), __s1_len < 4) ? (__builtin_constant_p (constants_STRING_IN) && ((size_t)(const void *)((constants_STRING_IN) + 1) - (size_t)(const void *)(constants_STRING_IN) == 1) ? __builtin_strcmp ((* (test_VariableLengthStruct*)inArg._value).a, constants_STRING_IN) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (constants_STRING_IN); register int __result = (((__const unsigned char *) (__const char *) ((* (test_VariableLengthStruct*)inArg._value).a))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) ((* (test_VariableLengthStruct*)inArg._value).a))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) ((* (test_VariableLengthStruct*)inArg._value).a))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) ((* (test_VariableLengthStruct*)inArg._value).a))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (constants_STRING_IN) && ((size_t)(const void *)((constants_STRING_IN) + 1) - (size_t)(const void *)(constants_STRING_IN) == 1) && (__s2_len = strlen (constants_STRING_IN), __s2_len < 4) ? (__builtin_constant_p ((* (test_VariableLengthStruct*)inArg._value).a) && ((size_t)(const void *)(((* (test_VariableLengthStruct*)inArg._value).a) + 1) - (size_t)(const void *)((* (test_VariableLengthStruct*)inArg._value).a) == 1) ? __builtin_strcmp ((* (test_VariableLengthStruct*)inArg._value).a, constants_STRING_IN) : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) ((* (test_VariableLengthStruct*)inArg._value).a); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (constants_STRING_IN))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (constants_STRING_IN))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (constants_STRING_IN))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (constants_STRING_IN))[3]); } } __result; }))) : __builtin_strcmp ((* (test_VariableLengthStruct*)inArg._value).a, constants_STRING_IN)))); }) == 0) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1400, __PRETTY_FUNCTION__, "strcmp ((* (test_VariableLengthStruct*)inArg._value).a, constants_STRING_IN) == 0"); });

 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_TypeCode_equal (inoutArg._type, ((CORBA_TypeCode)&TC_test_VariableLengthStruct_struct), ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1402, __PRETTY_FUNCTION__, "CORBA_TypeCode_equal (inoutArg._type, TC_test_VariableLengthStruct, ev)"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p ((* (test_VariableLengthStruct*)inoutArg._value).a) && __builtin_constant_p (constants_STRING_INOUT_OUT) && (__s1_len = strlen ((* (test_VariableLengthStruct*)inoutArg._value).a), __s2_len = strlen (constants_STRING_INOUT_OUT), (!((size_t)(const void *)(((* (test_VariableLengthStruct*)inoutArg._value).a) + 1) - (size_t)(const void *)((* (test_VariableLengthStruct*)inoutArg._value).a) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((constants_STRING_INOUT_OUT) + 1) - (size_t)(const void *)(constants_STRING_INOUT_OUT) == 1) || __s2_len >= 4)) ? __builtin_strcmp ((* (test_VariableLengthStruct*)inoutArg._value).a, constants_STRING_INOUT_OUT) : (__builtin_constant_p ((* (test_VariableLengthStruct*)inoutArg._value).a) && ((size_t)(const void *)(((* (test_VariableLengthStruct*)inoutArg._value).a) + 1) - (size_t)(const void *)((* (test_VariableLengthStruct*)inoutArg._value).a) == 1) && (__s1_len = strlen ((* (test_VariableLengthStruct*)inoutArg._value).a), __s1_len < 4) ? (__builtin_constant_p (constants_STRING_INOUT_OUT) && ((size_t)(const void *)((constants_STRING_INOUT_OUT) + 1) - (size_t)(const void *)(constants_STRING_INOUT_OUT) == 1) ? __builtin_strcmp ((* (test_VariableLengthStruct*)inoutArg._value).a, constants_STRING_INOUT_OUT) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (constants_STRING_INOUT_OUT); register int __result = (((__const unsigned char *) (__const char *) ((* (test_VariableLengthStruct*)inoutArg._value).a))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) ((* (test_VariableLengthStruct*)inoutArg._value).a))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) ((* (test_VariableLengthStruct*)inoutArg._value).a))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) ((* (test_VariableLengthStruct*)inoutArg._value).a))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (constants_STRING_INOUT_OUT) && ((size_t)(const void *)((constants_STRING_INOUT_OUT) + 1) - (size_t)(const void *)(constants_STRING_INOUT_OUT) == 1) && (__s2_len = strlen (constants_STRING_INOUT_OUT), __s2_len < 4) ? (__builtin_constant_p ((* (test_VariableLengthStruct*)inoutArg._value).a) && ((size_t)(const void *)(((* (test_VariableLengthStruct*)inoutArg._value).a) + 1) - (size_t)(const void *)((* (test_VariableLengthStruct*)inoutArg._value).a) == 1) ? __builtin_strcmp ((* (test_VariableLengthStruct*)inoutArg._value).a, constants_STRING_INOUT_OUT) : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) ((* (test_VariableLengthStruct*)inoutArg._value).a); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (constants_STRING_INOUT_OUT))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (constants_STRING_INOUT_OUT))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (constants_STRING_INOUT_OUT))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (constants_STRING_INOUT_OUT))[3]); } } __result; }))) : __builtin_strcmp ((* (test_VariableLengthStruct*)inoutArg._value).a, constants_STRING_INOUT_OUT)))); }) == 0) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1403, __PRETTY_FUNCTION__, "strcmp ((* (test_VariableLengthStruct*)inoutArg._value).a, constants_STRING_INOUT_OUT) == 0"); });

 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_TypeCode_equal (outArg->_type, ((CORBA_TypeCode)&TC_test_VariableLengthStruct_struct), ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1405, __PRETTY_FUNCTION__, "CORBA_TypeCode_equal (outArg->_type, TC_test_VariableLengthStruct, ev)"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p ((* (test_VariableLengthStruct*)outArg->_value).a) && __builtin_constant_p (constants_STRING_OUT) && (__s1_len = strlen ((* (test_VariableLengthStruct*)outArg->_value).a), __s2_len = strlen (constants_STRING_OUT), (!((size_t)(const void *)(((* (test_VariableLengthStruct*)outArg->_value).a) + 1) - (size_t)(const void *)((* (test_VariableLengthStruct*)outArg->_value).a) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((constants_STRING_OUT) + 1) - (size_t)(const void *)(constants_STRING_OUT) == 1) || __s2_len >= 4)) ? __builtin_strcmp ((* (test_VariableLengthStruct*)outArg->_value).a, constants_STRING_OUT) : (__builtin_constant_p ((* (test_VariableLengthStruct*)outArg->_value).a) && ((size_t)(const void *)(((* (test_VariableLengthStruct*)outArg->_value).a) + 1) - (size_t)(const void *)((* (test_VariableLengthStruct*)outArg->_value).a) == 1) && (__s1_len = strlen ((* (test_VariableLengthStruct*)outArg->_value).a), __s1_len < 4) ? (__builtin_constant_p (constants_STRING_OUT) && ((size_t)(const void *)((constants_STRING_OUT) + 1) - (size_t)(const void *)(constants_STRING_OUT) == 1) ? __builtin_strcmp ((* (test_VariableLengthStruct*)outArg->_value).a, constants_STRING_OUT) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (constants_STRING_OUT); register int __result = (((__const unsigned char *) (__const char *) ((* (test_VariableLengthStruct*)outArg->_value).a))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) ((* (test_VariableLengthStruct*)outArg->_value).a))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) ((* (test_VariableLengthStruct*)outArg->_value).a))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) ((* (test_VariableLengthStruct*)outArg->_value).a))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (constants_STRING_OUT) && ((size_t)(const void *)((constants_STRING_OUT) + 1) - (size_t)(const void *)(constants_STRING_OUT) == 1) && (__s2_len = strlen (constants_STRING_OUT), __s2_len < 4) ? (__builtin_constant_p ((* (test_VariableLengthStruct*)outArg->_value).a) && ((size_t)(const void *)(((* (test_VariableLengthStruct*)outArg->_value).a) + 1) - (size_t)(const void *)((* (test_VariableLengthStruct*)outArg->_value).a) == 1) ? __builtin_strcmp ((* (test_VariableLengthStruct*)outArg->_value).a, constants_STRING_OUT) : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) ((* (test_VariableLengthStruct*)outArg->_value).a); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (constants_STRING_OUT))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (constants_STRING_OUT))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (constants_STRING_OUT))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (constants_STRING_OUT))[3]); } } __result; }))) : __builtin_strcmp ((* (test_VariableLengthStruct*)outArg->_value).a, constants_STRING_OUT)))); }) == 0) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1406, __PRETTY_FUNCTION__, "strcmp ((* (test_VariableLengthStruct*)outArg->_value).a, constants_STRING_OUT) == 0"); });

 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_TypeCode_equal (retn->_type, ((CORBA_TypeCode)&TC_test_VariableLengthStruct_struct), ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1408, __PRETTY_FUNCTION__, "CORBA_TypeCode_equal (retn->_type, TC_test_VariableLengthStruct, ev)"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p ((* (test_VariableLengthStruct*)retn->_value).a) && __builtin_constant_p (constants_STRING_RETN) && (__s1_len = strlen ((* (test_VariableLengthStruct*)retn->_value).a), __s2_len = strlen (constants_STRING_RETN), (!((size_t)(const void *)(((* (test_VariableLengthStruct*)retn->_value).a) + 1) - (size_t)(const void *)((* (test_VariableLengthStruct*)retn->_value).a) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((constants_STRING_RETN) + 1) - (size_t)(const void *)(constants_STRING_RETN) == 1) || __s2_len >= 4)) ? __builtin_strcmp ((* (test_VariableLengthStruct*)retn->_value).a, constants_STRING_RETN) : (__builtin_constant_p ((* (test_VariableLengthStruct*)retn->_value).a) && ((size_t)(const void *)(((* (test_VariableLengthStruct*)retn->_value).a) + 1) - (size_t)(const void *)((* (test_VariableLengthStruct*)retn->_value).a) == 1) && (__s1_len = strlen ((* (test_VariableLengthStruct*)retn->_value).a), __s1_len < 4) ? (__builtin_constant_p (constants_STRING_RETN) && ((size_t)(const void *)((constants_STRING_RETN) + 1) - (size_t)(const void *)(constants_STRING_RETN) == 1) ? __builtin_strcmp ((* (test_VariableLengthStruct*)retn->_value).a, constants_STRING_RETN) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (constants_STRING_RETN); register int __result = (((__const unsigned char *) (__const char *) ((* (test_VariableLengthStruct*)retn->_value).a))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) ((* (test_VariableLengthStruct*)retn->_value).a))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) ((* (test_VariableLengthStruct*)retn->_value).a))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) ((* (test_VariableLengthStruct*)retn->_value).a))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (constants_STRING_RETN) && ((size_t)(const void *)((constants_STRING_RETN) + 1) - (size_t)(const void *)(constants_STRING_RETN) == 1) && (__s2_len = strlen (constants_STRING_RETN), __s2_len < 4) ? (__builtin_constant_p ((* (test_VariableLengthStruct*)retn->_value).a) && ((size_t)(const void *)(((* (test_VariableLengthStruct*)retn->_value).a) + 1) - (size_t)(const void *)((* (test_VariableLengthStruct*)retn->_value).a) == 1) ? __builtin_strcmp ((* (test_VariableLengthStruct*)retn->_value).a, constants_STRING_RETN) : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) ((* (test_VariableLengthStruct*)retn->_value).a); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (constants_STRING_RETN))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (constants_STRING_RETN))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (constants_STRING_RETN))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (constants_STRING_RETN))[3]); } } __result; }))) : __builtin_strcmp ((* (test_VariableLengthStruct*)retn->_value).a, constants_STRING_RETN)))); }) == 0) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1409, __PRETTY_FUNCTION__, "strcmp ((* (test_VariableLengthStruct*)retn->_value).a, constants_STRING_RETN) == 0"); });


 if ((&inArg)->_release){

  CORBA_free (inArg._value);
  CORBA_Object_release ((CORBA_Object)inArg._type, ev);
 }

 if ((&inoutArg)->_release){
  CORBA_free (inoutArg._value);
  CORBA_Object_release ((CORBA_Object)inoutArg._type, ev);
 }

 CORBA_free (outArg);
 CORBA_free (retn);

 CORBA_Object_release (objref, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1427, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

}

static void
testSequenceOfAny (test_TestFactory factory,
     CORBA_Environment *ev)
{


 test_AnySeq anyseq;
 int i;

 if (!thread_tests) g_print("Testing Sequence of Any...\n");

 anyseq._buffer = ((CORBA_any*)ORBit_small_allocbuf (((CORBA_TypeCode)&TC_CORBA_sequence_CORBA_any_struct), (2)));
 anyseq._length = 2;
 (&anyseq)->_release = CORBA_TRUE;

 for (i = 0; i < anyseq._length; i++) {
  anyseq._buffer [i]._type = (CORBA_TypeCode) ((CORBA_TypeCode)&TC_CORBA_string_struct);
  anyseq._buffer [i]._value = &constants_STRING_IN;
  (&anyseq._buffer[i])->_release = CORBA_FALSE;

 }

 CORBA_free (anyseq._buffer);
}

static void
testAnyException (test_TestFactory factory,
    CORBA_Environment *ev)
{
 CORBA_any *inArg;
 test_TestException *testex;

 if (!thread_tests) g_print("Testing Any with exception...\n");

 inArg = CORBA_any__alloc ();
 testex = ((test_TestException *)ORBit_small_alloc (((CORBA_TypeCode)&TC_test_TestException_struct)));
 inArg->_type = (CORBA_TypeCode) ((CORBA_TypeCode)&TC_test_TestException_struct);
 inArg->_value = testex;
 (inArg)->_release = CORBA_TRUE;

 CORBA_free (inArg);
}

static void
testAnyEquivalence (test_TestFactory factory,
      CORBA_Environment *ev)
{
 test_unionSeq *aseq, *bseq;
 CORBA_any *a, *b;

 if (!thread_tests) g_print("Testing Anys equivalence...\n");

 a = CORBA_any__alloc ();
 b = CORBA_any__alloc ();

 a->_type = b->_type = (CORBA_TypeCode) ((CORBA_TypeCode)&TC_test_unionSeq_struct);

 aseq = ((test_unionSeq *)ORBit_small_alloc (((CORBA_TypeCode)&TC_CORBA_sequence_test_VariableLengthUnion_struct)));
 bseq = ((test_unionSeq *)ORBit_small_alloc (((CORBA_TypeCode)&TC_CORBA_sequence_test_VariableLengthUnion_struct)));
 aseq->_length = aseq->_maximum = 3;
 bseq->_length = bseq->_maximum = 3;
 aseq->_buffer = ((test_VariableLengthUnion*)ORBit_small_allocbuf (((CORBA_TypeCode)&TC_CORBA_sequence_test_VariableLengthUnion_struct), (3)));
 bseq->_buffer = ((test_VariableLengthUnion*)ORBit_small_allocbuf (((CORBA_TypeCode)&TC_CORBA_sequence_test_VariableLengthUnion_struct), (3)));
 bseq->_release = aseq->_release = CORBA_TRUE;
 bseq->_buffer [0]._d = aseq->_buffer [0]._d = 4;
 bseq->_buffer [0]._u.z = aseq->_buffer [0]._u.z = CORBA_TRUE;
 bseq->_buffer [1]._d = aseq->_buffer [1]._d = 2;
 aseq->_buffer [1]._u.y = CORBA_string_dup ("blah");
 bseq->_buffer [1]._u.y = CORBA_string_dup ("blah");

 bseq->_buffer [2]._d = aseq->_buffer [2]._d = 55;
 bseq->_buffer [2]._u.w = aseq->_buffer [2]._u.w = 0x12345678;

 a->_value = aseq;
 b->_value = bseq;

 (a)->_release = CORBA_TRUE;
 (b)->_release = CORBA_TRUE;

 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ORBit_any_equivalent (a, b, ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1510, __PRETTY_FUNCTION__, "ORBit_any_equivalent (a, b, ev)"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1511, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 bseq->_buffer [0]._u.z = CORBA_FALSE;

 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (!ORBit_any_equivalent (a, b, ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1515, __PRETTY_FUNCTION__, "!ORBit_any_equivalent (a, b, ev)"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1516, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 CORBA_free (b);
 b = ((void *)0);
 bseq = ((void *)0);

 b = ORBit_copy_value (a, ((CORBA_TypeCode)&TC_CORBA_any_struct));

 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (b != ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1524, __PRETTY_FUNCTION__, "b != NULL"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ORBit_any_equivalent (a, b, ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1525, __PRETTY_FUNCTION__, "ORBit_any_equivalent (a, b, ev)"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1526, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 bseq = (test_unionSeq *) b->_value;
 bseq->_buffer [0]._u.z = CORBA_FALSE;

 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (!ORBit_any_equivalent (a, b, ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1531, __PRETTY_FUNCTION__, "!ORBit_any_equivalent (a, b, ev)"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1532, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 CORBA_free (a);
 CORBA_free (b);
}

static void
testTypeCode (test_TestFactory factory,
       CORBA_Environment *ev)
{
 test_AnyServer objref;
 CORBA_TypeCode inArg, inoutArg, outArg, retn;

 if (!thread_tests) g_print("Testing TypeCodes...\n");
 objref = test_TestFactory_getAnyServer (factory, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1547, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 inArg = ((CORBA_TypeCode)&TC_test_ArrayUnion_struct);
 inoutArg = ((CORBA_TypeCode)&TC_test_AnyServer_struct);

 retn = test_AnyServer_opTypeCode (objref, inArg, &inoutArg, &outArg, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1553, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_TypeCode_equal (inArg, ((CORBA_TypeCode)&TC_test_ArrayUnion_struct), ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1555, __PRETTY_FUNCTION__, "CORBA_TypeCode_equal (inArg, TC_test_ArrayUnion, ev)"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_TypeCode_equal (inoutArg, ((CORBA_TypeCode)&TC_test_TestException_struct), ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1556, __PRETTY_FUNCTION__, "CORBA_TypeCode_equal (inoutArg, TC_test_TestException, ev)"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_TypeCode_equal (outArg, ((CORBA_TypeCode)&TC_test_AnEnum_struct), ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1557, __PRETTY_FUNCTION__, "CORBA_TypeCode_equal (outArg, TC_test_AnEnum, ev)"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_TypeCode_equal (retn, ((CORBA_TypeCode)&TC_test_VariableLengthStruct_struct), ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1558, __PRETTY_FUNCTION__, "CORBA_TypeCode_equal (retn, TC_test_VariableLengthStruct, ev)"); });

 CORBA_Object_release ((CORBA_Object)inArg, ev);
 CORBA_Object_release ((CORBA_Object)inoutArg, ev);
 CORBA_Object_release ((CORBA_Object)outArg, ev);
 CORBA_Object_release ((CORBA_Object)retn, ev);

 CORBA_Object_release (objref, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1566, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
}

static void
testContext (test_TestFactory factory,
      CORBA_Environment *ev)
{
 test_ContextServer objref;
 CORBA_Object inArg, inoutArg, outArg, retn;
 CORBA_Context ctx;

 if (!thread_tests) g_print("Testing Contexts...\n");

 objref = test_TestFactory_getContextServer (factory, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1580, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 inArg = inoutArg = outArg = retn = ((void *)0);

 CORBA_Context_create_child (((void *)0), "Whatever", &ctx, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1585, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 CORBA_Context_set_one_value (ctx, "foo", "foo1", ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1588, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
 CORBA_Context_set_one_value (ctx, "foo", "foo2", ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1590, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
 CORBA_Context_set_one_value (ctx, "bar", "baaaa", ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1592, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 retn = test_ContextServer_opWithContext (
  objref, inArg, &inoutArg, &outArg, ctx, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1596, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 CORBA_Object_release (retn, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1599, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
 CORBA_Object_release (inArg, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1601, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
 CORBA_Object_release (inoutArg, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1603, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
 CORBA_Object_release (outArg, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1605, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 CORBA_Object_release ( (CORBA_Object)ctx, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1608, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 CORBA_Object_release (objref, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1611, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
}


static test_StrSeq *
make_large_str_seq (void)
{
 test_StrSeq *seq = ((test_StrSeq *)ORBit_small_alloc (((CORBA_TypeCode)&TC_CORBA_sequence_CORBA_string_struct)));
 int i;
 static const char base_data[] = "This is a longish test string it could go on for ever and ever";

 seq->_buffer = ((CORBA_string*)ORBit_small_allocbuf (((CORBA_TypeCode)&TC_CORBA_sequence_CORBA_string_struct), (4096)));

 for (i = 0; i < 4096; i++) {
  int len = 3 + (int) ((sizeof (base_data) - 3.0) * rand () / (2147483647 + 1.0));
  seq->_buffer [i] = CORBA_string_dup (base_data);
  seq->_buffer [i] [len] = '\0';
 }

 seq->_length = seq->_maximum = 4096;
 seq->_release = CORBA_TRUE;

 return seq;
}

static void
testMisc (test_TestFactory factory,
   CORBA_Environment *ev)
{
 CORBA_char *foo;
 CORBA_Context ctx;
 test_BasicServer objref;

 if (!thread_tests) g_print("Testing Misc bits...\n");

 if (!in_proc) {

  foo = test_BasicServer__get_foo (factory, ev);
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_SYSTEM_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1649, __PRETTY_FUNCTION__, "ev->_major == CORBA_SYSTEM_EXCEPTION"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (!__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (ev->_id) && __builtin_constant_p ("IDL:omg.org/CORBA/BAD_OPERATION:1.0") && (__s1_len = strlen (ev->_id), __s2_len = strlen ("IDL:omg.org/CORBA/BAD_OPERATION:1.0"), (!((size_t)(const void *)((ev->_id) + 1) - (size_t)(const void *)(ev->_id) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("IDL:omg.org/CORBA/BAD_OPERATION:1.0") + 1) - (size_t)(const void *)("IDL:omg.org/CORBA/BAD_OPERATION:1.0") == 1) || __s2_len >= 4)) ? __builtin_strcmp (ev->_id, "IDL:omg.org/CORBA/BAD_OPERATION:1.0") : (__builtin_constant_p (ev->_id) && ((size_t)(const void *)((ev->_id) + 1) - (size_t)(const void *)(ev->_id) == 1) && (__s1_len = strlen (ev->_id), __s1_len < 4) ? (__builtin_constant_p ("IDL:omg.org/CORBA/BAD_OPERATION:1.0") && ((size_t)(const void *)(("IDL:omg.org/CORBA/BAD_OPERATION:1.0") + 1) - (size_t)(const void *)("IDL:omg.org/CORBA/BAD_OPERATION:1.0") == 1) ? __builtin_strcmp (ev->_id, "IDL:omg.org/CORBA/BAD_OPERATION:1.0") : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) ("IDL:omg.org/CORBA/BAD_OPERATION:1.0"); register int __result = (((__const unsigned char *) (__const char *) (ev->_id))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (ev->_id))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (ev->_id))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (ev->_id))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("IDL:omg.org/CORBA/BAD_OPERATION:1.0") && ((size_t)(const void *)(("IDL:omg.org/CORBA/BAD_OPERATION:1.0") + 1) - (size_t)(const void *)("IDL:omg.org/CORBA/BAD_OPERATION:1.0") == 1) && (__s2_len = strlen ("IDL:omg.org/CORBA/BAD_OPERATION:1.0"), __s2_len < 4) ? (__builtin_constant_p (ev->_id) && ((size_t)(const void *)((ev->_id) + 1) - (size_t)(const void *)(ev->_id) == 1) ? __builtin_strcmp (ev->_id, "IDL:omg.org/CORBA/BAD_OPERATION:1.0") : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (ev->_id); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) ("IDL:omg.org/CORBA/BAD_OPERATION:1.0"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) ("IDL:omg.org/CORBA/BAD_OPERATION:1.0"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) ("IDL:omg.org/CORBA/BAD_OPERATION:1.0"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) ("IDL:omg.org/CORBA/BAD_OPERATION:1.0"))[3]); } } __result; }))) : __builtin_strcmp (ev->_id, "IDL:omg.org/CORBA/BAD_OPERATION:1.0")))); })) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1650, __PRETTY_FUNCTION__, "!strcmp (ev->_id, \"IDL:omg.org/CORBA/BAD_OPERATION:1.0\")"); });
  CORBA_exception_free (ev);
 }

 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ORBit_copy_value (((void *)0), ((CORBA_TypeCode)&TC_CORBA_boolean_struct)) == ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1654, __PRETTY_FUNCTION__, "ORBit_copy_value (NULL, TC_CORBA_boolean) == NULL"); });

 objref = test_TestFactory_getBasicServer (factory, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1657, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (objref != ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1658, __PRETTY_FUNCTION__, "objref != CORBA_OBJECT_NIL"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_Object_is_a (objref, "IDL:orbit/test/BasicServer:1.0", ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1659, __PRETTY_FUNCTION__, "CORBA_Object_is_a (objref, \"IDL:orbit/test/BasicServer:1.0\", ev)"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1660, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 {
  CORBA_char *ior;
  CORBA_Object o2;

  ior = CORBA_ORB_object_to_string (global_orb, factory, ev);
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1667, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

  o2 = CORBA_ORB_string_to_object (global_orb, ior, ev);
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1670, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

  CORBA_free (ior);

  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (o2 == factory) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1674, __PRETTY_FUNCTION__, "o2 == factory"); });
  CORBA_Object_release (o2, ev);
 }

 test_BasicServer_noImplement (objref, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_SYSTEM_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1679, __PRETTY_FUNCTION__, "ev->_major == CORBA_SYSTEM_EXCEPTION"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (!__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (ev->_id) && __builtin_constant_p ("IDL:omg.org/CORBA/NO_IMPLEMENT:1.0") && (__s1_len = strlen (ev->_id), __s2_len = strlen ("IDL:omg.org/CORBA/NO_IMPLEMENT:1.0"), (!((size_t)(const void *)((ev->_id) + 1) - (size_t)(const void *)(ev->_id) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("IDL:omg.org/CORBA/NO_IMPLEMENT:1.0") + 1) - (size_t)(const void *)("IDL:omg.org/CORBA/NO_IMPLEMENT:1.0") == 1) || __s2_len >= 4)) ? __builtin_strcmp (ev->_id, "IDL:omg.org/CORBA/NO_IMPLEMENT:1.0") : (__builtin_constant_p (ev->_id) && ((size_t)(const void *)((ev->_id) + 1) - (size_t)(const void *)(ev->_id) == 1) && (__s1_len = strlen (ev->_id), __s1_len < 4) ? (__builtin_constant_p ("IDL:omg.org/CORBA/NO_IMPLEMENT:1.0") && ((size_t)(const void *)(("IDL:omg.org/CORBA/NO_IMPLEMENT:1.0") + 1) - (size_t)(const void *)("IDL:omg.org/CORBA/NO_IMPLEMENT:1.0") == 1) ? __builtin_strcmp (ev->_id, "IDL:omg.org/CORBA/NO_IMPLEMENT:1.0") : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) ("IDL:omg.org/CORBA/NO_IMPLEMENT:1.0"); register int __result = (((__const unsigned char *) (__const char *) (ev->_id))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (ev->_id))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (ev->_id))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (ev->_id))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("IDL:omg.org/CORBA/NO_IMPLEMENT:1.0") && ((size_t)(const void *)(("IDL:omg.org/CORBA/NO_IMPLEMENT:1.0") + 1) - (size_t)(const void *)("IDL:omg.org/CORBA/NO_IMPLEMENT:1.0") == 1) && (__s2_len = strlen ("IDL:omg.org/CORBA/NO_IMPLEMENT:1.0"), __s2_len < 4) ? (__builtin_constant_p (ev->_id) && ((size_t)(const void *)((ev->_id) + 1) - (size_t)(const void *)(ev->_id) == 1) ? __builtin_strcmp (ev->_id, "IDL:omg.org/CORBA/NO_IMPLEMENT:1.0") : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (ev->_id); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) ("IDL:omg.org/CORBA/NO_IMPLEMENT:1.0"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) ("IDL:omg.org/CORBA/NO_IMPLEMENT:1.0"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) ("IDL:omg.org/CORBA/NO_IMPLEMENT:1.0"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) ("IDL:omg.org/CORBA/NO_IMPLEMENT:1.0"))[3]); } } __result; }))) : __builtin_strcmp (ev->_id, "IDL:omg.org/CORBA/NO_IMPLEMENT:1.0")))); })) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1680, __PRETTY_FUNCTION__, "!strcmp (ev->_id, \"IDL:omg.org/CORBA/NO_IMPLEMENT:1.0\")"); });
 CORBA_exception_free (ev);

 if (!in_proc) {
  test_StrSeq *seq;

  seq = make_large_str_seq ();
  test_BasicServer_testLargeStringSeq (objref, seq, ev);
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1688, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
  CORBA_free (seq);
 }

 CORBA_Object_release (objref, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1693, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });


 if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (((CORBA_TypeCode)&TC_test_ObjectStruct_struct)->subtypes [0]->repo_id) && __builtin_constant_p ("IDL:orbit/test/DerivedServer:1.0") && (__s1_len = strlen (((CORBA_TypeCode)&TC_test_ObjectStruct_struct)->subtypes [0]->repo_id), __s2_len = strlen ("IDL:orbit/test/DerivedServer:1.0"), (!((size_t)(const void *)((((CORBA_TypeCode)&TC_test_ObjectStruct_struct)->subtypes [0]->repo_id) + 1) - (size_t)(const void *)(((CORBA_TypeCode)&TC_test_ObjectStruct_struct)->subtypes [0]->repo_id) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("IDL:orbit/test/DerivedServer:1.0") + 1) - (size_t)(const void *)("IDL:orbit/test/DerivedServer:1.0") == 1) || __s2_len >= 4)) ? __builtin_strcmp (((CORBA_TypeCode)&TC_test_ObjectStruct_struct)->subtypes [0]->repo_id, "IDL:orbit/test/DerivedServer:1.0") : (__builtin_constant_p (((CORBA_TypeCode)&TC_test_ObjectStruct_struct)->subtypes [0]->repo_id) && ((size_t)(const void *)((((CORBA_TypeCode)&TC_test_ObjectStruct_struct)->subtypes [0]->repo_id) + 1) - (size_t)(const void *)(((CORBA_TypeCode)&TC_test_ObjectStruct_struct)->subtypes [0]->repo_id) == 1) && (__s1_len = strlen (((CORBA_TypeCode)&TC_test_ObjectStruct_struct)->subtypes [0]->repo_id), __s1_len < 4) ? (__builtin_constant_p ("IDL:orbit/test/DerivedServer:1.0") && ((size_t)(const void *)(("IDL:orbit/test/DerivedServer:1.0") + 1) - (size_t)(const void *)("IDL:orbit/test/DerivedServer:1.0") == 1) ? __builtin_strcmp (((CORBA_TypeCode)&TC_test_ObjectStruct_struct)->subtypes [0]->repo_id, "IDL:orbit/test/DerivedServer:1.0") : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) ("IDL:orbit/test/DerivedServer:1.0"); register int __result = (((__const unsigned char *) (__const char *) (((CORBA_TypeCode)&TC_test_ObjectStruct_struct)->subtypes [0]->repo_id))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (((CORBA_TypeCode)&TC_test_ObjectStruct_struct)->subtypes [0]->repo_id))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (((CORBA_TypeCode)&TC_test_ObjectStruct_struct)->subtypes [0]->repo_id))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (((CORBA_TypeCode)&TC_test_ObjectStruct_struct)->subtypes [0]->repo_id))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("IDL:orbit/test/DerivedServer:1.0") && ((size_t)(const void *)(("IDL:orbit/test/DerivedServer:1.0") + 1) - (size_t)(const void *)("IDL:orbit/test/DerivedServer:1.0") == 1) && (__s2_len = strlen ("IDL:orbit/test/DerivedServer:1.0"), __s2_len < 4) ? (__builtin_constant_p (((CORBA_TypeCode)&TC_test_ObjectStruct_struct)->subtypes [0]->repo_id) && ((size_t)(const void *)((((CORBA_TypeCode)&TC_test_ObjectStruct_struct)->subtypes [0]->repo_id) + 1) - (size_t)(const void *)(((CORBA_TypeCode)&TC_test_ObjectStruct_struct)->subtypes [0]->repo_id) == 1) ? __builtin_strcmp (((CORBA_TypeCode)&TC_test_ObjectStruct_struct)->subtypes [0]->repo_id, "IDL:orbit/test/DerivedServer:1.0") : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (((CORBA_TypeCode)&TC_test_ObjectStruct_struct)->subtypes [0]->repo_id); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) ("IDL:orbit/test/DerivedServer:1.0"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) ("IDL:orbit/test/DerivedServer:1.0"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) ("IDL:orbit/test/DerivedServer:1.0"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) ("IDL:orbit/test/DerivedServer:1.0"))[3]); } } __result; }))) : __builtin_strcmp (((CORBA_TypeCode)&TC_test_ObjectStruct_struct)->subtypes [0]->repo_id, "IDL:orbit/test/DerivedServer:1.0")))); }))

  g_log (((gchar*) 0), G_LOG_LEVEL_WARNING, "Martin's bug needs fixing");


 CORBA_exception_set (ev, CORBA_USER_EXCEPTION,
        "IDL:orbit/test/SimpleException:1.0", ((void *)0));
 CORBA_exception_free (ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_id == ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1704, __PRETTY_FUNCTION__, "ev->_id == NULL"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_any._value == ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1705, __PRETTY_FUNCTION__, "ev->_any._value == NULL"); });


 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_TypeCode_equal ( ((CORBA_TypeCode)&TC_CORBA_string_struct), ((CORBA_TypeCode)&TC_CORBA_string_struct), ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1709, __PRETTY_FUNCTION__, "CORBA_TypeCode_equal ( TC_CORBA_string, TC_CORBA_string, ev)"); });

 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1710, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (!CORBA_TypeCode_equal ( ((CORBA_TypeCode)&TC_test_StrSeq_struct), ((CORBA_TypeCode)&TC_test_AnotherStrSeq_struct), ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1712, __PRETTY_FUNCTION__, "!CORBA_TypeCode_equal ( TC_test_StrSeq, TC_test_AnotherStrSeq, ev)"); });

 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1713, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });


 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_TypeCode_equivalent ( ((CORBA_TypeCode)&TC_CORBA_string_struct), ((CORBA_TypeCode)&TC_CORBA_string_struct), ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1717, __PRETTY_FUNCTION__, "CORBA_TypeCode_equivalent ( TC_CORBA_string, TC_CORBA_string, ev)"); });

 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1718, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_TypeCode_equivalent ( ((CORBA_TypeCode)&TC_test_StrSeq_struct), ((CORBA_TypeCode)&TC_test_AnotherStrSeq_struct), ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1720, __PRETTY_FUNCTION__, "CORBA_TypeCode_equivalent ( TC_test_StrSeq, TC_test_AnotherStrSeq, ev)"); });

 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1721, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });




 if (!in_proc) {
  test_DeadReferenceObj obj;

  obj = test_TestFactory_createDeadReferenceObj (factory, ev);
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1730, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (obj != ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1731, __PRETTY_FUNCTION__, "obj != CORBA_OBJECT_NIL"); });

  test_DeadReferenceObj_test (obj, ev);
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1734, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

  CORBA_Object_release (obj, ev);
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1737, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
 } else {
  test_BasicServer obj;
  PortableServer_ObjectId *oid;
  POA_test_BasicServer *servant;

  servant = (simple_servant_new (&(BasicServer_vepv), POA_test_BasicServer__init));
  obj = create_object (global_poa, servant, ev);

  oid = PortableServer_POA_servant_to_id (
   global_poa, servant, ev);
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1748, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
  PortableServer_POA_deactivate_object (
   global_poa, oid, ev);
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1751, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

  CORBA_free (oid);

  test_BasicServer_opException (obj, ev);
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_SYSTEM_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1756, __PRETTY_FUNCTION__, "ev->_major == CORBA_SYSTEM_EXCEPTION"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (!__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (ev->_id) && __builtin_constant_p ("IDL:omg.org/CORBA/OBJECT_NOT_EXIST:1.0") && (__s1_len = strlen (ev->_id), __s2_len = strlen ("IDL:omg.org/CORBA/OBJECT_NOT_EXIST:1.0"), (!((size_t)(const void *)((ev->_id) + 1) - (size_t)(const void *)(ev->_id) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("IDL:omg.org/CORBA/OBJECT_NOT_EXIST:1.0") + 1) - (size_t)(const void *)("IDL:omg.org/CORBA/OBJECT_NOT_EXIST:1.0") == 1) || __s2_len >= 4)) ? __builtin_strcmp (ev->_id, "IDL:omg.org/CORBA/OBJECT_NOT_EXIST:1.0") : (__builtin_constant_p (ev->_id) && ((size_t)(const void *)((ev->_id) + 1) - (size_t)(const void *)(ev->_id) == 1) && (__s1_len = strlen (ev->_id), __s1_len < 4) ? (__builtin_constant_p ("IDL:omg.org/CORBA/OBJECT_NOT_EXIST:1.0") && ((size_t)(const void *)(("IDL:omg.org/CORBA/OBJECT_NOT_EXIST:1.0") + 1) - (size_t)(const void *)("IDL:omg.org/CORBA/OBJECT_NOT_EXIST:1.0") == 1) ? __builtin_strcmp (ev->_id, "IDL:omg.org/CORBA/OBJECT_NOT_EXIST:1.0") : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) ("IDL:omg.org/CORBA/OBJECT_NOT_EXIST:1.0"); register int __result = (((__const unsigned char *) (__const char *) (ev->_id))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (ev->_id))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (ev->_id))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (ev->_id))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("IDL:omg.org/CORBA/OBJECT_NOT_EXIST:1.0") && ((size_t)(const void *)(("IDL:omg.org/CORBA/OBJECT_NOT_EXIST:1.0") + 1) - (size_t)(const void *)("IDL:omg.org/CORBA/OBJECT_NOT_EXIST:1.0") == 1) && (__s2_len = strlen ("IDL:omg.org/CORBA/OBJECT_NOT_EXIST:1.0"), __s2_len < 4) ? (__builtin_constant_p (ev->_id) && ((size_t)(const void *)((ev->_id) + 1) - (size_t)(const void *)(ev->_id) == 1) ? __builtin_strcmp (ev->_id, "IDL:omg.org/CORBA/OBJECT_NOT_EXIST:1.0") : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (ev->_id); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) ("IDL:omg.org/CORBA/OBJECT_NOT_EXIST:1.0"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) ("IDL:omg.org/CORBA/OBJECT_NOT_EXIST:1.0"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) ("IDL:omg.org/CORBA/OBJECT_NOT_EXIST:1.0"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) ("IDL:omg.org/CORBA/OBJECT_NOT_EXIST:1.0"))[3]); } } __result; }))) : __builtin_strcmp (ev->_id, "IDL:omg.org/CORBA/OBJECT_NOT_EXIST:1.0")))); })) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1757, __PRETTY_FUNCTION__, "!strcmp (ev->_id, ex_CORBA_OBJECT_NOT_EXIST)"); });
  CORBA_exception_free (ev);

  test_BasicServer_opOneWay (obj, "Foo", ev);
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_SYSTEM_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1761, __PRETTY_FUNCTION__, "ev->_major == CORBA_SYSTEM_EXCEPTION"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (!__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (ev->_id) && __builtin_constant_p ("IDL:omg.org/CORBA/OBJECT_NOT_EXIST:1.0") && (__s1_len = strlen (ev->_id), __s2_len = strlen ("IDL:omg.org/CORBA/OBJECT_NOT_EXIST:1.0"), (!((size_t)(const void *)((ev->_id) + 1) - (size_t)(const void *)(ev->_id) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("IDL:omg.org/CORBA/OBJECT_NOT_EXIST:1.0") + 1) - (size_t)(const void *)("IDL:omg.org/CORBA/OBJECT_NOT_EXIST:1.0") == 1) || __s2_len >= 4)) ? __builtin_strcmp (ev->_id, "IDL:omg.org/CORBA/OBJECT_NOT_EXIST:1.0") : (__builtin_constant_p (ev->_id) && ((size_t)(const void *)((ev->_id) + 1) - (size_t)(const void *)(ev->_id) == 1) && (__s1_len = strlen (ev->_id), __s1_len < 4) ? (__builtin_constant_p ("IDL:omg.org/CORBA/OBJECT_NOT_EXIST:1.0") && ((size_t)(const void *)(("IDL:omg.org/CORBA/OBJECT_NOT_EXIST:1.0") + 1) - (size_t)(const void *)("IDL:omg.org/CORBA/OBJECT_NOT_EXIST:1.0") == 1) ? __builtin_strcmp (ev->_id, "IDL:omg.org/CORBA/OBJECT_NOT_EXIST:1.0") : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) ("IDL:omg.org/CORBA/OBJECT_NOT_EXIST:1.0"); register int __result = (((__const unsigned char *) (__const char *) (ev->_id))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (ev->_id))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (ev->_id))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (ev->_id))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("IDL:omg.org/CORBA/OBJECT_NOT_EXIST:1.0") && ((size_t)(const void *)(("IDL:omg.org/CORBA/OBJECT_NOT_EXIST:1.0") + 1) - (size_t)(const void *)("IDL:omg.org/CORBA/OBJECT_NOT_EXIST:1.0") == 1) && (__s2_len = strlen ("IDL:omg.org/CORBA/OBJECT_NOT_EXIST:1.0"), __s2_len < 4) ? (__builtin_constant_p (ev->_id) && ((size_t)(const void *)((ev->_id) + 1) - (size_t)(const void *)(ev->_id) == 1) ? __builtin_strcmp (ev->_id, "IDL:omg.org/CORBA/OBJECT_NOT_EXIST:1.0") : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (ev->_id); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) ("IDL:omg.org/CORBA/OBJECT_NOT_EXIST:1.0"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) ("IDL:omg.org/CORBA/OBJECT_NOT_EXIST:1.0"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) ("IDL:omg.org/CORBA/OBJECT_NOT_EXIST:1.0"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) ("IDL:omg.org/CORBA/OBJECT_NOT_EXIST:1.0"))[3]); } } __result; }))) : __builtin_strcmp (ev->_id, "IDL:omg.org/CORBA/OBJECT_NOT_EXIST:1.0")))); })) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1762, __PRETTY_FUNCTION__, "!strcmp (ev->_id, ex_CORBA_OBJECT_NOT_EXIST)"); });
  CORBA_exception_free (ev);

  CORBA_Object_release (obj, ev);
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1766, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
 }


 CORBA_ORB_get_default_context (
  global_orb, &ctx, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1772, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ctx != ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1773, __PRETTY_FUNCTION__, "ctx != CORBA_OBJECT_NIL"); });
 CORBA_Object_release ((CORBA_Object) ctx, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1775, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });


 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ORBit_small_get_servant (((void *)0)) == ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1778, __PRETTY_FUNCTION__, "ORBit_small_get_servant (NULL) == NULL"); });
 if (in_proc) {
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ORBit_small_get_servant (factory)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1780, __PRETTY_FUNCTION__, "ORBit_small_get_servant (factory)"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ORBit_small_get_connection_status (factory) == ORBIT_CONNECTION_IN_PROC) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1782, __PRETTY_FUNCTION__, "ORBit_small_get_connection_status (factory) == ORBIT_CONNECTION_IN_PROC"); });

 } else {
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (!ORBit_small_get_servant (factory)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1784, __PRETTY_FUNCTION__, "!ORBit_small_get_servant (factory)"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ORBit_small_get_connection_status (factory) == ORBIT_CONNECTION_CONNECTED) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1786, __PRETTY_FUNCTION__, "ORBit_small_get_connection_status (factory) == ORBIT_CONNECTION_CONNECTED"); });

 }
}

static void
testIOR (test_TestFactory factory,
  CORBA_Environment *ev)
{
 int i, count;
 CORBA_Object objref;

 if (!thread_tests) g_print("Testing IOR marshalling ...\n");

 objref = test_TestFactory_getBasicServer (factory, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1800, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });


 count = test_BasicServer_getObjectCount (objref, ev);
 for (i = 0; i < count; i++)
 {
  CORBA_Object test_obj;
  test_obj = test_BasicServer_getObject (objref, i, ev);
  if (ev->_major != CORBA_NO_EXCEPTION)
   g_log (((gchar*) 0), G_LOG_LEVEL_ERROR, "Error demarshalling object number %d: %s", i, CORBA_exception_id (ev));

 }

 CORBA_Object_release (objref, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1814, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
}

static void
testLifeCycle (test_TestFactory factory,
        CORBA_Environment *ev)
{
 test_LifeCycleServer objref;
 ORBit_IMethod *method;

 if (!thread_tests) g_print("Testing LifeCycle bits...\n");

 objref = test_TestFactory_createLifeCycleServer (factory, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1827, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 if (!thread_tests) g_print(" pre gnome 2.4 stubs ...\n");

 if (in_proc) {
  method = &test_LifeCycleServer__iinterface.methods._buffer[1];
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (!__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (method->name) && __builtin_constant_p ("deactivateUnrefOnReturn") && (__s1_len = strlen (method->name), __s2_len = strlen ("deactivateUnrefOnReturn"), (!((size_t)(const void *)((method->name) + 1) - (size_t)(const void *)(method->name) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("deactivateUnrefOnReturn") + 1) - (size_t)(const void *)("deactivateUnrefOnReturn") == 1) || __s2_len >= 4)) ? __builtin_strcmp (method->name, "deactivateUnrefOnReturn") : (__builtin_constant_p (method->name) && ((size_t)(const void *)((method->name) + 1) - (size_t)(const void *)(method->name) == 1) && (__s1_len = strlen (method->name), __s1_len < 4) ? (__builtin_constant_p ("deactivateUnrefOnReturn") && ((size_t)(const void *)(("deactivateUnrefOnReturn") + 1) - (size_t)(const void *)("deactivateUnrefOnReturn") == 1) ? __builtin_strcmp (method->name, "deactivateUnrefOnReturn") : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) ("deactivateUnrefOnReturn"); register int __result = (((__const unsigned char *) (__const char *) (method->name))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (method->name))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (method->name))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (method->name))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("deactivateUnrefOnReturn") && ((size_t)(const void *)(("deactivateUnrefOnReturn") + 1) - (size_t)(const void *)("deactivateUnrefOnReturn") == 1) && (__s2_len = strlen ("deactivateUnrefOnReturn"), __s2_len < 4) ? (__builtin_constant_p (method->name) && ((size_t)(const void *)((method->name) + 1) - (size_t)(const void *)(method->name) == 1) ? __builtin_strcmp (method->name, "deactivateUnrefOnReturn") : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (method->name); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) ("deactivateUnrefOnReturn"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) ("deactivateUnrefOnReturn"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) ("deactivateUnrefOnReturn"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) ("deactivateUnrefOnReturn"))[3]); } } __result; }))) : __builtin_strcmp (method->name, "deactivateUnrefOnReturn")))); })) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1833, __PRETTY_FUNCTION__, "!strcmp (method->name, \"deactivateUnrefOnReturn\")"); });
 } else {
  method = &test_LifeCycleServer__iinterface.methods._buffer[0];
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (!__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (method->name) && __builtin_constant_p ("deactivateOnReturn") && (__s1_len = strlen (method->name), __s2_len = strlen ("deactivateOnReturn"), (!((size_t)(const void *)((method->name) + 1) - (size_t)(const void *)(method->name) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("deactivateOnReturn") + 1) - (size_t)(const void *)("deactivateOnReturn") == 1) || __s2_len >= 4)) ? __builtin_strcmp (method->name, "deactivateOnReturn") : (__builtin_constant_p (method->name) && ((size_t)(const void *)((method->name) + 1) - (size_t)(const void *)(method->name) == 1) && (__s1_len = strlen (method->name), __s1_len < 4) ? (__builtin_constant_p ("deactivateOnReturn") && ((size_t)(const void *)(("deactivateOnReturn") + 1) - (size_t)(const void *)("deactivateOnReturn") == 1) ? __builtin_strcmp (method->name, "deactivateOnReturn") : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) ("deactivateOnReturn"); register int __result = (((__const unsigned char *) (__const char *) (method->name))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (method->name))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (method->name))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (method->name))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("deactivateOnReturn") && ((size_t)(const void *)(("deactivateOnReturn") + 1) - (size_t)(const void *)("deactivateOnReturn") == 1) && (__s2_len = strlen ("deactivateOnReturn"), __s2_len < 4) ? (__builtin_constant_p (method->name) && ((size_t)(const void *)((method->name) + 1) - (size_t)(const void *)(method->name) == 1) ? __builtin_strcmp (method->name, "deactivateOnReturn") : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (method->name); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) ("deactivateOnReturn"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) ("deactivateOnReturn"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) ("deactivateOnReturn"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) ("deactivateOnReturn"))[3]); } } __result; }))) : __builtin_strcmp (method->name, "deactivateOnReturn")))); })) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1836, __PRETTY_FUNCTION__, "!strcmp (method->name, \"deactivateOnReturn\")"); });
 }

 ORBit_small_invoke_stub (objref, method, ((void *)0), ((void *)0), ((void *)0), ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1840, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 if (!in_proc)
  CORBA_Object_release (objref, ev);

 if (!thread_tests) g_print(" post gnome 2.4 stubs ...\n");

 objref = test_TestFactory_createLifeCycleServer (factory, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1848, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 test_LifeCycleServer_deactivateOnReturn (objref, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1851, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 CORBA_Object_release (objref, ev);
}

static volatile int done = 0;

static void
test_BasicServer_opExceptionA_cb (CORBA_Object object,
      ORBit_IMethod *m_data,
      ORBitAsyncQueueEntry *aqe,
      gpointer user_data,
      CORBA_Environment *ev)
{
 test_TestException *ex;


 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1868, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 ORBit_small_demarshal_async (aqe, ((void *)0), ((void *)0), ev);

 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_USER_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1872, __PRETTY_FUNCTION__, "ev->_major == CORBA_USER_EXCEPTION"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (CORBA_exception_id (ev)) && __builtin_constant_p ("IDL:orbit/test/TestException:1.0") && (__s1_len = strlen (CORBA_exception_id (ev)), __s2_len = strlen ("IDL:orbit/test/TestException:1.0"), (!((size_t)(const void *)((CORBA_exception_id (ev)) + 1) - (size_t)(const void *)(CORBA_exception_id (ev)) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("IDL:orbit/test/TestException:1.0") + 1) - (size_t)(const void *)("IDL:orbit/test/TestException:1.0") == 1) || __s2_len >= 4)) ? __builtin_strcmp (CORBA_exception_id (ev), "IDL:orbit/test/TestException:1.0") : (__builtin_constant_p (CORBA_exception_id (ev)) && ((size_t)(const void *)((CORBA_exception_id (ev)) + 1) - (size_t)(const void *)(CORBA_exception_id (ev)) == 1) && (__s1_len = strlen (CORBA_exception_id (ev)), __s1_len < 4) ? (__builtin_constant_p ("IDL:orbit/test/TestException:1.0") && ((size_t)(const void *)(("IDL:orbit/test/TestException:1.0") + 1) - (size_t)(const void *)("IDL:orbit/test/TestException:1.0") == 1) ? __builtin_strcmp (CORBA_exception_id (ev), "IDL:orbit/test/TestException:1.0") : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) ("IDL:orbit/test/TestException:1.0"); register int __result = (((__const unsigned char *) (__const char *) (CORBA_exception_id (ev)))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (CORBA_exception_id (ev)))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (CORBA_exception_id (ev)))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (CORBA_exception_id (ev)))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("IDL:orbit/test/TestException:1.0") && ((size_t)(const void *)(("IDL:orbit/test/TestException:1.0") + 1) - (size_t)(const void *)("IDL:orbit/test/TestException:1.0") == 1) && (__s2_len = strlen ("IDL:orbit/test/TestException:1.0"), __s2_len < 4) ? (__builtin_constant_p (CORBA_exception_id (ev)) && ((size_t)(const void *)((CORBA_exception_id (ev)) + 1) - (size_t)(const void *)(CORBA_exception_id (ev)) == 1) ? __builtin_strcmp (CORBA_exception_id (ev), "IDL:orbit/test/TestException:1.0") : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (CORBA_exception_id (ev)); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) ("IDL:orbit/test/TestException:1.0"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) ("IDL:orbit/test/TestException:1.0"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) ("IDL:orbit/test/TestException:1.0"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) ("IDL:orbit/test/TestException:1.0"))[3]); } } __result; }))) : __builtin_strcmp (CORBA_exception_id (ev), "IDL:orbit/test/TestException:1.0")))); }) == 0) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1873, __PRETTY_FUNCTION__, "strcmp (CORBA_exception_id (ev), ex_test_TestException) == 0"); });

 ex = CORBA_exception_value (ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (ex->reason) && __builtin_constant_p (constants_STRING_IN) && (__s1_len = strlen (ex->reason), __s2_len = strlen (constants_STRING_IN), (!((size_t)(const void *)((ex->reason) + 1) - (size_t)(const void *)(ex->reason) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((constants_STRING_IN) + 1) - (size_t)(const void *)(constants_STRING_IN) == 1) || __s2_len >= 4)) ? __builtin_strcmp (ex->reason, constants_STRING_IN) : (__builtin_constant_p (ex->reason) && ((size_t)(const void *)((ex->reason) + 1) - (size_t)(const void *)(ex->reason) == 1) && (__s1_len = strlen (ex->reason), __s1_len < 4) ? (__builtin_constant_p (constants_STRING_IN) && ((size_t)(const void *)((constants_STRING_IN) + 1) - (size_t)(const void *)(constants_STRING_IN) == 1) ? __builtin_strcmp (ex->reason, constants_STRING_IN) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (constants_STRING_IN); register int __result = (((__const unsigned char *) (__const char *) (ex->reason))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (ex->reason))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (ex->reason))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (ex->reason))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (constants_STRING_IN) && ((size_t)(const void *)((constants_STRING_IN) + 1) - (size_t)(const void *)(constants_STRING_IN) == 1) && (__s2_len = strlen (constants_STRING_IN), __s2_len < 4) ? (__builtin_constant_p (ex->reason) && ((size_t)(const void *)((ex->reason) + 1) - (size_t)(const void *)(ex->reason) == 1) ? __builtin_strcmp (ex->reason, constants_STRING_IN) : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (ex->reason); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (constants_STRING_IN))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (constants_STRING_IN))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (constants_STRING_IN))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (constants_STRING_IN))[3]); } } __result; }))) : __builtin_strcmp (ex->reason, constants_STRING_IN)))); }) == 0) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1876, __PRETTY_FUNCTION__, "strcmp (ex->reason, constants_STRING_IN) == 0"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ex->number == 0x12345678) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1877, __PRETTY_FUNCTION__, "ex->number == constants_LONG_IN"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ex->aseq._length == 1) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1878, __PRETTY_FUNCTION__, "ex->aseq._length == 1"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ex->aseq._buffer[0] == 0x12345678) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1879, __PRETTY_FUNCTION__, "ex->aseq._buffer[0] == constants_LONG_IN"); });

 done = 1;
}


static void
test_BasicServer_opExceptionA (CORBA_Object obj,
          CORBA_Environment *ev)
{
 ORBit_IMethod *m_data;

 m_data = &test_BasicServer__iinterface.methods._buffer [(test_BasicServer_opException__imethods_index)];

 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (!__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (m_data->name) && __builtin_constant_p ("opException") && (__s1_len = strlen (m_data->name), __s2_len = strlen ("opException"), (!((size_t)(const void *)((m_data->name) + 1) - (size_t)(const void *)(m_data->name) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("opException") + 1) - (size_t)(const void *)("opException") == 1) || __s2_len >= 4)) ? __builtin_strcmp (m_data->name, "opException") : (__builtin_constant_p (m_data->name) && ((size_t)(const void *)((m_data->name) + 1) - (size_t)(const void *)(m_data->name) == 1) && (__s1_len = strlen (m_data->name), __s1_len < 4) ? (__builtin_constant_p ("opException") && ((size_t)(const void *)(("opException") + 1) - (size_t)(const void *)("opException") == 1) ? __builtin_strcmp (m_data->name, "opException") : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) ("opException"); register int __result = (((__const unsigned char *) (__const char *) (m_data->name))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (m_data->name))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (m_data->name))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (m_data->name))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("opException") && ((size_t)(const void *)(("opException") + 1) - (size_t)(const void *)("opException") == 1) && (__s2_len = strlen ("opException"), __s2_len < 4) ? (__builtin_constant_p (m_data->name) && ((size_t)(const void *)((m_data->name) + 1) - (size_t)(const void *)(m_data->name) == 1) ? __builtin_strcmp (m_data->name, "opException") : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (m_data->name); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) ("opException"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) ("opException"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) ("opException"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) ("opException"))[3]); } } __result; }))) : __builtin_strcmp (m_data->name, "opException")))); })) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1893, __PRETTY_FUNCTION__, "!strcmp (m_data->name, \"opException\")"); });

 ORBit_small_invoke_async (
  obj, m_data, test_BasicServer_opExceptionA_cb,
  ((void *)0), ((void *)0), ((void *)0), ev);
}

static void
test_BasicServer_opStringA_cb (CORBA_Object object,
          ORBit_IMethod *m_data,
          ORBitAsyncQueueEntry *aqe,
          gpointer user_data,
          CORBA_Environment *ev)
{
 CORBA_char *inout_str = ((void *)0), *out_str, *ret_str;
 CORBA_char **out_str_shim = &out_str;

 gpointer args[3];
 gpointer ret = &ret_str;

 args[0] = ((void *)0);
 args[1] = &inout_str;
 args[2] = &out_str_shim;


 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1918, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 ORBit_small_demarshal_async (aqe, ret, args, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1921, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (!__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (inout_str) && __builtin_constant_p (constants_STRING_INOUT_OUT) && (__s1_len = strlen (inout_str), __s2_len = strlen (constants_STRING_INOUT_OUT), (!((size_t)(const void *)((inout_str) + 1) - (size_t)(const void *)(inout_str) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((constants_STRING_INOUT_OUT) + 1) - (size_t)(const void *)(constants_STRING_INOUT_OUT) == 1) || __s2_len >= 4)) ? __builtin_strcmp (inout_str, constants_STRING_INOUT_OUT) : (__builtin_constant_p (inout_str) && ((size_t)(const void *)((inout_str) + 1) - (size_t)(const void *)(inout_str) == 1) && (__s1_len = strlen (inout_str), __s1_len < 4) ? (__builtin_constant_p (constants_STRING_INOUT_OUT) && ((size_t)(const void *)((constants_STRING_INOUT_OUT) + 1) - (size_t)(const void *)(constants_STRING_INOUT_OUT) == 1) ? __builtin_strcmp (inout_str, constants_STRING_INOUT_OUT) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (constants_STRING_INOUT_OUT); register int __result = (((__const unsigned char *) (__const char *) (inout_str))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (inout_str))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (inout_str))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (inout_str))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (constants_STRING_INOUT_OUT) && ((size_t)(const void *)((constants_STRING_INOUT_OUT) + 1) - (size_t)(const void *)(constants_STRING_INOUT_OUT) == 1) && (__s2_len = strlen (constants_STRING_INOUT_OUT), __s2_len < 4) ? (__builtin_constant_p (inout_str) && ((size_t)(const void *)((inout_str) + 1) - (size_t)(const void *)(inout_str) == 1) ? __builtin_strcmp (inout_str, constants_STRING_INOUT_OUT) : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (inout_str); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (constants_STRING_INOUT_OUT))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (constants_STRING_INOUT_OUT))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (constants_STRING_INOUT_OUT))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (constants_STRING_INOUT_OUT))[3]); } } __result; }))) : __builtin_strcmp (inout_str, constants_STRING_INOUT_OUT)))); })) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1923, __PRETTY_FUNCTION__, "!strcmp (inout_str, constants_STRING_INOUT_OUT)"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (!__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (out_str) && __builtin_constant_p (constants_STRING_OUT) && (__s1_len = strlen (out_str), __s2_len = strlen (constants_STRING_OUT), (!((size_t)(const void *)((out_str) + 1) - (size_t)(const void *)(out_str) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((constants_STRING_OUT) + 1) - (size_t)(const void *)(constants_STRING_OUT) == 1) || __s2_len >= 4)) ? __builtin_strcmp (out_str, constants_STRING_OUT) : (__builtin_constant_p (out_str) && ((size_t)(const void *)((out_str) + 1) - (size_t)(const void *)(out_str) == 1) && (__s1_len = strlen (out_str), __s1_len < 4) ? (__builtin_constant_p (constants_STRING_OUT) && ((size_t)(const void *)((constants_STRING_OUT) + 1) - (size_t)(const void *)(constants_STRING_OUT) == 1) ? __builtin_strcmp (out_str, constants_STRING_OUT) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (constants_STRING_OUT); register int __result = (((__const unsigned char *) (__const char *) (out_str))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (out_str))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (out_str))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (out_str))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (constants_STRING_OUT) && ((size_t)(const void *)((constants_STRING_OUT) + 1) - (size_t)(const void *)(constants_STRING_OUT) == 1) && (__s2_len = strlen (constants_STRING_OUT), __s2_len < 4) ? (__builtin_constant_p (out_str) && ((size_t)(const void *)((out_str) + 1) - (size_t)(const void *)(out_str) == 1) ? __builtin_strcmp (out_str, constants_STRING_OUT) : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (out_str); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (constants_STRING_OUT))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (constants_STRING_OUT))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (constants_STRING_OUT))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (constants_STRING_OUT))[3]); } } __result; }))) : __builtin_strcmp (out_str, constants_STRING_OUT)))); })) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1924, __PRETTY_FUNCTION__, "!strcmp (out_str, constants_STRING_OUT)"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (!__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (ret_str) && __builtin_constant_p (constants_STRING_RETN) && (__s1_len = strlen (ret_str), __s2_len = strlen (constants_STRING_RETN), (!((size_t)(const void *)((ret_str) + 1) - (size_t)(const void *)(ret_str) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((constants_STRING_RETN) + 1) - (size_t)(const void *)(constants_STRING_RETN) == 1) || __s2_len >= 4)) ? __builtin_strcmp (ret_str, constants_STRING_RETN) : (__builtin_constant_p (ret_str) && ((size_t)(const void *)((ret_str) + 1) - (size_t)(const void *)(ret_str) == 1) && (__s1_len = strlen (ret_str), __s1_len < 4) ? (__builtin_constant_p (constants_STRING_RETN) && ((size_t)(const void *)((constants_STRING_RETN) + 1) - (size_t)(const void *)(constants_STRING_RETN) == 1) ? __builtin_strcmp (ret_str, constants_STRING_RETN) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (constants_STRING_RETN); register int __result = (((__const unsigned char *) (__const char *) (ret_str))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (ret_str))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (ret_str))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (ret_str))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (constants_STRING_RETN) && ((size_t)(const void *)((constants_STRING_RETN) + 1) - (size_t)(const void *)(constants_STRING_RETN) == 1) && (__s2_len = strlen (constants_STRING_RETN), __s2_len < 4) ? (__builtin_constant_p (ret_str) && ((size_t)(const void *)((ret_str) + 1) - (size_t)(const void *)(ret_str) == 1) ? __builtin_strcmp (ret_str, constants_STRING_RETN) : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (ret_str); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (constants_STRING_RETN))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (constants_STRING_RETN))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (constants_STRING_RETN))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (constants_STRING_RETN))[3]); } } __result; }))) : __builtin_strcmp (ret_str, constants_STRING_RETN)))); })) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1925, __PRETTY_FUNCTION__, "!strcmp (ret_str, constants_STRING_RETN)"); });

 CORBA_free (inout_str);
 CORBA_free (out_str);
 CORBA_free (ret_str);

 done = 1;
}

static void
test_BasicServer_opStringA (CORBA_Object obj,
       const CORBA_char *in_str,
       const CORBA_char *inout_str,
       CORBA_Environment *ev)
{
 gpointer args[3];
 ORBit_IMethod *m_data;

 args[0] = &in_str;
 args[1] = &inout_str;
 args[2] = ((void *)0);

 m_data = &test_BasicServer__iinterface.methods._buffer[(test_BasicServer_opString__imethods_index)];

 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (!__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (m_data->name) && __builtin_constant_p ("opString") && (__s1_len = strlen (m_data->name), __s2_len = strlen ("opString"), (!((size_t)(const void *)((m_data->name) + 1) - (size_t)(const void *)(m_data->name) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("opString") + 1) - (size_t)(const void *)("opString") == 1) || __s2_len >= 4)) ? __builtin_strcmp (m_data->name, "opString") : (__builtin_constant_p (m_data->name) && ((size_t)(const void *)((m_data->name) + 1) - (size_t)(const void *)(m_data->name) == 1) && (__s1_len = strlen (m_data->name), __s1_len < 4) ? (__builtin_constant_p ("opString") && ((size_t)(const void *)(("opString") + 1) - (size_t)(const void *)("opString") == 1) ? __builtin_strcmp (m_data->name, "opString") : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) ("opString"); register int __result = (((__const unsigned char *) (__const char *) (m_data->name))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (m_data->name))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (m_data->name))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (m_data->name))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("opString") && ((size_t)(const void *)(("opString") + 1) - (size_t)(const void *)("opString") == 1) && (__s2_len = strlen ("opString"), __s2_len < 4) ? (__builtin_constant_p (m_data->name) && ((size_t)(const void *)((m_data->name) + 1) - (size_t)(const void *)(m_data->name) == 1) ? __builtin_strcmp (m_data->name, "opString") : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (m_data->name); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) ("opString"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) ("opString"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) ("opString"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) ("opString"))[3]); } } __result; }))) : __builtin_strcmp (m_data->name, "opString")))); })) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1949, __PRETTY_FUNCTION__, "!strcmp (m_data->name, \"opString\")"); });

 ORBit_small_invoke_async (
  obj, m_data, test_BasicServer_opStringA_cb,
  ((void *)0), args, ((void *)0), ev);
}

static void
wait_until_done (void)
{
 while (!done)
  g_main_context_iteration (((void *)0), (!(0)));
}

static void
testAsync (test_TestFactory factory,
    CORBA_Environment *ev)
{
 test_BasicServer objref;

 if (!thread_tests) g_print("Testing Async invocations ...\n");
 objref = test_TestFactory_getBasicServer (factory, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1971, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 if (in_proc) {
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (objref->profile_list == ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1974, __PRETTY_FUNCTION__, "objref->profile_list == NULL"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ORBit_small_get_connection_ref (objref) == ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1975, __PRETTY_FUNCTION__, "ORBit_small_get_connection_ref (objref) == NULL"); });
 }

 done = 0;
 test_BasicServer_opStringA (
  objref, constants_STRING_IN,
  constants_STRING_INOUT_IN, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1982, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });


 testString (objref, ev);

 wait_until_done ();

 done = 0;
 test_BasicServer_opExceptionA (objref, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1991, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 wait_until_done ();

 CORBA_Object_release (objref, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 1996, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
}

static void
broken_cb (LinkConnection *connection, gboolean *broken)
{
 *broken = (!(0));
}

static void
testPingPong (test_TestFactory factory,
       gboolean thread_tests,
       CORBA_Environment *ev)
{
 test_PingPongServer r_objref, l_objref, objref;
 CORBA_unsigned_long before_remote_hash;
 CORBA_unsigned_long after_remote_hash;


 if (thread_tests) {
  static volatile int warned = 0;
  if (!warned++)
   g_log (((gchar*) 0), G_LOG_LEVEL_WARNING, "No thread available to handle incoming requests");
  return;
 }


 if (!thread_tests) g_print("Testing ping pong invocations ...\n");
 r_objref = test_TestFactory_createPingPongServer (factory, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2025, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 l_objref = TestFactory_createPingPongServer (((void *)0), ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2028, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
 CORBA_Object_release (l_objref, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ORBit_small_get_servant (l_objref) != ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2030, __PRETTY_FUNCTION__, "ORBit_small_get_servant (l_objref) != NULL"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2031, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 before_remote_hash = CORBA_Object_hash (l_objref, 0, ev);


 test_PingPongServer_pingPong (r_objref, l_objref, 64, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2037, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 if (!thread_tests) g_print("Testing ping pong reg / lookup ...\n");
 test_PingPongServer_set (r_objref, l_objref, "Foo", ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2041, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 objref = test_PingPongServer_get (r_objref, "Foo", ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2044, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ORBit_small_get_servant (objref) != ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2045, __PRETTY_FUNCTION__, "ORBit_small_get_servant (objref) != NULL"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (l_objref == objref) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2046, __PRETTY_FUNCTION__, "l_objref == objref"); });

 after_remote_hash = CORBA_Object_hash (l_objref, 0, ev);

 if (!thread_tests) g_print("Testing hashing\n");
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (before_remote_hash == after_remote_hash) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2051, __PRETTY_FUNCTION__, "before_remote_hash == after_remote_hash"); });

 if (!thread_tests) g_print("Testing equivalence\n");
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_Object_is_equivalent ( l_objref, objref, ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2055, __PRETTY_FUNCTION__, "CORBA_Object_is_equivalent ( l_objref, objref, ev)"); });

 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_Object_is_equivalent ( ((void *)0), ((void *)0), ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2057, __PRETTY_FUNCTION__, "CORBA_Object_is_equivalent ( CORBA_OBJECT_NIL, CORBA_OBJECT_NIL, ev)"); });

 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_Object_is_equivalent ( l_objref, l_objref, ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2059, __PRETTY_FUNCTION__, "CORBA_Object_is_equivalent ( l_objref, l_objref, ev)"); });

 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_Object_is_equivalent ( r_objref, r_objref, ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2061, __PRETTY_FUNCTION__, "CORBA_Object_is_equivalent ( r_objref, r_objref, ev)"); });

 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (!CORBA_Object_is_equivalent ( r_objref, l_objref, ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2063, __PRETTY_FUNCTION__, "!CORBA_Object_is_equivalent ( r_objref, l_objref, ev)"); });

 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (!CORBA_Object_is_equivalent ( l_objref, r_objref, ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2065, __PRETTY_FUNCTION__, "!CORBA_Object_is_equivalent ( l_objref, r_objref, ev)"); });

 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (!CORBA_Object_is_equivalent ( l_objref, ((void *)0), ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2067, __PRETTY_FUNCTION__, "!CORBA_Object_is_equivalent ( l_objref, CORBA_OBJECT_NIL, ev)"); });

 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (!CORBA_Object_is_equivalent ( ((void *)0), l_objref, ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2069, __PRETTY_FUNCTION__, "!CORBA_Object_is_equivalent ( CORBA_OBJECT_NIL, l_objref, ev)"); });
# 2085 "client.c"
 if (!in_proc) {
  int i;
  ORBitConnection *cnx = ORBit_small_get_connection_ref (r_objref);
  const char *base =
   "This string is in order to provide some "
   "more bulky data on the wire, the larger "
   "the better. When the socket buffer fills "
   "we start exercising the linc buffering code "
   "and hopefully we get an exception somewhere "
   "indicating that the buffer is full and that "
   "the write has failed & that the connection is "
   "now saturated ";
  char *str;
  gboolean broken = (0);

  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (cnx != ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2100, __PRETTY_FUNCTION__, "cnx != NULL"); });
  ORBit_connection_set_max_buffer (cnx, 10000);

  str = g_strdup (base);
  for (i = 0; i < 4; i++) {
   char *new;
   new = g_strconcat (str, str, ((void *)0));
   g_free (str);
   str = new;
  }

  if (!thread_tests) g_print("Testing non blocking IO ...\n");

  ORBit_small_listen_for_broken (
   r_objref, ((GCallback) (broken_cb)),
   &broken);

  for (i = 0; i < 100; i++) {
   test_PingPongServer_opSleep (
    r_objref, str, ev);
   if (broken)
    break;
  }

  g_free (str);




  CORBA_exception_free (ev);
  ORBit_small_connection_unref (cnx);

  ORBit_connection_set_max_buffer (cnx, 0);
 }

 CORBA_Object_release (objref, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2136, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 CORBA_Object_release (l_objref, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2139, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 CORBA_Object_release (r_objref, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2142, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
}

static void
testPolicy (test_TestFactory factory,
     gboolean thread_tests,
     CORBA_Environment *ev)
{
 ORBitPolicy *policy;
 test_PingPongServer r_objref, l_objref;

 if (thread_tests || !thread_safe)
  return;

 if (!thread_tests) g_print("Testing policy code ...\n");
 r_objref = test_TestFactory_createPingPongServer (factory, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2158, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 l_objref = TestFactory_createPingPongServer (((void *)0), ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2161, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
 CORBA_Object_release (l_objref, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ORBit_small_get_servant (l_objref) != ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2163, __PRETTY_FUNCTION__, "ORBit_small_get_servant (l_objref) != NULL"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2164, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 policy = ORBit_policy_new ((ORBit_policy_ex_get_type ()),
       "allow", global_poa, ((void *)0));
 ORBit_object_set_policy (r_objref, policy);
 test_PingPongServer_pingPong (r_objref, l_objref, 64, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2170, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
 ORBit_object_set_policy (r_objref, ((void *)0));
 ORBit_policy_unref (policy);

 CORBA_Object_release (l_objref, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2175, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 CORBA_Object_release (r_objref, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2178, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
}

static void
dummy_cb (LinkConnection *connection, gboolean *invoked)
{
 *invoked = (!(0));
}

static void
testSegv (test_TestFactory factory,
   CORBA_Environment *ev)
{
 gboolean broken = (0);
 gboolean invoked = (0);

 if (in_proc)
  return;

 if (!thread_tests) g_print("Testing Fatal invocations ...\n");

 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ORBit_small_listen_for_broken ( factory, ((GCallback) (broken_cb)), &broken) == ORBIT_CONNECTION_CONNECTED) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2201, __PRETTY_FUNCTION__, "ORBit_small_listen_for_broken ( factory, G_CALLBACK (broken_cb), &broken) == ORBIT_CONNECTION_CONNECTED"); });



 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ORBit_small_listen_for_broken ( factory, ((GCallback) (dummy_cb)), &invoked) == ORBIT_CONNECTION_CONNECTED) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2205, __PRETTY_FUNCTION__, "ORBit_small_listen_for_broken ( factory, G_CALLBACK (dummy_cb), &invoked) == ORBIT_CONNECTION_CONNECTED"); });



 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ORBit_small_unlisten_for_broken ( factory, ((GCallback) (dummy_cb))) == ORBIT_CONNECTION_CONNECTED) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2209, __PRETTY_FUNCTION__, "ORBit_small_unlisten_for_broken ( factory, G_CALLBACK (dummy_cb)) == ORBIT_CONNECTION_CONNECTED"); });


 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (!CORBA_Object_non_existent (factory, ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2210, __PRETTY_FUNCTION__, "!CORBA_Object_non_existent (factory, ev)"); });

 test_TestFactory_segv (factory, "do it!", ev);
# 2224 "client.c"
 if (ORBit_small_unlisten_for_broken (factory, ((GCallback) (broken_cb))) !=
     ORBIT_CONNECTION_CONNECTED)
  g_log (((gchar*) 0), G_LOG_LEVEL_WARNING, "Unusual race in unlisten");
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2227, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

}

static void
test_initial_references (CORBA_ORB orb,
    CORBA_Environment *ev)
{
 CORBA_ORB_ObjectIdList *list;
 int i;

 fprintf (stderr, "\nInitial References:\n");

 list = CORBA_ORB_list_initial_services (orb, ev);

 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION && list && list->_length) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2242, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION && list && list->_length"); });

 for (i = 0; i < list->_length; i++) {
  CORBA_ORB_ObjectId id;
  CORBA_Object obj;

  id = list->_buffer [i];

  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (id) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2250, __PRETTY_FUNCTION__, "id"); });

  fprintf (stderr, "\t%s ... ", id);

  obj = CORBA_ORB_resolve_initial_references (orb, id, ev);

  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION && obj != ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2256, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION && obj != CORBA_OBJECT_NIL"); });

  CORBA_Object_release (obj, ev);

  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2260, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

  fprintf (stderr, "okay\n");
 }

 CORBA_free (list);
}



static void
test_time_noop (test_TestFactory factory,
  CORBA_Environment *ev)
{
 int i;
 int old_flags;
 GTimer *timer;

 timer = g_timer_new ();
 g_timer_start (timer);
 for (i = 0; i < 1000; i++)
  test_TestFactory_noOp (factory, ev);
 g_timer_stop (timer);
 fprintf (stderr, "In proc (fast) took %g msecs\n",
 g_timer_elapsed (timer, ((void *)0)) * 1000);

 old_flags = ORBit_small_flags;
 ORBit_small_flags |= 2;
 g_timer_reset (timer);
 g_timer_start (timer);
 for (i = 0; i < 1000; i++)
  test_TestFactory_noOp (factory, ev);
 g_timer_stop (timer);
 fprintf (stderr, "In proc (slow) took %g msecs\n",
   g_timer_elapsed (timer, ((void *)0)) * 1000);
 ORBit_small_flags = old_flags;

 g_timer_destroy (timer);
}

static void
test_basic_server (test_TestFactory factory,
     CORBA_Environment *ev)
{
 test_BasicServer objref;

 objref = test_TestFactory_getBasicServer (factory, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2307, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (objref != ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2308, __PRETTY_FUNCTION__, "objref != CORBA_OBJECT_NIL"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_Object_is_a (objref, "IDL:orbit/test/BasicServer:1.0", ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2309, __PRETTY_FUNCTION__, "CORBA_Object_is_a (objref, \"IDL:orbit/test/BasicServer:1.0\", ev)"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2310, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 testAttribute (objref, ev);
 testString (objref, ev);
 testLong (objref, ev);
 testLongLong (objref, ev);
 testFloat (objref, ev);
 testDouble (objref, ev);
 testLongDouble (objref, ev);
 testEnum (objref, ev);
 testException (objref, ev);
 testBoolAlign (objref, ev);

 CORBA_Object_release (objref, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2324, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
}

static void
testDerivedServer (test_TestFactory factory,
     CORBA_Environment *ev)
{
 CORBA_Object obj;
 PortableServer_ServantBase *servant;
 PortableServer_ObjectId *oid;
 ORBit_POAObject pobj;
 PortableServer_ServantBase__epv DerivedServer_base_epv = {((void *)0), simple_finalize, ((void *)0)};
 POA_test_BasicServer__vepv DerivedServer_vepv = { &DerivedServer_base_epv, ((void *)0) };

 if (!thread_tests) g_print("Testing DerivedServer ...\n");

 servant = (simple_servant_new (&(DerivedServer_vepv), POA_test_DerivedServer__init));
 obj = create_object (global_poa, servant, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2342, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (test_C1__classid != 0) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2344, __PRETTY_FUNCTION__, "test_C1__classid != 0"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (test_B1__classid != 0) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2345, __PRETTY_FUNCTION__, "test_B1__classid != 0"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (test_B2__classid != 0) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2346, __PRETTY_FUNCTION__, "test_B2__classid != 0"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (test_DerivedServer__classid != 0) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2347, __PRETTY_FUNCTION__, "test_DerivedServer__classid != 0"); });

 pobj = (ORBit_POAObject) obj->adaptor_obj;
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (pobj->vepvmap_cache [test_DerivedServer__classid] != 0) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2350, __PRETTY_FUNCTION__, "pobj->vepvmap_cache [test_DerivedServer__classid] != 0"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (pobj->vepvmap_cache [test_C1__classid] != 0) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2351, __PRETTY_FUNCTION__, "pobj->vepvmap_cache [test_C1__classid] != 0"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (pobj->vepvmap_cache [test_B1__classid] != 0) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2352, __PRETTY_FUNCTION__, "pobj->vepvmap_cache [test_B1__classid] != 0"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (pobj->vepvmap_cache [test_B2__classid] != 0) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2353, __PRETTY_FUNCTION__, "pobj->vepvmap_cache [test_B2__classid] != 0"); });

 CORBA_Object_release (obj, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2356, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 oid = PortableServer_POA_servant_to_id (global_poa, servant, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2359, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
 PortableServer_POA_deactivate_object (global_poa, oid, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2361, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 CORBA_free (oid);
}

static void
testNonExistent (test_TestFactory factory, CORBA_Environment *ev)
{
 CORBA_Object non_existent;
 const char *non_existent_ior =
  "IOR:010000001f00000049444c3a6f726269742f746573742f54657"
  "374466163746f72793a312e300000030000000054424f6400000001"
  "01020005000000554e495800000000160000006c6f63616c686f737"
  "42e6c6f63616c646f6d61696e0000002d0000002f746d702f6f7262"
  "69742d6d69636861656c2f6c696e632d363733322d302d373362323"
  "966373333316662390000000000000000caaedfba58000000010102"
  "002d0000002f746d702f6f726269742d6d69636861656c2f6c696e6"
  "32d363733322d302d37336232396637333331666239000000001c00"
  "000000000000331c40f8ba0fa828dc2928282828282808000000db7"
  "e269601000000480000000100000002000000050000001c00000000"
  "000000331c40f8ba0fa828dc2928282828282808000000db7e26960"
  "1000000140000000100000001000105000000000901010000000000";

 if (!in_proc)
  return;
 if (!thread_tests) g_print("Testing CORBA_Object_non_existent ...\n");

 non_existent = CORBA_ORB_string_to_object
  (global_orb, non_existent_ior, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_Object_non_existent (non_existent, ev)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2390, __PRETTY_FUNCTION__, "CORBA_Object_non_existent (non_existent, ev)"); });
 CORBA_Object_release (non_existent, ((void *)0));
}

static void
testWithException (test_TestFactory factory, CORBA_Environment *ev)
{
 int old_flags;
 CORBA_Object objref;

 CORBA_exception_set (ev, CORBA_SYSTEM_EXCEPTION,
        "IDL:omg.org/CORBA/OBJECT_NOT_EXIST:1.0", ((void *)0));
 objref = test_TestFactory_getBasicServer (factory, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2403, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
 CORBA_Object_release (objref, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2405, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 old_flags = ORBit_small_flags;
 ORBit_small_flags |= 2;

 CORBA_exception_set (ev, CORBA_SYSTEM_EXCEPTION,
        "IDL:omg.org/CORBA/OBJECT_NOT_EXIST:1.0", ((void *)0));
 objref = test_TestFactory_getBasicServer (factory, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2413, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
 CORBA_Object_release (objref, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2415, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 ORBit_small_flags = old_flags;
}

static void
run_tests (test_TestFactory factory,
    gboolean thread_tests,
    CORBA_Environment *ev)
{
 int i;

 for (i = 0; i < 1; i++) {
  testSequenceHelpers ();
  testConst ();
  test_basic_server (factory, ev);
  testIsA (factory, ev);
  testFixedLengthStruct (factory, ev);
  testVariableLengthStruct (factory, ev);
  testCompoundStruct (factory, ev);
  testAlignHoleStruct (factory, ev);
  testObjectStruct (factory, ev);
  testStructAny (factory, ev);
  testUnboundedSequence (factory, ev);
  testBoundedSequence (factory, ev);
  testAnySequence (factory, ev);
  testFixedLengthUnion (factory, ev);
  testVariableLengthUnion (factory, ev);
  testMiscUnions (factory, ev);
  testUnionArray (factory, ev);
  testFixedLengthArray (factory, ev);
  testVariableLengthArray (factory, ev);
  testAnyStrSeq (factory, ev);
  testAnyLong (factory, ev);
  testAnyString (factory, ev);
  testAnyStruct (factory, ev);
  testAnyException (factory, ev);
  testAnyEquivalence (factory, ev);
  testSequenceOfAny (factory, ev);
  testTypeCode (factory, ev);
  testContext (factory, ev);
  testIInterface (factory, ev);
  testDerivedServer (factory, ev);
  testNonExistent (factory, ev);

  if (!thread_tests)
   testAsync (factory, ev);

  if (!in_proc) {
   testPingPong (factory, thread_tests, ev);
   testPolicy (factory, thread_tests, ev);
  }
  testMisc (factory, ev);
  testIOR (factory, ev);
  testWithException (factory, ev);
  testLifeCycle (factory, ev);
 }




}

static gpointer
test_thread (gpointer data)
{
 CORBA_Environment ev[1];
 test_TestFactory factory = data;

 CORBA_exception_init (ev);
 run_tests (factory, (!(0)), ev);
 CORBA_exception_free (ev);

 return data;
}

static void
run_threaded_tests (test_TestFactory factory,
      CORBA_Environment *ev)
{
 int i;
 GError *error = ((void *)0);
 GThread **threads;

 if (!8)
  return;

 fprintf (stderr, "Testing with %d threads\n", 8);

 threads = ((GThread * *) g_malloc0 (((gsize) sizeof (GThread *)) * ((gsize) (8))));

 for (i = 0; i < 8; i++) {
  threads [i] = (g_thread_create_full (test_thread, factory, 0, (!(0)), (0), G_THREAD_PRIORITY_NORMAL, &error));

  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (!error) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2509, __PRETTY_FUNCTION__, "!error"); });
 }

 for (i = 0; i < 8; i++) {
  if (!(g_thread_join (threads [i]) == factory))
   g_log (((gchar*) 0), G_LOG_LEVEL_ERROR, "Wierd thread join problem '%d'", i);
 }
}

static void
dump_protos (void)
{
 int enabled_count = 0;
 LinkProtocolInfo *info;

 for (info = link_protocol_all (); info->name; info++) {
  gboolean enabled;

  if ((enabled = ORBit_proto_use (info->name)))
   enabled_count++;

  fprintf (stderr, "Protocol %8s: %s\n",
    info->name,
    enabled ? "enabled" : "disabled");
 }

 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (enabled_count > 0) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2535, __PRETTY_FUNCTION__, "enabled_count > 0"); });
}

static void
test_init (CORBA_Environment *ev)
{
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (CORBA_ORB_init (((void *)0), ((void *)0), "", ev) == global_orb) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2541, __PRETTY_FUNCTION__, "CORBA_ORB_init (NULL, NULL, \"\", ev) == global_orb"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2542, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 CORBA_ORB_destroy (global_orb, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2545, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
 CORBA_Object_release ((CORBA_Object)global_orb, ev);
}

int
main (int argc, char *argv [])
{
 CORBA_Environment ev[1];
 test_TestFactory factory;
 ORBit_IInterfaces *interfaces = ((void *)0);
 gboolean gen_imodule = (0);
 char *orb_name;
 int i;

 CORBA_exception_init (ev);







 for (i = 0; i < argc; i++) {
  if (!__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (argv [i]) && __builtin_constant_p ("--gen-imodule") && (__s1_len = strlen (argv [i]), __s2_len = strlen ("--gen-imodule"), (!((size_t)(const void *)((argv [i]) + 1) - (size_t)(const void *)(argv [i]) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("--gen-imodule") + 1) - (size_t)(const void *)("--gen-imodule") == 1) || __s2_len >= 4)) ? __builtin_strcmp (argv [i], "--gen-imodule") : (__builtin_constant_p (argv [i]) && ((size_t)(const void *)((argv [i]) + 1) - (size_t)(const void *)(argv [i]) == 1) && (__s1_len = strlen (argv [i]), __s1_len < 4) ? (__builtin_constant_p ("--gen-imodule") && ((size_t)(const void *)(("--gen-imodule") + 1) - (size_t)(const void *)("--gen-imodule") == 1) ? __builtin_strcmp (argv [i], "--gen-imodule") : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) ("--gen-imodule"); register int __result = (((__const unsigned char *) (__const char *) (argv [i]))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (argv [i]))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (argv [i]))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (argv [i]))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("--gen-imodule") && ((size_t)(const void *)(("--gen-imodule") + 1) - (size_t)(const void *)("--gen-imodule") == 1) && (__s2_len = strlen ("--gen-imodule"), __s2_len < 4) ? (__builtin_constant_p (argv [i]) && ((size_t)(const void *)((argv [i]) + 1) - (size_t)(const void *)(argv [i]) == 1) ? __builtin_strcmp (argv [i], "--gen-imodule") : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (argv [i]); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) ("--gen-imodule"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) ("--gen-imodule"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) ("--gen-imodule"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) ("--gen-imodule"))[3]); } } __result; }))) : __builtin_strcmp (argv [i], "--gen-imodule")))); }))
   gen_imodule = (!(0));
  if (!__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (argv [i]) && __builtin_constant_p ("--thread-safe") && (__s1_len = strlen (argv [i]), __s2_len = strlen ("--thread-safe"), (!((size_t)(const void *)((argv [i]) + 1) - (size_t)(const void *)(argv [i]) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("--thread-safe") + 1) - (size_t)(const void *)("--thread-safe") == 1) || __s2_len >= 4)) ? __builtin_strcmp (argv [i], "--thread-safe") : (__builtin_constant_p (argv [i]) && ((size_t)(const void *)((argv [i]) + 1) - (size_t)(const void *)(argv [i]) == 1) && (__s1_len = strlen (argv [i]), __s1_len < 4) ? (__builtin_constant_p ("--thread-safe") && ((size_t)(const void *)(("--thread-safe") + 1) - (size_t)(const void *)("--thread-safe") == 1) ? __builtin_strcmp (argv [i], "--thread-safe") : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) ("--thread-safe"); register int __result = (((__const unsigned char *) (__const char *) (argv [i]))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (argv [i]))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (argv [i]))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (argv [i]))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("--thread-safe") && ((size_t)(const void *)(("--thread-safe") + 1) - (size_t)(const void *)("--thread-safe") == 1) && (__s2_len = strlen ("--thread-safe"), __s2_len < 4) ? (__builtin_constant_p (argv [i]) && ((size_t)(const void *)((argv [i]) + 1) - (size_t)(const void *)(argv [i]) == 1) ? __builtin_strcmp (argv [i], "--thread-safe") : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (argv [i]); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) ("--thread-safe"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) ("--thread-safe"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) ("--thread-safe"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) ("--thread-safe"))[3]); } } __result; }))) : __builtin_strcmp (argv [i], "--thread-safe")))); }))
   thread_safe = (!(0));
  if (!__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (argv [i]) && __builtin_constant_p ("--thread-tests") && (__s1_len = strlen (argv [i]), __s2_len = strlen ("--thread-tests"), (!((size_t)(const void *)((argv [i]) + 1) - (size_t)(const void *)(argv [i]) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("--thread-tests") + 1) - (size_t)(const void *)("--thread-tests") == 1) || __s2_len >= 4)) ? __builtin_strcmp (argv [i], "--thread-tests") : (__builtin_constant_p (argv [i]) && ((size_t)(const void *)((argv [i]) + 1) - (size_t)(const void *)(argv [i]) == 1) && (__s1_len = strlen (argv [i]), __s1_len < 4) ? (__builtin_constant_p ("--thread-tests") && ((size_t)(const void *)(("--thread-tests") + 1) - (size_t)(const void *)("--thread-tests") == 1) ? __builtin_strcmp (argv [i], "--thread-tests") : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) ("--thread-tests"); register int __result = (((__const unsigned char *) (__const char *) (argv [i]))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (argv [i]))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (argv [i]))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (argv [i]))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("--thread-tests") && ((size_t)(const void *)(("--thread-tests") + 1) - (size_t)(const void *)("--thread-tests") == 1) && (__s2_len = strlen ("--thread-tests"), __s2_len < 4) ? (__builtin_constant_p (argv [i]) && ((size_t)(const void *)((argv [i]) + 1) - (size_t)(const void *)(argv [i]) == 1) ? __builtin_strcmp (argv [i], "--thread-tests") : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (argv [i]); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) ("--thread-tests"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) ("--thread-tests"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) ("--thread-tests"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) ("--thread-tests"))[3]); } } __result; }))) : __builtin_strcmp (argv [i], "--thread-tests")))); })) {
   thread_safe = (!(0));
   thread_tests = (!(0));
  }
 }

 if (thread_safe)
  orb_name = "orbit-local-orb";
 else
  orb_name = "orbit-local-non-threaded-orb";

 global_orb = CORBA_ORB_init (&argc, argv, orb_name, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2584, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });






 if (gen_imodule) {
  CORBA_sequence_CORBA_TypeCode *typecodes = ((void *)0);

  interfaces = ORBit_iinterfaces_from_file (
    "../../test/everything" "/everything.idl", ((void *)0), &typecodes);
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (interfaces != ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2596, __PRETTY_FUNCTION__, "interfaces != NULL"); });
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (typecodes != ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2597, __PRETTY_FUNCTION__, "typecodes != NULL"); });

  CORBA_free (typecodes);

  init_iinterfaces (interfaces, ev);
 }

 test_init (ev);
 test_initial_references (global_orb, ev);

 free (malloc (8));

 dump_protos ();


 in_proc = (!(0));

 fprintf (stderr, "\n --- In proc ---\n\n\n");
 factory = get_server (global_orb, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (factory->profile_list == ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2616, __PRETTY_FUNCTION__, "factory->profile_list == NULL"); });
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ORBit_object_get_connection (factory) == ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2617, __PRETTY_FUNCTION__, "ORBit_object_get_connection (factory) == NULL"); });

 test_time_noop (factory, ev);
 run_tests (factory, (0), ev);
 if (thread_tests)
  g_log (((gchar*) 0), G_LOG_LEVEL_WARNING, "FIXME: disabled in-proc threaded tests for now");


 CORBA_Object_release (factory, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2626, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
 factory = ((void *)0);

 fprintf (stderr, "\n\n --- Out of proc ---\n\n\n");
 in_proc = (0);

 {
  int size;
  char ior [1024];
  FILE *infile = fopen ("iorfile", "rb");

  if (!infile)
   g_log (((gchar*) 0), G_LOG_LEVEL_ERROR, "Start the server before running the client");

  size = fread (ior, 1, 1024, infile);
  fclose (infile);
  ior [size] = '\0';

  factory = CORBA_ORB_string_to_object (global_orb, ior, ev);
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2645, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

  if (CORBA_Object_non_existent (factory, ev))
   g_log (((gchar*) 0), G_LOG_LEVEL_ERROR, "Can't contact the server");
  (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2649, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });
 }
 run_tests (factory, (0), ev);
 if (thread_tests)
  run_threaded_tests (factory, ev);
 testSegv (factory, ev);

 CORBA_Object_release (factory, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2657, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 if (gen_imodule)
  CORBA_free (interfaces);

 CORBA_Object_release ((CORBA_Object) global_poa, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2663, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 CORBA_ORB_destroy (global_orb, ev);
 CORBA_exception_free (ev);

 CORBA_Object_release ((CORBA_Object) global_orb, ev);
 (void) __extension__ ({ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (ev->_major == CORBA_NO_EXCEPTION) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else g_assert_warning (((gchar*) 0), "client.c", 2669, __PRETTY_FUNCTION__, "ev->_major == CORBA_NO_EXCEPTION"); });

 CORBA_exception_free (ev);

 if (!thread_tests) g_print("All tests passed successfully\n");

 return 0;
}
