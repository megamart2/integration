# 1 "reload.c"
# 1 "/home/czhang/gcc-3.4.0/gcc//"
# 1 "<built-in>"
# 1 "<command line>"
# 1 "reload.c"
# 89 "reload.c"
# 1 "config.h" 1


# 1 "auto-host.h" 1
# 4 "config.h" 2

# 1 "./../include/ansidecl.h" 1
# 6 "config.h" 2
# 90 "reload.c" 2
# 1 "system.h" 1
# 28 "system.h"
# 1 "/usr/lib/gcc/i386-redhat-linux/4.1.1/include/stdarg.h" 1 3 4
# 43 "/usr/lib/gcc/i386-redhat-linux/4.1.1/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 105 "/usr/lib/gcc/i386-redhat-linux/4.1.1/include/stdarg.h" 3 4
typedef __gnuc_va_list va_list;
# 29 "system.h" 2
# 39 "system.h"
# 1 "/usr/lib/gcc/i386-redhat-linux/4.1.1/include/stddef.h" 1 3 4
# 152 "/usr/lib/gcc/i386-redhat-linux/4.1.1/include/stddef.h" 3 4
typedef int ptrdiff_t;
# 214 "/usr/lib/gcc/i386-redhat-linux/4.1.1/include/stddef.h" 3 4
typedef unsigned int size_t;
# 326 "/usr/lib/gcc/i386-redhat-linux/4.1.1/include/stddef.h" 3 4
typedef long int wchar_t;
# 40 "system.h" 2


# 1 "/usr/include/stdio.h" 1 3 4
# 28 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 329 "/usr/include/features.h" 3 4
# 1 "/usr/include/sys/cdefs.h" 1 3 4
# 313 "/usr/include/sys/cdefs.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 314 "/usr/include/sys/cdefs.h" 2 3 4
# 330 "/usr/include/features.h" 2 3 4
# 352 "/usr/include/features.h" 3 4
# 1 "/usr/include/gnu/stubs.h" 1 3 4



# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 5 "/usr/include/gnu/stubs.h" 2 3 4


# 1 "/usr/include/gnu/stubs-32.h" 1 3 4
# 8 "/usr/include/gnu/stubs.h" 2 3 4
# 353 "/usr/include/features.h" 2 3 4
# 29 "/usr/include/stdio.h" 2 3 4





# 1 "/usr/lib/gcc/i386-redhat-linux/4.1.1/include/stddef.h" 1 3 4
# 35 "/usr/include/stdio.h" 2 3 4

# 1 "/usr/include/bits/types.h" 1 3 4
# 28 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 29 "/usr/include/bits/types.h" 2 3 4


# 1 "/usr/lib/gcc/i386-redhat-linux/4.1.1/include/stddef.h" 1 3 4
# 32 "/usr/include/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;




__extension__ typedef signed long long int __int64_t;
__extension__ typedef unsigned long long int __uint64_t;







__extension__ typedef long long int __quad_t;
__extension__ typedef unsigned long long int __u_quad_t;
# 134 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/typesizes.h" 1 3 4
# 135 "/usr/include/bits/types.h" 2 3 4


__extension__ typedef __u_quad_t __dev_t;
__extension__ typedef unsigned int __uid_t;
__extension__ typedef unsigned int __gid_t;
__extension__ typedef unsigned long int __ino_t;
__extension__ typedef __u_quad_t __ino64_t;
__extension__ typedef unsigned int __mode_t;
__extension__ typedef unsigned int __nlink_t;
__extension__ typedef long int __off_t;
__extension__ typedef __quad_t __off64_t;
__extension__ typedef int __pid_t;
__extension__ typedef struct { int __val[2]; } __fsid_t;
__extension__ typedef long int __clock_t;
__extension__ typedef unsigned long int __rlim_t;
__extension__ typedef __u_quad_t __rlim64_t;
__extension__ typedef unsigned int __id_t;
__extension__ typedef long int __time_t;
__extension__ typedef unsigned int __useconds_t;
__extension__ typedef long int __suseconds_t;

__extension__ typedef int __daddr_t;
__extension__ typedef long int __swblk_t;
__extension__ typedef int __key_t;


__extension__ typedef int __clockid_t;


__extension__ typedef void * __timer_t;


__extension__ typedef long int __blksize_t;




__extension__ typedef long int __blkcnt_t;
__extension__ typedef __quad_t __blkcnt64_t;


__extension__ typedef unsigned long int __fsblkcnt_t;
__extension__ typedef __u_quad_t __fsblkcnt64_t;


__extension__ typedef unsigned long int __fsfilcnt_t;
__extension__ typedef __u_quad_t __fsfilcnt64_t;

__extension__ typedef int __ssize_t;



typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;


__extension__ typedef int __intptr_t;


__extension__ typedef unsigned int __socklen_t;
# 37 "/usr/include/stdio.h" 2 3 4









typedef struct _IO_FILE FILE;





# 62 "/usr/include/stdio.h" 3 4
typedef struct _IO_FILE __FILE;
# 72 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/libio.h" 1 3 4
# 32 "/usr/include/libio.h" 3 4
# 1 "/usr/include/_G_config.h" 1 3 4
# 14 "/usr/include/_G_config.h" 3 4
# 1 "/usr/lib/gcc/i386-redhat-linux/4.1.1/include/stddef.h" 1 3 4
# 355 "/usr/lib/gcc/i386-redhat-linux/4.1.1/include/stddef.h" 3 4
typedef unsigned int wint_t;
# 15 "/usr/include/_G_config.h" 2 3 4
# 24 "/usr/include/_G_config.h" 3 4
# 1 "/usr/include/wchar.h" 1 3 4
# 48 "/usr/include/wchar.h" 3 4
# 1 "/usr/lib/gcc/i386-redhat-linux/4.1.1/include/stddef.h" 1 3 4
# 49 "/usr/include/wchar.h" 2 3 4

# 1 "/usr/include/bits/wchar.h" 1 3 4
# 51 "/usr/include/wchar.h" 2 3 4
# 76 "/usr/include/wchar.h" 3 4
typedef struct
{
  int __count;
  union
  {
    wint_t __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
# 25 "/usr/include/_G_config.h" 2 3 4

typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
# 44 "/usr/include/_G_config.h" 3 4
# 1 "/usr/include/gconv.h" 1 3 4
# 28 "/usr/include/gconv.h" 3 4
# 1 "/usr/include/wchar.h" 1 3 4
# 48 "/usr/include/wchar.h" 3 4
# 1 "/usr/lib/gcc/i386-redhat-linux/4.1.1/include/stddef.h" 1 3 4
# 49 "/usr/include/wchar.h" 2 3 4
# 29 "/usr/include/gconv.h" 2 3 4


# 1 "/usr/lib/gcc/i386-redhat-linux/4.1.1/include/stddef.h" 1 3 4
# 32 "/usr/include/gconv.h" 2 3 4





enum
{
  __GCONV_OK = 0,
  __GCONV_NOCONV,
  __GCONV_NODB,
  __GCONV_NOMEM,

  __GCONV_EMPTY_INPUT,
  __GCONV_FULL_OUTPUT,
  __GCONV_ILLEGAL_INPUT,
  __GCONV_INCOMPLETE_INPUT,

  __GCONV_ILLEGAL_DESCRIPTOR,
  __GCONV_INTERNAL_ERROR
};



enum
{
  __GCONV_IS_LAST = 0x0001,
  __GCONV_IGNORE_ERRORS = 0x0002
};



struct __gconv_step;
struct __gconv_step_data;
struct __gconv_loaded_object;
struct __gconv_trans_data;



typedef int (*__gconv_fct) (struct __gconv_step *, struct __gconv_step_data *,
       __const unsigned char **, __const unsigned char *,
       unsigned char **, size_t *, int, int);


typedef wint_t (*__gconv_btowc_fct) (struct __gconv_step *, unsigned char);


typedef int (*__gconv_init_fct) (struct __gconv_step *);
typedef void (*__gconv_end_fct) (struct __gconv_step *);



typedef int (*__gconv_trans_fct) (struct __gconv_step *,
      struct __gconv_step_data *, void *,
      __const unsigned char *,
      __const unsigned char **,
      __const unsigned char *, unsigned char **,
      size_t *);


typedef int (*__gconv_trans_context_fct) (void *, __const unsigned char *,
       __const unsigned char *,
       unsigned char *, unsigned char *);


typedef int (*__gconv_trans_query_fct) (__const char *, __const char ***,
     size_t *);


typedef int (*__gconv_trans_init_fct) (void **, const char *);
typedef void (*__gconv_trans_end_fct) (void *);

struct __gconv_trans_data
{

  __gconv_trans_fct __trans_fct;
  __gconv_trans_context_fct __trans_context_fct;
  __gconv_trans_end_fct __trans_end_fct;
  void *__data;
  struct __gconv_trans_data *__next;
};



struct __gconv_step
{
  struct __gconv_loaded_object *__shlib_handle;
  __const char *__modname;

  int __counter;

  char *__from_name;
  char *__to_name;

  __gconv_fct __fct;
  __gconv_btowc_fct __btowc_fct;
  __gconv_init_fct __init_fct;
  __gconv_end_fct __end_fct;



  int __min_needed_from;
  int __max_needed_from;
  int __min_needed_to;
  int __max_needed_to;


  int __stateful;

  void *__data;
};



struct __gconv_step_data
{
  unsigned char *__outbuf;
  unsigned char *__outbufend;



  int __flags;



  int __invocation_counter;



  int __internal_use;

  __mbstate_t *__statep;
  __mbstate_t __state;



  struct __gconv_trans_data *__trans;
};



typedef struct __gconv_info
{
  size_t __nsteps;
  struct __gconv_step *__steps;
  __extension__ struct __gconv_step_data __data [];
} *__gconv_t;
# 45 "/usr/include/_G_config.h" 2 3 4
typedef union
{
  struct __gconv_info __cd;
  struct
  {
    struct __gconv_info __cd;
    struct __gconv_step_data __data;
  } __combined;
} _G_iconv_t;

typedef int _G_int16_t __attribute__ ((__mode__ (__HI__)));
typedef int _G_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int _G_uint16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int _G_uint32_t __attribute__ ((__mode__ (__SI__)));
# 33 "/usr/include/libio.h" 2 3 4
# 166 "/usr/include/libio.h" 3 4
struct _IO_jump_t; struct _IO_FILE;
# 176 "/usr/include/libio.h" 3 4
typedef void _IO_lock_t;





struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
# 199 "/usr/include/libio.h" 3 4
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
# 267 "/usr/include/libio.h" 3 4
struct _IO_FILE {
  int _flags;




  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;



  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
# 315 "/usr/include/libio.h" 3 4
  __off64_t _offset;
# 324 "/usr/include/libio.h" 3 4
  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;
  size_t __pad5;

  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};


typedef struct _IO_FILE _IO_FILE;


struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
# 360 "/usr/include/libio.h" 3 4
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, __const char *__buf,
     size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);


typedef int __io_close_fn (void *__cookie);




typedef __io_read_fn cookie_read_function_t;
typedef __io_write_fn cookie_write_function_t;
typedef __io_seek_fn cookie_seek_function_t;
typedef __io_close_fn cookie_close_function_t;


typedef struct
{
  __io_read_fn *read;
  __io_write_fn *write;
  __io_seek_fn *seek;
  __io_close_fn *close;
} _IO_cookie_io_functions_t;
typedef _IO_cookie_io_functions_t cookie_io_functions_t;

struct _IO_cookie_file;


extern void _IO_cookie_init (struct _IO_cookie_file *__cfile, int __read_write,
        void *__cookie, _IO_cookie_io_functions_t __fns);







extern int __underflow (_IO_FILE *) __attribute__ ((__nothrow__));
extern int __uflow (_IO_FILE *) __attribute__ ((__nothrow__));
extern int __overflow (_IO_FILE *, int) __attribute__ ((__nothrow__));
extern wint_t __wunderflow (_IO_FILE *) __attribute__ ((__nothrow__));
extern wint_t __wuflow (_IO_FILE *) __attribute__ ((__nothrow__));
extern wint_t __woverflow (_IO_FILE *, wint_t) __attribute__ ((__nothrow__));
# 450 "/usr/include/libio.h" 3 4
extern int _IO_getc (_IO_FILE *__fp) __attribute__ ((__nothrow__));
extern int _IO_putc (int __c, _IO_FILE *__fp) __attribute__ ((__nothrow__));
extern int _IO_feof (_IO_FILE *__fp) __attribute__ ((__nothrow__));
extern int _IO_ferror (_IO_FILE *__fp) __attribute__ ((__nothrow__));

extern int _IO_peekc_locked (_IO_FILE *__fp) __attribute__ ((__nothrow__));





extern void _IO_flockfile (_IO_FILE *) __attribute__ ((__nothrow__));
extern void _IO_funlockfile (_IO_FILE *) __attribute__ ((__nothrow__));
extern int _IO_ftrylockfile (_IO_FILE *) __attribute__ ((__nothrow__));
# 480 "/usr/include/libio.h" 3 4
extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
   __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
    __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t) __attribute__ ((__nothrow__));
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t) __attribute__ ((__nothrow__));

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int) __attribute__ ((__nothrow__));
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int) __attribute__ ((__nothrow__));

extern void _IO_free_backup_area (_IO_FILE *) __attribute__ ((__nothrow__));
# 73 "/usr/include/stdio.h" 2 3 4
# 86 "/usr/include/stdio.h" 3 4


typedef _G_fpos_t fpos_t;





typedef _G_fpos64_t fpos64_t;
# 138 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/bits/stdio_lim.h" 1 3 4
# 139 "/usr/include/stdio.h" 2 3 4



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;









extern int remove (__const char *__filename) __attribute__ ((__nothrow__));

extern int rename (__const char *__old, __const char *__new) __attribute__ ((__nothrow__));




extern int renameat (int __oldfd, __const char *__old, int __newfd,
       __const char *__new) __attribute__ ((__nothrow__));








extern FILE *tmpfile (void);
# 181 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile64 (void);



extern char *tmpnam (char *__s) __attribute__ ((__nothrow__));





extern char *tmpnam_r (char *__s) __attribute__ ((__nothrow__));
# 203 "/usr/include/stdio.h" 3 4
extern char *tempnam (__const char *__dir, __const char *__pfx)
     __attribute__ ((__nothrow__)) __attribute__ ((__malloc__));








extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);

# 228 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 238 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);









extern FILE *fopen (__const char *__restrict __filename,
      __const char *__restrict __modes);




extern FILE *freopen (__const char *__restrict __filename,
        __const char *__restrict __modes,
        FILE *__restrict __stream);
# 269 "/usr/include/stdio.h" 3 4


extern FILE *fopen64 (__const char *__restrict __filename,
        __const char *__restrict __modes);
extern FILE *freopen64 (__const char *__restrict __filename,
   __const char *__restrict __modes,
   FILE *__restrict __stream);




extern FILE *fdopen (int __fd, __const char *__modes) __attribute__ ((__nothrow__));





extern FILE *fopencookie (void *__restrict __magic_cookie,
     __const char *__restrict __modes,
     _IO_cookie_io_functions_t __io_funcs) __attribute__ ((__nothrow__));


extern FILE *fmemopen (void *__s, size_t __len, __const char *__modes) __attribute__ ((__nothrow__));




extern FILE *open_memstream (char **__restrict __bufloc,
        size_t *__restrict __sizeloc) __attribute__ ((__nothrow__));



extern FILE *open_wmemstream (wchar_t **__restrict __bufloc,
         size_t *__restrict __sizeloc) __attribute__ ((__nothrow__));






extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __attribute__ ((__nothrow__));



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) __attribute__ ((__nothrow__));





extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) __attribute__ ((__nothrow__));


extern void setlinebuf (FILE *__stream) __attribute__ ((__nothrow__));








extern int fprintf (FILE *__restrict __stream,
      __const char *__restrict __format, ...);




extern int printf (__const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      __const char *__restrict __format, ...) __attribute__ ((__nothrow__));





extern int vfprintf (FILE *__restrict __s, __const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (__const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, __const char *__restrict __format,
       __gnuc_va_list __arg) __attribute__ ((__nothrow__));





extern int snprintf (char *__restrict __s, size_t __maxlen,
       __const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        __const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0)));






extern int vasprintf (char **__restrict __ptr, __const char *__restrict __f,
        __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 0)));
extern int __asprintf (char **__restrict __ptr,
         __const char *__restrict __fmt, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3)));
extern int asprintf (char **__restrict __ptr,
       __const char *__restrict __fmt, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3)));







extern int vdprintf (int __fd, __const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, __const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));








extern int fscanf (FILE *__restrict __stream,
     __const char *__restrict __format, ...) ;




extern int scanf (__const char *__restrict __format, ...) ;

extern int sscanf (__const char *__restrict __s,
     __const char *__restrict __format, ...) __attribute__ ((__nothrow__));








extern int vfscanf (FILE *__restrict __s, __const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (__const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (__const char *__restrict __s,
      __const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__scanf__, 2, 0)));









extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);

# 466 "/usr/include/stdio.h" 3 4
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 477 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);











extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);

# 510 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);








extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     ;






extern char *gets (char *__s) ;

# 556 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream) ;
# 572 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
          size_t *__restrict __n, int __delimiter,
          FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
        size_t *__restrict __n, int __delimiter,
        FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
       size_t *__restrict __n,
       FILE *__restrict __stream) ;








extern int fputs (__const char *__restrict __s, FILE *__restrict __stream);





extern int puts (__const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (__const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s) ;

# 633 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (__const char *__restrict __s,
      FILE *__restrict __stream);
# 644 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (__const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream) ;








extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);

# 680 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 699 "/usr/include/stdio.h" 3 4






extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, __const fpos_t *__pos);
# 722 "/usr/include/stdio.h" 3 4



extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, __const fpos64_t *__pos);




extern void clearerr (FILE *__stream) __attribute__ ((__nothrow__));

extern int feof (FILE *__stream) __attribute__ ((__nothrow__)) ;

extern int ferror (FILE *__stream) __attribute__ ((__nothrow__)) ;




extern void clearerr_unlocked (FILE *__stream) __attribute__ ((__nothrow__));
extern int feof_unlocked (FILE *__stream) __attribute__ ((__nothrow__)) ;
extern int ferror_unlocked (FILE *__stream) __attribute__ ((__nothrow__)) ;








extern void perror (__const char *__s);






# 1 "/usr/include/bits/sys_errlist.h" 1 3 4
# 27 "/usr/include/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern __const char *__const sys_errlist[];


extern int _sys_nerr;
extern __const char *__const _sys_errlist[];
# 761 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) __attribute__ ((__nothrow__)) ;




extern int fileno_unlocked (FILE *__stream) __attribute__ ((__nothrow__)) ;
# 780 "/usr/include/stdio.h" 3 4
extern FILE *popen (__const char *__command, __const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) __attribute__ ((__nothrow__));





extern char *cuserid (char *__s);




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      __const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       __const char *__restrict __format,
       __gnuc_va_list __args)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__));



extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__)) ;


extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__));
# 850 "/usr/include/stdio.h" 3 4

# 43 "system.h" 2
# 107 "system.h"
# 1 "./../include/safe-ctype.h" 1
# 61 "./../include/safe-ctype.h"
enum {

  _sch_isblank = 0x0001,
  _sch_iscntrl = 0x0002,
  _sch_isdigit = 0x0004,
  _sch_islower = 0x0008,
  _sch_isprint = 0x0010,
  _sch_ispunct = 0x0020,
  _sch_isspace = 0x0040,
  _sch_isupper = 0x0080,
  _sch_isxdigit = 0x0100,


  _sch_isidst = 0x0200,
  _sch_isvsp = 0x0400,
  _sch_isnvsp = 0x0800,


  _sch_isalpha = _sch_isupper|_sch_islower,
  _sch_isalnum = _sch_isalpha|_sch_isdigit,
  _sch_isidnum = _sch_isidst|_sch_isdigit,
  _sch_isgraph = _sch_isalnum|_sch_ispunct,
  _sch_iscppsp = _sch_isvsp|_sch_isnvsp,
  _sch_isbasic = _sch_isprint|_sch_iscppsp

};


extern const unsigned short _sch_istable[256];
# 114 "./../include/safe-ctype.h"
extern const unsigned char _sch_toupper[256];
extern const unsigned char _sch_tolower[256];
# 108 "system.h" 2

# 1 "/usr/include/sys/types.h" 1 3 4
# 29 "/usr/include/sys/types.h" 3 4






typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;



typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;





typedef __off_t off_t;






typedef __off64_t off64_t;




typedef __pid_t pid_t;




typedef __id_t id_t;




typedef __ssize_t ssize_t;





typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;
# 133 "/usr/include/sys/types.h" 3 4
# 1 "/usr/include/time.h" 1 3 4
# 59 "/usr/include/time.h" 3 4


typedef __clock_t clock_t;



# 75 "/usr/include/time.h" 3 4


typedef __time_t time_t;



# 93 "/usr/include/time.h" 3 4
typedef __clockid_t clockid_t;
# 105 "/usr/include/time.h" 3 4
typedef __timer_t timer_t;
# 134 "/usr/include/sys/types.h" 2 3 4



typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;





# 1 "/usr/lib/gcc/i386-redhat-linux/4.1.1/include/stddef.h" 1 3 4
# 148 "/usr/include/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
# 195 "/usr/include/sys/types.h" 3 4
typedef int int8_t __attribute__ ((__mode__ (__QI__)));
typedef int int16_t __attribute__ ((__mode__ (__HI__)));
typedef int int32_t __attribute__ ((__mode__ (__SI__)));
typedef int int64_t __attribute__ ((__mode__ (__DI__)));


typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));
# 217 "/usr/include/sys/types.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 37 "/usr/include/endian.h" 3 4
# 1 "/usr/include/bits/endian.h" 1 3 4
# 38 "/usr/include/endian.h" 2 3 4
# 218 "/usr/include/sys/types.h" 2 3 4


# 1 "/usr/include/sys/select.h" 1 3 4
# 31 "/usr/include/sys/select.h" 3 4
# 1 "/usr/include/bits/select.h" 1 3 4
# 32 "/usr/include/sys/select.h" 2 3 4


# 1 "/usr/include/bits/sigset.h" 1 3 4
# 23 "/usr/include/bits/sigset.h" 3 4
typedef int __sig_atomic_t;




typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
  } __sigset_t;
# 35 "/usr/include/sys/select.h" 2 3 4



typedef __sigset_t sigset_t;





# 1 "/usr/include/time.h" 1 3 4
# 121 "/usr/include/time.h" 3 4
struct timespec
  {
    __time_t tv_sec;
    long int tv_nsec;
  };
# 45 "/usr/include/sys/select.h" 2 3 4

# 1 "/usr/include/bits/time.h" 1 3 4
# 69 "/usr/include/bits/time.h" 3 4
struct timeval
  {
    __time_t tv_sec;
    __suseconds_t tv_usec;
  };
# 47 "/usr/include/sys/select.h" 2 3 4
# 55 "/usr/include/sys/select.h" 3 4
typedef long int __fd_mask;
# 67 "/usr/include/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 99 "/usr/include/sys/select.h" 3 4

# 109 "/usr/include/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 121 "/usr/include/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);



# 221 "/usr/include/sys/types.h" 2 3 4


# 1 "/usr/include/sys/sysmacros.h" 1 3 4
# 29 "/usr/include/sys/sysmacros.h" 3 4
__extension__
extern __inline unsigned int gnu_dev_major (unsigned long long int __dev)
     __attribute__ ((__nothrow__));
__extension__
extern __inline unsigned int gnu_dev_minor (unsigned long long int __dev)
     __attribute__ ((__nothrow__));
__extension__
extern __inline unsigned long long int gnu_dev_makedev (unsigned int __major,
       unsigned int __minor)
     __attribute__ ((__nothrow__));


__extension__ extern __inline unsigned int
__attribute__ ((__nothrow__)) gnu_dev_major (unsigned long long int __dev)
{
  return ((__dev >> 8) & 0xfff) | ((unsigned int) (__dev >> 32) & ~0xfff);
}

__extension__ extern __inline unsigned int
__attribute__ ((__nothrow__)) gnu_dev_minor (unsigned long long int __dev)
{
  return (__dev & 0xff) | ((unsigned int) (__dev >> 12) & ~0xff);
}

__extension__ extern __inline unsigned long long int
__attribute__ ((__nothrow__)) gnu_dev_makedev (unsigned int __major, unsigned int __minor)
{
  return ((__minor & 0xff) | ((__major & 0xfff) << 8)
   | (((unsigned long long int) (__minor & ~0xff)) << 12)
   | (((unsigned long long int) (__major & ~0xfff)) << 32));
}
# 224 "/usr/include/sys/types.h" 2 3 4




typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 262 "/usr/include/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;





# 1 "/usr/include/bits/pthreadtypes.h" 1 3 4
# 36 "/usr/include/bits/pthreadtypes.h" 3 4
typedef unsigned long int pthread_t;


typedef union
{
  char __size[36];
  long int __align;
} pthread_attr_t;


typedef struct __pthread_internal_slist
{
  struct __pthread_internal_slist *__next;
} __pthread_slist_t;




typedef union
{
  struct __pthread_mutex_s
  {
    int __lock;
    unsigned int __count;
    int __owner;


    int __kind;
    unsigned int __nusers;
    __extension__ union
    {
      int __spins;
      __pthread_slist_t __list;
    };
  } __data;
  char __size[24];
  long int __align;
} pthread_mutex_t;

typedef union
{
  char __size[4];
  long int __align;
} pthread_mutexattr_t;




typedef union
{
  struct
  {
    int __lock;
    unsigned int __futex;
    __extension__ unsigned long long int __total_seq;
    __extension__ unsigned long long int __wakeup_seq;
    __extension__ unsigned long long int __woken_seq;
    void *__mutex;
    unsigned int __nwaiters;
    unsigned int __broadcast_seq;
  } __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;

typedef union
{
  char __size[4];
  long int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;





typedef union
{
  struct
  {
    int __lock;
    unsigned int __nr_readers;
    unsigned int __readers_wakeup;
    unsigned int __writer_wakeup;
    unsigned int __nr_readers_queued;
    unsigned int __nr_writers_queued;


    unsigned int __flags;
    int __writer;
  } __data;
  char __size[32];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[20];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 271 "/usr/include/sys/types.h" 2 3 4



# 110 "system.h" 2

# 1 "/usr/include/errno.h" 1 3 4
# 32 "/usr/include/errno.h" 3 4




# 1 "/usr/include/bits/errno.h" 1 3 4
# 25 "/usr/include/bits/errno.h" 3 4
# 1 "/usr/include/linux/errno.h" 1 3 4



# 1 "/usr/include/asm/errno.h" 1 3 4
# 5 "/usr/include/linux/errno.h" 2 3 4
# 26 "/usr/include/bits/errno.h" 2 3 4
# 43 "/usr/include/bits/errno.h" 3 4
extern int *__errno_location (void) __attribute__ ((__nothrow__)) __attribute__ ((__const__));
# 37 "/usr/include/errno.h" 2 3 4
# 55 "/usr/include/errno.h" 3 4
extern char *program_invocation_name, *program_invocation_short_name;




# 69 "/usr/include/errno.h" 3 4
typedef int error_t;
# 112 "system.h" 2
# 122 "system.h"
# 1 "/usr/include/string.h" 1 3 4
# 28 "/usr/include/string.h" 3 4





# 1 "/usr/lib/gcc/i386-redhat-linux/4.1.1/include/stddef.h" 1 3 4
# 34 "/usr/include/string.h" 2 3 4




extern void *memcpy (void *__restrict __dest,
       __const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, __const void *__src, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));






extern void *memccpy (void *__restrict __dest, __const void *__restrict __src,
        int __c, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));





extern void *memset (void *__s, int __c, size_t __n) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int memcmp (__const void *__s1, __const void *__s2, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern void *memchr (__const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern void *rawmemchr (__const void *__s, int __c)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern void *memrchr (__const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strcpy (char *__restrict __dest, __const char *__restrict __src)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        __const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, __const char *__restrict __src)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, __const char *__restrict __src,
        size_t __n) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (__const char *__s1, __const char *__s2)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (__const char *__s1, __const char *__s2, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (__const char *__s1, __const char *__s2)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         __const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));






# 1 "/usr/include/xlocale.h" 1 3 4
# 28 "/usr/include/xlocale.h" 3 4
typedef struct __locale_struct
{

  struct locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
} *__locale_t;
# 119 "/usr/include/string.h" 2 3 4


extern int strcoll_l (__const char *__s1, __const char *__s2, __locale_t __l)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern size_t strxfrm_l (char *__dest, __const char *__src, size_t __n,
    __locale_t __l) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 4)));




extern char *strdup (__const char *__s)
     __attribute__ ((__nothrow__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (__const char *__string, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 165 "/usr/include/string.h" 3 4


extern char *strchr (__const char *__s, int __c)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));

extern char *strrchr (__const char *__s, int __c)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strchrnul (__const char *__s, int __c)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strcspn (__const char *__s, __const char *__reject)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (__const char *__s, __const char *__accept)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strpbrk (__const char *__s, __const char *__accept)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strstr (__const char *__haystack, __const char *__needle)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern char *strtok (char *__restrict __s, __const char *__restrict __delim)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));




extern char *__strtok_r (char *__restrict __s,
    __const char *__restrict __delim,
    char **__restrict __save_ptr)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, __const char *__restrict __delim,
         char **__restrict __save_ptr)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 3)));




extern char *strcasestr (__const char *__haystack, __const char *__needle)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));






extern void *memmem (__const void *__haystack, size_t __haystacklen,
       __const void *__needle, size_t __needlelen)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)));



extern void *__mempcpy (void *__restrict __dest,
   __const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        __const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));





extern size_t strlen (__const char *__s)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strnlen (__const char *__string, size_t __maxlen)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strerror (int __errnum) __attribute__ ((__nothrow__));

# 281 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));





extern void __bzero (void *__s, size_t __n) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern void bcopy (__const void *__src, void *__dest, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int bcmp (__const void *__s1, __const void *__s2, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *index (__const char *__s, int __c)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern char *rindex (__const char *__s, int __c)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));



extern int ffs (int __i) __attribute__ ((__nothrow__)) __attribute__ ((__const__));




extern int ffsl (long int __l) __attribute__ ((__nothrow__)) __attribute__ ((__const__));

__extension__ extern int ffsll (long long int __ll)
     __attribute__ ((__nothrow__)) __attribute__ ((__const__));




extern int strcasecmp (__const char *__s1, __const char *__s2)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (__const char *__s1, __const char *__s2, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));





extern int strcasecmp_l (__const char *__s1, __const char *__s2,
    __locale_t __loc)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern int strncasecmp_l (__const char *__s1, __const char *__s2,
     size_t __n, __locale_t __loc)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));





extern char *strsep (char **__restrict __stringp,
       __const char *__restrict __delim)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (__const char *__s1, __const char *__s2)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strsignal (int __sig) __attribute__ ((__nothrow__));


extern char *__stpcpy (char *__restrict __dest, __const char *__restrict __src)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, __const char *__restrict __src)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   __const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        __const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));






extern char *basename (__const char *__filename) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
# 426 "/usr/include/string.h" 3 4

# 123 "system.h" 2
# 1 "/usr/include/strings.h" 1 3 4
# 124 "system.h" 2
# 135 "system.h"
# 1 "/usr/include/stdlib.h" 1 3 4
# 33 "/usr/include/stdlib.h" 3 4
# 1 "/usr/lib/gcc/i386-redhat-linux/4.1.1/include/stddef.h" 1 3 4
# 34 "/usr/include/stdlib.h" 2 3 4








# 1 "/usr/include/bits/waitflags.h" 1 3 4
# 43 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/bits/waitstatus.h" 1 3 4
# 67 "/usr/include/bits/waitstatus.h" 3 4
union wait
  {
    int w_status;
    struct
      {

 unsigned int __w_termsig:7;
 unsigned int __w_coredump:1;
 unsigned int __w_retcode:8;
 unsigned int:16;







      } __wait_terminated;
    struct
      {

 unsigned int __w_stopval:8;
 unsigned int __w_stopsig:8;
 unsigned int:16;






      } __wait_stopped;
  };
# 44 "/usr/include/stdlib.h" 2 3 4
# 68 "/usr/include/stdlib.h" 3 4
typedef union
  {
    union wait *__uptr;
    int *__iptr;
  } __WAIT_STATUS __attribute__ ((__transparent_union__));
# 96 "/usr/include/stdlib.h" 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;







__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;


# 140 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) __attribute__ ((__nothrow__)) ;




extern double atof (__const char *__nptr)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (__const char *__nptr)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (__const char *__nptr)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





__extension__ extern long long int atoll (__const char *__nptr)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





extern double strtod (__const char *__restrict __nptr,
        char **__restrict __endptr)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;





extern float strtof (__const char *__restrict __nptr,
       char **__restrict __endptr) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;

extern long double strtold (__const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;





extern long int strtol (__const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;

extern unsigned long int strtoul (__const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;




__extension__
extern long long int strtoq (__const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;

__extension__
extern unsigned long long int strtouq (__const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;





__extension__
extern long long int strtoll (__const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;

__extension__
extern unsigned long long int strtoull (__const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;

# 240 "/usr/include/stdlib.h" 3 4
extern long int strtol_l (__const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     __locale_t __loc) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 4))) ;

extern unsigned long int strtoul_l (__const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, __locale_t __loc)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 4))) ;

__extension__
extern long long int strtoll_l (__const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    __locale_t __loc)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 4))) ;

__extension__
extern unsigned long long int strtoull_l (__const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, __locale_t __loc)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 4))) ;

extern double strtod_l (__const char *__restrict __nptr,
   char **__restrict __endptr, __locale_t __loc)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 3))) ;

extern float strtof_l (__const char *__restrict __nptr,
         char **__restrict __endptr, __locale_t __loc)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 3))) ;

extern long double strtold_l (__const char *__restrict __nptr,
         char **__restrict __endptr,
         __locale_t __loc)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 3))) ;






extern double __strtod_internal (__const char *__restrict __nptr,
     char **__restrict __endptr, int __group)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;
extern float __strtof_internal (__const char *__restrict __nptr,
    char **__restrict __endptr, int __group)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;
extern long double __strtold_internal (__const char *__restrict __nptr,
           char **__restrict __endptr,
           int __group)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;

extern long int __strtol_internal (__const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, int __group)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;



extern unsigned long int __strtoul_internal (__const char *__restrict __nptr,
          char **__restrict __endptr,
          int __base, int __group)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;




__extension__
extern long long int __strtoll_internal (__const char *__restrict __nptr,
      char **__restrict __endptr,
      int __base, int __group)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;



__extension__
extern unsigned long long int __strtoull_internal (__const char *
         __restrict __nptr,
         char **__restrict __endptr,
         int __base, int __group)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;
# 429 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) __attribute__ ((__nothrow__)) ;


extern long int a64l (__const char *__s)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;
# 445 "/usr/include/stdlib.h" 3 4
extern long int random (void) __attribute__ ((__nothrow__));


extern void srandom (unsigned int __seed) __attribute__ ((__nothrow__));





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));






extern int rand (void) __attribute__ ((__nothrow__));

extern void srand (unsigned int __seed) __attribute__ ((__nothrow__));




extern int rand_r (unsigned int *__seed) __attribute__ ((__nothrow__));







extern double drand48 (void) __attribute__ ((__nothrow__));
extern double erand48 (unsigned short int __xsubi[3]) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) __attribute__ ((__nothrow__));
extern long int nrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) __attribute__ ((__nothrow__));
extern long int jrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) __attribute__ ((__nothrow__));
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    unsigned long long int __a;
  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));









extern void *malloc (size_t __size) __attribute__ ((__nothrow__)) __attribute__ ((__malloc__)) ;

extern void *calloc (size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__)) __attribute__ ((__malloc__)) ;







extern void *realloc (void *__ptr, size_t __size)
     __attribute__ ((__nothrow__)) __attribute__ ((__malloc__)) __attribute__ ((__warn_unused_result__));

extern void free (void *__ptr) __attribute__ ((__nothrow__));




extern void cfree (void *__ptr) __attribute__ ((__nothrow__));



# 1 "/usr/include/alloca.h" 1 3 4
# 25 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib/gcc/i386-redhat-linux/4.1.1/include/stddef.h" 1 3 4
# 26 "/usr/include/alloca.h" 2 3 4







extern void *alloca (size_t __size) __attribute__ ((__nothrow__));






# 613 "/usr/include/stdlib.h" 2 3 4




extern void *valloc (size_t __size) __attribute__ ((__nothrow__)) __attribute__ ((__malloc__)) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;




extern void abort (void) __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));





extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));






extern void exit (int __status) __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));






extern void _Exit (int __status) __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));






extern char *getenv (__const char *__name) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;




extern char *__secure_getenv (__const char *__name)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;





extern int putenv (char *__string) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));





extern int setenv (__const char *__name, __const char *__value, int __replace)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));


extern int unsetenv (__const char *__name) __attribute__ ((__nothrow__));






extern int clearenv (void) __attribute__ ((__nothrow__));
# 698 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;
# 709 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 719 "/usr/include/stdlib.h" 3 4
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 729 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;








extern int system (__const char *__command) ;







extern char *canonicalize_file_name (__const char *__name)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;
# 757 "/usr/include/stdlib.h" 3 4
extern char *realpath (__const char *__restrict __name,
         char *__restrict __resolved) __attribute__ ((__nothrow__)) ;






typedef int (*__compar_fn_t) (__const void *, __const void *);


typedef __compar_fn_t comparison_fn_t;






extern void *bsearch (__const void *__key, __const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;



extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));



extern int abs (int __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__)) ;
extern long int labs (long int __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__)) ;



__extension__ extern long long int llabs (long long int __x)
     __attribute__ ((__nothrow__)) __attribute__ ((__const__)) ;







extern div_t div (int __numer, int __denom)
     __attribute__ ((__nothrow__)) __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     __attribute__ ((__nothrow__)) __attribute__ ((__const__)) ;




__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     __attribute__ ((__nothrow__)) __attribute__ ((__const__)) ;

# 822 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4, 5)));







extern int mblen (__const char *__s, size_t __n) __attribute__ ((__nothrow__)) ;


extern int mbtowc (wchar_t *__restrict __pwc,
     __const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__)) ;


extern int wctomb (char *__s, wchar_t __wchar) __attribute__ ((__nothrow__)) ;



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   __const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__));

extern size_t wcstombs (char *__restrict __s,
   __const wchar_t *__restrict __pwcs, size_t __n)
     __attribute__ ((__nothrow__));








extern int rpmatch (__const char *__response) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;
# 910 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *__const *__restrict __tokens,
        char **__restrict __valuep)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2, 3))) ;





extern void setkey (__const char *__key) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) __attribute__ ((__nothrow__));



extern int unlockpt (int __fd) __attribute__ ((__nothrow__));




extern char *ptsname (int __fd) __attribute__ ((__nothrow__)) ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
# 978 "/usr/include/stdlib.h" 3 4

# 136 "system.h" 2
# 158 "system.h"
# 1 "/usr/include/unistd.h" 1 3 4
# 28 "/usr/include/unistd.h" 3 4

# 171 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/bits/posix_opt.h" 1 3 4
# 172 "/usr/include/unistd.h" 2 3 4



# 1 "/usr/include/bits/environments.h" 1 3 4
# 176 "/usr/include/unistd.h" 2 3 4
# 195 "/usr/include/unistd.h" 3 4
# 1 "/usr/lib/gcc/i386-redhat-linux/4.1.1/include/stddef.h" 1 3 4
# 196 "/usr/include/unistd.h" 2 3 4
# 236 "/usr/include/unistd.h" 3 4
typedef __intptr_t intptr_t;






typedef __socklen_t socklen_t;
# 256 "/usr/include/unistd.h" 3 4
extern int access (__const char *__name, int __type) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));




extern int euidaccess (__const char *__name, int __type)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int eaccess (__const char *__name, int __type)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));






extern int faccessat (int __fd, __const char *__file, int __type, int __flag)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2))) ;
# 299 "/usr/include/unistd.h" 3 4
extern __off_t lseek (int __fd, __off_t __offset, int __whence) __attribute__ ((__nothrow__));
# 310 "/usr/include/unistd.h" 3 4
extern __off64_t lseek64 (int __fd, __off64_t __offset, int __whence)
     __attribute__ ((__nothrow__));






extern int close (int __fd);






extern ssize_t read (int __fd, void *__buf, size_t __nbytes) ;





extern ssize_t write (int __fd, __const void *__buf, size_t __n) ;
# 341 "/usr/include/unistd.h" 3 4
extern ssize_t pread (int __fd, void *__buf, size_t __nbytes,
        __off_t __offset) ;






extern ssize_t pwrite (int __fd, __const void *__buf, size_t __n,
         __off_t __offset) ;
# 369 "/usr/include/unistd.h" 3 4
extern ssize_t pread64 (int __fd, void *__buf, size_t __nbytes,
   __off64_t __offset) ;


extern ssize_t pwrite64 (int __fd, __const void *__buf, size_t __n,
    __off64_t __offset) ;







extern int pipe (int __pipedes[2]) __attribute__ ((__nothrow__)) ;
# 391 "/usr/include/unistd.h" 3 4
extern unsigned int alarm (unsigned int __seconds) __attribute__ ((__nothrow__));
# 403 "/usr/include/unistd.h" 3 4
extern unsigned int sleep (unsigned int __seconds);






extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     __attribute__ ((__nothrow__));






extern int usleep (__useconds_t __useconds);
# 427 "/usr/include/unistd.h" 3 4
extern int pause (void);



extern int chown (__const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;



extern int fchown (int __fd, __uid_t __owner, __gid_t __group) __attribute__ ((__nothrow__)) ;




extern int lchown (__const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;






extern int fchownat (int __fd, __const char *__file, __uid_t __owner,
       __gid_t __group, int __flag)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2))) ;



extern int chdir (__const char *__path) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;



extern int fchdir (int __fd) __attribute__ ((__nothrow__)) ;
# 469 "/usr/include/unistd.h" 3 4
extern char *getcwd (char *__buf, size_t __size) __attribute__ ((__nothrow__)) ;





extern char *get_current_dir_name (void) __attribute__ ((__nothrow__));






extern char *getwd (char *__buf)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__)) ;




extern int dup (int __fd) __attribute__ ((__nothrow__)) ;


extern int dup2 (int __fd, int __fd2) __attribute__ ((__nothrow__));


extern char **__environ;

extern char **environ;





extern int execve (__const char *__path, char *__const __argv[],
     char *__const __envp[]) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));




extern int fexecve (int __fd, char *__const __argv[], char *__const __envp[])
     __attribute__ ((__nothrow__));




extern int execv (__const char *__path, char *__const __argv[])
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern int execle (__const char *__path, __const char *__arg, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern int execl (__const char *__path, __const char *__arg, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern int execvp (__const char *__file, char *__const __argv[])
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));




extern int execlp (__const char *__file, __const char *__arg, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));




extern int nice (int __inc) __attribute__ ((__nothrow__)) ;




extern void _exit (int __status) __attribute__ ((__noreturn__));





# 1 "/usr/include/bits/confname.h" 1 3 4
# 26 "/usr/include/bits/confname.h" 3 4
enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };


enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,




    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,



    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG,


    _SC_LEVEL1_ICACHE_SIZE,

    _SC_LEVEL1_ICACHE_ASSOC,

    _SC_LEVEL1_ICACHE_LINESIZE,

    _SC_LEVEL1_DCACHE_SIZE,

    _SC_LEVEL1_DCACHE_ASSOC,

    _SC_LEVEL1_DCACHE_LINESIZE,

    _SC_LEVEL2_CACHE_SIZE,

    _SC_LEVEL2_CACHE_ASSOC,

    _SC_LEVEL2_CACHE_LINESIZE,

    _SC_LEVEL3_CACHE_SIZE,

    _SC_LEVEL3_CACHE_ASSOC,

    _SC_LEVEL3_CACHE_LINESIZE,

    _SC_LEVEL4_CACHE_SIZE,

    _SC_LEVEL4_CACHE_ASSOC,

    _SC_LEVEL4_CACHE_LINESIZE,



    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

    _SC_RAW_SOCKETS

  };


enum
  {
    _CS_PATH,


    _CS_V6_WIDTH_RESTRICTED_ENVS,


    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS

  };
# 553 "/usr/include/unistd.h" 2 3 4


extern long int pathconf (__const char *__path, int __name)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern long int fpathconf (int __fd, int __name) __attribute__ ((__nothrow__));


extern long int sysconf (int __name) __attribute__ ((__nothrow__)) __attribute__ ((__const__));



extern size_t confstr (int __name, char *__buf, size_t __len) __attribute__ ((__nothrow__));




extern __pid_t getpid (void) __attribute__ ((__nothrow__));


extern __pid_t getppid (void) __attribute__ ((__nothrow__));




extern __pid_t getpgrp (void) __attribute__ ((__nothrow__));
# 589 "/usr/include/unistd.h" 3 4
extern __pid_t __getpgid (__pid_t __pid) __attribute__ ((__nothrow__));

extern __pid_t getpgid (__pid_t __pid) __attribute__ ((__nothrow__));






extern int setpgid (__pid_t __pid, __pid_t __pgid) __attribute__ ((__nothrow__));
# 615 "/usr/include/unistd.h" 3 4
extern int setpgrp (void) __attribute__ ((__nothrow__));
# 632 "/usr/include/unistd.h" 3 4
extern __pid_t setsid (void) __attribute__ ((__nothrow__));



extern __pid_t getsid (__pid_t __pid) __attribute__ ((__nothrow__));



extern __uid_t getuid (void) __attribute__ ((__nothrow__));


extern __uid_t geteuid (void) __attribute__ ((__nothrow__));


extern __gid_t getgid (void) __attribute__ ((__nothrow__));


extern __gid_t getegid (void) __attribute__ ((__nothrow__));




extern int getgroups (int __size, __gid_t __list[]) __attribute__ ((__nothrow__)) ;



extern int group_member (__gid_t __gid) __attribute__ ((__nothrow__));






extern int setuid (__uid_t __uid) __attribute__ ((__nothrow__));




extern int setreuid (__uid_t __ruid, __uid_t __euid) __attribute__ ((__nothrow__));




extern int seteuid (__uid_t __uid) __attribute__ ((__nothrow__));






extern int setgid (__gid_t __gid) __attribute__ ((__nothrow__));




extern int setregid (__gid_t __rgid, __gid_t __egid) __attribute__ ((__nothrow__));




extern int setegid (__gid_t __gid) __attribute__ ((__nothrow__));





extern int getresuid (__uid_t *__ruid, __uid_t *__euid, __uid_t *__suid)
     __attribute__ ((__nothrow__));



extern int getresgid (__gid_t *__rgid, __gid_t *__egid, __gid_t *__sgid)
     __attribute__ ((__nothrow__));



extern int setresuid (__uid_t __ruid, __uid_t __euid, __uid_t __suid)
     __attribute__ ((__nothrow__));



extern int setresgid (__gid_t __rgid, __gid_t __egid, __gid_t __sgid)
     __attribute__ ((__nothrow__));






extern __pid_t fork (void) __attribute__ ((__nothrow__));






extern __pid_t vfork (void) __attribute__ ((__nothrow__));





extern char *ttyname (int __fd) __attribute__ ((__nothrow__));



extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2))) ;



extern int isatty (int __fd) __attribute__ ((__nothrow__));





extern int ttyslot (void) __attribute__ ((__nothrow__));




extern int link (__const char *__from, __const char *__to)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2))) ;




extern int linkat (int __fromfd, __const char *__from, int __tofd,
     __const char *__to, int __flags)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 4))) ;




extern int symlink (__const char *__from, __const char *__to)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2))) ;




extern ssize_t readlink (__const char *__restrict __path,
    char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2))) ;




extern int symlinkat (__const char *__from, int __tofd,
        __const char *__to) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 3))) ;


extern ssize_t readlinkat (int __fd, __const char *__restrict __path,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 3))) ;



extern int unlink (__const char *__name) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern int unlinkat (int __fd, __const char *__name, int __flag)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));



extern int rmdir (__const char *__path) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern __pid_t tcgetpgrp (int __fd) __attribute__ ((__nothrow__));


extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) __attribute__ ((__nothrow__));






extern char *getlogin (void);







extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)));




extern int setlogin (__const char *__name) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
# 835 "/usr/include/unistd.h" 3 4
# 1 "./../include/getopt.h" 1 3 4
# 36 "./../include/getopt.h" 3 4
extern char *optarg;
# 50 "./../include/getopt.h" 3 4
extern int optind;




extern int opterr;



extern int optopt;
# 82 "./../include/getopt.h" 3 4
struct option
{

  const char *name;





  int has_arg;
  int *flag;
  int val;
};
# 113 "./../include/getopt.h" 3 4
extern int getopt (int argc, char *const *argv, const char *shortopts);







extern int getopt_long (int argc, char *const *argv, const char *shortopts,
          const struct option *longopts, int *longind);
extern int getopt_long_only (int argc, char *const *argv,
        const char *shortopts,
               const struct option *longopts, int *longind);


extern int _getopt_internal (int argc, char *const *argv,
        const char *shortopts,
               const struct option *longopts, int *longind,
        int long_only);
# 836 "/usr/include/unistd.h" 2 3 4







extern int gethostname (char *__name, size_t __len) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));






extern int sethostname (__const char *__name, size_t __len)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;



extern int sethostid (long int __id) __attribute__ ((__nothrow__)) ;





extern int getdomainname (char *__name, size_t __len)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;
extern int setdomainname (__const char *__name, size_t __len)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;





extern int vhangup (void) __attribute__ ((__nothrow__));


extern int revoke (__const char *__file) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;







extern int profil (unsigned short int *__sample_buffer, size_t __size,
     size_t __offset, unsigned int __scale)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));





extern int acct (__const char *__name) __attribute__ ((__nothrow__));



extern char *getusershell (void) __attribute__ ((__nothrow__));
extern void endusershell (void) __attribute__ ((__nothrow__));
extern void setusershell (void) __attribute__ ((__nothrow__));





extern int daemon (int __nochdir, int __noclose) __attribute__ ((__nothrow__)) ;






extern int chroot (__const char *__path) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;



extern char *getpass (__const char *__prompt) __attribute__ ((__nonnull__ (1)));
# 921 "/usr/include/unistd.h" 3 4
extern int fsync (int __fd);






extern long int gethostid (void);


extern void sync (void) __attribute__ ((__nothrow__));




extern int getpagesize (void) __attribute__ ((__nothrow__)) __attribute__ ((__const__));




extern int getdtablesize (void) __attribute__ ((__nothrow__));




extern int truncate (__const char *__file, __off_t __length)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;
# 958 "/usr/include/unistd.h" 3 4
extern int truncate64 (__const char *__file, __off64_t __length)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;
# 968 "/usr/include/unistd.h" 3 4
extern int ftruncate (int __fd, __off_t __length) __attribute__ ((__nothrow__)) ;
# 978 "/usr/include/unistd.h" 3 4
extern int ftruncate64 (int __fd, __off64_t __length) __attribute__ ((__nothrow__)) ;
# 988 "/usr/include/unistd.h" 3 4
extern int brk (void *__addr) __attribute__ ((__nothrow__)) ;





extern void *sbrk (intptr_t __delta) __attribute__ ((__nothrow__));
# 1009 "/usr/include/unistd.h" 3 4
extern long int syscall (long int __sysno, ...) __attribute__ ((__nothrow__));
# 1032 "/usr/include/unistd.h" 3 4
extern int lockf (int __fd, int __cmd, __off_t __len) ;
# 1042 "/usr/include/unistd.h" 3 4
extern int lockf64 (int __fd, int __cmd, __off64_t __len) ;
# 1063 "/usr/include/unistd.h" 3 4
extern int fdatasync (int __fildes) __attribute__ ((__nothrow__));







extern char *crypt (__const char *__key, __const char *__salt)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));



extern void encrypt (char *__block, int __edflag) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));






extern void swab (__const void *__restrict __from, void *__restrict __to,
    ssize_t __n) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));







extern char *ctermid (char *__s) __attribute__ ((__nothrow__));
# 1101 "/usr/include/unistd.h" 3 4

# 159 "system.h" 2



# 1 "/usr/include/sys/param.h" 1 3 4
# 22 "/usr/include/sys/param.h" 3 4
# 1 "/usr/lib/gcc/i386-redhat-linux/4.1.1/include/limits.h" 1 3 4
# 11 "/usr/lib/gcc/i386-redhat-linux/4.1.1/include/limits.h" 3 4
# 1 "/usr/lib/gcc/i386-redhat-linux/4.1.1/include/syslimits.h" 1 3 4






# 1 "/usr/lib/gcc/i386-redhat-linux/4.1.1/include/limits.h" 1 3 4
# 122 "/usr/lib/gcc/i386-redhat-linux/4.1.1/include/limits.h" 3 4
# 1 "/usr/include/limits.h" 1 3 4
# 145 "/usr/include/limits.h" 3 4
# 1 "/usr/include/bits/posix1_lim.h" 1 3 4
# 153 "/usr/include/bits/posix1_lim.h" 3 4
# 1 "/usr/include/bits/local_lim.h" 1 3 4
# 36 "/usr/include/bits/local_lim.h" 3 4
# 1 "/usr/include/linux/limits.h" 1 3 4
# 37 "/usr/include/bits/local_lim.h" 2 3 4
# 154 "/usr/include/bits/posix1_lim.h" 2 3 4
# 146 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/bits/posix2_lim.h" 1 3 4
# 150 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/bits/xopen_lim.h" 1 3 4
# 34 "/usr/include/bits/xopen_lim.h" 3 4
# 1 "/usr/include/bits/stdio_lim.h" 1 3 4
# 35 "/usr/include/bits/xopen_lim.h" 2 3 4
# 154 "/usr/include/limits.h" 2 3 4
# 123 "/usr/lib/gcc/i386-redhat-linux/4.1.1/include/limits.h" 2 3 4
# 8 "/usr/lib/gcc/i386-redhat-linux/4.1.1/include/syslimits.h" 2 3 4
# 12 "/usr/lib/gcc/i386-redhat-linux/4.1.1/include/limits.h" 2 3 4
# 23 "/usr/include/sys/param.h" 2 3 4

# 1 "/usr/include/linux/param.h" 1 3 4



# 1 "/usr/include/asm/param.h" 1 3 4
# 5 "/usr/include/linux/param.h" 2 3 4
# 25 "/usr/include/sys/param.h" 2 3 4
# 163 "system.h" 2





# 1 "/usr/lib/gcc/i386-redhat-linux/4.1.1/include/limits.h" 1 3 4
# 169 "system.h" 2



# 1 "hwint.h" 1
# 173 "system.h" 2
# 201 "system.h"
# 1 "/usr/include/sys/time.h" 1 3 4
# 27 "/usr/include/sys/time.h" 3 4
# 1 "/usr/include/time.h" 1 3 4
# 28 "/usr/include/sys/time.h" 2 3 4

# 1 "/usr/include/bits/time.h" 1 3 4
# 30 "/usr/include/sys/time.h" 2 3 4
# 39 "/usr/include/sys/time.h" 3 4

# 57 "/usr/include/sys/time.h" 3 4
struct timezone
  {
    int tz_minuteswest;
    int tz_dsttime;
  };

typedef struct timezone *__restrict __timezone_ptr_t;
# 73 "/usr/include/sys/time.h" 3 4
extern int gettimeofday (struct timeval *__restrict __tv,
    __timezone_ptr_t __tz) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));




extern int settimeofday (__const struct timeval *__tv,
    __const struct timezone *__tz)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));





extern int adjtime (__const struct timeval *__delta,
      struct timeval *__olddelta) __attribute__ ((__nothrow__));




enum __itimer_which
  {

    ITIMER_REAL = 0,


    ITIMER_VIRTUAL = 1,



    ITIMER_PROF = 2

  };



struct itimerval
  {

    struct timeval it_interval;

    struct timeval it_value;
  };




typedef enum __itimer_which __itimer_which_t;






extern int getitimer (__itimer_which_t __which,
        struct itimerval *__value) __attribute__ ((__nothrow__));




extern int setitimer (__itimer_which_t __which,
        __const struct itimerval *__restrict __new,
        struct itimerval *__restrict __old) __attribute__ ((__nothrow__));




extern int utimes (__const char *__file, __const struct timeval __tvp[2])
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern int lutimes (__const char *__file, __const struct timeval __tvp[2])
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int futimes (int __fd, __const struct timeval __tvp[2]) __attribute__ ((__nothrow__));






extern int futimesat (int __fd, __const char *__file,
        __const struct timeval __tvp[2]) __attribute__ ((__nothrow__));
# 191 "/usr/include/sys/time.h" 3 4

# 202 "system.h" 2
# 1 "/usr/include/time.h" 1 3 4
# 31 "/usr/include/time.h" 3 4








# 1 "/usr/lib/gcc/i386-redhat-linux/4.1.1/include/stddef.h" 1 3 4
# 40 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/bits/time.h" 1 3 4
# 44 "/usr/include/time.h" 2 3 4
# 132 "/usr/include/time.h" 3 4


struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  __const char *tm_zone;




};








struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };


struct sigevent;
# 181 "/usr/include/time.h" 3 4



extern clock_t clock (void) __attribute__ ((__nothrow__));


extern time_t time (time_t *__timer) __attribute__ ((__nothrow__));


extern double difftime (time_t __time1, time_t __time0)
     __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) __attribute__ ((__nothrow__));





extern size_t strftime (char *__restrict __s, size_t __maxsize,
   __const char *__restrict __format,
   __const struct tm *__restrict __tp) __attribute__ ((__nothrow__));





extern char *strptime (__const char *__restrict __s,
         __const char *__restrict __fmt, struct tm *__tp)
     __attribute__ ((__nothrow__));







extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     __const char *__restrict __format,
     __const struct tm *__restrict __tp,
     __locale_t __loc) __attribute__ ((__nothrow__));

extern char *strptime_l (__const char *__restrict __s,
    __const char *__restrict __fmt, struct tm *__tp,
    __locale_t __loc) __attribute__ ((__nothrow__));






extern struct tm *gmtime (__const time_t *__timer) __attribute__ ((__nothrow__));



extern struct tm *localtime (__const time_t *__timer) __attribute__ ((__nothrow__));





extern struct tm *gmtime_r (__const time_t *__restrict __timer,
       struct tm *__restrict __tp) __attribute__ ((__nothrow__));



extern struct tm *localtime_r (__const time_t *__restrict __timer,
          struct tm *__restrict __tp) __attribute__ ((__nothrow__));





extern char *asctime (__const struct tm *__tp) __attribute__ ((__nothrow__));


extern char *ctime (__const time_t *__timer) __attribute__ ((__nothrow__));







extern char *asctime_r (__const struct tm *__restrict __tp,
   char *__restrict __buf) __attribute__ ((__nothrow__));


extern char *ctime_r (__const time_t *__restrict __timer,
        char *__restrict __buf) __attribute__ ((__nothrow__));




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) __attribute__ ((__nothrow__));



extern int daylight;
extern long int timezone;





extern int stime (__const time_t *__when) __attribute__ ((__nothrow__));
# 312 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) __attribute__ ((__nothrow__));


extern time_t timelocal (struct tm *__tp) __attribute__ ((__nothrow__));


extern int dysize (int __year) __attribute__ ((__nothrow__)) __attribute__ ((__const__));
# 327 "/usr/include/time.h" 3 4
extern int nanosleep (__const struct timespec *__requested_time,
        struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) __attribute__ ((__nothrow__));


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) __attribute__ ((__nothrow__));


extern int clock_settime (clockid_t __clock_id, __const struct timespec *__tp)
     __attribute__ ((__nothrow__));






extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       __const struct timespec *__req,
       struct timespec *__rem);


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) __attribute__ ((__nothrow__));




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) __attribute__ ((__nothrow__));


extern int timer_delete (timer_t __timerid) __attribute__ ((__nothrow__));


extern int timer_settime (timer_t __timerid, int __flags,
     __const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) __attribute__ ((__nothrow__));


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     __attribute__ ((__nothrow__));


extern int timer_getoverrun (timer_t __timerid) __attribute__ ((__nothrow__));
# 389 "/usr/include/time.h" 3 4
extern int getdate_err;
# 398 "/usr/include/time.h" 3 4
extern struct tm *getdate (__const char *__string);
# 412 "/usr/include/time.h" 3 4
extern int getdate_r (__const char *__restrict __string,
        struct tm *__restrict __resbufp);



# 203 "system.h" 2
# 214 "system.h"
# 1 "/usr/include/fcntl.h" 1 3 4
# 30 "/usr/include/fcntl.h" 3 4




# 1 "/usr/include/bits/fcntl.h" 1 3 4
# 138 "/usr/include/bits/fcntl.h" 3 4
struct flock
  {
    short int l_type;
    short int l_whence;

    __off_t l_start;
    __off_t l_len;




    __pid_t l_pid;
  };


struct flock64
  {
    short int l_type;
    short int l_whence;
    __off64_t l_start;
    __off64_t l_len;
    __pid_t l_pid;
  };
# 183 "/usr/include/bits/fcntl.h" 3 4



extern ssize_t readahead (int __fd, __off64_t __offset, size_t __count)
    __attribute__ ((__nothrow__));


# 35 "/usr/include/fcntl.h" 2 3 4



# 1 "/usr/include/sys/stat.h" 1 3 4
# 103 "/usr/include/sys/stat.h" 3 4


# 1 "/usr/include/bits/stat.h" 1 3 4
# 36 "/usr/include/bits/stat.h" 3 4
struct stat
  {
    __dev_t st_dev;
    unsigned short int __pad1;

    __ino_t st_ino;



    __mode_t st_mode;
    __nlink_t st_nlink;
    __uid_t st_uid;
    __gid_t st_gid;
    __dev_t st_rdev;
    unsigned short int __pad2;

    __off_t st_size;



    __blksize_t st_blksize;


    __blkcnt_t st_blocks;
# 70 "/usr/include/bits/stat.h" 3 4
    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 85 "/usr/include/bits/stat.h" 3 4
    unsigned long int __unused4;
    unsigned long int __unused5;



  };


struct stat64
  {
    __dev_t st_dev;
    unsigned int __pad1;

    __ino_t __st_ino;
    __mode_t st_mode;
    __nlink_t st_nlink;
    __uid_t st_uid;
    __gid_t st_gid;
    __dev_t st_rdev;
    unsigned int __pad2;
    __off64_t st_size;
    __blksize_t st_blksize;

    __blkcnt64_t st_blocks;







    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 127 "/usr/include/bits/stat.h" 3 4
    __ino64_t st_ino;
  };
# 106 "/usr/include/sys/stat.h" 2 3 4
# 207 "/usr/include/sys/stat.h" 3 4
extern int stat (__const char *__restrict __file,
   struct stat *__restrict __buf) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));



extern int fstat (int __fd, struct stat *__buf) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));
# 226 "/usr/include/sys/stat.h" 3 4
extern int stat64 (__const char *__restrict __file,
     struct stat64 *__restrict __buf) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
extern int fstat64 (int __fd, struct stat64 *__buf) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));







extern int fstatat (int __fd, __const char *__restrict __file,
      struct stat *__restrict __buf, int __flag)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 3)));
# 250 "/usr/include/sys/stat.h" 3 4
extern int fstatat64 (int __fd, __const char *__restrict __file,
        struct stat64 *__restrict __buf, int __flag)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 3)));






extern int lstat (__const char *__restrict __file,
    struct stat *__restrict __buf) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
# 272 "/usr/include/sys/stat.h" 3 4
extern int lstat64 (__const char *__restrict __file,
      struct stat64 *__restrict __buf)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));





extern int chmod (__const char *__file, __mode_t __mode)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));





extern int lchmod (__const char *__file, __mode_t __mode)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));




extern int fchmod (int __fd, __mode_t __mode) __attribute__ ((__nothrow__));





extern int fchmodat (int __fd, __const char *__file, __mode_t mode, int __flag)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2))) ;






extern __mode_t umask (__mode_t __mask) __attribute__ ((__nothrow__));




extern __mode_t getumask (void) __attribute__ ((__nothrow__));



extern int mkdir (__const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));





extern int mkdirat (int __fd, __const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));






extern int mknod (__const char *__path, __mode_t __mode, __dev_t __dev)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));






extern int mknodat (int __fd, __const char *__path, __mode_t __mode,
      __dev_t __dev) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));




extern int mkfifo (__const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));





extern int mkfifoat (int __fd, __const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));
# 380 "/usr/include/sys/stat.h" 3 4
extern int __fxstat (int __ver, int __fildes, struct stat *__stat_buf)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3)));
extern int __xstat (int __ver, __const char *__filename,
      struct stat *__stat_buf) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 3)));
extern int __lxstat (int __ver, __const char *__filename,
       struct stat *__stat_buf) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 3)));
extern int __fxstatat (int __ver, int __fildes, __const char *__filename,
         struct stat *__stat_buf, int __flag)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4)));
# 413 "/usr/include/sys/stat.h" 3 4
extern int __fxstat64 (int __ver, int __fildes, struct stat64 *__stat_buf)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3)));
extern int __xstat64 (int __ver, __const char *__filename,
        struct stat64 *__stat_buf) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 3)));
extern int __lxstat64 (int __ver, __const char *__filename,
         struct stat64 *__stat_buf) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 3)));
extern int __fxstatat64 (int __ver, int __fildes, __const char *__filename,
    struct stat64 *__stat_buf, int __flag)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4)));

extern int __xmknod (int __ver, __const char *__path, __mode_t __mode,
       __dev_t *__dev) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 4)));

extern int __xmknodat (int __ver, int __fd, __const char *__path,
         __mode_t __mode, __dev_t *__dev)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 5)));




extern __inline__ int
__attribute__ ((__nothrow__)) stat (__const char *__path, struct stat *__statbuf)
{
  return __xstat (3, __path, __statbuf);
}


extern __inline__ int
__attribute__ ((__nothrow__)) lstat (__const char *__path, struct stat *__statbuf)
{
  return __lxstat (3, __path, __statbuf);
}


extern __inline__ int
__attribute__ ((__nothrow__)) fstat (int __fd, struct stat *__statbuf)
{
  return __fxstat (3, __fd, __statbuf);
}


extern __inline__ int
__attribute__ ((__nothrow__)) fstatat (int __fd, __const char *__filename, struct stat *__statbuf, int __flag)

{
  return __fxstatat (3, __fd, __filename, __statbuf, __flag);
}



extern __inline__ int
__attribute__ ((__nothrow__)) mknod (__const char *__path, __mode_t __mode, __dev_t __dev)
{
  return __xmknod (1, __path, __mode, &__dev);
}



extern __inline__ int
__attribute__ ((__nothrow__)) mknodat (int __fd, __const char *__path, __mode_t __mode, __dev_t __dev)

{
  return __xmknodat (1, __fd, __path, __mode, &__dev);
}





extern __inline__ int
__attribute__ ((__nothrow__)) stat64 (__const char *__path, struct stat64 *__statbuf)
{
  return __xstat64 (3, __path, __statbuf);
}


extern __inline__ int
__attribute__ ((__nothrow__)) lstat64 (__const char *__path, struct stat64 *__statbuf)
{
  return __lxstat64 (3, __path, __statbuf);
}


extern __inline__ int
__attribute__ ((__nothrow__)) fstat64 (int __fd, struct stat64 *__statbuf)
{
  return __fxstat64 (3, __fd, __statbuf);
}


extern __inline__ int
__attribute__ ((__nothrow__)) fstatat64 (int __fd, __const char *__filename, struct stat64 *__statbuf, int __flag)

{
  return __fxstatat64 (3, __fd, __filename, __statbuf, __flag);
}







# 39 "/usr/include/fcntl.h" 2 3 4
# 76 "/usr/include/fcntl.h" 3 4
extern int fcntl (int __fd, int __cmd, ...);
# 85 "/usr/include/fcntl.h" 3 4
extern int open (__const char *__file, int __oflag, ...) __attribute__ ((__nonnull__ (1)));
# 95 "/usr/include/fcntl.h" 3 4
extern int open64 (__const char *__file, int __oflag, ...) __attribute__ ((__nonnull__ (1)));
# 109 "/usr/include/fcntl.h" 3 4
extern int openat (int __fd, __const char *__file, int __oflag, ...)
     __attribute__ ((__nonnull__ (2)));
# 120 "/usr/include/fcntl.h" 3 4
extern int openat64 (int __fd, __const char *__file, int __oflag, ...)
     __attribute__ ((__nonnull__ (2)));
# 130 "/usr/include/fcntl.h" 3 4
extern int creat (__const char *__file, __mode_t __mode) __attribute__ ((__nonnull__ (1)));
# 140 "/usr/include/fcntl.h" 3 4
extern int creat64 (__const char *__file, __mode_t __mode) __attribute__ ((__nonnull__ (1)));
# 176 "/usr/include/fcntl.h" 3 4
extern int posix_fadvise (int __fd, __off_t __offset, __off_t __len,
     int __advise) __attribute__ ((__nothrow__));
# 188 "/usr/include/fcntl.h" 3 4
extern int posix_fadvise64 (int __fd, __off64_t __offset, __off64_t __len,
       int __advise) __attribute__ ((__nothrow__));
# 198 "/usr/include/fcntl.h" 3 4
extern int posix_fallocate (int __fd, __off_t __offset, __off_t __len);
# 209 "/usr/include/fcntl.h" 3 4
extern int posix_fallocate64 (int __fd, __off64_t __offset, __off64_t __len);




# 215 "system.h" 2
# 252 "system.h"
# 1 "/usr/include/sys/wait.h" 1 3 4
# 29 "/usr/include/sys/wait.h" 3 4


# 1 "/usr/include/signal.h" 1 3 4
# 31 "/usr/include/signal.h" 3 4


# 1 "/usr/include/bits/sigset.h" 1 3 4
# 103 "/usr/include/bits/sigset.h" 3 4
extern int __sigismember (__const __sigset_t *, int);
extern int __sigaddset (__sigset_t *, int);
extern int __sigdelset (__sigset_t *, int);
# 34 "/usr/include/signal.h" 2 3 4







typedef __sig_atomic_t sig_atomic_t;

# 58 "/usr/include/signal.h" 3 4
# 1 "/usr/include/bits/signum.h" 1 3 4
# 59 "/usr/include/signal.h" 2 3 4
# 75 "/usr/include/signal.h" 3 4
typedef void (*__sighandler_t) (int);




extern __sighandler_t __sysv_signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__));

extern __sighandler_t sysv_signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__));







extern __sighandler_t signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__));
# 104 "/usr/include/signal.h" 3 4





extern __sighandler_t bsd_signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__));






extern int kill (__pid_t __pid, int __sig) __attribute__ ((__nothrow__));






extern int killpg (__pid_t __pgrp, int __sig) __attribute__ ((__nothrow__));




extern int raise (int __sig) __attribute__ ((__nothrow__));




extern __sighandler_t ssignal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__));
extern int gsignal (int __sig) __attribute__ ((__nothrow__));




extern void psignal (int __sig, __const char *__s);
# 153 "/usr/include/signal.h" 3 4
extern int __sigpause (int __sig_or_mask, int __is_sig);
# 162 "/usr/include/signal.h" 3 4
extern int sigpause (int __sig) __asm__ ("__xpg_sigpause");
# 181 "/usr/include/signal.h" 3 4
extern int sigblock (int __mask) __attribute__ ((__nothrow__)) __attribute__ ((__deprecated__));


extern int sigsetmask (int __mask) __attribute__ ((__nothrow__)) __attribute__ ((__deprecated__));


extern int siggetmask (void) __attribute__ ((__nothrow__)) __attribute__ ((__deprecated__));
# 196 "/usr/include/signal.h" 3 4
typedef __sighandler_t sighandler_t;




typedef __sighandler_t sig_t;
# 212 "/usr/include/signal.h" 3 4
# 1 "/usr/include/bits/siginfo.h" 1 3 4
# 25 "/usr/include/bits/siginfo.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 26 "/usr/include/bits/siginfo.h" 2 3 4







typedef union sigval
  {
    int sival_int;
    void *sival_ptr;
  } sigval_t;
# 51 "/usr/include/bits/siginfo.h" 3 4
typedef struct siginfo
  {
    int si_signo;
    int si_errno;

    int si_code;

    union
      {
 int _pad[((128 / sizeof (int)) - 3)];


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
   } _kill;


 struct
   {
     int si_tid;
     int si_overrun;
     sigval_t si_sigval;
   } _timer;


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
     sigval_t si_sigval;
   } _rt;


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
     int si_status;
     __clock_t si_utime;
     __clock_t si_stime;
   } _sigchld;


 struct
   {
     void *si_addr;
   } _sigfault;


 struct
   {
     long int si_band;
     int si_fd;
   } _sigpoll;
      } _sifields;
  } siginfo_t;
# 129 "/usr/include/bits/siginfo.h" 3 4
enum
{
  SI_ASYNCNL = -60,

  SI_TKILL = -6,

  SI_SIGIO,

  SI_ASYNCIO,

  SI_MESGQ,

  SI_TIMER,

  SI_QUEUE,

  SI_USER,

  SI_KERNEL = 0x80

};



enum
{
  ILL_ILLOPC = 1,

  ILL_ILLOPN,

  ILL_ILLADR,

  ILL_ILLTRP,

  ILL_PRVOPC,

  ILL_PRVREG,

  ILL_COPROC,

  ILL_BADSTK

};


enum
{
  FPE_INTDIV = 1,

  FPE_INTOVF,

  FPE_FLTDIV,

  FPE_FLTOVF,

  FPE_FLTUND,

  FPE_FLTRES,

  FPE_FLTINV,

  FPE_FLTSUB

};


enum
{
  SEGV_MAPERR = 1,

  SEGV_ACCERR

};


enum
{
  BUS_ADRALN = 1,

  BUS_ADRERR,

  BUS_OBJERR

};


enum
{
  TRAP_BRKPT = 1,

  TRAP_TRACE

};


enum
{
  CLD_EXITED = 1,

  CLD_KILLED,

  CLD_DUMPED,

  CLD_TRAPPED,

  CLD_STOPPED,

  CLD_CONTINUED

};


enum
{
  POLL_IN = 1,

  POLL_OUT,

  POLL_MSG,

  POLL_ERR,

  POLL_PRI,

  POLL_HUP

};
# 273 "/usr/include/bits/siginfo.h" 3 4
typedef struct sigevent
  {
    sigval_t sigev_value;
    int sigev_signo;
    int sigev_notify;

    union
      {
 int _pad[((64 / sizeof (int)) - 3)];



 __pid_t _tid;

 struct
   {
     void (*_function) (sigval_t);
     void *_attribute;
   } _sigev_thread;
      } _sigev_un;
  } sigevent_t;






enum
{
  SIGEV_SIGNAL = 0,

  SIGEV_NONE,

  SIGEV_THREAD,


  SIGEV_THREAD_ID = 4

};
# 213 "/usr/include/signal.h" 2 3 4



extern int sigemptyset (sigset_t *__set) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int sigfillset (sigset_t *__set) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int sigaddset (sigset_t *__set, int __signo) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int sigdelset (sigset_t *__set, int __signo) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int sigismember (__const sigset_t *__set, int __signo)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern int sigisemptyset (__const sigset_t *__set) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int sigandset (sigset_t *__set, __const sigset_t *__left,
        __const sigset_t *__right) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2, 3)));


extern int sigorset (sigset_t *__set, __const sigset_t *__left,
       __const sigset_t *__right) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2, 3)));




# 1 "/usr/include/bits/sigaction.h" 1 3 4
# 25 "/usr/include/bits/sigaction.h" 3 4
struct sigaction
  {


    union
      {

 __sighandler_t sa_handler;

 void (*sa_sigaction) (int, siginfo_t *, void *);
      }
    __sigaction_handler;







    __sigset_t sa_mask;


    int sa_flags;


    void (*sa_restorer) (void);
  };
# 247 "/usr/include/signal.h" 2 3 4


extern int sigprocmask (int __how, __const sigset_t *__restrict __set,
   sigset_t *__restrict __oset) __attribute__ ((__nothrow__));






extern int sigsuspend (__const sigset_t *__set) __attribute__ ((__nonnull__ (1)));


extern int sigaction (int __sig, __const struct sigaction *__restrict __act,
        struct sigaction *__restrict __oact) __attribute__ ((__nothrow__));


extern int sigpending (sigset_t *__set) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));






extern int sigwait (__const sigset_t *__restrict __set, int *__restrict __sig)
     __attribute__ ((__nonnull__ (1, 2)));






extern int sigwaitinfo (__const sigset_t *__restrict __set,
   siginfo_t *__restrict __info) __attribute__ ((__nonnull__ (1)));






extern int sigtimedwait (__const sigset_t *__restrict __set,
    siginfo_t *__restrict __info,
    __const struct timespec *__restrict __timeout)
     __attribute__ ((__nonnull__ (1)));



extern int sigqueue (__pid_t __pid, int __sig, __const union sigval __val)
     __attribute__ ((__nothrow__));
# 304 "/usr/include/signal.h" 3 4
extern __const char *__const _sys_siglist[65];
extern __const char *__const sys_siglist[65];


struct sigvec
  {
    __sighandler_t sv_handler;
    int sv_mask;

    int sv_flags;

  };
# 328 "/usr/include/signal.h" 3 4
extern int sigvec (int __sig, __const struct sigvec *__vec,
     struct sigvec *__ovec) __attribute__ ((__nothrow__));



# 1 "/usr/include/bits/sigcontext.h" 1 3 4
# 28 "/usr/include/bits/sigcontext.h" 3 4
# 1 "/usr/include/asm/sigcontext.h" 1 3 4
# 18 "/usr/include/asm/sigcontext.h" 3 4
struct _fpreg {
 unsigned short significand[4];
 unsigned short exponent;
};

struct _fpxreg {
 unsigned short significand[4];
 unsigned short exponent;
 unsigned short padding[3];
};

struct _xmmreg {
 unsigned long element[4];
};

struct _fpstate {

 unsigned long cw;
 unsigned long sw;
 unsigned long tag;
 unsigned long ipoff;
 unsigned long cssel;
 unsigned long dataoff;
 unsigned long datasel;
 struct _fpreg _st[8];
 unsigned short status;
 unsigned short magic;


 unsigned long _fxsr_env[6];
 unsigned long mxcsr;
 unsigned long reserved;
 struct _fpxreg _fxsr_st[8];
 struct _xmmreg _xmm[8];
 unsigned long padding[56];
};



struct sigcontext {
 unsigned short gs, __gsh;
 unsigned short fs, __fsh;
 unsigned short es, __esh;
 unsigned short ds, __dsh;
 unsigned long edi;
 unsigned long esi;
 unsigned long ebp;
 unsigned long esp;
 unsigned long ebx;
 unsigned long edx;
 unsigned long ecx;
 unsigned long eax;
 unsigned long trapno;
 unsigned long err;
 unsigned long eip;
 unsigned short cs, __csh;
 unsigned long eflags;
 unsigned long esp_at_signal;
 unsigned short ss, __ssh;
 struct _fpstate * fpstate;
 unsigned long oldmask;
 unsigned long cr2;
};
# 29 "/usr/include/bits/sigcontext.h" 2 3 4
# 334 "/usr/include/signal.h" 2 3 4


extern int sigreturn (struct sigcontext *__scp) __attribute__ ((__nothrow__));
# 346 "/usr/include/signal.h" 3 4
extern int siginterrupt (int __sig, int __interrupt) __attribute__ ((__nothrow__));

# 1 "/usr/include/bits/sigstack.h" 1 3 4
# 26 "/usr/include/bits/sigstack.h" 3 4
struct sigstack
  {
    void *ss_sp;
    int ss_onstack;
  };



enum
{
  SS_ONSTACK = 1,

  SS_DISABLE

};
# 50 "/usr/include/bits/sigstack.h" 3 4
typedef struct sigaltstack
  {
    void *ss_sp;
    int ss_flags;
    size_t ss_size;
  } stack_t;
# 349 "/usr/include/signal.h" 2 3 4


# 1 "/usr/include/sys/ucontext.h" 1 3 4
# 23 "/usr/include/sys/ucontext.h" 3 4
# 1 "/usr/include/signal.h" 1 3 4
# 24 "/usr/include/sys/ucontext.h" 2 3 4



# 1 "/usr/include/bits/sigcontext.h" 1 3 4
# 28 "/usr/include/sys/ucontext.h" 2 3 4



typedef int greg_t;





typedef greg_t gregset_t[19];



enum
{
  REG_GS = 0,

  REG_FS,

  REG_ES,

  REG_DS,

  REG_EDI,

  REG_ESI,

  REG_EBP,

  REG_ESP,

  REG_EBX,

  REG_EDX,

  REG_ECX,

  REG_EAX,

  REG_TRAPNO,

  REG_ERR,

  REG_EIP,

  REG_CS,

  REG_EFL,

  REG_UESP,

  REG_SS

};



struct _libc_fpreg
{
  unsigned short int significand[4];
  unsigned short int exponent;
};

struct _libc_fpstate
{
  unsigned long int cw;
  unsigned long int sw;
  unsigned long int tag;
  unsigned long int ipoff;
  unsigned long int cssel;
  unsigned long int dataoff;
  unsigned long int datasel;
  struct _libc_fpreg _st[8];
  unsigned long int status;
};


typedef struct _libc_fpstate *fpregset_t;


typedef struct
  {
    gregset_t gregs;


    fpregset_t fpregs;
    unsigned long int oldmask;
    unsigned long int cr2;
  } mcontext_t;


typedef struct ucontext
  {
    unsigned long int uc_flags;
    struct ucontext *uc_link;
    stack_t uc_stack;
    mcontext_t uc_mcontext;
    __sigset_t uc_sigmask;
    struct _libc_fpstate __fpregs_mem;
  } ucontext_t;
# 352 "/usr/include/signal.h" 2 3 4





extern int sigstack (struct sigstack *__ss, struct sigstack *__oss)
     __attribute__ ((__nothrow__)) __attribute__ ((__deprecated__));



extern int sigaltstack (__const struct sigaltstack *__restrict __ss,
   struct sigaltstack *__restrict __oss) __attribute__ ((__nothrow__));







extern int sighold (int __sig) __attribute__ ((__nothrow__));


extern int sigrelse (int __sig) __attribute__ ((__nothrow__));


extern int sigignore (int __sig) __attribute__ ((__nothrow__));


extern __sighandler_t sigset (int __sig, __sighandler_t __disp) __attribute__ ((__nothrow__));






# 1 "/usr/include/bits/sigthread.h" 1 3 4
# 31 "/usr/include/bits/sigthread.h" 3 4
extern int pthread_sigmask (int __how,
       __const __sigset_t *__restrict __newmask,
       __sigset_t *__restrict __oldmask)__attribute__ ((__nothrow__));


extern int pthread_kill (pthread_t __threadid, int __signo) __attribute__ ((__nothrow__));
# 388 "/usr/include/signal.h" 2 3 4






extern int __libc_current_sigrtmin (void) __attribute__ ((__nothrow__));

extern int __libc_current_sigrtmax (void) __attribute__ ((__nothrow__));




# 32 "/usr/include/sys/wait.h" 2 3 4
# 1 "/usr/include/sys/resource.h" 1 3 4
# 25 "/usr/include/sys/resource.h" 3 4
# 1 "/usr/include/bits/resource.h" 1 3 4
# 33 "/usr/include/bits/resource.h" 3 4
enum __rlimit_resource
{

  RLIMIT_CPU = 0,



  RLIMIT_FSIZE = 1,



  RLIMIT_DATA = 2,



  RLIMIT_STACK = 3,



  RLIMIT_CORE = 4,






  __RLIMIT_RSS = 5,



  RLIMIT_NOFILE = 7,
  __RLIMIT_OFILE = RLIMIT_NOFILE,




  RLIMIT_AS = 9,



  __RLIMIT_NPROC = 6,



  __RLIMIT_MEMLOCK = 8,



  __RLIMIT_LOCKS = 10,



  __RLIMIT_SIGPENDING = 11,



  __RLIMIT_MSGQUEUE = 12,





  __RLIMIT_NICE = 13,




  __RLIMIT_RTPRIO = 14,


  __RLIMIT_NLIMITS = 15,
  __RLIM_NLIMITS = __RLIMIT_NLIMITS


};
# 127 "/usr/include/bits/resource.h" 3 4
typedef __rlim_t rlim_t;




typedef __rlim64_t rlim64_t;


struct rlimit
  {

    rlim_t rlim_cur;

    rlim_t rlim_max;
  };


struct rlimit64
  {

    rlim64_t rlim_cur;

    rlim64_t rlim_max;
 };



enum __rusage_who
{

  RUSAGE_SELF = 0,



  RUSAGE_CHILDREN = -1

};


# 1 "/usr/include/bits/time.h" 1 3 4
# 167 "/usr/include/bits/resource.h" 2 3 4


struct rusage
  {

    struct timeval ru_utime;

    struct timeval ru_stime;

    long int ru_maxrss;


    long int ru_ixrss;

    long int ru_idrss;

    long int ru_isrss;


    long int ru_minflt;

    long int ru_majflt;

    long int ru_nswap;


    long int ru_inblock;

    long int ru_oublock;

    long int ru_msgsnd;

    long int ru_msgrcv;

    long int ru_nsignals;



    long int ru_nvcsw;


    long int ru_nivcsw;
  };







enum __priority_which
{
  PRIO_PROCESS = 0,

  PRIO_PGRP = 1,

  PRIO_USER = 2

};
# 26 "/usr/include/sys/resource.h" 2 3 4













typedef enum __rlimit_resource __rlimit_resource_t;
typedef enum __rusage_who __rusage_who_t;
typedef enum __priority_which __priority_which_t;
# 51 "/usr/include/sys/resource.h" 3 4
extern int getrlimit (__rlimit_resource_t __resource,
        struct rlimit *__rlimits) __attribute__ ((__nothrow__));
# 62 "/usr/include/sys/resource.h" 3 4
extern int getrlimit64 (__rlimit_resource_t __resource,
   struct rlimit64 *__rlimits) __attribute__ ((__nothrow__));






extern int setrlimit (__rlimit_resource_t __resource,
        __const struct rlimit *__rlimits) __attribute__ ((__nothrow__));
# 82 "/usr/include/sys/resource.h" 3 4
extern int setrlimit64 (__rlimit_resource_t __resource,
   __const struct rlimit64 *__rlimits) __attribute__ ((__nothrow__));




extern int getrusage (__rusage_who_t __who, struct rusage *__usage) __attribute__ ((__nothrow__));





extern int getpriority (__priority_which_t __which, id_t __who) __attribute__ ((__nothrow__));



extern int setpriority (__priority_which_t __which, id_t __who, int __prio)
     __attribute__ ((__nothrow__));


# 33 "/usr/include/sys/wait.h" 2 3 4
# 102 "/usr/include/sys/wait.h" 3 4
typedef enum
{
  P_ALL,
  P_PID,
  P_PGID
} idtype_t;
# 116 "/usr/include/sys/wait.h" 3 4
extern __pid_t wait (__WAIT_STATUS __stat_loc);
# 139 "/usr/include/sys/wait.h" 3 4
extern __pid_t waitpid (__pid_t __pid, int *__stat_loc, int __options);



# 1 "/usr/include/bits/siginfo.h" 1 3 4
# 25 "/usr/include/bits/siginfo.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 26 "/usr/include/bits/siginfo.h" 2 3 4
# 144 "/usr/include/sys/wait.h" 2 3 4
# 155 "/usr/include/sys/wait.h" 3 4
extern int waitid (idtype_t __idtype, __id_t __id, siginfo_t *__infop,
     int __options);





struct rusage;






extern __pid_t wait3 (__WAIT_STATUS __stat_loc, int __options,
        struct rusage * __usage) __attribute__ ((__nothrow__));





struct rusage;


extern __pid_t wait4 (__pid_t __pid, __WAIT_STATUS __stat_loc, int __options,
        struct rusage *__usage) __attribute__ ((__nothrow__));




# 253 "system.h" 2
# 303 "system.h"
extern int getopt (int, char * const *, const char *);
# 319 "system.h"
# 1 "/usr/include/malloc.h" 1 3 4
# 24 "/usr/include/malloc.h" 3 4
# 1 "/usr/lib/gcc/i386-redhat-linux/4.1.1/include/stddef.h" 1 3 4
# 25 "/usr/include/malloc.h" 2 3 4
# 46 "/usr/include/malloc.h" 3 4



extern void *malloc (size_t __size) __attribute__ ((__nothrow__)) __attribute__ ((__malloc__)) ;


extern void *calloc (size_t __nmemb, size_t __size) __attribute__ ((__nothrow__))
       __attribute__ ((__malloc__)) ;



extern void *realloc (void *__ptr, size_t __size) __attribute__ ((__nothrow__))
       __attribute__ ((__malloc__)) __attribute__ ((__warn_unused_result__));


extern void free (void *__ptr) __attribute__ ((__nothrow__));


extern void cfree (void *__ptr) __attribute__ ((__nothrow__));


extern void *memalign (size_t __alignment, size_t __size) __attribute__ ((__nothrow__))
       __attribute__ ((__malloc__)) ;


extern void *valloc (size_t __size) __attribute__ ((__nothrow__))
       __attribute__ ((__malloc__)) ;



extern void * pvalloc (size_t __size) __attribute__ ((__nothrow__))
       __attribute__ ((__malloc__)) ;



extern void *(*__morecore) (ptrdiff_t __size);


extern void *__default_morecore (ptrdiff_t __size) __attribute__ ((__nothrow__))
       __attribute__ ((__malloc__));



struct mallinfo {
  int arena;
  int ordblks;
  int smblks;
  int hblks;
  int hblkhd;
  int usmblks;
  int fsmblks;
  int uordblks;
  int fordblks;
  int keepcost;
};


extern struct mallinfo mallinfo (void) __attribute__ ((__nothrow__));
# 128 "/usr/include/malloc.h" 3 4
extern int mallopt (int __param, int __val) __attribute__ ((__nothrow__));



extern int malloc_trim (size_t __pad) __attribute__ ((__nothrow__));



extern size_t malloc_usable_size (void *__ptr) __attribute__ ((__nothrow__));


extern void malloc_stats (void) __attribute__ ((__nothrow__));


extern void *malloc_get_state (void) __attribute__ ((__nothrow__));



extern int malloc_set_state (void *__ptr) __attribute__ ((__nothrow__));




extern void (*__malloc_initialize_hook) (void);

extern void (*__free_hook) (void *__ptr, __const void *);

extern void *(*__malloc_hook) (size_t __size, __const void *);

extern void *(*__realloc_hook) (void *__ptr, size_t __size, __const void *);

extern void *(*__memalign_hook) (size_t __alignment, size_t __size, __const void *);


extern void (*__after_morecore_hook) (void);


extern void __malloc_check_init (void) __attribute__ ((__nothrow__));



# 320 "system.h" 2
# 469 "system.h"
# 1 "./../include/filenames.h" 1
# 470 "system.h" 2
# 480 "system.h"
# 1 "./../include/libiberty.h" 1
# 42 "./../include/libiberty.h"
# 1 "./../include/ansidecl.h" 1
# 43 "./../include/libiberty.h" 2



# 1 "/usr/lib/gcc/i386-redhat-linux/4.1.1/include/stddef.h" 1 3 4
# 47 "./../include/libiberty.h" 2







extern char **buildargv (const char *) __attribute__ ((__malloc__));



extern void freeargv (char **);




extern char **dupargv (char **) __attribute__ ((__malloc__));
# 86 "./../include/libiberty.h"
extern const char *lbasename (const char *);



extern char *lrealpath (const char *);





extern char *concat (const char *, ...) __attribute__ ((__malloc__));
# 105 "./../include/libiberty.h"
extern char *reconcat (char *, const char *, ...) __attribute__ ((__malloc__));





extern unsigned long concat_length (const char *, ...);






extern char *concat_copy (char *, const char *, ...);






extern char *concat_copy2 (const char *, ...);



extern char *libiberty_concat_ptr;
# 141 "./../include/libiberty.h"
extern int fdmatch (int fd1, int fd2);




extern char * getpwd (void);



extern long get_run_time (void);




extern char *make_relative_prefix (const char *, const char *, const char *);




extern char *choose_temp_base (void) __attribute__ ((__malloc__));



extern char *make_temp_file (const char *) __attribute__ ((__malloc__));



extern const char *spaces (int count);




extern int errno_max (void);




extern const char *strerrno (int);



extern int strtoerrno (const char *);



extern char *xstrerror (int);




extern int signo_max (void);
# 203 "./../include/libiberty.h"
extern const char *strsigno (int);



extern int strtosigno (const char *);



extern int xatexit (void (*fn) (void));



extern void xexit (int status) __attribute__ ((__noreturn__));



extern void xmalloc_set_program_name (const char *);


extern void xmalloc_failed (size_t) __attribute__ ((__noreturn__));





extern void * xmalloc (size_t) __attribute__ ((__malloc__));





extern void * xrealloc (void *, size_t);




extern void * xcalloc (size_t, size_t) __attribute__ ((__malloc__));



extern char *xstrdup (const char *) __attribute__ ((__malloc__));



extern void * xmemdup (const void *, size_t, size_t) __attribute__ ((__malloc__));


extern double physmem_total (void);
extern double physmem_available (void);





extern const unsigned char _hex_value[256];
extern void hex_init (void);
# 274 "./../include/libiberty.h"
extern int pexecute (const char *, char * const *, const char *, const char *, char **, char **, int);




extern int pwait (int, int *, int);





extern int asprintf (char **, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3))) __attribute__ ((__nonnull__ (2)));
# 304 "./../include/libiberty.h"
extern void * C_alloca (size_t) __attribute__ ((__malloc__));
# 481 "system.h" 2
# 534 "system.h"
# 1 "/usr/lib/gcc/i386-redhat-linux/4.1.1/include/stdbool.h" 1 3 4
# 535 "system.h" 2
# 578 "system.h"
        




        



        
# 610 "system.h"
        
# 637 "system.h"
        
# 649 "system.h"
        
# 659 "system.h"
        
# 91 "reload.c" 2
# 1 "coretypes.h" 1
# 40 "coretypes.h"
struct rtx_def;
typedef struct rtx_def *rtx;
struct rtvec_def;
typedef struct rtvec_def *rtvec;
union tree_node;
typedef union tree_node *tree;





struct cpp_reader;
# 92 "reload.c" 2
# 1 "tm.h" 1



# 1 "config/i386/i386.h" 1
# 39 "config/i386/i386.h"
struct processor_costs {
  const int add;
  const int lea;
  const int shift_var;
  const int shift_const;
  const int mult_init[5];

  const int mult_bit;
  const int divide[5];

  int movsx;
  int movzx;
  const int large_insn;
  const int move_ratio;

  const int movzbl_load;
  const int int_load[3];


  const int int_store[3];

  const int fp_move;
  const int fp_load[3];

  const int fp_store[3];

  const int mmx_move;
  const int mmx_load[2];

  const int mmx_store[2];

  const int sse_move;
  const int sse_load[3];

  const int sse_store[3];

  const int mmxsse_to_integer;

  const int prefetch_block;
  const int simultaneous_prefetches;

  const int branch_cost;
  const int fadd;
  const int fmul;
  const int fdiv;
  const int fabs;
  const int fchs;
  const int fsqrt;
};

extern const struct processor_costs *ix86_cost;



extern int target_flags;
# 224 "config/i386/i386.h"
extern const int x86_use_leave, x86_push_memory, x86_zero_extend_with_and;
extern const int x86_use_bit_test, x86_cmove, x86_deep_branch;
extern const int x86_branch_hints, x86_unroll_strlen;
extern const int x86_double_with_add, x86_partial_reg_stall, x86_movx;
extern const int x86_use_loop, x86_use_fiop, x86_use_mov0;
extern const int x86_use_cltd, x86_read_modify_write;
extern const int x86_read_modify, x86_split_long_moves;
extern const int x86_promote_QImode, x86_single_stringop, x86_fast_prefix;
extern const int x86_himode_math, x86_qimode_math, x86_promote_qi_regs;
extern const int x86_promote_hi_regs, x86_integer_DFmode_moves;
extern const int x86_add_esp_4, x86_add_esp_8, x86_sub_esp_4, x86_sub_esp_8;
extern const int x86_partial_reg_dependency, x86_memory_mismatch_stall;
extern const int x86_accumulate_outgoing_args, x86_prologue_using_move;
extern const int x86_epilogue_using_move, x86_decompose_lea;
extern const int x86_arch_always_fancy_math_387, x86_shift1;
extern const int x86_sse_partial_reg_dependency, x86_sse_partial_regs;
extern const int x86_sse_typeless_stores, x86_sse_load0_by_pxor;
extern const int x86_use_ffreep, x86_sse_partial_regs_for_cvtsd2ss;
extern const int x86_inter_unit_moves;
extern int x86_prefetch_sse;
# 1278 "config/i386/i386.h"
enum reg_class
{
  NO_REGS,
  AREG, DREG, CREG, BREG, SIREG, DIREG,
  AD_REGS,
  Q_REGS,
  NON_Q_REGS,
  INDEX_REGS,
  LEGACY_REGS,
  GENERAL_REGS,
  FP_TOP_REG, FP_SECOND_REG,
  FLOAT_REGS,
  SSE_REGS,
  MMX_REGS,
  FP_TOP_SSE_REGS,
  FP_SECOND_SSE_REGS,
  FLOAT_SSE_REGS,
  FLOAT_INT_REGS,
  INT_SSE_REGS,
  FLOAT_INT_SSE_REGS,
  ALL_REGS, LIM_REG_CLASSES
};
# 1748 "config/i386/i386.h"
typedef struct ix86_args {
  int words;
  int nregs;
  int regno;
  int fastcall;
  int sse_words;
  int sse_nregs;
  int warn_sse;
  int warn_mmx;
  int sse_regno;
  int mmx_words;
  int mmx_nregs;
  int mmx_regno;
  int maybe_vaarg;
} CUMULATIVE_ARGS;
# 2086 "config/i386/i386.h"
enum ix86_builtins
{
  IX86_BUILTIN_ADDPS,
  IX86_BUILTIN_ADDSS,
  IX86_BUILTIN_DIVPS,
  IX86_BUILTIN_DIVSS,
  IX86_BUILTIN_MULPS,
  IX86_BUILTIN_MULSS,
  IX86_BUILTIN_SUBPS,
  IX86_BUILTIN_SUBSS,

  IX86_BUILTIN_CMPEQPS,
  IX86_BUILTIN_CMPLTPS,
  IX86_BUILTIN_CMPLEPS,
  IX86_BUILTIN_CMPGTPS,
  IX86_BUILTIN_CMPGEPS,
  IX86_BUILTIN_CMPNEQPS,
  IX86_BUILTIN_CMPNLTPS,
  IX86_BUILTIN_CMPNLEPS,
  IX86_BUILTIN_CMPNGTPS,
  IX86_BUILTIN_CMPNGEPS,
  IX86_BUILTIN_CMPORDPS,
  IX86_BUILTIN_CMPUNORDPS,
  IX86_BUILTIN_CMPNEPS,
  IX86_BUILTIN_CMPEQSS,
  IX86_BUILTIN_CMPLTSS,
  IX86_BUILTIN_CMPLESS,
  IX86_BUILTIN_CMPNEQSS,
  IX86_BUILTIN_CMPNLTSS,
  IX86_BUILTIN_CMPNLESS,
  IX86_BUILTIN_CMPORDSS,
  IX86_BUILTIN_CMPUNORDSS,
  IX86_BUILTIN_CMPNESS,

  IX86_BUILTIN_COMIEQSS,
  IX86_BUILTIN_COMILTSS,
  IX86_BUILTIN_COMILESS,
  IX86_BUILTIN_COMIGTSS,
  IX86_BUILTIN_COMIGESS,
  IX86_BUILTIN_COMINEQSS,
  IX86_BUILTIN_UCOMIEQSS,
  IX86_BUILTIN_UCOMILTSS,
  IX86_BUILTIN_UCOMILESS,
  IX86_BUILTIN_UCOMIGTSS,
  IX86_BUILTIN_UCOMIGESS,
  IX86_BUILTIN_UCOMINEQSS,

  IX86_BUILTIN_CVTPI2PS,
  IX86_BUILTIN_CVTPS2PI,
  IX86_BUILTIN_CVTSI2SS,
  IX86_BUILTIN_CVTSI642SS,
  IX86_BUILTIN_CVTSS2SI,
  IX86_BUILTIN_CVTSS2SI64,
  IX86_BUILTIN_CVTTPS2PI,
  IX86_BUILTIN_CVTTSS2SI,
  IX86_BUILTIN_CVTTSS2SI64,

  IX86_BUILTIN_MAXPS,
  IX86_BUILTIN_MAXSS,
  IX86_BUILTIN_MINPS,
  IX86_BUILTIN_MINSS,

  IX86_BUILTIN_LOADAPS,
  IX86_BUILTIN_LOADUPS,
  IX86_BUILTIN_STOREAPS,
  IX86_BUILTIN_STOREUPS,
  IX86_BUILTIN_LOADSS,
  IX86_BUILTIN_STORESS,
  IX86_BUILTIN_MOVSS,

  IX86_BUILTIN_MOVHLPS,
  IX86_BUILTIN_MOVLHPS,
  IX86_BUILTIN_LOADHPS,
  IX86_BUILTIN_LOADLPS,
  IX86_BUILTIN_STOREHPS,
  IX86_BUILTIN_STORELPS,

  IX86_BUILTIN_MASKMOVQ,
  IX86_BUILTIN_MOVMSKPS,
  IX86_BUILTIN_PMOVMSKB,

  IX86_BUILTIN_MOVNTPS,
  IX86_BUILTIN_MOVNTQ,

  IX86_BUILTIN_LOADDQA,
  IX86_BUILTIN_LOADDQU,
  IX86_BUILTIN_STOREDQA,
  IX86_BUILTIN_STOREDQU,
  IX86_BUILTIN_MOVQ,
  IX86_BUILTIN_LOADD,
  IX86_BUILTIN_STORED,

  IX86_BUILTIN_CLRTI,

  IX86_BUILTIN_PACKSSWB,
  IX86_BUILTIN_PACKSSDW,
  IX86_BUILTIN_PACKUSWB,

  IX86_BUILTIN_PADDB,
  IX86_BUILTIN_PADDW,
  IX86_BUILTIN_PADDD,
  IX86_BUILTIN_PADDQ,
  IX86_BUILTIN_PADDSB,
  IX86_BUILTIN_PADDSW,
  IX86_BUILTIN_PADDUSB,
  IX86_BUILTIN_PADDUSW,
  IX86_BUILTIN_PSUBB,
  IX86_BUILTIN_PSUBW,
  IX86_BUILTIN_PSUBD,
  IX86_BUILTIN_PSUBQ,
  IX86_BUILTIN_PSUBSB,
  IX86_BUILTIN_PSUBSW,
  IX86_BUILTIN_PSUBUSB,
  IX86_BUILTIN_PSUBUSW,

  IX86_BUILTIN_PAND,
  IX86_BUILTIN_PANDN,
  IX86_BUILTIN_POR,
  IX86_BUILTIN_PXOR,

  IX86_BUILTIN_PAVGB,
  IX86_BUILTIN_PAVGW,

  IX86_BUILTIN_PCMPEQB,
  IX86_BUILTIN_PCMPEQW,
  IX86_BUILTIN_PCMPEQD,
  IX86_BUILTIN_PCMPGTB,
  IX86_BUILTIN_PCMPGTW,
  IX86_BUILTIN_PCMPGTD,

  IX86_BUILTIN_PEXTRW,
  IX86_BUILTIN_PINSRW,

  IX86_BUILTIN_PMADDWD,

  IX86_BUILTIN_PMAXSW,
  IX86_BUILTIN_PMAXUB,
  IX86_BUILTIN_PMINSW,
  IX86_BUILTIN_PMINUB,

  IX86_BUILTIN_PMULHUW,
  IX86_BUILTIN_PMULHW,
  IX86_BUILTIN_PMULLW,

  IX86_BUILTIN_PSADBW,
  IX86_BUILTIN_PSHUFW,

  IX86_BUILTIN_PSLLW,
  IX86_BUILTIN_PSLLD,
  IX86_BUILTIN_PSLLQ,
  IX86_BUILTIN_PSRAW,
  IX86_BUILTIN_PSRAD,
  IX86_BUILTIN_PSRLW,
  IX86_BUILTIN_PSRLD,
  IX86_BUILTIN_PSRLQ,
  IX86_BUILTIN_PSLLWI,
  IX86_BUILTIN_PSLLDI,
  IX86_BUILTIN_PSLLQI,
  IX86_BUILTIN_PSRAWI,
  IX86_BUILTIN_PSRADI,
  IX86_BUILTIN_PSRLWI,
  IX86_BUILTIN_PSRLDI,
  IX86_BUILTIN_PSRLQI,

  IX86_BUILTIN_PUNPCKHBW,
  IX86_BUILTIN_PUNPCKHWD,
  IX86_BUILTIN_PUNPCKHDQ,
  IX86_BUILTIN_PUNPCKLBW,
  IX86_BUILTIN_PUNPCKLWD,
  IX86_BUILTIN_PUNPCKLDQ,

  IX86_BUILTIN_SHUFPS,

  IX86_BUILTIN_RCPPS,
  IX86_BUILTIN_RCPSS,
  IX86_BUILTIN_RSQRTPS,
  IX86_BUILTIN_RSQRTSS,
  IX86_BUILTIN_SQRTPS,
  IX86_BUILTIN_SQRTSS,

  IX86_BUILTIN_UNPCKHPS,
  IX86_BUILTIN_UNPCKLPS,

  IX86_BUILTIN_ANDPS,
  IX86_BUILTIN_ANDNPS,
  IX86_BUILTIN_ORPS,
  IX86_BUILTIN_XORPS,

  IX86_BUILTIN_EMMS,
  IX86_BUILTIN_LDMXCSR,
  IX86_BUILTIN_STMXCSR,
  IX86_BUILTIN_SFENCE,


  IX86_BUILTIN_FEMMS,
  IX86_BUILTIN_PAVGUSB,
  IX86_BUILTIN_PF2ID,
  IX86_BUILTIN_PFACC,
  IX86_BUILTIN_PFADD,
  IX86_BUILTIN_PFCMPEQ,
  IX86_BUILTIN_PFCMPGE,
  IX86_BUILTIN_PFCMPGT,
  IX86_BUILTIN_PFMAX,
  IX86_BUILTIN_PFMIN,
  IX86_BUILTIN_PFMUL,
  IX86_BUILTIN_PFRCP,
  IX86_BUILTIN_PFRCPIT1,
  IX86_BUILTIN_PFRCPIT2,
  IX86_BUILTIN_PFRSQIT1,
  IX86_BUILTIN_PFRSQRT,
  IX86_BUILTIN_PFSUB,
  IX86_BUILTIN_PFSUBR,
  IX86_BUILTIN_PI2FD,
  IX86_BUILTIN_PMULHRW,


  IX86_BUILTIN_PF2IW,
  IX86_BUILTIN_PFNACC,
  IX86_BUILTIN_PFPNACC,
  IX86_BUILTIN_PI2FW,
  IX86_BUILTIN_PSWAPDSI,
  IX86_BUILTIN_PSWAPDSF,

  IX86_BUILTIN_SSE_ZERO,
  IX86_BUILTIN_MMX_ZERO,


  IX86_BUILTIN_ADDPD,
  IX86_BUILTIN_ADDSD,
  IX86_BUILTIN_DIVPD,
  IX86_BUILTIN_DIVSD,
  IX86_BUILTIN_MULPD,
  IX86_BUILTIN_MULSD,
  IX86_BUILTIN_SUBPD,
  IX86_BUILTIN_SUBSD,

  IX86_BUILTIN_CMPEQPD,
  IX86_BUILTIN_CMPLTPD,
  IX86_BUILTIN_CMPLEPD,
  IX86_BUILTIN_CMPGTPD,
  IX86_BUILTIN_CMPGEPD,
  IX86_BUILTIN_CMPNEQPD,
  IX86_BUILTIN_CMPNLTPD,
  IX86_BUILTIN_CMPNLEPD,
  IX86_BUILTIN_CMPNGTPD,
  IX86_BUILTIN_CMPNGEPD,
  IX86_BUILTIN_CMPORDPD,
  IX86_BUILTIN_CMPUNORDPD,
  IX86_BUILTIN_CMPNEPD,
  IX86_BUILTIN_CMPEQSD,
  IX86_BUILTIN_CMPLTSD,
  IX86_BUILTIN_CMPLESD,
  IX86_BUILTIN_CMPNEQSD,
  IX86_BUILTIN_CMPNLTSD,
  IX86_BUILTIN_CMPNLESD,
  IX86_BUILTIN_CMPORDSD,
  IX86_BUILTIN_CMPUNORDSD,
  IX86_BUILTIN_CMPNESD,

  IX86_BUILTIN_COMIEQSD,
  IX86_BUILTIN_COMILTSD,
  IX86_BUILTIN_COMILESD,
  IX86_BUILTIN_COMIGTSD,
  IX86_BUILTIN_COMIGESD,
  IX86_BUILTIN_COMINEQSD,
  IX86_BUILTIN_UCOMIEQSD,
  IX86_BUILTIN_UCOMILTSD,
  IX86_BUILTIN_UCOMILESD,
  IX86_BUILTIN_UCOMIGTSD,
  IX86_BUILTIN_UCOMIGESD,
  IX86_BUILTIN_UCOMINEQSD,

  IX86_BUILTIN_MAXPD,
  IX86_BUILTIN_MAXSD,
  IX86_BUILTIN_MINPD,
  IX86_BUILTIN_MINSD,

  IX86_BUILTIN_ANDPD,
  IX86_BUILTIN_ANDNPD,
  IX86_BUILTIN_ORPD,
  IX86_BUILTIN_XORPD,

  IX86_BUILTIN_SQRTPD,
  IX86_BUILTIN_SQRTSD,

  IX86_BUILTIN_UNPCKHPD,
  IX86_BUILTIN_UNPCKLPD,

  IX86_BUILTIN_SHUFPD,

  IX86_BUILTIN_LOADAPD,
  IX86_BUILTIN_LOADUPD,
  IX86_BUILTIN_STOREAPD,
  IX86_BUILTIN_STOREUPD,
  IX86_BUILTIN_LOADSD,
  IX86_BUILTIN_STORESD,
  IX86_BUILTIN_MOVSD,

  IX86_BUILTIN_LOADHPD,
  IX86_BUILTIN_LOADLPD,
  IX86_BUILTIN_STOREHPD,
  IX86_BUILTIN_STORELPD,

  IX86_BUILTIN_CVTDQ2PD,
  IX86_BUILTIN_CVTDQ2PS,

  IX86_BUILTIN_CVTPD2DQ,
  IX86_BUILTIN_CVTPD2PI,
  IX86_BUILTIN_CVTPD2PS,
  IX86_BUILTIN_CVTTPD2DQ,
  IX86_BUILTIN_CVTTPD2PI,

  IX86_BUILTIN_CVTPI2PD,
  IX86_BUILTIN_CVTSI2SD,
  IX86_BUILTIN_CVTSI642SD,

  IX86_BUILTIN_CVTSD2SI,
  IX86_BUILTIN_CVTSD2SI64,
  IX86_BUILTIN_CVTSD2SS,
  IX86_BUILTIN_CVTSS2SD,
  IX86_BUILTIN_CVTTSD2SI,
  IX86_BUILTIN_CVTTSD2SI64,

  IX86_BUILTIN_CVTPS2DQ,
  IX86_BUILTIN_CVTPS2PD,
  IX86_BUILTIN_CVTTPS2DQ,

  IX86_BUILTIN_MOVNTI,
  IX86_BUILTIN_MOVNTPD,
  IX86_BUILTIN_MOVNTDQ,

  IX86_BUILTIN_SETPD1,
  IX86_BUILTIN_SETPD,
  IX86_BUILTIN_CLRPD,
  IX86_BUILTIN_SETRPD,
  IX86_BUILTIN_LOADPD1,
  IX86_BUILTIN_LOADRPD,
  IX86_BUILTIN_STOREPD1,
  IX86_BUILTIN_STORERPD,


  IX86_BUILTIN_MASKMOVDQU,
  IX86_BUILTIN_MOVMSKPD,
  IX86_BUILTIN_PMOVMSKB128,
  IX86_BUILTIN_MOVQ2DQ,
  IX86_BUILTIN_MOVDQ2Q,

  IX86_BUILTIN_PACKSSWB128,
  IX86_BUILTIN_PACKSSDW128,
  IX86_BUILTIN_PACKUSWB128,

  IX86_BUILTIN_PADDB128,
  IX86_BUILTIN_PADDW128,
  IX86_BUILTIN_PADDD128,
  IX86_BUILTIN_PADDQ128,
  IX86_BUILTIN_PADDSB128,
  IX86_BUILTIN_PADDSW128,
  IX86_BUILTIN_PADDUSB128,
  IX86_BUILTIN_PADDUSW128,
  IX86_BUILTIN_PSUBB128,
  IX86_BUILTIN_PSUBW128,
  IX86_BUILTIN_PSUBD128,
  IX86_BUILTIN_PSUBQ128,
  IX86_BUILTIN_PSUBSB128,
  IX86_BUILTIN_PSUBSW128,
  IX86_BUILTIN_PSUBUSB128,
  IX86_BUILTIN_PSUBUSW128,

  IX86_BUILTIN_PAND128,
  IX86_BUILTIN_PANDN128,
  IX86_BUILTIN_POR128,
  IX86_BUILTIN_PXOR128,

  IX86_BUILTIN_PAVGB128,
  IX86_BUILTIN_PAVGW128,

  IX86_BUILTIN_PCMPEQB128,
  IX86_BUILTIN_PCMPEQW128,
  IX86_BUILTIN_PCMPEQD128,
  IX86_BUILTIN_PCMPGTB128,
  IX86_BUILTIN_PCMPGTW128,
  IX86_BUILTIN_PCMPGTD128,

  IX86_BUILTIN_PEXTRW128,
  IX86_BUILTIN_PINSRW128,

  IX86_BUILTIN_PMADDWD128,

  IX86_BUILTIN_PMAXSW128,
  IX86_BUILTIN_PMAXUB128,
  IX86_BUILTIN_PMINSW128,
  IX86_BUILTIN_PMINUB128,

  IX86_BUILTIN_PMULUDQ,
  IX86_BUILTIN_PMULUDQ128,
  IX86_BUILTIN_PMULHUW128,
  IX86_BUILTIN_PMULHW128,
  IX86_BUILTIN_PMULLW128,

  IX86_BUILTIN_PSADBW128,
  IX86_BUILTIN_PSHUFHW,
  IX86_BUILTIN_PSHUFLW,
  IX86_BUILTIN_PSHUFD,

  IX86_BUILTIN_PSLLW128,
  IX86_BUILTIN_PSLLD128,
  IX86_BUILTIN_PSLLQ128,
  IX86_BUILTIN_PSRAW128,
  IX86_BUILTIN_PSRAD128,
  IX86_BUILTIN_PSRLW128,
  IX86_BUILTIN_PSRLD128,
  IX86_BUILTIN_PSRLQ128,
  IX86_BUILTIN_PSLLDQI128,
  IX86_BUILTIN_PSLLWI128,
  IX86_BUILTIN_PSLLDI128,
  IX86_BUILTIN_PSLLQI128,
  IX86_BUILTIN_PSRAWI128,
  IX86_BUILTIN_PSRADI128,
  IX86_BUILTIN_PSRLDQI128,
  IX86_BUILTIN_PSRLWI128,
  IX86_BUILTIN_PSRLDI128,
  IX86_BUILTIN_PSRLQI128,

  IX86_BUILTIN_PUNPCKHBW128,
  IX86_BUILTIN_PUNPCKHWD128,
  IX86_BUILTIN_PUNPCKHDQ128,
  IX86_BUILTIN_PUNPCKHQDQ128,
  IX86_BUILTIN_PUNPCKLBW128,
  IX86_BUILTIN_PUNPCKLWD128,
  IX86_BUILTIN_PUNPCKLDQ128,
  IX86_BUILTIN_PUNPCKLQDQ128,

  IX86_BUILTIN_CLFLUSH,
  IX86_BUILTIN_MFENCE,
  IX86_BUILTIN_LFENCE,


  IX86_BUILTIN_ADDSUBPS,
  IX86_BUILTIN_HADDPS,
  IX86_BUILTIN_HSUBPS,
  IX86_BUILTIN_MOVSHDUP,
  IX86_BUILTIN_MOVSLDUP,
  IX86_BUILTIN_ADDSUBPD,
  IX86_BUILTIN_HADDPD,
  IX86_BUILTIN_HSUBPD,
  IX86_BUILTIN_LOADDDUP,
  IX86_BUILTIN_MOVDDUP,
  IX86_BUILTIN_LDDQU,

  IX86_BUILTIN_MONITOR,
  IX86_BUILTIN_MWAIT,

  IX86_BUILTIN_MAX
};
# 2783 "config/i386/i386.h"
extern int const dbx_register_map[53];
extern int const dbx64_register_map[53];
extern int const svr4_dbx_register_map[53];
# 3000 "config/i386/i386.h"
enum processor_type
{
  PROCESSOR_I386,
  PROCESSOR_I486,
  PROCESSOR_PENTIUM,
  PROCESSOR_PENTIUMPRO,
  PROCESSOR_K6,
  PROCESSOR_ATHLON,
  PROCESSOR_PENTIUM4,
  PROCESSOR_K8,
  PROCESSOR_max
};

extern enum processor_type ix86_tune;
extern const char *ix86_tune_string;

extern enum processor_type ix86_arch;
extern const char *ix86_arch_string;

enum fpmath_unit
{
  FPMATH_387 = 1,
  FPMATH_SSE = 2
};

extern enum fpmath_unit ix86_fpmath;
extern const char *ix86_fpmath_string;

enum tls_dialect
{
  TLS_DIALECT_GNU,
  TLS_DIALECT_SUN
};

extern enum tls_dialect ix86_tls_dialect;
extern const char *ix86_tls_dialect_string;

enum cmodel {
  CM_32,
  CM_SMALL,
  CM_KERNEL,
  CM_MEDIUM,
  CM_LARGE,
  CM_SMALL_PIC
};

extern enum cmodel ix86_cmodel;
extern const char *ix86_cmodel_string;






enum asm_dialect {
  ASM_ATT,
  ASM_INTEL
};

extern const char *ix86_asm_string;
extern enum asm_dialect ix86_asm_dialect;

extern int ix86_regparm;
extern const char *ix86_regparm_string;

extern int ix86_preferred_stack_boundary;
extern const char *ix86_preferred_stack_boundary_string;

extern int ix86_branch_cost;
extern const char *ix86_branch_cost_string;

extern const char *ix86_debug_arg_string;
extern const char *ix86_debug_addr_string;


extern const char *ix86_align_loops_string;
extern const char *ix86_align_jumps_string;
extern const char *ix86_align_funcs_string;


extern enum reg_class const regclass_map[53];

extern rtx ix86_compare_op0;
extern rtx ix86_compare_op1;
# 3100 "config/i386/i386.h"
enum fp_cw_mode {FP_CW_STORED, FP_CW_UNINITIALIZED, FP_CW_ANY};
# 3161 "config/i386/i386.h"
struct machine_function
{
  struct stack_local_entry *stack_locals;
  const char *some_ld_name;
  int save_varrargs_registers;
  int accesses_prev_frame;
  int optimize_mode_switching;


  int use_fast_prologue_epilogue;


  int use_fast_prologue_epilogue_nregs;
};
# 5 "tm.h" 2
# 1 "config/i386/unix.h" 1
# 6 "tm.h" 2
# 1 "config/i386/att.h" 1
# 7 "tm.h" 2
# 1 "config/dbxelf.h" 1
# 8 "tm.h" 2
# 1 "config/elfos.h" 1
# 9 "tm.h" 2
# 1 "config/svr4.h" 1
# 10 "tm.h" 2
# 1 "config/linux.h" 1
# 11 "tm.h" 2
# 1 "config/i386/linux.h" 1
# 12 "tm.h" 2
# 1 "defaults.h" 1
# 13 "tm.h" 2


# 1 "insn-constants.h" 1
# 16 "tm.h" 2
# 1 "insn-flags.h" 1
# 744 "insn-flags.h"
static __inline__ rtx gen_cmpdi_ccno_1_rex64 (rtx, rtx);
static __inline__ rtx
gen_cmpdi_ccno_1_rex64(rtx a __attribute__ ((__unused__)), rtx b __attribute__ ((__unused__)))
{
  return 0;
}
static __inline__ rtx gen_cmpdi_1_insn_rex64 (rtx, rtx);
static __inline__ rtx
gen_cmpdi_1_insn_rex64(rtx a __attribute__ ((__unused__)), rtx b __attribute__ ((__unused__)))
{
  return 0;
}
extern rtx gen_cmpqi_ext_3_insn (rtx, rtx);
static __inline__ rtx gen_cmpqi_ext_3_insn_rex64 (rtx, rtx);
static __inline__ rtx
gen_cmpqi_ext_3_insn_rex64(rtx a __attribute__ ((__unused__)), rtx b __attribute__ ((__unused__)))
{
  return 0;
}
extern rtx gen_x86_sahf_1 (rtx);
extern rtx gen_popsi1 (rtx);
extern rtx gen_movsi_insv_1 (rtx, rtx);
static __inline__ rtx gen_pushdi2_rex64 (rtx, rtx);
static __inline__ rtx
gen_pushdi2_rex64(rtx a __attribute__ ((__unused__)), rtx b __attribute__ ((__unused__)))
{
  return 0;
}
static __inline__ rtx gen_popdi1 (rtx);
static __inline__ rtx
gen_popdi1(rtx a __attribute__ ((__unused__)))
{
  return 0;
}
extern rtx gen_swapxf (rtx, rtx);
extern rtx gen_zero_extendhisi2_and (rtx, rtx);
extern rtx gen_zero_extendsidi2_32 (rtx, rtx);
static __inline__ rtx gen_zero_extendsidi2_rex64 (rtx, rtx);
static __inline__ rtx
gen_zero_extendsidi2_rex64(rtx a __attribute__ ((__unused__)), rtx b __attribute__ ((__unused__)))
{
  return 0;
}
static __inline__ rtx gen_zero_extendhidi2 (rtx, rtx);
static __inline__ rtx
gen_zero_extendhidi2(rtx a __attribute__ ((__unused__)), rtx b __attribute__ ((__unused__)))
{
  return 0;
}
static __inline__ rtx gen_zero_extendqidi2 (rtx, rtx);
static __inline__ rtx
gen_zero_extendqidi2(rtx a __attribute__ ((__unused__)), rtx b __attribute__ ((__unused__)))
{
  return 0;
}
static __inline__ rtx gen_extendsidi2_rex64 (rtx, rtx);
static __inline__ rtx
gen_extendsidi2_rex64(rtx a __attribute__ ((__unused__)), rtx b __attribute__ ((__unused__)))
{
  return 0;
}
static __inline__ rtx gen_extendhidi2 (rtx, rtx);
static __inline__ rtx
gen_extendhidi2(rtx a __attribute__ ((__unused__)), rtx b __attribute__ ((__unused__)))
{
  return 0;
}
static __inline__ rtx gen_extendqidi2 (rtx, rtx);
static __inline__ rtx
gen_extendqidi2(rtx a __attribute__ ((__unused__)), rtx b __attribute__ ((__unused__)))
{
  return 0;
}
extern rtx gen_extendhisi2 (rtx, rtx);
extern rtx gen_extendqihi2 (rtx, rtx);
extern rtx gen_extendqisi2 (rtx, rtx);
extern rtx gen_truncdfsf2_sse_only (rtx, rtx);
extern rtx gen_fix_truncdi_nomemory (rtx, rtx, rtx, rtx, rtx);
extern rtx gen_fix_truncdi_memory (rtx, rtx, rtx, rtx);
static __inline__ rtx gen_fix_truncsfdi_sse (rtx, rtx);
static __inline__ rtx
gen_fix_truncsfdi_sse(rtx a __attribute__ ((__unused__)), rtx b __attribute__ ((__unused__)))
{
  return 0;
}
static __inline__ rtx gen_fix_truncdfdi_sse (rtx, rtx);
static __inline__ rtx
gen_fix_truncdfdi_sse(rtx a __attribute__ ((__unused__)), rtx b __attribute__ ((__unused__)))
{
  return 0;
}
extern rtx gen_fix_truncsi_nomemory (rtx, rtx, rtx, rtx, rtx);
extern rtx gen_fix_truncsi_memory (rtx, rtx, rtx, rtx);
extern rtx gen_fix_truncsfsi_sse (rtx, rtx);
extern rtx gen_fix_truncdfsi_sse (rtx, rtx);
extern rtx gen_fix_trunchi_nomemory (rtx, rtx, rtx, rtx, rtx);
extern rtx gen_fix_trunchi_memory (rtx, rtx, rtx, rtx);
extern rtx gen_x86_fnstcw_1 (rtx);
extern rtx gen_x86_fldcw_1 (rtx);
extern rtx gen_floathixf2 (rtx, rtx);
extern rtx gen_floatsixf2 (rtx, rtx);
extern rtx gen_floatdixf2 (rtx, rtx);
static __inline__ rtx gen_adddi3_carry_rex64 (rtx, rtx, rtx, rtx);
static __inline__ rtx
gen_adddi3_carry_rex64(rtx a __attribute__ ((__unused__)), rtx b __attribute__ ((__unused__)), rtx c __attribute__ ((__unused__)), rtx d __attribute__ ((__unused__)))
{
  return 0;
}
extern rtx gen_addqi3_carry (rtx, rtx, rtx, rtx);
extern rtx gen_addhi3_carry (rtx, rtx, rtx, rtx);
extern rtx gen_addsi3_carry (rtx, rtx, rtx, rtx);
extern rtx gen_addqi3_cc (rtx, rtx, rtx);
static __inline__ rtx gen_addsi_1_zext (rtx, rtx, rtx);
static __inline__ rtx
gen_addsi_1_zext(rtx a __attribute__ ((__unused__)), rtx b __attribute__ ((__unused__)), rtx c __attribute__ ((__unused__)))
{
  return 0;
}
extern rtx gen_addqi_ext_1 (rtx, rtx, rtx);
static __inline__ rtx gen_subdi3_carry_rex64 (rtx, rtx, rtx, rtx);
static __inline__ rtx
gen_subdi3_carry_rex64(rtx a __attribute__ ((__unused__)), rtx b __attribute__ ((__unused__)), rtx c __attribute__ ((__unused__)), rtx d __attribute__ ((__unused__)))
{
  return 0;
}
extern rtx gen_subqi3_carry (rtx, rtx, rtx, rtx);
extern rtx gen_subhi3_carry (rtx, rtx, rtx, rtx);
extern rtx gen_subsi3_carry (rtx, rtx, rtx, rtx);
static __inline__ rtx gen_subsi3_carry_zext (rtx, rtx, rtx, rtx);
static __inline__ rtx
gen_subsi3_carry_zext(rtx a __attribute__ ((__unused__)), rtx b __attribute__ ((__unused__)), rtx c __attribute__ ((__unused__)), rtx d __attribute__ ((__unused__)))
{
  return 0;
}
extern rtx gen_divqi3 (rtx, rtx, rtx);
extern rtx gen_udivqi3 (rtx, rtx, rtx);
extern rtx gen_divmodhi4 (rtx, rtx, rtx, rtx);
static __inline__ rtx gen_udivmoddi4 (rtx, rtx, rtx, rtx);
static __inline__ rtx
gen_udivmoddi4(rtx a __attribute__ ((__unused__)), rtx b __attribute__ ((__unused__)), rtx c __attribute__ ((__unused__)), rtx d __attribute__ ((__unused__)))
{
  return 0;
}
extern rtx gen_udivmodsi4 (rtx, rtx, rtx, rtx);
extern rtx gen_testsi_1 (rtx, rtx);
extern rtx gen_andqi_ext_0 (rtx, rtx, rtx);
extern rtx gen_iorqi_ext_0 (rtx, rtx, rtx);
extern rtx gen_xorqi_ext_0 (rtx, rtx, rtx);
extern rtx gen_negsf2_memory (rtx, rtx);
extern rtx gen_negsf2_ifs (rtx, rtx, rtx);
extern rtx gen_negdf2_memory (rtx, rtx);
extern rtx gen_negdf2_ifs (rtx, rtx, rtx);
extern rtx gen_abssf2_memory (rtx, rtx);
extern rtx gen_abssf2_ifs (rtx, rtx, rtx);
extern rtx gen_absdf2_memory (rtx, rtx);
extern rtx gen_absdf2_ifs (rtx, rtx, rtx);
extern rtx gen_ashldi3_1 (rtx, rtx, rtx);
extern rtx gen_x86_shld_1 (rtx, rtx, rtx);
static __inline__ rtx gen_ashrdi3_63_rex64 (rtx, rtx, rtx);
static __inline__ rtx
gen_ashrdi3_63_rex64(rtx a __attribute__ ((__unused__)), rtx b __attribute__ ((__unused__)), rtx c __attribute__ ((__unused__)))
{
  return 0;
}
extern rtx gen_ashrdi3_1 (rtx, rtx, rtx);
extern rtx gen_x86_shrd_1 (rtx, rtx, rtx);
extern rtx gen_ashrsi3_31 (rtx, rtx, rtx);
extern rtx gen_lshrdi3_1 (rtx, rtx, rtx);
extern rtx gen_setcc_2 (rtx, rtx);
extern rtx gen_jump (rtx);
extern rtx gen_doloop_end_internal (rtx, rtx, rtx);
extern rtx gen_blockage (rtx);
extern rtx gen_return_internal (void);
extern rtx gen_return_internal_long (void);
extern rtx gen_return_pop_internal (rtx);
extern rtx gen_return_indirect_internal (rtx);
extern rtx gen_nop (void);
extern rtx gen_align (rtx);
extern rtx gen_set_got (rtx);
extern rtx gen_eh_return_si (rtx);
static __inline__ rtx gen_eh_return_di (rtx);
static __inline__ rtx
gen_eh_return_di(rtx a __attribute__ ((__unused__)))
{
  return 0;
}
extern rtx gen_leave (void);
static __inline__ rtx gen_leave_rex64 (void);
static __inline__ rtx
gen_leave_rex64(void)
{
  return 0;
}
extern rtx gen_ctzsi2 (rtx, rtx);
extern rtx gen_sqrtsf2_1 (rtx, rtx);
extern rtx gen_sqrtsf2_1_sse_only (rtx, rtx);
extern rtx gen_sqrtsf2_i387 (rtx, rtx);
extern rtx gen_sqrtdf2_1 (rtx, rtx);
extern rtx gen_sqrtdf2_1_sse_only (rtx, rtx);
extern rtx gen_sqrtdf2_i387 (rtx, rtx);
extern rtx gen_sqrtxf2 (rtx, rtx);
extern rtx gen_sindf2 (rtx, rtx);
extern rtx gen_sinsf2 (rtx, rtx);
extern rtx gen_sinxf2 (rtx, rtx);
extern rtx gen_cosdf2 (rtx, rtx);
extern rtx gen_cossf2 (rtx, rtx);
extern rtx gen_cosxf2 (rtx, rtx);
extern rtx gen_atan2df3_1 (rtx, rtx, rtx);
extern rtx gen_atan2sf3_1 (rtx, rtx, rtx);
extern rtx gen_atan2xf3_1 (rtx, rtx, rtx);
extern rtx gen_cld (void);
static __inline__ rtx gen_x86_movdicc_0_m1_rex64 (rtx, rtx);
static __inline__ rtx
gen_x86_movdicc_0_m1_rex64(rtx a __attribute__ ((__unused__)), rtx b __attribute__ ((__unused__)))
{
  return 0;
}
static __inline__ rtx gen_movdicc_c_rex64 (rtx, rtx, rtx, rtx);
static __inline__ rtx
gen_movdicc_c_rex64(rtx a __attribute__ ((__unused__)), rtx b __attribute__ ((__unused__)), rtx c __attribute__ ((__unused__)), rtx d __attribute__ ((__unused__)))
{
  return 0;
}
extern rtx gen_x86_movsicc_0_m1 (rtx, rtx);
extern rtx gen_pro_epilogue_adjust_stack_1 (rtx, rtx, rtx);
static __inline__ rtx gen_pro_epilogue_adjust_stack_rex64 (rtx, rtx, rtx);
static __inline__ rtx
gen_pro_epilogue_adjust_stack_rex64(rtx a __attribute__ ((__unused__)), rtx b __attribute__ ((__unused__)), rtx c __attribute__ ((__unused__)))
{
  return 0;
}
static __inline__ rtx gen_pro_epilogue_adjust_stack_rex64_2 (rtx, rtx, rtx, rtx);
static __inline__ rtx
gen_pro_epilogue_adjust_stack_rex64_2(rtx a __attribute__ ((__unused__)), rtx b __attribute__ ((__unused__)), rtx c __attribute__ ((__unused__)), rtx d __attribute__ ((__unused__)))
{
  return 0;
}
extern rtx gen_sse_movsfcc (rtx, rtx, rtx, rtx, rtx, rtx);
extern rtx gen_sse_movsfcc_eq (rtx, rtx, rtx, rtx, rtx);
extern rtx gen_sse_movdfcc (rtx, rtx, rtx, rtx, rtx, rtx);
extern rtx gen_sse_movdfcc_eq (rtx, rtx, rtx, rtx, rtx);
extern rtx gen_allocate_stack_worker_1 (rtx);
static __inline__ rtx gen_allocate_stack_worker_rex64 (rtx);
static __inline__ rtx
gen_allocate_stack_worker_rex64(rtx a __attribute__ ((__unused__)))
{
  return 0;
}
extern rtx gen_trap (void);
extern rtx gen_movv4sf_internal (rtx, rtx);
extern rtx gen_movv4si_internal (rtx, rtx);
extern rtx gen_movv2di_internal (rtx, rtx);
extern rtx gen_movv8qi_internal (rtx, rtx);
extern rtx gen_movv4hi_internal (rtx, rtx);
extern rtx gen_movv2si_internal (rtx, rtx);
extern rtx gen_movv2sf_internal (rtx, rtx);
extern rtx gen_movv2df_internal (rtx, rtx);
extern rtx gen_movv8hi_internal (rtx, rtx);
extern rtx gen_movv16qi_internal (rtx, rtx);
extern rtx gen_movti_internal (rtx, rtx);
extern rtx gen_sse_movmskps (rtx, rtx);
extern rtx gen_mmx_pmovmskb (rtx, rtx);
extern rtx gen_mmx_maskmovq (rtx, rtx, rtx);
static __inline__ rtx gen_mmx_maskmovq_rex (rtx, rtx, rtx);
static __inline__ rtx
gen_mmx_maskmovq_rex(rtx a __attribute__ ((__unused__)), rtx b __attribute__ ((__unused__)), rtx c __attribute__ ((__unused__)))
{
  return 0;
}
extern rtx gen_sse_movntv4sf (rtx, rtx);
extern rtx gen_sse_movntdi (rtx, rtx);
extern rtx gen_sse_movhlps (rtx, rtx, rtx);
extern rtx gen_sse_movlhps (rtx, rtx, rtx);
extern rtx gen_sse_movhps (rtx, rtx, rtx);
extern rtx gen_sse_movlps (rtx, rtx, rtx);
extern rtx gen_sse_loadss_1 (rtx, rtx, rtx);
extern rtx gen_sse_movss (rtx, rtx, rtx);
extern rtx gen_sse_storess (rtx, rtx);
extern rtx gen_sse_shufps (rtx, rtx, rtx, rtx);
extern rtx gen_addv4sf3 (rtx, rtx, rtx);
extern rtx gen_vmaddv4sf3 (rtx, rtx, rtx);
extern rtx gen_subv4sf3 (rtx, rtx, rtx);
extern rtx gen_vmsubv4sf3 (rtx, rtx, rtx);
extern rtx gen_mulv4sf3 (rtx, rtx, rtx);
extern rtx gen_vmmulv4sf3 (rtx, rtx, rtx);
extern rtx gen_divv4sf3 (rtx, rtx, rtx);
extern rtx gen_vmdivv4sf3 (rtx, rtx, rtx);
extern rtx gen_rcpv4sf2 (rtx, rtx);
extern rtx gen_vmrcpv4sf2 (rtx, rtx, rtx);
extern rtx gen_rsqrtv4sf2 (rtx, rtx);
extern rtx gen_vmrsqrtv4sf2 (rtx, rtx, rtx);
extern rtx gen_sqrtv4sf2 (rtx, rtx);
extern rtx gen_vmsqrtv4sf2 (rtx, rtx, rtx);
extern rtx gen_sse2_andv2di3 (rtx, rtx, rtx);
extern rtx gen_sse2_nandv2di3 (rtx, rtx, rtx);
extern rtx gen_sse2_iorv2di3 (rtx, rtx, rtx);
extern rtx gen_sse2_xorv2di3 (rtx, rtx, rtx);
extern rtx gen_sse_clrv4sf (rtx, rtx);
extern rtx gen_sse_clrv2df (rtx);
extern rtx gen_maskcmpv4sf3 (rtx, rtx, rtx, rtx);
extern rtx gen_maskncmpv4sf3 (rtx, rtx, rtx, rtx);
extern rtx gen_vmmaskcmpv4sf3 (rtx, rtx, rtx, rtx);
extern rtx gen_vmmaskncmpv4sf3 (rtx, rtx, rtx, rtx);
extern rtx gen_sse_comi (rtx, rtx);
extern rtx gen_sse_ucomi (rtx, rtx);
extern rtx gen_sse_unpckhps (rtx, rtx, rtx);
extern rtx gen_sse_unpcklps (rtx, rtx, rtx);
extern rtx gen_smaxv4sf3 (rtx, rtx, rtx);
extern rtx gen_vmsmaxv4sf3 (rtx, rtx, rtx);
extern rtx gen_sminv4sf3 (rtx, rtx, rtx);
extern rtx gen_vmsminv4sf3 (rtx, rtx, rtx);
extern rtx gen_cvtpi2ps (rtx, rtx, rtx);
extern rtx gen_cvtps2pi (rtx, rtx);
extern rtx gen_cvttps2pi (rtx, rtx);
extern rtx gen_cvtsi2ss (rtx, rtx, rtx);
static __inline__ rtx gen_cvtsi2ssq (rtx, rtx, rtx);
static __inline__ rtx
gen_cvtsi2ssq(rtx a __attribute__ ((__unused__)), rtx b __attribute__ ((__unused__)), rtx c __attribute__ ((__unused__)))
{
  return 0;
}
extern rtx gen_cvtss2si (rtx, rtx);
extern rtx gen_cvtss2siq (rtx, rtx);
extern rtx gen_cvttss2si (rtx, rtx);
static __inline__ rtx gen_cvttss2siq (rtx, rtx);
static __inline__ rtx
gen_cvttss2siq(rtx a __attribute__ ((__unused__)), rtx b __attribute__ ((__unused__)))
{
  return 0;
}
extern rtx gen_addv8qi3 (rtx, rtx, rtx);
extern rtx gen_addv4hi3 (rtx, rtx, rtx);
extern rtx gen_addv2si3 (rtx, rtx, rtx);
extern rtx gen_mmx_adddi3 (rtx, rtx, rtx);
extern rtx gen_ssaddv8qi3 (rtx, rtx, rtx);
extern rtx gen_ssaddv4hi3 (rtx, rtx, rtx);
extern rtx gen_usaddv8qi3 (rtx, rtx, rtx);
extern rtx gen_usaddv4hi3 (rtx, rtx, rtx);
extern rtx gen_subv8qi3 (rtx, rtx, rtx);
extern rtx gen_subv4hi3 (rtx, rtx, rtx);
extern rtx gen_subv2si3 (rtx, rtx, rtx);
extern rtx gen_mmx_subdi3 (rtx, rtx, rtx);
extern rtx gen_sssubv8qi3 (rtx, rtx, rtx);
extern rtx gen_sssubv4hi3 (rtx, rtx, rtx);
extern rtx gen_ussubv8qi3 (rtx, rtx, rtx);
extern rtx gen_ussubv4hi3 (rtx, rtx, rtx);
extern rtx gen_mulv4hi3 (rtx, rtx, rtx);
extern rtx gen_smulv4hi3_highpart (rtx, rtx, rtx);
extern rtx gen_umulv4hi3_highpart (rtx, rtx, rtx);
extern rtx gen_mmx_pmaddwd (rtx, rtx, rtx);
extern rtx gen_mmx_iordi3 (rtx, rtx, rtx);
extern rtx gen_mmx_xordi3 (rtx, rtx, rtx);
extern rtx gen_mmx_clrdi (rtx);
extern rtx gen_mmx_anddi3 (rtx, rtx, rtx);
extern rtx gen_mmx_nanddi3 (rtx, rtx, rtx);
extern rtx gen_mmx_uavgv8qi3 (rtx, rtx, rtx);
extern rtx gen_mmx_uavgv4hi3 (rtx, rtx, rtx);
extern rtx gen_mmx_psadbw (rtx, rtx, rtx);
extern rtx gen_mmx_pinsrw (rtx, rtx, rtx, rtx);
extern rtx gen_mmx_pextrw (rtx, rtx, rtx);
extern rtx gen_mmx_pshufw (rtx, rtx, rtx);
extern rtx gen_eqv8qi3 (rtx, rtx, rtx);
extern rtx gen_eqv4hi3 (rtx, rtx, rtx);
extern rtx gen_eqv2si3 (rtx, rtx, rtx);
extern rtx gen_gtv8qi3 (rtx, rtx, rtx);
extern rtx gen_gtv4hi3 (rtx, rtx, rtx);
extern rtx gen_gtv2si3 (rtx, rtx, rtx);
extern rtx gen_umaxv8qi3 (rtx, rtx, rtx);
extern rtx gen_smaxv4hi3 (rtx, rtx, rtx);
extern rtx gen_uminv8qi3 (rtx, rtx, rtx);
extern rtx gen_sminv4hi3 (rtx, rtx, rtx);
extern rtx gen_ashrv4hi3 (rtx, rtx, rtx);
extern rtx gen_ashrv2si3 (rtx, rtx, rtx);
extern rtx gen_lshrv4hi3 (rtx, rtx, rtx);
extern rtx gen_lshrv2si3 (rtx, rtx, rtx);
extern rtx gen_mmx_lshrdi3 (rtx, rtx, rtx);
extern rtx gen_ashlv4hi3 (rtx, rtx, rtx);
extern rtx gen_ashlv2si3 (rtx, rtx, rtx);
extern rtx gen_mmx_ashldi3 (rtx, rtx, rtx);
extern rtx gen_mmx_packsswb (rtx, rtx, rtx);
extern rtx gen_mmx_packssdw (rtx, rtx, rtx);
extern rtx gen_mmx_packuswb (rtx, rtx, rtx);
extern rtx gen_mmx_punpckhbw (rtx, rtx, rtx);
extern rtx gen_mmx_punpckhwd (rtx, rtx, rtx);
extern rtx gen_mmx_punpckhdq (rtx, rtx, rtx);
extern rtx gen_mmx_punpcklbw (rtx, rtx, rtx);
extern rtx gen_mmx_punpcklwd (rtx, rtx, rtx);
extern rtx gen_mmx_punpckldq (rtx, rtx, rtx);
extern rtx gen_emms (void);
extern rtx gen_ldmxcsr (rtx);
extern rtx gen_stmxcsr (rtx);
extern rtx gen_addv2sf3 (rtx, rtx, rtx);
extern rtx gen_subv2sf3 (rtx, rtx, rtx);
extern rtx gen_subrv2sf3 (rtx, rtx, rtx);
extern rtx gen_gtv2sf3 (rtx, rtx, rtx);
extern rtx gen_gev2sf3 (rtx, rtx, rtx);
extern rtx gen_eqv2sf3 (rtx, rtx, rtx);
extern rtx gen_pfmaxv2sf3 (rtx, rtx, rtx);
extern rtx gen_pfminv2sf3 (rtx, rtx, rtx);
extern rtx gen_mulv2sf3 (rtx, rtx, rtx);
extern rtx gen_femms (void);
extern rtx gen_pf2id (rtx, rtx);
extern rtx gen_pf2iw (rtx, rtx);
extern rtx gen_pfacc (rtx, rtx, rtx);
extern rtx gen_pfnacc (rtx, rtx, rtx);
extern rtx gen_pfpnacc (rtx, rtx, rtx);
extern rtx gen_pi2fw (rtx, rtx);
extern rtx gen_floatv2si2 (rtx, rtx);
extern rtx gen_pavgusb (rtx, rtx, rtx);
extern rtx gen_pfrcpv2sf2 (rtx, rtx);
extern rtx gen_pfrcpit1v2sf3 (rtx, rtx, rtx);
extern rtx gen_pfrcpit2v2sf3 (rtx, rtx, rtx);
extern rtx gen_pfrsqrtv2sf2 (rtx, rtx);
extern rtx gen_pfrsqit1v2sf3 (rtx, rtx, rtx);
extern rtx gen_pmulhrwv4hi3 (rtx, rtx, rtx);
extern rtx gen_pswapdv2si2 (rtx, rtx);
extern rtx gen_pswapdv2sf2 (rtx, rtx);
extern rtx gen_addv2df3 (rtx, rtx, rtx);
extern rtx gen_vmaddv2df3 (rtx, rtx, rtx);
extern rtx gen_subv2df3 (rtx, rtx, rtx);
extern rtx gen_vmsubv2df3 (rtx, rtx, rtx);
extern rtx gen_mulv2df3 (rtx, rtx, rtx);
extern rtx gen_vmmulv2df3 (rtx, rtx, rtx);
extern rtx gen_divv2df3 (rtx, rtx, rtx);
extern rtx gen_vmdivv2df3 (rtx, rtx, rtx);
extern rtx gen_smaxv2df3 (rtx, rtx, rtx);
extern rtx gen_vmsmaxv2df3 (rtx, rtx, rtx);
extern rtx gen_sminv2df3 (rtx, rtx, rtx);
extern rtx gen_vmsminv2df3 (rtx, rtx, rtx);
extern rtx gen_sqrtv2df2 (rtx, rtx);
extern rtx gen_vmsqrtv2df2 (rtx, rtx, rtx);
extern rtx gen_maskcmpv2df3 (rtx, rtx, rtx, rtx);
extern rtx gen_maskncmpv2df3 (rtx, rtx, rtx, rtx);
extern rtx gen_vmmaskcmpv2df3 (rtx, rtx, rtx, rtx);
extern rtx gen_vmmaskncmpv2df3 (rtx, rtx, rtx, rtx);
extern rtx gen_sse2_comi (rtx, rtx);
extern rtx gen_sse2_ucomi (rtx, rtx);
extern rtx gen_sse2_movmskpd (rtx, rtx);
extern rtx gen_sse2_pmovmskb (rtx, rtx);
extern rtx gen_sse2_maskmovdqu (rtx, rtx, rtx);
extern rtx gen_sse2_maskmovdqu_rex64 (rtx, rtx, rtx);
extern rtx gen_sse2_movntv2df (rtx, rtx);
extern rtx gen_sse2_movntv2di (rtx, rtx);
extern rtx gen_sse2_movntsi (rtx, rtx);
extern rtx gen_cvtdq2ps (rtx, rtx);
extern rtx gen_cvtps2dq (rtx, rtx);
extern rtx gen_cvttps2dq (rtx, rtx);
extern rtx gen_cvtdq2pd (rtx, rtx);
extern rtx gen_cvtpd2dq (rtx, rtx);
extern rtx gen_cvttpd2dq (rtx, rtx);
extern rtx gen_cvtpd2pi (rtx, rtx);
extern rtx gen_cvttpd2pi (rtx, rtx);
extern rtx gen_cvtpi2pd (rtx, rtx);
extern rtx gen_cvtsd2si (rtx, rtx);
static __inline__ rtx gen_cvtsd2siq (rtx, rtx);
static __inline__ rtx
gen_cvtsd2siq(rtx a __attribute__ ((__unused__)), rtx b __attribute__ ((__unused__)))
{
  return 0;
}
extern rtx gen_cvttsd2si (rtx, rtx);
static __inline__ rtx gen_cvttsd2siq (rtx, rtx);
static __inline__ rtx
gen_cvttsd2siq(rtx a __attribute__ ((__unused__)), rtx b __attribute__ ((__unused__)))
{
  return 0;
}
extern rtx gen_cvtsi2sd (rtx, rtx, rtx);
static __inline__ rtx gen_cvtsi2sdq (rtx, rtx, rtx);
static __inline__ rtx
gen_cvtsi2sdq(rtx a __attribute__ ((__unused__)), rtx b __attribute__ ((__unused__)), rtx c __attribute__ ((__unused__)))
{
  return 0;
}
extern rtx gen_cvtsd2ss (rtx, rtx, rtx);
extern rtx gen_cvtss2sd (rtx, rtx, rtx);
extern rtx gen_cvtpd2ps (rtx, rtx);
extern rtx gen_cvtps2pd (rtx, rtx);
extern rtx gen_addv16qi3 (rtx, rtx, rtx);
extern rtx gen_addv8hi3 (rtx, rtx, rtx);
extern rtx gen_addv4si3 (rtx, rtx, rtx);
extern rtx gen_addv2di3 (rtx, rtx, rtx);
extern rtx gen_ssaddv16qi3 (rtx, rtx, rtx);
extern rtx gen_ssaddv8hi3 (rtx, rtx, rtx);
extern rtx gen_usaddv16qi3 (rtx, rtx, rtx);
extern rtx gen_usaddv8hi3 (rtx, rtx, rtx);
extern rtx gen_subv16qi3 (rtx, rtx, rtx);
extern rtx gen_subv8hi3 (rtx, rtx, rtx);
extern rtx gen_subv4si3 (rtx, rtx, rtx);
extern rtx gen_subv2di3 (rtx, rtx, rtx);
extern rtx gen_sssubv16qi3 (rtx, rtx, rtx);
extern rtx gen_sssubv8hi3 (rtx, rtx, rtx);
extern rtx gen_ussubv16qi3 (rtx, rtx, rtx);
extern rtx gen_ussubv8hi3 (rtx, rtx, rtx);
extern rtx gen_mulv8hi3 (rtx, rtx, rtx);
extern rtx gen_smulv8hi3_highpart (rtx, rtx, rtx);
extern rtx gen_umulv8hi3_highpart (rtx, rtx, rtx);
extern rtx gen_sse2_umulsidi3 (rtx, rtx, rtx);
extern rtx gen_sse2_umulv2siv2di3 (rtx, rtx, rtx);
extern rtx gen_sse2_pmaddwd (rtx, rtx, rtx);
extern rtx gen_sse2_clrti (rtx);
extern rtx gen_sse2_uavgv16qi3 (rtx, rtx, rtx);
extern rtx gen_sse2_uavgv8hi3 (rtx, rtx, rtx);
extern rtx gen_sse2_psadbw (rtx, rtx, rtx);
extern rtx gen_sse2_pinsrw (rtx, rtx, rtx, rtx);
extern rtx gen_sse2_pextrw (rtx, rtx, rtx);
extern rtx gen_sse2_pshufd (rtx, rtx, rtx);
extern rtx gen_sse2_pshuflw (rtx, rtx, rtx);
extern rtx gen_sse2_pshufhw (rtx, rtx, rtx);
extern rtx gen_eqv16qi3 (rtx, rtx, rtx);
extern rtx gen_eqv8hi3 (rtx, rtx, rtx);
extern rtx gen_eqv4si3 (rtx, rtx, rtx);
extern rtx gen_gtv16qi3 (rtx, rtx, rtx);
extern rtx gen_gtv8hi3 (rtx, rtx, rtx);
extern rtx gen_gtv4si3 (rtx, rtx, rtx);
extern rtx gen_umaxv16qi3 (rtx, rtx, rtx);
extern rtx gen_smaxv8hi3 (rtx, rtx, rtx);
extern rtx gen_uminv16qi3 (rtx, rtx, rtx);
extern rtx gen_sminv8hi3 (rtx, rtx, rtx);
extern rtx gen_ashrv8hi3 (rtx, rtx, rtx);
extern rtx gen_ashrv4si3 (rtx, rtx, rtx);
extern rtx gen_lshrv8hi3 (rtx, rtx, rtx);
extern rtx gen_lshrv4si3 (rtx, rtx, rtx);
extern rtx gen_lshrv2di3 (rtx, rtx, rtx);
extern rtx gen_ashlv8hi3 (rtx, rtx, rtx);
extern rtx gen_ashlv4si3 (rtx, rtx, rtx);
extern rtx gen_ashlv2di3 (rtx, rtx, rtx);
extern rtx gen_ashrv8hi3_ti (rtx, rtx, rtx);
extern rtx gen_ashrv4si3_ti (rtx, rtx, rtx);
extern rtx gen_lshrv8hi3_ti (rtx, rtx, rtx);
extern rtx gen_lshrv4si3_ti (rtx, rtx, rtx);
extern rtx gen_lshrv2di3_ti (rtx, rtx, rtx);
extern rtx gen_ashlv8hi3_ti (rtx, rtx, rtx);
extern rtx gen_ashlv4si3_ti (rtx, rtx, rtx);
extern rtx gen_ashlv2di3_ti (rtx, rtx, rtx);
extern rtx gen_sse2_ashlti3 (rtx, rtx, rtx);
extern rtx gen_sse2_lshrti3 (rtx, rtx, rtx);
extern rtx gen_sse2_unpckhpd (rtx, rtx, rtx);
extern rtx gen_sse2_unpcklpd (rtx, rtx, rtx);
extern rtx gen_sse2_packsswb (rtx, rtx, rtx);
extern rtx gen_sse2_packssdw (rtx, rtx, rtx);
extern rtx gen_sse2_packuswb (rtx, rtx, rtx);
extern rtx gen_sse2_punpckhbw (rtx, rtx, rtx);
extern rtx gen_sse2_punpckhwd (rtx, rtx, rtx);
extern rtx gen_sse2_punpckhdq (rtx, rtx, rtx);
extern rtx gen_sse2_punpcklbw (rtx, rtx, rtx);
extern rtx gen_sse2_punpcklwd (rtx, rtx, rtx);
extern rtx gen_sse2_punpckldq (rtx, rtx, rtx);
extern rtx gen_sse2_punpcklqdq (rtx, rtx, rtx);
extern rtx gen_sse2_punpckhqdq (rtx, rtx, rtx);
extern rtx gen_sse2_movapd (rtx, rtx);
extern rtx gen_sse2_movupd (rtx, rtx);
extern rtx gen_sse2_movdqa (rtx, rtx);
extern rtx gen_sse2_movdqu (rtx, rtx);
extern rtx gen_sse2_movdq2q (rtx, rtx);
static __inline__ rtx gen_sse2_movdq2q_rex64 (rtx, rtx);
static __inline__ rtx
gen_sse2_movdq2q_rex64(rtx a __attribute__ ((__unused__)), rtx b __attribute__ ((__unused__)))
{
  return 0;
}
extern rtx gen_sse2_movq2dq (rtx, rtx);
static __inline__ rtx gen_sse2_movq2dq_rex64 (rtx, rtx);
static __inline__ rtx
gen_sse2_movq2dq_rex64(rtx a __attribute__ ((__unused__)), rtx b __attribute__ ((__unused__)))
{
  return 0;
}
extern rtx gen_sse2_movq (rtx, rtx);
extern rtx gen_sse2_loadd (rtx, rtx);
extern rtx gen_sse2_stored (rtx, rtx);
extern rtx gen_sse2_movhpd (rtx, rtx, rtx);
extern rtx gen_sse2_loadsd_1 (rtx, rtx, rtx);
extern rtx gen_sse2_movsd (rtx, rtx, rtx);
extern rtx gen_sse2_storesd (rtx, rtx);
extern rtx gen_sse2_shufpd (rtx, rtx, rtx, rtx);
extern rtx gen_sse2_clflush (rtx);
extern rtx gen_mwait (rtx, rtx);
extern rtx gen_monitor (rtx, rtx, rtx);
extern rtx gen_addsubv4sf3 (rtx, rtx, rtx);
extern rtx gen_addsubv2df3 (rtx, rtx, rtx);
extern rtx gen_haddv4sf3 (rtx, rtx, rtx);
extern rtx gen_haddv2df3 (rtx, rtx, rtx);
extern rtx gen_hsubv4sf3 (rtx, rtx, rtx);
extern rtx gen_hsubv2df3 (rtx, rtx, rtx);
extern rtx gen_movshdup (rtx, rtx);
extern rtx gen_movsldup (rtx, rtx);
extern rtx gen_lddqu (rtx, rtx);
extern rtx gen_loadddup (rtx, rtx);
extern rtx gen_movddup (rtx, rtx);
extern rtx gen_cmpdi (rtx, rtx);
extern rtx gen_cmpsi (rtx, rtx);
extern rtx gen_cmphi (rtx, rtx);
extern rtx gen_cmpqi (rtx, rtx);
static __inline__ rtx gen_cmpdi_1_rex64 (rtx, rtx);
static __inline__ rtx
gen_cmpdi_1_rex64(rtx a __attribute__ ((__unused__)), rtx b __attribute__ ((__unused__)))
{
  return 0;
}
extern rtx gen_cmpsi_1 (rtx, rtx);
extern rtx gen_cmpqi_ext_3 (rtx, rtx);
extern rtx gen_cmpxf (rtx, rtx);
extern rtx gen_cmpdf (rtx, rtx);
extern rtx gen_cmpsf (rtx, rtx);
extern rtx gen_movsi (rtx, rtx);
extern rtx gen_movhi (rtx, rtx);
extern rtx gen_movstricthi (rtx, rtx);
extern rtx gen_movqi (rtx, rtx);
extern rtx gen_reload_outqi (rtx, rtx, rtx);
extern rtx gen_movstrictqi (rtx, rtx);
extern rtx gen_movdi (rtx, rtx);
extern rtx gen_movsf (rtx, rtx);
extern rtx gen_movdf (rtx, rtx);
extern rtx gen_movxf (rtx, rtx);
extern rtx gen_zero_extendhisi2 (rtx, rtx);
extern rtx gen_zero_extendqihi2 (rtx, rtx);
extern rtx gen_zero_extendqisi2 (rtx, rtx);
extern rtx gen_zero_extendsidi2 (rtx, rtx);
extern rtx gen_extendsidi2 (rtx, rtx);
extern rtx gen_extendsfdf2 (rtx, rtx);
extern rtx gen_extendsfxf2 (rtx, rtx);
extern rtx gen_extenddfxf2 (rtx, rtx);
extern rtx gen_truncdfsf2 (rtx, rtx);
extern rtx gen_truncxfsf2 (rtx, rtx);
extern rtx gen_truncxfdf2 (rtx, rtx);
extern rtx gen_fix_truncxfdi2 (rtx, rtx);
extern rtx gen_fix_truncdfdi2 (rtx, rtx);
extern rtx gen_fix_truncsfdi2 (rtx, rtx);
extern rtx gen_fix_truncxfsi2 (rtx, rtx);
extern rtx gen_fix_truncdfsi2 (rtx, rtx);
extern rtx gen_fix_truncsfsi2 (rtx, rtx);
extern rtx gen_fix_truncxfhi2 (rtx, rtx);
extern rtx gen_fix_truncdfhi2 (rtx, rtx);
extern rtx gen_fix_truncsfhi2 (rtx, rtx);
extern rtx gen_floathisf2 (rtx, rtx);
extern rtx gen_floatsisf2 (rtx, rtx);
extern rtx gen_floatdisf2 (rtx, rtx);
extern rtx gen_floathidf2 (rtx, rtx);
extern rtx gen_floatsidf2 (rtx, rtx);
extern rtx gen_floatdidf2 (rtx, rtx);
extern rtx gen_floatunssisf2 (rtx, rtx);
static __inline__ rtx gen_floatunsdisf2 (rtx, rtx);
static __inline__ rtx
gen_floatunsdisf2(rtx a __attribute__ ((__unused__)), rtx b __attribute__ ((__unused__)))
{
  return 0;
}
static __inline__ rtx gen_floatunsdidf2 (rtx, rtx);
static __inline__ rtx
gen_floatunsdidf2(rtx a __attribute__ ((__unused__)), rtx b __attribute__ ((__unused__)))
{
  return 0;
}
extern rtx gen_vec_setv2df (rtx, rtx, rtx);
extern rtx gen_vec_extractv2df (rtx, rtx, rtx);
extern rtx gen_vec_initv2df (rtx, rtx);
extern rtx gen_vec_setv4sf (rtx, rtx, rtx);
extern rtx gen_vec_extractv4sf (rtx, rtx, rtx);
extern rtx gen_vec_initv4sf (rtx, rtx);
extern rtx gen_adddi3 (rtx, rtx, rtx);
extern rtx gen_addsi3 (rtx, rtx, rtx);
extern rtx gen_addhi3 (rtx, rtx, rtx);
extern rtx gen_addqi3 (rtx, rtx, rtx);
extern rtx gen_addxf3 (rtx, rtx, rtx);
extern rtx gen_adddf3 (rtx, rtx, rtx);
extern rtx gen_addsf3 (rtx, rtx, rtx);
extern rtx gen_subdi3 (rtx, rtx, rtx);
extern rtx gen_subsi3 (rtx, rtx, rtx);
extern rtx gen_subhi3 (rtx, rtx, rtx);
extern rtx gen_subqi3 (rtx, rtx, rtx);
extern rtx gen_subxf3 (rtx, rtx, rtx);
extern rtx gen_subdf3 (rtx, rtx, rtx);
extern rtx gen_subsf3 (rtx, rtx, rtx);
static __inline__ rtx gen_muldi3 (rtx, rtx, rtx);
static __inline__ rtx
gen_muldi3(rtx a __attribute__ ((__unused__)), rtx b __attribute__ ((__unused__)), rtx c __attribute__ ((__unused__)))
{
  return 0;
}
extern rtx gen_mulsi3 (rtx, rtx, rtx);
extern rtx gen_mulhi3 (rtx, rtx, rtx);
extern rtx gen_mulqi3 (rtx, rtx, rtx);
extern rtx gen_umulqihi3 (rtx, rtx, rtx);
extern rtx gen_mulqihi3 (rtx, rtx, rtx);
static __inline__ rtx gen_umulditi3 (rtx, rtx, rtx);
static __inline__ rtx
gen_umulditi3(rtx a __attribute__ ((__unused__)), rtx b __attribute__ ((__unused__)), rtx c __attribute__ ((__unused__)))
{
  return 0;
}
extern rtx gen_umulsidi3 (rtx, rtx, rtx);
static __inline__ rtx gen_mulditi3 (rtx, rtx, rtx);
static __inline__ rtx
gen_mulditi3(rtx a __attribute__ ((__unused__)), rtx b __attribute__ ((__unused__)), rtx c __attribute__ ((__unused__)))
{
  return 0;
}
extern rtx gen_mulsidi3 (rtx, rtx, rtx);
static __inline__ rtx gen_umuldi3_highpart (rtx, rtx, rtx);
static __inline__ rtx
gen_umuldi3_highpart(rtx a __attribute__ ((__unused__)), rtx b __attribute__ ((__unused__)), rtx c __attribute__ ((__unused__)))
{
  return 0;
}
extern rtx gen_umulsi3_highpart (rtx, rtx, rtx);
static __inline__ rtx gen_smuldi3_highpart (rtx, rtx, rtx);
static __inline__ rtx
gen_smuldi3_highpart(rtx a __attribute__ ((__unused__)), rtx b __attribute__ ((__unused__)), rtx c __attribute__ ((__unused__)))
{
  return 0;
}
extern rtx gen_smulsi3_highpart (rtx, rtx, rtx);
extern rtx gen_mulxf3 (rtx, rtx, rtx);
extern rtx gen_muldf3 (rtx, rtx, rtx);
extern rtx gen_mulsf3 (rtx, rtx, rtx);
extern rtx gen_divxf3 (rtx, rtx, rtx);
extern rtx gen_divdf3 (rtx, rtx, rtx);
extern rtx gen_divsf3 (rtx, rtx, rtx);
static __inline__ rtx gen_divmoddi4 (rtx, rtx, rtx, rtx);
static __inline__ rtx
gen_divmoddi4(rtx a __attribute__ ((__unused__)), rtx b __attribute__ ((__unused__)), rtx c __attribute__ ((__unused__)), rtx d __attribute__ ((__unused__)))
{
  return 0;
}
extern rtx gen_divmodsi4 (rtx, rtx, rtx, rtx);
extern rtx gen_udivmodhi4 (rtx, rtx, rtx, rtx);
extern rtx gen_testsi_ccno_1 (rtx, rtx);
extern rtx gen_testqi_ccz_1 (rtx, rtx);
extern rtx gen_testqi_ext_ccno_0 (rtx, rtx);
static __inline__ rtx gen_anddi3 (rtx, rtx, rtx);
static __inline__ rtx
gen_anddi3(rtx a __attribute__ ((__unused__)), rtx b __attribute__ ((__unused__)), rtx c __attribute__ ((__unused__)))
{
  return 0;
}
extern rtx gen_andsi3 (rtx, rtx, rtx);
extern rtx gen_andhi3 (rtx, rtx, rtx);
extern rtx gen_andqi3 (rtx, rtx, rtx);
static __inline__ rtx gen_iordi3 (rtx, rtx, rtx);
static __inline__ rtx
gen_iordi3(rtx a __attribute__ ((__unused__)), rtx b __attribute__ ((__unused__)), rtx c __attribute__ ((__unused__)))
{
  return 0;
}
extern rtx gen_iorsi3 (rtx, rtx, rtx);
extern rtx gen_iorhi3 (rtx, rtx, rtx);
extern rtx gen_iorqi3 (rtx, rtx, rtx);
static __inline__ rtx gen_xordi3 (rtx, rtx, rtx);
static __inline__ rtx
gen_xordi3(rtx a __attribute__ ((__unused__)), rtx b __attribute__ ((__unused__)), rtx c __attribute__ ((__unused__)))
{
  return 0;
}
extern rtx gen_xorsi3 (rtx, rtx, rtx);
extern rtx gen_xorhi3 (rtx, rtx, rtx);
extern rtx gen_xorqi3 (rtx, rtx, rtx);
extern rtx gen_xorqi_cc_ext_1 (rtx, rtx, rtx);
extern rtx gen_negdi2 (rtx, rtx);
extern rtx gen_negsi2 (rtx, rtx);
extern rtx gen_neghi2 (rtx, rtx);
extern rtx gen_negqi2 (rtx, rtx);
extern rtx gen_negsf2 (rtx, rtx);
extern rtx gen_negdf2 (rtx, rtx);
extern rtx gen_negxf2 (rtx, rtx);
extern rtx gen_abssf2 (rtx, rtx);
extern rtx gen_absdf2 (rtx, rtx);
extern rtx gen_absxf2 (rtx, rtx);
static __inline__ rtx gen_one_cmpldi2 (rtx, rtx);
static __inline__ rtx
gen_one_cmpldi2(rtx a __attribute__ ((__unused__)), rtx b __attribute__ ((__unused__)))
{
  return 0;
}
extern rtx gen_one_cmplsi2 (rtx, rtx);
extern rtx gen_one_cmplhi2 (rtx, rtx);
extern rtx gen_one_cmplqi2 (rtx, rtx);
extern rtx gen_ashldi3 (rtx, rtx, rtx);
extern rtx gen_x86_shift_adj_1 (rtx, rtx, rtx, rtx);
extern rtx gen_x86_shift_adj_2 (rtx, rtx, rtx);
extern rtx gen_ashlsi3 (rtx, rtx, rtx);
extern rtx gen_ashlhi3 (rtx, rtx, rtx);
extern rtx gen_ashlqi3 (rtx, rtx, rtx);
extern rtx gen_ashrdi3 (rtx, rtx, rtx);
extern rtx gen_x86_shift_adj_3 (rtx, rtx, rtx);
extern rtx gen_ashrsi3 (rtx, rtx, rtx);
extern rtx gen_ashrhi3 (rtx, rtx, rtx);
extern rtx gen_ashrqi3 (rtx, rtx, rtx);
extern rtx gen_lshrdi3 (rtx, rtx, rtx);
extern rtx gen_lshrsi3 (rtx, rtx, rtx);
extern rtx gen_lshrhi3 (rtx, rtx, rtx);
extern rtx gen_lshrqi3 (rtx, rtx, rtx);
static __inline__ rtx gen_rotldi3 (rtx, rtx, rtx);
static __inline__ rtx
gen_rotldi3(rtx a __attribute__ ((__unused__)), rtx b __attribute__ ((__unused__)), rtx c __attribute__ ((__unused__)))
{
  return 0;
}
extern rtx gen_rotlsi3 (rtx, rtx, rtx);
extern rtx gen_rotlhi3 (rtx, rtx, rtx);
extern rtx gen_rotlqi3 (rtx, rtx, rtx);
static __inline__ rtx gen_rotrdi3 (rtx, rtx, rtx);
static __inline__ rtx
gen_rotrdi3(rtx a __attribute__ ((__unused__)), rtx b __attribute__ ((__unused__)), rtx c __attribute__ ((__unused__)))
{
  return 0;
}
extern rtx gen_rotrsi3 (rtx, rtx, rtx);
extern rtx gen_rotrhi3 (rtx, rtx, rtx);
extern rtx gen_rotrqi3 (rtx, rtx, rtx);
extern rtx gen_extv (rtx, rtx, rtx, rtx);
extern rtx gen_extzv (rtx, rtx, rtx, rtx);
extern rtx gen_insv (rtx, rtx, rtx, rtx);
extern rtx gen_seq (rtx);
extern rtx gen_sne (rtx);
extern rtx gen_sgt (rtx);
extern rtx gen_sgtu (rtx);
extern rtx gen_slt (rtx);
extern rtx gen_sltu (rtx);
extern rtx gen_sge (rtx);
extern rtx gen_sgeu (rtx);
extern rtx gen_sle (rtx);
extern rtx gen_sleu (rtx);
extern rtx gen_sunordered (rtx);
extern rtx gen_sordered (rtx);
extern rtx gen_suneq (rtx);
extern rtx gen_sunge (rtx);
extern rtx gen_sungt (rtx);
extern rtx gen_sunle (rtx);
extern rtx gen_sunlt (rtx);
extern rtx gen_sltgt (rtx);
extern rtx gen_beq (rtx);
extern rtx gen_bne (rtx);
extern rtx gen_bgt (rtx);
extern rtx gen_bgtu (rtx);
extern rtx gen_blt (rtx);
extern rtx gen_bltu (rtx);
extern rtx gen_bge (rtx);
extern rtx gen_bgeu (rtx);
extern rtx gen_ble (rtx);
extern rtx gen_bleu (rtx);
extern rtx gen_bunordered (rtx);
extern rtx gen_bordered (rtx);
extern rtx gen_buneq (rtx);
extern rtx gen_bunge (rtx);
extern rtx gen_bungt (rtx);
extern rtx gen_bunle (rtx);
extern rtx gen_bunlt (rtx);
extern rtx gen_bltgt (rtx);
extern rtx gen_indirect_jump (rtx);
extern rtx gen_tablejump (rtx, rtx);
extern rtx gen_doloop_end (rtx, rtx, rtx, rtx, rtx);

extern rtx gen_call_pop (rtx, rtx, rtx, rtx);

extern rtx gen_call (rtx, rtx, rtx);

extern rtx gen_sibcall (rtx, rtx, rtx);

extern rtx gen_call_value_pop (rtx, rtx, rtx, rtx, rtx);

extern rtx gen_call_value (rtx, rtx, rtx, rtx);

extern rtx gen_sibcall_value (rtx, rtx, rtx, rtx);
extern rtx gen_untyped_call (rtx, rtx, rtx);
extern rtx gen_return (void);
extern rtx gen_prologue (void);
extern rtx gen_epilogue (void);
extern rtx gen_sibcall_epilogue (void);
extern rtx gen_eh_return (rtx);
extern rtx gen_ffssi2 (rtx, rtx);
extern rtx gen_clzsi2 (rtx, rtx);
extern rtx gen_tls_global_dynamic_32 (rtx, rtx);
extern rtx gen_tls_global_dynamic_64 (rtx, rtx);
extern rtx gen_tls_local_dynamic_base_32 (rtx);
extern rtx gen_tls_local_dynamic_base_64 (rtx);
extern rtx gen_sqrtsf2 (rtx, rtx);
extern rtx gen_sqrtdf2 (rtx, rtx);
extern rtx gen_atan2df3 (rtx, rtx, rtx);
extern rtx gen_atan2sf3 (rtx, rtx, rtx);
extern rtx gen_atan2xf3 (rtx, rtx, rtx);
extern rtx gen_logsf2 (rtx, rtx);
extern rtx gen_logdf2 (rtx, rtx);
extern rtx gen_logxf2 (rtx, rtx);
extern rtx gen_expsf2 (rtx, rtx);
extern rtx gen_expdf2 (rtx, rtx);
extern rtx gen_expxf2 (rtx, rtx);
extern rtx gen_atansf2 (rtx, rtx);
extern rtx gen_atandf2 (rtx, rtx);
extern rtx gen_atanxf2 (rtx, rtx);
extern rtx gen_movstrsi (rtx, rtx, rtx, rtx);
static __inline__ rtx gen_movstrdi (rtx, rtx, rtx, rtx);
static __inline__ rtx
gen_movstrdi(rtx a __attribute__ ((__unused__)), rtx b __attribute__ ((__unused__)), rtx c __attribute__ ((__unused__)), rtx d __attribute__ ((__unused__)))
{
  return 0;
}
extern rtx gen_strmov (rtx, rtx, rtx, rtx);
extern rtx gen_strmov_singleop (rtx, rtx, rtx, rtx, rtx, rtx);
extern rtx gen_rep_mov (rtx, rtx, rtx, rtx, rtx, rtx, rtx);
extern rtx gen_clrstrsi (rtx, rtx, rtx);
static __inline__ rtx gen_clrstrdi (rtx, rtx, rtx);
static __inline__ rtx
gen_clrstrdi(rtx a __attribute__ ((__unused__)), rtx b __attribute__ ((__unused__)), rtx c __attribute__ ((__unused__)))
{
  return 0;
}
extern rtx gen_strset (rtx, rtx, rtx);
extern rtx gen_strset_singleop (rtx, rtx, rtx, rtx);
extern rtx gen_rep_stos (rtx, rtx, rtx, rtx, rtx);
extern rtx gen_cmpstrsi (rtx, rtx, rtx, rtx, rtx);
extern rtx gen_cmpintqi (rtx);
extern rtx gen_cmpstrqi_nz_1 (rtx, rtx, rtx, rtx, rtx, rtx);
extern rtx gen_cmpstrqi_1 (rtx, rtx, rtx, rtx, rtx, rtx);
extern rtx gen_strlensi (rtx, rtx, rtx, rtx);
extern rtx gen_strlendi (rtx, rtx, rtx, rtx);
extern rtx gen_strlenqi_1 (rtx, rtx, rtx);
static __inline__ rtx gen_movdicc (rtx, rtx, rtx, rtx);
static __inline__ rtx
gen_movdicc(rtx a __attribute__ ((__unused__)), rtx b __attribute__ ((__unused__)), rtx c __attribute__ ((__unused__)), rtx d __attribute__ ((__unused__)))
{
  return 0;
}
extern rtx gen_movsicc (rtx, rtx, rtx, rtx);
extern rtx gen_movhicc (rtx, rtx, rtx, rtx);
extern rtx gen_movqicc (rtx, rtx, rtx, rtx);
extern rtx gen_movsfcc (rtx, rtx, rtx, rtx);
extern rtx gen_movdfcc (rtx, rtx, rtx, rtx);
extern rtx gen_movxfcc (rtx, rtx, rtx, rtx);
extern rtx gen_minsf3 (rtx, rtx, rtx);
extern rtx gen_addqicc (rtx, rtx, rtx, rtx);
extern rtx gen_addhicc (rtx, rtx, rtx, rtx);
extern rtx gen_addsicc (rtx, rtx, rtx, rtx);
static __inline__ rtx gen_adddicc (rtx, rtx, rtx, rtx);
static __inline__ rtx
gen_adddicc(rtx a __attribute__ ((__unused__)), rtx b __attribute__ ((__unused__)), rtx c __attribute__ ((__unused__)), rtx d __attribute__ ((__unused__)))
{
  return 0;
}
extern rtx gen_mindf3 (rtx, rtx, rtx);
extern rtx gen_maxsf3 (rtx, rtx, rtx);
extern rtx gen_maxdf3 (rtx, rtx, rtx);
extern rtx gen_allocate_stack_worker (rtx);
extern rtx gen_allocate_stack_worker_postreload (rtx);
extern rtx gen_allocate_stack_worker_rex64_postreload (rtx);
extern rtx gen_allocate_stack (rtx, rtx);
extern rtx gen_builtin_setjmp_receiver (rtx);
extern rtx gen_conditional_trap (rtx, rtx);
extern rtx gen_movti (rtx, rtx);
static __inline__ rtx gen_movtf (rtx, rtx);
static __inline__ rtx
gen_movtf(rtx a __attribute__ ((__unused__)), rtx b __attribute__ ((__unused__)))
{
  return 0;
}
extern rtx gen_movv2df (rtx, rtx);
extern rtx gen_movv8hi (rtx, rtx);
extern rtx gen_movv16qi (rtx, rtx);
extern rtx gen_movv4sf (rtx, rtx);
extern rtx gen_movv4si (rtx, rtx);
extern rtx gen_movv2di (rtx, rtx);
extern rtx gen_movv2si (rtx, rtx);
extern rtx gen_movv4hi (rtx, rtx);
extern rtx gen_movv8qi (rtx, rtx);
extern rtx gen_movv2sf (rtx, rtx);
extern rtx gen_sse_movaps (rtx, rtx);
extern rtx gen_sse_movups (rtx, rtx);
extern rtx gen_sse_loadss (rtx, rtx);
extern rtx gen_sse_andv4sf3 (rtx, rtx, rtx);
extern rtx gen_sse_nandv4sf3 (rtx, rtx, rtx);
extern rtx gen_sse_iorv4sf3 (rtx, rtx, rtx);
extern rtx gen_sse_xorv4sf3 (rtx, rtx, rtx);
extern rtx gen_sse2_andv2df3 (rtx, rtx, rtx);
extern rtx gen_sse2_nandv2df3 (rtx, rtx, rtx);
extern rtx gen_sse2_iorv2df3 (rtx, rtx, rtx);
extern rtx gen_sse2_xorv2df3 (rtx, rtx, rtx);
extern rtx gen_sfence (void);
static __inline__ rtx gen_sse_prologue_save (rtx, rtx, rtx, rtx);
static __inline__ rtx
gen_sse_prologue_save(rtx a __attribute__ ((__unused__)), rtx b __attribute__ ((__unused__)), rtx c __attribute__ ((__unused__)), rtx d __attribute__ ((__unused__)))
{
  return 0;
}
extern rtx gen_prefetch (rtx, rtx, rtx);
extern rtx gen_sse2_loadsd (rtx, rtx);
extern rtx gen_sse2_mfence (void);
extern rtx gen_sse2_lfence (void);
# 17 "tm.h" 2
# 93 "reload.c" 2
# 1 "rtl.h" 1
# 25 "rtl.h"
struct function;

# 1 "machmode.h" 1
# 26 "machmode.h"
# 1 "insn-modes.h" 1






enum machine_mode
{
  VOIDmode,
  BLKmode,
  CCmode,
  CCGCmode,
  CCGOCmode,
  CCNOmode,
  CCZmode,
  CCFPmode,
  CCFPUmode,
  BImode,
  QImode,
  HImode,
  SImode,
  DImode,
  TImode,
  SFmode,
  DFmode,
  XFmode,
  TFmode,
  CQImode,
  CHImode,
  CSImode,
  CDImode,
  CTImode,
  SCmode,
  DCmode,
  XCmode,
  TCmode,
  V2QImode,
  V4QImode,
  V2HImode,
  V8QImode,
  V4HImode,
  V2SImode,
  V1DImode,
  V16QImode,
  V8HImode,
  V4SImode,
  V2DImode,
  V8SImode,
  V4DImode,
  V8DImode,
  V2SFmode,
  V4SFmode,
  V2DFmode,
  V8SFmode,
  V4DFmode,
  V16SFmode,
  V8DFmode,
  MAX_MACHINE_MODE,

  MIN_MODE_RANDOM = VOIDmode,
  MAX_MODE_RANDOM = BLKmode,

  MIN_MODE_CC = CCmode,
  MAX_MODE_CC = CCFPUmode,

  MIN_MODE_INT = QImode,
  MAX_MODE_INT = TImode,

  MIN_MODE_PARTIAL_INT = VOIDmode,
  MAX_MODE_PARTIAL_INT = VOIDmode,

  MIN_MODE_FLOAT = SFmode,
  MAX_MODE_FLOAT = TFmode,

  MIN_MODE_COMPLEX_INT = CQImode,
  MAX_MODE_COMPLEX_INT = CTImode,

  MIN_MODE_COMPLEX_FLOAT = SCmode,
  MAX_MODE_COMPLEX_FLOAT = TCmode,

  MIN_MODE_VECTOR_INT = V2QImode,
  MAX_MODE_VECTOR_INT = V8DImode,

  MIN_MODE_VECTOR_FLOAT = V2SFmode,
  MAX_MODE_VECTOR_FLOAT = V8DFmode,

  NUM_MACHINE_MODES = MAX_MACHINE_MODE
};
# 27 "machmode.h" 2



extern const char * const mode_name[NUM_MACHINE_MODES];




# 1 "mode-classes.def" 1
# 36 "machmode.h" 2

enum mode_class { MODE_RANDOM, MODE_CC, MODE_INT, MODE_PARTIAL_INT, MODE_FLOAT, MODE_COMPLEX_INT, MODE_COMPLEX_FLOAT, MODE_VECTOR_INT, MODE_VECTOR_FLOAT, MAX_MODE_CLASS };






extern const unsigned char mode_class[NUM_MACHINE_MODES];
# 81 "machmode.h"
extern unsigned char mode_size[NUM_MACHINE_MODES];




extern const unsigned short mode_precision[NUM_MACHINE_MODES];





extern const unsigned long mode_mask_array[NUM_MACHINE_MODES];





extern const unsigned char mode_inner[NUM_MACHINE_MODES];
# 110 "machmode.h"
extern const unsigned char mode_nunits[NUM_MACHINE_MODES];




extern const unsigned char mode_wider[NUM_MACHINE_MODES];






extern enum machine_mode mode_for_size (unsigned int, enum mode_class, int);



extern enum machine_mode smallest_mode_for_size (unsigned int,
       enum mode_class);





extern enum machine_mode int_mode_for_mode (enum machine_mode);



extern enum machine_mode get_best_mode (int, int, unsigned int,
     enum machine_mode, int);



extern unsigned char mode_base_align[NUM_MACHINE_MODES];

extern unsigned get_mode_alignment (enum machine_mode);





extern const unsigned char class_narrowest_mode[MAX_MODE_CLASS];





extern enum machine_mode byte_mode;
extern enum machine_mode word_mode;
extern enum machine_mode ptr_mode;


extern void init_adjust_machine_modes (void);
# 28 "rtl.h" 2
# 1 "input.h" 1
# 27 "input.h"
struct location_s
{

  const char *file;


  int line;
};
typedef struct location_s location_t;

struct file_stack
{
  struct file_stack *next;
  location_t location;
};


extern const char *main_input_filename;

extern location_t input_location;





extern struct file_stack *input_file_stack;


extern struct file_stack *expr_wfl_stack;


extern int input_file_stack_tick;

extern void push_srcloc (const char *name, int line);
extern void pop_srcloc (void);
# 29 "rtl.h" 2
# 42 "rtl.h"
enum rtx_code {


# 1 "rtl.def" 1
# 70 "rtl.def"
UNKNOWN ,



NIL ,




INCLUDE ,






EXPR_LIST ,



INSN_LIST ,
# 129 "rtl.def"
MATCH_OPERAND ,






MATCH_SCRATCH ,




MATCH_DUP ,







MATCH_OPERATOR ,
# 158 "rtl.def"
MATCH_PARALLEL ,




MATCH_OP_DUP ,




MATCH_PAR_DUP ,




MATCH_INSN ,
# 192 "rtl.def"
DEFINE_INSN ,







DEFINE_PEEPHOLE ,
# 211 "rtl.def"
DEFINE_SPLIT ,
# 239 "rtl.def"
DEFINE_INSN_AND_SPLIT ,



DEFINE_PEEPHOLE2 ,



DEFINE_COMBINE ,
# 260 "rtl.def"
DEFINE_EXPAND ,
# 276 "rtl.def"
DEFINE_DELAY ,
# 317 "rtl.def"
DEFINE_FUNCTION_UNIT ,


DEFINE_ASM_ATTRIBUTES ,
# 333 "rtl.def"
DEFINE_COND_EXEC ,





SEQUENCE ,


ADDRESS ,
# 358 "rtl.def"
DEFINE_CPU_UNIT ,




DEFINE_QUERY_CPU_UNIT ,
# 373 "rtl.def"
EXCLUSION_SET ,
# 395 "rtl.def"
PRESENCE_SET ,
# 416 "rtl.def"
FINAL_PRESENCE_SET ,
# 439 "rtl.def"
ABSENCE_SET ,




FINAL_ABSENCE_SET ,
# 455 "rtl.def"
DEFINE_BYPASS ,
# 464 "rtl.def"
DEFINE_AUTOMATON ,
# 487 "rtl.def"
AUTOMATA_OPTION ,
# 496 "rtl.def"
DEFINE_RESERVATION ,
# 544 "rtl.def"
DEFINE_INSN_RESERVATION ,
# 555 "rtl.def"
DEFINE_ATTR ,


ATTR ,







SET_ATTR ,
# 581 "rtl.def"
SET_ATTR_ALTERNATIVE ,




EQ_ATTR ,



EQ_ATTR_ALT ,
# 600 "rtl.def"
ATTR_FLAG ,
# 613 "rtl.def"
INSN ,



JUMP_INSN ,






CALL_INSN ,


BARRIER ,







CODE_LABEL ,






NOTE ,
# 655 "rtl.def"
COND_EXEC ,


PARALLEL ,







ASM_INPUT ,
# 680 "rtl.def"
ASM_OPERANDS ,
# 691 "rtl.def"
UNSPEC ,


UNSPEC_VOLATILE ,



ADDR_VEC ,
# 723 "rtl.def"
ADDR_DIFF_VEC ,
# 734 "rtl.def"
PREFETCH ,
# 746 "rtl.def"
SET ,




USE ,




CLOBBER ,





CALL ,



RETURN ,





TRAP_IF ,




RESX ,






CONST_INT ,




CONST_DOUBLE ,


CONST_VECTOR ,


CONST_STRING ,





CONST ,



PC ,


VALUE ,
# 817 "rtl.def"
REG ,






SCRATCH ,
# 834 "rtl.def"
SUBREG ,
# 847 "rtl.def"
STRICT_LOW_PART ,





CONCAT ,




MEM ,





LABEL_REF ,






SYMBOL_REF ,






CC0 ,
# 887 "rtl.def"
ADDRESSOF ,
# 905 "rtl.def"
QUEUED ,
# 917 "rtl.def"
IF_THEN_ELSE ,
# 926 "rtl.def"
COND ,


COMPARE ,


PLUS ,


MINUS ,


NEG ,

MULT ,


DIV ,

MOD ,


UDIV ,
UMOD ,


AND ,

IOR ,

XOR ,

NOT ,




ASHIFT ,
ROTATE ,
ASHIFTRT ,
LSHIFTRT ,
ROTATERT ,





SMIN ,
SMAX ,
UMIN ,
UMAX ,
# 985 "rtl.def"
PRE_DEC ,
PRE_INC ,
POST_DEC ,
POST_INC ,
# 1002 "rtl.def"
PRE_MODIFY ,
POST_MODIFY ,



NE ,
EQ ,
GE ,
GT ,
LE ,
LT ,
GEU ,
GTU ,
LEU ,
LTU ,


UNORDERED ,
ORDERED ,


UNEQ ,
UNGE ,
UNGT ,
UNLE ,
UNLT ,


LTGT ,




SIGN_EXTEND ,


ZERO_EXTEND ,


TRUNCATE ,


FLOAT_EXTEND ,
FLOAT_TRUNCATE ,


FLOAT ,







FIX ,


UNSIGNED_FLOAT ,




UNSIGNED_FIX ,


ABS ,


SQRT ,




FFS ,


CLZ ,


CTZ ,


POPCOUNT ,


PARITY ,
# 1098 "rtl.def"
SIGN_EXTRACT ,


ZERO_EXTRACT ,




HIGH ,



LO_SUM ,
# 1123 "rtl.def"
RANGE_INFO ,
# 1138 "rtl.def"
RANGE_REG ,





RANGE_VAR ,



RANGE_LIVE ,




CONSTANT_P_RTX ,
# 1174 "rtl.def"
CALL_PLACEHOLDER ,






VEC_MERGE ,





VEC_SELECT ,




VEC_CONCAT ,





VEC_DUPLICATE ,


SS_PLUS ,


US_PLUS ,


SS_MINUS ,


US_MINUS ,


SS_TRUNCATE ,


US_TRUNCATE ,
# 46 "rtl.h" 2


  LAST_AND_UNUSED_RTX_CODE};






extern const unsigned char rtx_length[((int) LAST_AND_UNUSED_RTX_CODE)];


extern const char * const rtx_name[((int) LAST_AND_UNUSED_RTX_CODE)];


extern const char * const rtx_format[((int) LAST_AND_UNUSED_RTX_CODE)];


extern const char rtx_class[((int) LAST_AND_UNUSED_RTX_CODE)];


extern const unsigned char rtx_size[((int) LAST_AND_UNUSED_RTX_CODE)];
extern const unsigned char rtx_next[((int) LAST_AND_UNUSED_RTX_CODE)];



typedef struct
{

  unsigned min_align: 8;

  unsigned base_after_vec: 1;
  unsigned min_after_vec: 1;

  unsigned max_after_vec: 1;

  unsigned min_after_base: 1;

  unsigned max_after_base: 1;


  unsigned offset_unsigned: 1;
  unsigned : 2;
  unsigned scale : 8;
} addr_diff_vec_flags;
# 99 "rtl.h"
typedef struct mem_attrs
{
  long alias;
  tree expr;
  rtx offset;
  rtx size;
  unsigned int align;
} mem_attrs;




typedef struct reg_attrs
{
  tree decl;
  long offset;
} reg_attrs;



union rtunion_def
{
  int rtint;
  unsigned int rtuint;
  const char *rtstr;
  rtx rtx;
  rtvec rtvec;
  enum machine_mode rttype;
  addr_diff_vec_flags rt_addr_diff_vec_flags;
  struct cselib_val_struct *rt_cselib;
  struct bitmap_head_def *rtbit;
  tree rttree;
  struct basic_block_def *bb;
  mem_attrs *rtmem;
  reg_attrs *rtreg;
};
typedef union rtunion_def rtunion;



struct rtx_def

{

  __extension__ enum rtx_code code: 16;


  __extension__ enum machine_mode mode : 8;






  unsigned int jump : 1;


  unsigned int call : 1;







  unsigned int unchanging : 1;
# 173 "rtl.h"
  unsigned int volatil : 1;
# 192 "rtl.h"
  unsigned int in_struct : 1;






  unsigned int used : 1;




  unsigned integrated : 1;
# 213 "rtl.h"
  unsigned frame_related : 1;




  union u {
    rtunion fld[1];
    long hwint[1];
  } u;
};
# 261 "rtl.h"
struct rtvec_def {
  int num_elem;
  rtx elem[1];
};
# 638 "rtl.h"
enum reg_note
{



  REG_DEAD = 1,


  REG_INC,
# 657 "rtl.h"
  REG_EQUIV,




  REG_EQUAL,





  REG_RETVAL,




  REG_LIBCALL,






  REG_NONNEG,



  REG_NO_CONFLICT,


  REG_UNUSED,
# 696 "rtl.h"
  REG_CC_SETTER, REG_CC_USER,




  REG_LABEL,





  REG_DEP_ANTI, REG_DEP_OUTPUT,





  REG_BR_PROB,




  REG_VALUE_PROFILE,



  REG_NOALIAS,



  REG_SAVE_AREA,





  REG_BR_PRED,




  REG_FRAME_RELATED_EXPR,




  REG_EH_CONTEXT,





  REG_EH_REGION,


  REG_SAVE_NOTE,





  REG_MAYBE_DEAD,


  REG_NORETURN,



  REG_NON_LOCAL_GOTO,



  REG_SETJMP,


  REG_ALWAYS_RETURN,



  REG_VTABLE_REF
};
# 788 "rtl.h"
extern const char * const reg_note_name[];
# 850 "rtl.h"
enum insn_note
{

  NOTE_INSN_BIAS = -100,



  NOTE_INSN_DELETED,



  NOTE_INSN_BLOCK_BEG,
  NOTE_INSN_BLOCK_END,


  NOTE_INSN_LOOP_BEG,
  NOTE_INSN_LOOP_END,


  NOTE_INSN_LOOP_CONT,

  NOTE_INSN_LOOP_VTOP,





  NOTE_INSN_LOOP_END_TOP_COND,






  NOTE_INSN_FUNCTION_END,


  NOTE_INSN_PROLOGUE_END,


  NOTE_INSN_EPILOGUE_BEG,


  NOTE_INSN_DELETED_LABEL,




  NOTE_INSN_FUNCTION_BEG,



  NOTE_INSN_EH_REGION_BEG,
  NOTE_INSN_EH_REGION_END,




  NOTE_INSN_REPEATED_LINE_NUMBER,


  NOTE_INSN_BASIC_BLOCK,



  NOTE_INSN_EXPECTED_VALUE,


  NOTE_INSN_PREDICTION,

  NOTE_INSN_MAX
};



extern const char * const note_insn_name[NOTE_INSN_MAX - NOTE_INSN_BIAS];
# 940 "rtl.h"
enum label_kind
{
  LABEL_NORMAL = 0,
  LABEL_STATIC_ENTRY,
  LABEL_GLOBAL_ENTRY,
  LABEL_WEAK_ENTRY
};
# 1067 "rtl.h"
extern unsigned int subreg_lsb (rtx);
extern unsigned int subreg_regno_offset (unsigned int, enum machine_mode,
      unsigned int, enum machine_mode);
extern _Bool subreg_offset_representable_p (unsigned int, enum machine_mode,
        unsigned int, enum machine_mode);
extern unsigned int subreg_regno (rtx);
# 1422 "rtl.h"
extern int rtx_equal_function_value_matters;


extern int generating_concat_p;




extern int ceil_log2 (unsigned long);




extern rtx expand_builtin_expect_jump (tree, rtx, rtx);
extern void purge_builtin_constant_p (void);


extern void set_stack_check_libfunc (rtx);
extern long trunc_int_for_mode (long, enum machine_mode);
extern rtx plus_constant_wide (rtx, long);
extern rtx plus_constant_for_output_wide (rtx, long);
extern void optimize_save_area_alloca (rtx);


extern rtx gen_rtx (enum rtx_code, enum machine_mode, ...);
extern rtvec gen_rtvec (int, ...);
extern rtx copy_insn_1 (rtx);
extern rtx copy_insn (rtx);
extern rtx gen_int_mode (long, enum machine_mode);
extern rtx emit_copy_of_insn_after (rtx, rtx);
extern void set_reg_attrs_from_mem (rtx, rtx);
extern void set_mem_attrs_from_reg (rtx, rtx);
extern void set_reg_attrs_for_parm (rtx, rtx);
extern int mem_expr_equal_p (tree, tree);


extern rtx rtx_alloc (enum rtx_code);
extern rtvec rtvec_alloc (int);
extern rtx copy_rtx (rtx);
extern void dump_rtx_statistics (void);


extern rtx copy_rtx_if_shared (rtx);


extern rtx copy_most_rtx (rtx, rtx);
extern rtx shallow_copy_rtx (rtx);
extern int rtx_equal_p (rtx, rtx);


extern rtvec gen_rtvec_v (int, rtx *);
extern rtx gen_reg_rtx (enum machine_mode);
extern rtx gen_rtx_REG_offset (rtx, enum machine_mode, unsigned int, int);
extern rtx gen_label_rtx (void);
extern int subreg_hard_regno (rtx, int);
extern rtx gen_lowpart_common (enum machine_mode, rtx);
extern rtx gen_lowpart (enum machine_mode, rtx);


extern rtx gen_lowpart_if_possible (enum machine_mode, rtx);


extern rtx gen_highpart (enum machine_mode, rtx);
extern rtx gen_highpart_mode (enum machine_mode, enum machine_mode, rtx);
extern rtx gen_realpart (enum machine_mode, rtx);
extern rtx gen_imagpart (enum machine_mode, rtx);
extern rtx operand_subword (rtx, unsigned int, int, enum machine_mode);


extern rtx operand_subword_force (rtx, unsigned int, enum machine_mode);
extern int subreg_lowpart_p (rtx);
extern unsigned int subreg_lowpart_offset (enum machine_mode,
        enum machine_mode);
extern unsigned int subreg_highpart_offset (enum machine_mode,
         enum machine_mode);
extern rtx make_safe_from (rtx, rtx);
extern rtx convert_memory_address (enum machine_mode, rtx);
extern rtx get_insns (void);
extern const char *get_insn_name (int);
extern rtx get_last_insn (void);
extern rtx get_last_insn_anywhere (void);
extern rtx get_first_nonnote_insn (void);
extern rtx get_last_nonnote_insn (void);
extern void start_sequence (void);
extern void push_to_sequence (rtx);
extern void end_sequence (void);
extern void push_to_full_sequence (rtx, rtx);
extern void end_full_sequence (rtx*, rtx*);
extern rtx immed_double_const (long, long,
          enum machine_mode);


extern rtx force_const_mem (enum machine_mode, rtx);


extern rtx get_pool_constant (rtx);
extern rtx get_pool_constant_mark (rtx, _Bool *);
extern enum machine_mode get_pool_mode (rtx);
extern rtx get_pool_constant_for_function (struct function *, rtx);
extern enum machine_mode get_pool_mode_for_function (struct function *, rtx);
extern int get_pool_offset (rtx);
extern rtx simplify_subtraction (rtx);


extern rtx assign_stack_local (enum machine_mode, long, int);
extern rtx assign_stack_temp (enum machine_mode, long, int);
extern rtx assign_stack_temp_for_type (enum machine_mode,
           long, int, tree);
extern rtx assign_temp (tree, int, int, int);


extern rtx emit_insn_before (rtx, rtx);
extern rtx emit_insn_before_noloc (rtx, rtx);
extern rtx emit_insn_before_setloc (rtx, rtx, int);
extern rtx emit_jump_insn_before (rtx, rtx);
extern rtx emit_jump_insn_before_noloc (rtx, rtx);
extern rtx emit_jump_insn_before_setloc (rtx, rtx, int);
extern rtx emit_call_insn_before (rtx, rtx);
extern rtx emit_call_insn_before_noloc (rtx, rtx);
extern rtx emit_call_insn_before_setloc (rtx, rtx, int);
extern rtx emit_barrier_before (rtx);
extern rtx emit_label_before (rtx, rtx);
extern rtx emit_note_before (int, rtx);
extern rtx emit_insn_after (rtx, rtx);
extern rtx emit_insn_after_noloc (rtx, rtx);
extern rtx emit_insn_after_setloc (rtx, rtx, int);
extern rtx emit_jump_insn_after (rtx, rtx);
extern rtx emit_jump_insn_after_noloc (rtx, rtx);
extern rtx emit_jump_insn_after_setloc (rtx, rtx, int);
extern rtx emit_call_insn_after (rtx, rtx);
extern rtx emit_call_insn_after_noloc (rtx, rtx);
extern rtx emit_call_insn_after_setloc (rtx, rtx, int);
extern rtx emit_barrier_after (rtx);
extern rtx emit_label_after (rtx, rtx);
extern rtx emit_note_after (int, rtx);
extern rtx emit_note_copy_after (rtx, rtx);
extern rtx emit_insn (rtx);
extern rtx emit_jump_insn (rtx);
extern rtx emit_call_insn (rtx);
extern rtx emit_label (rtx);
extern rtx emit_barrier (void);
extern rtx emit_note (int);
extern rtx emit_note_copy (rtx);
extern rtx emit_line_note (location_t);
extern rtx make_insn_raw (rtx);
extern void add_function_usage_to (rtx, rtx);
extern rtx last_call_insn (void);
extern rtx previous_insn (rtx);
extern rtx next_insn (rtx);
extern rtx prev_nonnote_insn (rtx);
extern rtx next_nonnote_insn (rtx);
extern rtx prev_real_insn (rtx);
extern rtx next_real_insn (rtx);
extern rtx prev_active_insn (rtx);
extern rtx next_active_insn (rtx);
extern int active_insn_p (rtx);
extern rtx prev_label (rtx);
extern rtx next_label (rtx);
extern rtx next_cc0_user (rtx);
extern rtx prev_cc0_setter (rtx);


extern tree choose_inner_scope (tree, tree);
extern int insn_line (rtx);
extern const char * insn_file (rtx);
extern int locator_line (int);
extern const char * locator_file (int);
extern int prologue_locator, epilogue_locator;


extern enum rtx_code reverse_condition (enum rtx_code);
extern enum rtx_code reverse_condition_maybe_unordered (enum rtx_code);
extern enum rtx_code swap_condition (enum rtx_code);
extern enum rtx_code unsigned_condition (enum rtx_code);
extern enum rtx_code signed_condition (enum rtx_code);
extern void mark_jump_label (rtx, rtx, int);
extern void cleanup_barriers (void);


extern _Bool squeeze_notes (rtx *, rtx *);
extern rtx delete_related_insns (rtx);
extern void delete_jump (rtx);
extern void delete_barrier (rtx);
extern rtx get_label_before (rtx);
extern rtx get_label_after (rtx);
extern rtx follow_jumps (rtx);


extern rtx *find_constant_term_loc (rtx *);


extern rtx try_split (rtx, rtx, int);
extern int split_branch_probability;


extern rtx split_insns (rtx, rtx);


extern rtx simplify_unary_operation (enum rtx_code, enum machine_mode, rtx,
         enum machine_mode);
extern rtx simplify_binary_operation (enum rtx_code, enum machine_mode, rtx,
          rtx);
extern rtx simplify_ternary_operation (enum rtx_code, enum machine_mode,
           enum machine_mode, rtx, rtx, rtx);
extern rtx simplify_relational_operation (enum rtx_code, enum machine_mode,
       rtx, rtx);
extern rtx simplify_gen_binary (enum rtx_code, enum machine_mode, rtx, rtx);
extern rtx simplify_gen_unary (enum rtx_code, enum machine_mode, rtx,
          enum machine_mode);
extern rtx simplify_gen_ternary (enum rtx_code, enum machine_mode,
     enum machine_mode, rtx, rtx, rtx);
extern rtx simplify_gen_relational (enum rtx_code, enum machine_mode,
        enum machine_mode, rtx, rtx);
extern rtx simplify_subreg (enum machine_mode, rtx, enum machine_mode,
       unsigned int);
extern rtx simplify_gen_subreg (enum machine_mode, rtx, enum machine_mode,
    unsigned int);
extern rtx simplify_replace_rtx (rtx, rtx, rtx);
extern rtx simplify_rtx (rtx);
extern rtx avoid_constant_pool_reference (rtx);


extern rtx gen_mem_addressof (rtx, tree, int);


extern enum machine_mode choose_hard_reg_mode (unsigned int, unsigned int,
            _Bool);


extern rtx set_unique_reg_note (rtx, enum reg_note, rtx);
# 1663 "rtl.h"
typedef struct replace_label_data
{
  rtx r1;
  rtx r2;
  _Bool update_label_nuses;
} replace_label_data;

extern int rtx_addr_can_trap_p (rtx);
extern _Bool nonzero_address_p (rtx);
extern int rtx_unstable_p (rtx);
extern int rtx_varies_p (rtx, int);
extern int rtx_addr_varies_p (rtx, int);
extern long get_integer_term (rtx);
extern rtx get_related_value (rtx);
extern rtx get_jump_table_offset (rtx, rtx *);
extern int global_reg_mentioned_p (rtx);
extern int reg_mentioned_p (rtx, rtx);
extern int count_occurrences (rtx, rtx, int);
extern int reg_referenced_p (rtx, rtx);
extern int reg_used_between_p (rtx, rtx, rtx);
extern int reg_referenced_between_p (rtx, rtx, rtx);
extern int reg_set_between_p (rtx, rtx, rtx);
extern int regs_set_between_p (rtx, rtx, rtx);
extern int commutative_operand_precedence (rtx);
extern int swap_commutative_operands_p (rtx, rtx);
extern int modified_between_p (rtx, rtx, rtx);
extern int no_labels_between_p (rtx, rtx);
extern int no_jumps_between_p (rtx, rtx);
extern int modified_in_p (rtx, rtx);
extern int insn_dependent_p (rtx, rtx);
extern int reg_set_p (rtx, rtx);
extern rtx single_set_2 (rtx, rtx);
extern int multiple_sets (rtx);
extern int set_noop_p (rtx);
extern int noop_move_p (rtx);
extern rtx find_last_value (rtx, rtx *, rtx, int);
extern int refers_to_regno_p (unsigned int, unsigned int, rtx, rtx *);
extern int reg_overlap_mentioned_p (rtx, rtx);
extern rtx set_of (rtx, rtx);
extern void note_stores (rtx, void (*) (rtx, rtx, void *), void *);
extern void note_uses (rtx *, void (*) (rtx *, void *), void *);
extern rtx reg_set_last (rtx, rtx);
extern int dead_or_set_p (rtx, rtx);
extern int dead_or_set_regno_p (rtx, unsigned int);
extern rtx find_reg_note (rtx, enum reg_note, rtx);
extern rtx find_regno_note (rtx, enum reg_note, unsigned int);
extern rtx find_reg_equal_equiv_note (rtx);
extern int find_reg_fusage (rtx, enum rtx_code, rtx);
extern int find_regno_fusage (rtx, enum rtx_code, unsigned int);
extern int pure_call_p (rtx);
extern void remove_note (rtx, rtx);
extern int side_effects_p (rtx);
extern int volatile_refs_p (rtx);
extern int volatile_insn_p (rtx);
extern int may_trap_p (rtx);
extern int inequality_comparisons_p (rtx);
extern rtx replace_rtx (rtx, rtx, rtx);
extern rtx replace_regs (rtx, rtx *, unsigned int, int);
extern int replace_label (rtx *, void *);
extern int rtx_referenced_p (rtx, rtx);
extern _Bool tablejump_p (rtx, rtx *, rtx *);
extern int computed_jump_p (rtx);
typedef int (*rtx_function) (rtx *, void *);
extern int for_each_rtx (rtx *, rtx_function, void *);
extern rtx regno_use_in (unsigned int, rtx);
extern int auto_inc_p (rtx);
extern int in_expr_list_p (rtx, rtx);
extern void remove_node_from_expr_list (rtx, rtx *);
extern int insns_safe_to_move_p (rtx, rtx, rtx *);
extern int loc_mentioned_in_p (rtx *, rtx);
extern rtx find_first_parameter_load (rtx, rtx);
extern _Bool keep_with_call_p (rtx);
extern _Bool label_is_jump_target_p (rtx, rtx);



extern rtx find_use_as_address (rtx, rtx, long);



void free_EXPR_LIST_list (rtx *);
void free_INSN_LIST_list (rtx *);
void free_EXPR_LIST_node (rtx);
void free_INSN_LIST_node (rtx);
rtx alloc_INSN_LIST (rtx, rtx);
rtx alloc_EXPR_LIST (int, rtx, rtx);







extern int max_parallel;


extern void free_reg_info (void);


extern int asm_noperands (rtx);
extern const char *decode_asm_operands (rtx, rtx *, rtx **, const char **,
     enum machine_mode *);

extern enum reg_class reg_preferred_class (int);
extern enum reg_class reg_alternate_class (int);

extern rtx get_first_nonparm_insn (void);

extern void split_all_insns (int);
extern void split_all_insns_noflow (void);


extern rtx const_int_rtx[64 * 2 + 1];





extern rtx const_true_rtx;

extern rtx const_tiny_rtx[3][(int) MAX_MACHINE_MODE];
# 1806 "rtl.h"
enum global_rtl_index
{
  GR_PC,
  GR_CC0,
  GR_STACK_POINTER,
  GR_FRAME_POINTER,
# 1821 "rtl.h"
  GR_HARD_FRAME_POINTER,





  GR_ARG_POINTER,


  GR_VIRTUAL_INCOMING_ARGS,
  GR_VIRTUAL_STACK_ARGS,
  GR_VIRTUAL_STACK_DYNAMIC,
  GR_VIRTUAL_OUTGOING_ARGS,
  GR_VIRTUAL_CFA,

  GR_MAX
};


extern rtx global_rtl[GR_MAX];
# 1854 "rtl.h"
extern rtx pic_offset_table_rtx;
extern rtx static_chain_rtx;
extern rtx static_chain_incoming_rtx;
extern rtx return_address_pointer_rtx;




# 1 "genrtl.h" 1





extern rtx gen_rtx_fmt_s (enum rtx_code, enum machine_mode mode,
           const char *arg0);
extern rtx gen_rtx_fmt_ee (enum rtx_code, enum machine_mode mode,
           rtx arg0, rtx arg1);
extern rtx gen_rtx_fmt_ue (enum rtx_code, enum machine_mode mode,
           rtx arg0, rtx arg1);
extern rtx gen_rtx_fmt_iss (enum rtx_code, enum machine_mode mode,
           int arg0, const char *arg1,
           const char *arg2);
extern rtx gen_rtx_fmt_is (enum rtx_code, enum machine_mode mode,
           int arg0, const char *arg1);
extern rtx gen_rtx_fmt_i (enum rtx_code, enum machine_mode mode,
           int arg0);
extern rtx gen_rtx_fmt_isE (enum rtx_code, enum machine_mode mode,
           int arg0, const char *arg1,
           rtvec arg2);
extern rtx gen_rtx_fmt_iE (enum rtx_code, enum machine_mode mode,
           int arg0, rtvec arg1);
extern rtx gen_rtx_fmt_Ess (enum rtx_code, enum machine_mode mode,
           rtvec arg0, const char *arg1,
           const char *arg2);
extern rtx gen_rtx_fmt_sEss (enum rtx_code, enum machine_mode mode,
           const char *arg0, rtvec arg1,
           const char *arg2, const char *arg3);
extern rtx gen_rtx_fmt_eE (enum rtx_code, enum machine_mode mode,
           rtx arg0, rtvec arg1);
extern rtx gen_rtx_fmt_E (enum rtx_code, enum machine_mode mode,
           rtvec arg0);
extern rtx gen_rtx_fmt_e (enum rtx_code, enum machine_mode mode,
           rtx arg0);
extern rtx gen_rtx_fmt_ss (enum rtx_code, enum machine_mode mode,
           const char *arg0, const char *arg1);
extern rtx gen_rtx_fmt_sies (enum rtx_code, enum machine_mode mode,
           const char *arg0, int arg1,
           rtx arg2, const char *arg3);
extern rtx gen_rtx_fmt_sse (enum rtx_code, enum machine_mode mode,
           const char *arg0, const char *arg1,
           rtx arg2);
extern rtx gen_rtx_fmt_sE (enum rtx_code, enum machine_mode mode,
           const char *arg0, rtvec arg1);
extern rtx gen_rtx_fmt_ii (enum rtx_code, enum machine_mode mode,
           int arg0, int arg1);
extern rtx gen_rtx_fmt_iuuBieiee (enum rtx_code, enum machine_mode mode,
           int arg0, rtx arg1, rtx arg2,
           struct basic_block_def *arg3,
           int arg4, rtx arg5, int arg6,
           rtx arg7, rtx arg8);
extern rtx gen_rtx_fmt_iuuBieiee0 (enum rtx_code, enum machine_mode mode,
           int arg0, rtx arg1, rtx arg2,
           struct basic_block_def *arg3,
           int arg4, rtx arg5, int arg6,
           rtx arg7, rtx arg8);
extern rtx gen_rtx_fmt_iuuBieieee (enum rtx_code, enum machine_mode mode,
           int arg0, rtx arg1, rtx arg2,
           struct basic_block_def *arg3,
           int arg4, rtx arg5, int arg6,
           rtx arg7, rtx arg8, rtx arg9);
extern rtx gen_rtx_fmt_iuu000000 (enum rtx_code, enum machine_mode mode,
           int arg0, rtx arg1, rtx arg2);
extern rtx gen_rtx_fmt_iuuB00is (enum rtx_code, enum machine_mode mode,
           int arg0, rtx arg1, rtx arg2,
           struct basic_block_def *arg3,
           int arg4, const char *arg5);
extern rtx gen_rtx_fmt_ssiEEsi (enum rtx_code, enum machine_mode mode,
           const char *arg0, const char *arg1,
           int arg2, rtvec arg3, rtvec arg4,
           const char *arg5, int arg6);
extern rtx gen_rtx_fmt_Ei (enum rtx_code, enum machine_mode mode,
           rtvec arg0, int arg1);
extern rtx gen_rtx_fmt_eEee0 (enum rtx_code, enum machine_mode mode,
           rtx arg0, rtvec arg1, rtx arg2,
           rtx arg3);
extern rtx gen_rtx_fmt_eee (enum rtx_code, enum machine_mode mode,
           rtx arg0, rtx arg1, rtx arg2);
extern rtx gen_rtx_fmt_ (enum rtx_code, enum machine_mode mode);
extern rtx gen_rtx_fmt_w (enum rtx_code, enum machine_mode mode,
           long arg0);
extern rtx gen_rtx_fmt_0 (enum rtx_code, enum machine_mode mode);
extern rtx gen_rtx_fmt_i00 (enum rtx_code, enum machine_mode mode,
           int arg0);
extern rtx gen_rtx_fmt_ei (enum rtx_code, enum machine_mode mode,
           rtx arg0, int arg1);
extern rtx gen_rtx_fmt_e0 (enum rtx_code, enum machine_mode mode,
           rtx arg0);
extern rtx gen_rtx_fmt_u00 (enum rtx_code, enum machine_mode mode,
           rtx arg0);
extern rtx gen_rtx_fmt_s00 (enum rtx_code, enum machine_mode mode,
           const char *arg0);
extern rtx gen_rtx_fmt_eit (enum rtx_code, enum machine_mode mode,
           rtx arg0, int arg1,
           union tree_node *arg2);
extern rtx gen_rtx_fmt_eeeee (enum rtx_code, enum machine_mode mode,
           rtx arg0, rtx arg1, rtx arg2,
           rtx arg3, rtx arg4);
extern rtx gen_rtx_fmt_Ee (enum rtx_code, enum machine_mode mode,
           rtvec arg0, rtx arg1);
extern rtx gen_rtx_fmt_uuEiiiiiibbii (enum rtx_code, enum machine_mode mode,
           rtx arg0, rtx arg1, rtvec arg2,
           int arg3, int arg4, int arg5,
           int arg6, int arg7, int arg8,
           struct bitmap_head_def *arg9,
           struct bitmap_head_def *arg10,
           int arg11, int arg12);
extern rtx gen_rtx_fmt_iiiiiiiitt (enum rtx_code, enum machine_mode mode,
           int arg0, int arg1, int arg2,
           int arg3, int arg4, int arg5,
           int arg6, int arg7,
           union tree_node *arg8,
           union tree_node *arg9);
extern rtx gen_rtx_fmt_eti (enum rtx_code, enum machine_mode mode,
           rtx arg0, union tree_node *arg1,
           int arg2);
extern rtx gen_rtx_fmt_bi (enum rtx_code, enum machine_mode mode,
           struct bitmap_head_def *arg0,
           int arg1);
extern rtx gen_rtx_fmt_uuuu (enum rtx_code, enum machine_mode mode,
           rtx arg0, rtx arg1, rtx arg2,
           rtx arg3);
# 1863 "rtl.h" 2







extern rtx gen_rtx_CONST_INT (enum machine_mode, long);
extern rtx gen_rtx_CONST_VECTOR (enum machine_mode, rtvec);
extern rtx gen_raw_REG (enum machine_mode, int);
extern rtx gen_rtx_REG (enum machine_mode, unsigned);
extern rtx gen_rtx_SUBREG (enum machine_mode, rtx, int);
extern rtx gen_rtx_MEM (enum machine_mode, rtx);

extern rtx gen_lowpart_SUBREG (enum machine_mode, rtx);
# 1947 "rtl.h"
extern rtx output_constant_def (tree, int);
extern rtx lookup_constant_def (tree);


extern void notice_rtl_inlining_of_deferred_constant (void);



extern int flow2_completed;




extern int reload_completed;


extern int epilogue_completed;




extern int reload_in_progress;







extern int cse_not_expected;



extern int no_new_pseudos;





extern int rtx_to_tree_code (enum rtx_code);


struct cse_basic_block_data;
# 2000 "rtl.h"
extern int rtx_cost (rtx, enum rtx_code);
extern int address_cost (rtx, enum machine_mode);
extern int delete_trivially_dead_insns (rtx, int);

extern int cse_main (rtx, int, int, FILE *);

extern void cse_end_of_basic_block (rtx, struct cse_basic_block_data *,
        int, int, int);
extern void cse_condition_code_reg (void);


extern int comparison_dominates_p (enum rtx_code, enum rtx_code);
extern int condjump_p (rtx);
extern int any_condjump_p (rtx);
extern int any_uncondjump_p (rtx);
extern int safe_to_remove_jump_p (rtx);
extern rtx pc_set (rtx);
extern rtx condjump_label (rtx);
extern int simplejump_p (rtx);
extern int returnjump_p (rtx);
extern int onlyjump_p (rtx);
extern int only_sets_cc0_p (rtx);
extern int sets_cc0_p (rtx);
extern int invert_jump_1 (rtx, rtx);
extern int invert_jump (rtx, rtx, int);
extern int rtx_renumbered_equal_p (rtx, rtx);
extern int true_regnum (rtx);
extern unsigned int reg_or_subregno (rtx);
extern int redirect_jump_1 (rtx, rtx);
extern int redirect_jump (rtx, rtx, int);
extern void rebuild_jump_labels (rtx);
extern enum rtx_code reversed_comparison_code (rtx, rtx);
extern enum rtx_code reversed_comparison_code_parts (enum rtx_code,
           rtx, rtx, rtx);
extern void delete_for_peephole (rtx, rtx);
extern int condjump_in_parallel_p (rtx);
extern void never_reached_warning (rtx, rtx);
extern void purge_line_number_notes (rtx);
extern void copy_loop_headers (rtx);


extern int max_reg_num (void);
extern int max_label_num (void);
extern int get_first_label_num (void);
extern void delete_insns_since (rtx);
extern void mark_reg_pointer (rtx, int);
extern void mark_user_reg (rtx);
extern void reset_used_flags (rtx);
extern void set_used_flags (rtx);
extern void reorder_insns (rtx, rtx, rtx);
extern void reorder_insns_nobb (rtx, rtx, rtx);
extern int get_max_uid (void);
extern int in_sequence_p (void);
extern void force_next_line_note (void);
extern void init_emit (void);
extern void init_emit_once (int);
extern void push_topmost_sequence (void);
extern void pop_topmost_sequence (void);
extern int subreg_realpart_p (rtx);
extern void reverse_comparison (rtx);
extern void set_new_first_and_last_insn (rtx, rtx);
extern void set_new_last_label_num (int);
extern void unshare_all_rtl_again (rtx);
extern void unshare_all_rtl_in_chain (rtx);
extern void verify_rtl_sharing (void);
extern void set_first_insn (rtx);
extern void set_last_insn (rtx);
extern void link_cc0_insns (rtx);
extern void add_insn (rtx);
extern void add_insn_before (rtx, rtx);
extern void add_insn_after (rtx, rtx);
extern void remove_insn (rtx);
extern void reorder_insns_with_line_notes (rtx, rtx, rtx);
extern void emit_insn_after_with_line_notes (rtx, rtx, rtx);
extern enum rtx_code classify_insn (rtx);
extern rtx emit (rtx);



int force_line_numbers (void);
void restore_line_number_status (int old_value);
extern void renumber_insns (FILE *);
extern void remove_unnecessary_notes (void);
extern rtx delete_insn (rtx);
extern void delete_insn_chain (rtx, rtx);
extern rtx unlink_insn_chain (rtx, rtx);
extern rtx delete_insn_and_edges (rtx);
extern void delete_insn_chain_and_edges (rtx, rtx);


extern int combine_instructions (rtx, unsigned int);
extern unsigned int extended_count (rtx, enum machine_mode, int);
extern rtx remove_death (unsigned int, rtx);

extern void dump_combine_stats (FILE *);
extern void dump_combine_total_stats (FILE *);


extern void web_main (void);



extern void schedule_insns (FILE *);
extern void schedule_ebbs (FILE *);

extern void fix_sched_param (const char *, const char *);


extern const char *print_rtx_head;
extern void debug_rtx (rtx);
extern void debug_rtx_list (rtx, int);
extern void debug_rtx_range (rtx, rtx);
extern rtx debug_rtx_find (rtx, int);

extern void print_mem_expr (FILE *, tree);
extern void print_rtl (FILE *, rtx);
extern void print_simple_rtl (FILE *, rtx);
extern int print_rtl_single (FILE *, rtx);
extern void print_inline_rtx (FILE *, rtx, int);



extern void init_loop (void);
extern rtx libcall_other_reg (rtx, rtx);

extern void loop_optimize (rtx, FILE *, int);

extern void branch_target_load_optimize (rtx, _Bool);
extern void record_excess_regs (rtx, rtx, rtx *);


extern void reposition_prologue_and_epilogue_notes (rtx);
extern void thread_prologue_and_epilogue_insns (rtx);
extern int prologue_epilogue_contains (rtx);
extern int sibcall_epilogue_contains (rtx);
extern void preserve_rtl_expr_result (rtx);
extern void mark_temp_addr_taken (rtx);
extern void update_temp_slot_address (rtx, rtx);
extern void purge_addressof (rtx);
extern void purge_hard_subreg_sets (rtx);


extern void set_file_and_line_for_stmt (location_t);
extern void expand_null_return (void);
extern void expand_naked_return (void);
extern void emit_jump (rtx);
extern int preserve_subexpressions_p (void);


extern rtx move_by_pieces (rtx, rtx, unsigned long,
      unsigned int, int);


extern void recompute_reg_usage (rtx, int);
extern int initialize_uninitialized_subregs (void);
extern void delete_dead_jumptables (void);

extern void print_rtl_with_bb (FILE *, rtx);
extern void dump_flow_info (FILE *);



extern void init_expmed (void);
extern void expand_inc (rtx, rtx);
extern void expand_dec (rtx, rtx);
extern rtx expand_mult_highpart (enum machine_mode, rtx,
     unsigned long, rtx, int, int);


extern _Bool can_copy_p (enum machine_mode);
extern rtx fis_get_condition (rtx);

extern int gcse_main (rtx, FILE *);
extern int bypass_jumps (FILE *);



extern void mark_elimination (int, int);

extern int global_alloc (FILE *);
extern void dump_global_regs (FILE *);





extern void build_insn_chain (rtx);


extern int reg_classes_intersect_p (enum reg_class, enum reg_class);
extern int reg_class_subset_p (enum reg_class, enum reg_class);
extern void globalize_reg (int);
extern void init_reg_modes_once (void);
extern void init_regs (void);
extern void init_fake_stack_mems (void);
extern void init_reg_sets (void);
extern void regset_release_memory (void);
extern void regclass_init (void);
extern void regclass (rtx, int, FILE *);
extern void reg_scan (rtx, unsigned int, int);
extern void reg_scan_update (rtx, rtx, unsigned int);
extern void fix_register (const char *, int, int);




extern _Bool invalid_mode_change_p (unsigned int, enum reg_class,
       enum machine_mode);

extern int delete_null_pointer_checks (rtx);



extern void regmove_optimize (rtx, int, FILE *);

extern void combine_stack_adjustments (void);



extern void dbr_schedule (rtx, FILE *);




extern void dump_local_alloc (FILE *);

extern int local_alloc (void);
extern int function_invariant_p (rtx);


extern void init_branch_prob (void);
extern void branch_prob (void);
extern void end_branch_prob (void);



extern _Bool reg_to_stack (rtx, FILE *);



enum libcall_type
{
  LCT_NORMAL = 0,
  LCT_CONST = 1,
  LCT_PURE = 2,
  LCT_CONST_MAKE_BLOCK = 3,
  LCT_PURE_MAKE_BLOCK = 4,
  LCT_NORETURN = 5,
  LCT_THROW = 6,
  LCT_ALWAYS_RETURN = 7,
  LCT_RETURNS_TWICE = 8
};

extern void emit_library_call (rtx, enum libcall_type, enum machine_mode, int,
          ...);
extern rtx emit_library_call_value (rtx, rtx, enum libcall_type,
        enum machine_mode, int, ...);


extern int set_dominates_use (int, int, int, rtx, rtx);


extern int in_data_section (void);
extern void init_varasm_once (void);


extern void init_rtl (void);
extern void traverse_md_constants (int (*) (void **, void *), void *);
struct md_constant { char *name, *value; };


extern int read_skip_spaces (FILE *);
extern rtx read_rtx (FILE *);


extern const char *read_rtx_filename;
extern int read_rtx_lineno;







extern void fancy_abort (const char *, int, const char *)
    __attribute__ ((__noreturn__));



extern void clear_reg_alias_info (rtx);
extern rtx canon_rtx (rtx);
extern int true_dependence (rtx, enum machine_mode, rtx, int (*)(rtx, int));
extern rtx get_addr (rtx);
extern int canon_true_dependence (rtx, enum machine_mode, rtx, rtx,
      int (*)(rtx, int));
extern int read_dependence (rtx, rtx);
extern int anti_dependence (rtx, rtx);
extern int output_dependence (rtx, rtx);
extern int unchanging_anti_dependence (rtx, rtx);
extern void mark_constant_function (void);
extern void init_alias_once (void);
extern void init_alias_analysis (void);
extern void end_alias_analysis (void);
extern rtx addr_side_effect_eval (rtx, int, int);
extern _Bool memory_modified_in_insn_p (rtx, rtx);
extern rtx find_base_term (rtx);


typedef enum {
  sibcall_use_normal = 1,
  sibcall_use_tail_recursion,
  sibcall_use_sibcall
} sibcall_use_t;

extern void optimize_sibling_and_tail_recursive_calls (void);
extern void replace_call_placeholder (rtx, sibcall_use_t);


extern int stack_regs_mentioned (rtx insn);



extern rtx stack_limit_rtx;


extern void regrename_optimize (void);
extern void copyprop_hardreg_forward (void);


extern void if_convert (int);


extern void invert_br_probabilities (rtx);
extern _Bool expensive_function_p (int);

extern void tracer (void);
# 94 "reload.c" 2
# 1 "tm_p.h" 1



# 1 "config/i386/i386-protos.h" 1
# 23 "config/i386/i386-protos.h"
extern void override_options (void);
extern void optimization_options (int, int);

extern int ix86_can_use_return_insn_p (void);
extern int ix86_frame_pointer_required (void);
extern void ix86_setup_frame_addresses (void);

extern void ix86_file_end (void);
extern long ix86_initial_elimination_offset (int, int);
extern void ix86_expand_prologue (void);
extern void ix86_expand_epilogue (int);

extern void ix86_output_addr_vec_elt (FILE *, int);
extern void ix86_output_addr_diff_elt (FILE *, int, int);


extern int ix86_aligned_p (rtx);

extern int standard_80387_constant_p (rtx);
extern const char *standard_80387_constant_opcode (rtx);
extern rtx standard_80387_constant_rtx (int);
extern int standard_sse_constant_p (rtx);
extern int symbolic_reference_mentioned_p (rtx);
extern _Bool extended_reg_mentioned_p (rtx);
extern _Bool x86_extended_QIreg_mentioned_p (rtx);
extern _Bool x86_extended_reg_mentioned_p (rtx);

extern int any_fp_register_operand (rtx, enum machine_mode);
extern int register_and_not_any_fp_reg_operand (rtx, enum machine_mode);

extern int fp_register_operand (rtx, enum machine_mode);
extern int register_and_not_fp_reg_operand (rtx, enum machine_mode);

extern int x86_64_general_operand (rtx, enum machine_mode);
extern int x86_64_szext_general_operand (rtx, enum machine_mode);
extern int x86_64_nonmemory_operand (rtx, enum machine_mode);
extern int x86_64_szext_nonmemory_operand (rtx, enum machine_mode);
extern int x86_64_immediate_operand (rtx, enum machine_mode);
extern int x86_64_zext_immediate_operand (rtx, enum machine_mode);
extern int symbolic_operand (rtx, enum machine_mode);
extern int tls_symbolic_operand (rtx, enum machine_mode);
extern int global_dynamic_symbolic_operand (rtx, enum machine_mode);
extern int local_dynamic_symbolic_operand (rtx, enum machine_mode);
extern int initial_exec_symbolic_operand (rtx, enum machine_mode);
extern int local_exec_symbolic_operand (rtx, enum machine_mode);
extern int pic_symbolic_operand (rtx, enum machine_mode);
extern int call_insn_operand (rtx, enum machine_mode);
extern int sibcall_insn_operand (rtx, enum machine_mode);
extern int constant_call_address_operand (rtx, enum machine_mode);
extern int const0_operand (rtx, enum machine_mode);
extern int const1_operand (rtx, enum machine_mode);
extern int const248_operand (rtx, enum machine_mode);
extern int incdec_operand (rtx, enum machine_mode);
extern int reg_no_sp_operand (rtx, enum machine_mode);
extern int mmx_reg_operand (rtx, enum machine_mode);
extern int general_no_elim_operand (rtx, enum machine_mode);
extern int nonmemory_no_elim_operand (rtx, enum machine_mode);
extern int q_regs_operand (rtx, enum machine_mode);
extern int non_q_regs_operand (rtx, enum machine_mode);
extern int sse_comparison_operator (rtx, enum machine_mode);
extern int fcmov_comparison_operator (rtx, enum machine_mode);
extern int cmp_fp_expander_operand (rtx, enum machine_mode);
extern int ix86_comparison_operator (rtx, enum machine_mode);
extern int ext_register_operand (rtx, enum machine_mode);
extern int binary_fp_operator (rtx, enum machine_mode);
extern int mult_operator (rtx, enum machine_mode);
extern int div_operator (rtx, enum machine_mode);
extern int arith_or_logical_operator (rtx, enum machine_mode);
extern int promotable_binary_operator (rtx, enum machine_mode);
extern int memory_displacement_operand (rtx, enum machine_mode);
extern int cmpsi_operand (rtx, enum machine_mode);
extern int long_memory_operand (rtx, enum machine_mode);
extern int aligned_operand (rtx, enum machine_mode);
extern enum machine_mode ix86_cc_mode (enum rtx_code, rtx, rtx);

extern int ix86_expand_movstr (rtx, rtx, rtx, rtx);
extern int ix86_expand_clrstr (rtx, rtx, rtx);
extern int ix86_expand_strlen (rtx, rtx, rtx, rtx);

extern _Bool legitimate_constant_p (rtx);
extern _Bool constant_address_p (rtx);
extern _Bool legitimate_pic_operand_p (rtx);
extern int legitimate_pic_address_disp_p (rtx);
extern int legitimate_address_p (enum machine_mode, rtx, int);
extern rtx legitimize_pic_address (rtx, rtx);
extern rtx legitimize_address (rtx, rtx, enum machine_mode);

extern void print_reg (rtx, int, FILE*);
extern void print_operand (FILE*, rtx, int);
extern void print_operand_address (FILE*, rtx);
extern _Bool output_addr_const_extra (FILE*, rtx);

extern void split_di (rtx[], int, rtx[], rtx[]);
extern void split_ti (rtx[], int, rtx[], rtx[]);

extern const char *output_set_got (rtx);
extern const char *output_387_binary_op (rtx, rtx*);
extern const char *output_fix_trunc (rtx, rtx*);
extern const char *output_fp_compare (rtx, rtx*, int, int);

extern void i386_dwarf_output_addr_const (FILE*, rtx);
extern void i386_output_dwarf_dtprel (FILE*, int, rtx);

extern void ix86_expand_clear (rtx);
extern void ix86_expand_move (enum machine_mode, rtx[]);
extern void ix86_expand_vector_move (enum machine_mode, rtx[]);
extern void ix86_expand_binary_operator (enum rtx_code,
      enum machine_mode, rtx[]);
extern int ix86_binary_operator_ok (enum rtx_code, enum machine_mode, rtx[]);
extern void ix86_expand_unary_operator (enum rtx_code, enum machine_mode,
     rtx[]);
extern int ix86_unary_operator_ok (enum rtx_code, enum machine_mode, rtx[]);
extern int ix86_match_ccmode (rtx, enum machine_mode);
extern rtx ix86_expand_compare (enum rtx_code, rtx *, rtx *);
extern int ix86_use_fcomi_compare (enum rtx_code);
extern void ix86_expand_branch (enum rtx_code, rtx);
extern int ix86_expand_setcc (enum rtx_code, rtx);
extern int ix86_expand_int_movcc (rtx[]);
extern int ix86_expand_fp_movcc (rtx[]);
extern int ix86_expand_int_addcc (rtx[]);
extern void ix86_expand_call (rtx, rtx, rtx, rtx, rtx, int);
extern void x86_initialize_trampoline (rtx, rtx, rtx);
extern rtx ix86_zero_extend_to_Pmode (rtx);
extern void ix86_split_long_move (rtx[]);
extern void ix86_split_ashldi (rtx *, rtx);
extern void ix86_split_ashrdi (rtx *, rtx);
extern void ix86_split_lshrdi (rtx *, rtx);
extern rtx ix86_find_base_term (rtx);
extern int ix86_check_movabs (rtx, int);

extern rtx assign_386_stack_local (enum machine_mode, int);
extern int ix86_attr_length_immediate_default (rtx, int);
extern int ix86_attr_length_address_default (rtx);

extern enum machine_mode ix86_fp_compare_mode (enum rtx_code);

extern int x86_64_sign_extended_value (rtx);
extern int x86_64_zero_extended_value (rtx);
extern rtx ix86_libcall_value (enum machine_mode);
extern _Bool ix86_function_value_regno_p (int);
extern _Bool ix86_function_arg_regno_p (int);
extern int ix86_function_arg_boundary (enum machine_mode, tree);
extern int ix86_return_in_memory (tree);
extern void ix86_va_start (tree, rtx);
extern rtx ix86_va_arg (tree, tree);
extern void ix86_setup_incoming_varargs (CUMULATIVE_ARGS *,
      enum machine_mode, tree, int *, int);

extern rtx ix86_force_to_memory (enum machine_mode, rtx);
extern void ix86_free_from_memory (enum machine_mode);
extern void ix86_split_fp_branch (enum rtx_code code, rtx, rtx, rtx, rtx, rtx);
extern int ix86_hard_regno_mode_ok (int, enum machine_mode);
extern int ix86_register_move_cost (enum machine_mode, enum reg_class,
        enum reg_class);
extern int ix86_secondary_memory_needed (enum reg_class, enum reg_class,
      enum machine_mode, int);
extern enum reg_class ix86_preferred_reload_class (rtx, enum reg_class);
extern int ix86_memory_move_cost (enum machine_mode, enum reg_class, int);
extern void emit_i387_cw_initialization (rtx, rtx);
extern _Bool ix86_fp_jump_nontrivial_p (enum rtx_code);
extern void x86_order_regs_for_local_alloc (void);
extern void x86_function_profiler (FILE *, int);
extern void x86_emit_floatuns (rtx [2]);
# 216 "config/i386/i386-protos.h"
extern rtx ix86_tls_get_addr (void);
extern _Bool ix86_must_pass_in_stack (enum machine_mode mode, tree);

extern void ix86_expand_vector_init (rtx, rtx);

extern int i386_pe_dllexport_name_p (const char *);
extern int i386_pe_dllimport_name_p (const char *);
extern void i386_pe_unique_section (tree, int);
extern void i386_pe_declare_function_type (FILE *, const char *, int);
extern void i386_pe_record_external_function (const char *);
extern void i386_pe_record_exported_symbol (const char *, int);
extern void i386_pe_asm_file_end (FILE *);
extern void i386_pe_encode_section_info (tree, rtx, int);
extern const char *i386_pe_strip_name_encoding (const char *);
extern const char *i386_pe_strip_name_encoding_full (const char *);
extern void i386_pe_output_labelref (FILE *, const char *);
# 5 "tm_p.h" 2
# 1 "tm-preds.h" 1







extern int x86_64_immediate_operand (rtx, enum machine_mode);
extern int x86_64_nonmemory_operand (rtx, enum machine_mode);
extern int x86_64_movabs_operand (rtx, enum machine_mode);
extern int x86_64_szext_nonmemory_operand (rtx, enum machine_mode);
extern int x86_64_general_operand (rtx, enum machine_mode);
extern int x86_64_szext_general_operand (rtx, enum machine_mode);
extern int x86_64_zext_immediate_operand (rtx, enum machine_mode);
extern int shiftdi_operand (rtx, enum machine_mode);
extern int const_int_1_31_operand (rtx, enum machine_mode);
extern int symbolic_operand (rtx, enum machine_mode);
extern int aligned_operand (rtx, enum machine_mode);
extern int pic_symbolic_operand (rtx, enum machine_mode);
extern int call_insn_operand (rtx, enum machine_mode);
extern int sibcall_insn_operand (rtx, enum machine_mode);
extern int constant_call_address_operand (rtx, enum machine_mode);
extern int const0_operand (rtx, enum machine_mode);
extern int const1_operand (rtx, enum machine_mode);
extern int const248_operand (rtx, enum machine_mode);
extern int const_0_to_3_operand (rtx, enum machine_mode);
extern int const_0_to_7_operand (rtx, enum machine_mode);
extern int const_0_to_15_operand (rtx, enum machine_mode);
extern int const_0_to_255_operand (rtx, enum machine_mode);
extern int incdec_operand (rtx, enum machine_mode);
extern int mmx_reg_operand (rtx, enum machine_mode);
extern int reg_no_sp_operand (rtx, enum machine_mode);
extern int general_no_elim_operand (rtx, enum machine_mode);
extern int nonmemory_no_elim_operand (rtx, enum machine_mode);
extern int index_register_operand (rtx, enum machine_mode);
extern int flags_reg_operand (rtx, enum machine_mode);
extern int q_regs_operand (rtx, enum machine_mode);
extern int non_q_regs_operand (rtx, enum machine_mode);
extern int fcmov_comparison_operator (rtx, enum machine_mode);
extern int sse_comparison_operator (rtx, enum machine_mode);
extern int ix86_comparison_operator (rtx, enum machine_mode);
extern int ix86_carry_flag_operator (rtx, enum machine_mode);
extern int cmp_fp_expander_operand (rtx, enum machine_mode);
extern int ext_register_operand (rtx, enum machine_mode);
extern int binary_fp_operator (rtx, enum machine_mode);
extern int mult_operator (rtx, enum machine_mode);
extern int div_operator (rtx, enum machine_mode);
extern int arith_or_logical_operator (rtx, enum machine_mode);
extern int promotable_binary_operator (rtx, enum machine_mode);
extern int memory_displacement_operand (rtx, enum machine_mode);
extern int cmpsi_operand (rtx, enum machine_mode);
extern int long_memory_operand (rtx, enum machine_mode);
extern int tls_symbolic_operand (rtx, enum machine_mode);
extern int global_dynamic_symbolic_operand (rtx, enum machine_mode);
extern int local_dynamic_symbolic_operand (rtx, enum machine_mode);
extern int initial_exec_symbolic_operand (rtx, enum machine_mode);
extern int local_exec_symbolic_operand (rtx, enum machine_mode);
extern int any_fp_register_operand (rtx, enum machine_mode);
extern int register_and_not_any_fp_reg_operand (rtx, enum machine_mode);
extern int fp_register_operand (rtx, enum machine_mode);
extern int register_and_not_fp_reg_operand (rtx, enum machine_mode);
extern int zero_extended_scalar_load_operand (rtx, enum machine_mode);
extern int vector_move_operand (rtx, enum machine_mode);
extern int no_seg_address_operand (rtx, enum machine_mode);
# 6 "tm_p.h" 2
# 95 "reload.c" 2
# 1 "insn-config.h" 1
# 96 "reload.c" 2
# 1 "expr.h" 1
# 57 "expr.h"
enum expand_modifier {EXPAND_NORMAL = 0, EXPAND_STACK_PARM = 2, EXPAND_SUM,
        EXPAND_CONST_ADDRESS, EXPAND_INITIALIZER, EXPAND_WRITE,
        EXPAND_MEMORY};
# 93 "expr.h"
enum direction {none, upward, downward};






struct args_size
{
  long constant;
  tree var;
};



struct locate_and_pad_arg_data
{



  struct args_size size;

  struct args_size offset;


  struct args_size slot_offset;


  struct args_size alignment_pad;

  enum direction where_pad;
};
# 191 "expr.h"
tree split_complex_types (tree);
tree split_complex_values (tree);


extern _Bool default_must_pass_in_stack (enum machine_mode, tree);
# 264 "expr.h"
enum optab_methods
{
  OPTAB_DIRECT,
  OPTAB_LIB,
  OPTAB_WIDEN,
  OPTAB_LIB_WIDEN,
  OPTAB_MUST_WIDEN
};




extern rtx expand_simple_binop (enum machine_mode, enum rtx_code, rtx,
    rtx, rtx, int, enum optab_methods);
extern rtx expand_simple_unop (enum machine_mode, enum rtx_code, rtx, rtx,
          int);



extern int have_insn_for (enum rtx_code, enum machine_mode);


extern void emit_libcall_block (rtx, rtx, rtx, rtx);





extern rtx gen_add2_insn (rtx, rtx);
extern rtx gen_add3_insn (rtx, rtx, rtx);
extern rtx gen_sub2_insn (rtx, rtx);
extern rtx gen_sub3_insn (rtx, rtx, rtx);
extern rtx gen_move_insn (rtx, rtx);
extern int have_add2_insn (rtx, rtx);
extern int have_sub2_insn (rtx, rtx);



extern void emit_cmp_and_jump_insns (rtx, rtx, enum rtx_code, rtx,
         enum machine_mode, int, rtx);


extern void emit_indirect_jump (rtx);



rtx emit_conditional_move (rtx, enum rtx_code, rtx, rtx, enum machine_mode,
      rtx, rtx, enum machine_mode, int);


int can_conditionally_move_p (enum machine_mode mode);


rtx emit_conditional_add (rtx, enum rtx_code, rtx, rtx, enum machine_mode,
     rtx, rtx, enum machine_mode, int);






extern rtx negate_rtx (enum machine_mode, rtx);


extern rtx expand_and (enum machine_mode, rtx, rtx, rtx);


extern rtx emit_store_flag (rtx, enum rtx_code, rtx, rtx, enum machine_mode,
       int, int);


extern rtx emit_store_flag_force (rtx, enum rtx_code, rtx, rtx,
      enum machine_mode, int, int);





extern rtx canonicalize_condition (rtx, rtx, int, rtx *, rtx, int);



extern rtx get_condition (rtx, rtx *, int);


extern rtx gen_cond_trap (enum rtx_code, rtx, rtx, rtx);


extern rtx expand_builtin (tree, rtx, rtx, enum machine_mode, int);
extern tree std_build_builtin_va_list (void);
extern void std_expand_builtin_va_start (tree, rtx);
extern rtx std_expand_builtin_va_arg (tree, tree);
extern rtx expand_builtin_va_arg (tree, tree);
extern rtx default_expand_builtin (tree, rtx, rtx, enum machine_mode, int);
extern void expand_builtin_setjmp_setup (rtx, rtx);
extern void expand_builtin_setjmp_receiver (rtx);
extern void expand_builtin_longjmp (rtx, rtx);
extern rtx expand_builtin_saveregs (void);
extern void expand_builtin_trap (void);
extern long get_varargs_alias_set (void);
extern long get_frame_alias_set (void);
extern void record_base_value (unsigned int, rtx, int);
extern void record_alias_subset (long, long);
extern long new_alias_set (void);
extern int can_address_p (tree);





extern void init_expr_once (void);


extern void init_expr (void);


extern void finish_expr_for_function (void);



extern rtx protect_from_queue (rtx, int);


extern void emit_queue (void);


extern int queued_subexp_p (rtx);



extern void convert_move (rtx, rtx, int);


extern rtx convert_to_mode (enum machine_mode, rtx, int);


extern rtx convert_modes (enum machine_mode, enum machine_mode, rtx, int);



enum block_op_methods
{
  BLOCK_OP_NORMAL,
  BLOCK_OP_NO_LIBCALL,
  BLOCK_OP_CALL_PARM
};

extern void init_block_move_fn (const char *);
extern void init_block_clear_fn (const char *);

extern rtx emit_block_move (rtx, rtx, rtx, enum block_op_methods);



extern void move_block_to_reg (int, rtx, int, enum machine_mode);



extern void move_block_from_reg (int, rtx, int);


extern rtx gen_group_rtx (rtx);



extern void emit_group_load (rtx, rtx, tree, int);



extern void emit_group_move (rtx, rtx);



extern void emit_group_store (rtx, rtx, tree, int);


extern rtx copy_blkmode_from_reg (rtx, rtx, tree);


extern void use_reg (rtx *, rtx);



extern void use_regs (rtx *, int, int);


extern void use_group_regs (rtx *, rtx);



extern rtx clear_storage (rtx, rtx);




extern int can_move_by_pieces (unsigned long, unsigned int);






extern int can_store_by_pieces (unsigned long,
    rtx (*) (void *, long,
      enum machine_mode),
    void *, unsigned int);






extern rtx store_by_pieces (rtx, unsigned long,
       rtx (*) (void *, long, enum machine_mode),
       void *, unsigned int, int);


extern rtx emit_move_insn (rtx, rtx);


extern rtx emit_move_insn_1 (rtx, rtx);



extern rtx push_block (rtx, int, int);


extern void emit_push_insn (rtx, enum machine_mode, tree, rtx, unsigned int,
       int, rtx, int, rtx, rtx, int, rtx);


extern rtx expand_assignment (tree, tree, int);





extern rtx store_expr (tree, rtx, int);




extern rtx force_operand (rtx, rtx);
# 515 "expr.h"
extern tree find_placeholder (tree, tree *);






extern rtx expand_expr_real (tree, rtx, enum machine_mode,
        enum expand_modifier, rtx *);



extern void init_pending_stack_adjust (void);



extern void clear_pending_stack_adjust (void);


extern void do_pending_stack_adjust (void);



extern tree string_constant (tree, tree *);


extern void jumpifnot (tree, rtx);


extern void jumpif (tree, rtx);



extern void do_jump (tree, rtx, rtx);


extern rtx compare_from_rtx (rtx, rtx, enum rtx_code, int, enum machine_mode,
        rtx);
extern void do_compare_rtx_and_jump (rtx, rtx, enum rtx_code, int,
         enum machine_mode, rtx, rtx, rtx);


extern int try_casesi (tree, tree, tree, tree, rtx, rtx);
extern int try_tablejump (tree, tree, tree, tree, rtx, rtx);



extern unsigned int case_values_threshold (void);




extern rtx expr_size (tree);



extern long int_expr_size (tree);

extern rtx lookup_static_chain (tree);



extern rtx fix_lexical_addr (rtx, tree);


extern rtx trampoline_address (tree);



extern rtx hard_function_value (tree, tree, int);

extern rtx prepare_call_address (rtx, tree, rtx *, int, int);

extern rtx expand_call (tree, rtx, int);
# 597 "expr.h"
extern void locate_and_pad_parm (enum machine_mode, tree, int, int, tree,
     struct args_size *,
     struct locate_and_pad_arg_data *);
extern rtx expand_inline_function (tree, tree, rtx, int, tree, rtx);


extern rtx label_rtx (tree);




extern rtx force_label_rtx (tree);


extern rtx promoted_input_arg (unsigned int, enum machine_mode *, int *);




extern rtx eliminate_constant_term (rtx, rtx *);



extern rtx memory_address (enum machine_mode, rtx);


extern rtx memory_address_noforce (enum machine_mode, rtx);


extern void set_mem_alias_set (rtx, long);


extern void set_mem_align (rtx, unsigned int);


extern void set_mem_expr (rtx, tree);


extern void set_mem_offset (rtx, rtx);


extern void set_mem_size (rtx, rtx);





extern rtx change_address (rtx, enum machine_mode, rtx);
# 665 "expr.h"
extern rtx adjust_address_1 (rtx, enum machine_mode, long, int, int);
extern rtx adjust_automodify_address_1 (rtx, enum machine_mode, rtx,
     long, int);




extern rtx offset_address (rtx, rtx, unsigned long);





extern rtx replace_equiv_address (rtx, rtx);


extern rtx replace_equiv_address_nv (rtx, rtx);



extern rtx widen_memory_access (rtx, enum machine_mode, long);



extern rtx validize_mem (rtx);




extern void maybe_set_unchanging (rtx, tree);




extern void set_mem_attributes (rtx, tree, int);




extern void set_mem_attributes_minus_bitpos (rtx, tree, int, long);


extern rtx assemble_trampoline_template (void);



extern rtx stabilize (rtx);



extern rtx copy_all_regs (rtx);


extern rtx copy_to_reg (rtx);


extern rtx copy_addr_to_reg (rtx);


extern rtx copy_to_mode_reg (enum machine_mode, rtx);


extern rtx copy_to_suggested_reg (rtx, rtx, enum machine_mode);



extern rtx force_reg (enum machine_mode, rtx);


extern rtx force_not_mem (rtx);


extern enum machine_mode promote_mode (tree, enum machine_mode, int *, int);


extern void adjust_stack (rtx);


extern void anti_adjust_stack (rtx);


enum save_level {SAVE_BLOCK, SAVE_FUNCTION, SAVE_NONLOCAL};


extern void emit_stack_save (enum save_level, rtx *, rtx);


extern void emit_stack_restore (enum save_level, rtx, rtx);



extern rtx allocate_dynamic_stack_space (rtx, rtx, int);






extern void probe_stack_range (long, rtx);



extern rtx hard_libcall_value (enum machine_mode);



extern rtx round_push (rtx);





enum extraction_pattern { EP_insv, EP_extv, EP_extzv };
extern enum machine_mode
mode_for_extraction (enum extraction_pattern, int);

extern rtx store_bit_field (rtx, unsigned long,
       unsigned long, enum machine_mode, rtx,
       long);
extern rtx extract_bit_field (rtx, unsigned long,
         unsigned long, int, rtx,
         enum machine_mode, enum machine_mode,
         long);
extern rtx expand_mult (enum machine_mode, rtx, rtx, rtx, int);
extern _Bool const_mult_add_overflow_p (rtx, rtx, rtx, enum machine_mode, int);
extern rtx expand_mult_add (rtx, rtx, rtx, rtx,enum machine_mode, int);
extern rtx expand_mult_highpart_adjust (enum machine_mode, rtx, rtx, rtx, rtx, int);

extern rtx assemble_static_space (unsigned long);
extern int safe_from_p (rtx, tree, int);



extern void init_optabs (void);
extern void init_all_optabs (void);


extern rtx init_one_libfunc (const char *);

extern void do_jump_by_parts_equality_rtx (rtx, rtx, rtx);
extern void do_jump_by_parts_greater_rtx (enum machine_mode, int, rtx, rtx,
       rtx, rtx);

extern void mark_seen_cases (tree, unsigned char *, long, int);

extern int vector_mode_valid_p (enum machine_mode);

extern tree placeholder_list;
# 97 "reload.c" 2
# 1 "optabs.h" 1
# 24 "optabs.h"
# 1 "insn-codes.h" 1






enum insn_code {


  CODE_FOR_cmpqi_ext_3_insn = 11,

  CODE_FOR_x86_sahf_1 = 23,
  CODE_FOR_popsi1 = 33,
  CODE_FOR_movsi_insv_1 = 55,


  CODE_FOR_swapxf = 72,
  CODE_FOR_zero_extendhisi2_and = 73,
  CODE_FOR_zero_extendsidi2_32 = 81,






  CODE_FOR_extendhisi2 = 84,
  CODE_FOR_extendqihi2 = 85,
  CODE_FOR_extendqisi2 = 86,
  CODE_FOR_truncdfsf2_sse_only = 97,
  CODE_FOR_fix_truncdi_nomemory = 104,
  CODE_FOR_fix_truncdi_memory = 105,


  CODE_FOR_fix_truncsi_nomemory = 107,
  CODE_FOR_fix_truncsi_memory = 108,
  CODE_FOR_fix_truncsfsi_sse = 109,
  CODE_FOR_fix_truncdfsi_sse = 110,
  CODE_FOR_fix_trunchi_nomemory = 112,
  CODE_FOR_fix_trunchi_memory = 113,
  CODE_FOR_x86_fnstcw_1 = 114,
  CODE_FOR_x86_fldcw_1 = 115,
  CODE_FOR_floathixf2 = 125,
  CODE_FOR_floatsixf2 = 126,
  CODE_FOR_floatdixf2 = 127,

  CODE_FOR_addqi3_carry = 129,
  CODE_FOR_addhi3_carry = 130,
  CODE_FOR_addsi3_carry = 131,
  CODE_FOR_addqi3_cc = 133,

  CODE_FOR_addqi_ext_1 = 156,

  CODE_FOR_subqi3_carry = 159,
  CODE_FOR_subhi3_carry = 160,
  CODE_FOR_subsi3_carry = 161,

  CODE_FOR_divqi3 = 181,
  CODE_FOR_udivqi3 = 182,
  CODE_FOR_divmodhi4 = 186,

  CODE_FOR_udivmodsi4 = 187,
  CODE_FOR_testsi_1 = 190,
  CODE_FOR_andqi_ext_0 = 205,
  CODE_FOR_iorqi_ext_0 = 220,
  CODE_FOR_xorqi_ext_0 = 231,
  CODE_FOR_negsf2_memory = 245,
  CODE_FOR_negsf2_ifs = 246,
  CODE_FOR_negdf2_memory = 248,
  CODE_FOR_negdf2_ifs = 249,
  CODE_FOR_abssf2_memory = 258,
  CODE_FOR_abssf2_ifs = 259,
  CODE_FOR_absdf2_memory = 261,
  CODE_FOR_absdf2_ifs = 262,
  CODE_FOR_ashldi3_1 = 277,
  CODE_FOR_x86_shld_1 = 279,

  CODE_FOR_ashrdi3_1 = 288,
  CODE_FOR_x86_shrd_1 = 290,
  CODE_FOR_ashrsi3_31 = 291,
  CODE_FOR_lshrdi3_1 = 306,
  CODE_FOR_setcc_2 = 339,
  CODE_FOR_jump = 354,
  CODE_FOR_doloop_end_internal = 357,
  CODE_FOR_blockage = 363,
  CODE_FOR_return_internal = 364,
  CODE_FOR_return_internal_long = 365,
  CODE_FOR_return_pop_internal = 366,
  CODE_FOR_return_indirect_internal = 367,
  CODE_FOR_nop = 368,
  CODE_FOR_align = 369,
  CODE_FOR_set_got = 370,
  CODE_FOR_eh_return_si = 371,

  CODE_FOR_leave = 372,

  CODE_FOR_ctzsi2 = 376,
  CODE_FOR_sqrtsf2_1 = 411,
  CODE_FOR_sqrtsf2_1_sse_only = 412,
  CODE_FOR_sqrtsf2_i387 = 413,
  CODE_FOR_sqrtdf2_1 = 414,
  CODE_FOR_sqrtdf2_1_sse_only = 415,
  CODE_FOR_sqrtdf2_i387 = 416,
  CODE_FOR_sqrtxf2 = 418,
  CODE_FOR_sindf2 = 421,
  CODE_FOR_sinsf2 = 422,
  CODE_FOR_sinxf2 = 424,
  CODE_FOR_cosdf2 = 425,
  CODE_FOR_cossf2 = 426,
  CODE_FOR_cosxf2 = 428,
  CODE_FOR_atan2df3_1 = 429,
  CODE_FOR_atan2sf3_1 = 430,
  CODE_FOR_atan2xf3_1 = 431,
  CODE_FOR_cld = 440,


  CODE_FOR_x86_movsicc_0_m1 = 454,
  CODE_FOR_pro_epilogue_adjust_stack_1 = 473,


  CODE_FOR_sse_movsfcc = 474,
  CODE_FOR_sse_movsfcc_eq = 475,
  CODE_FOR_sse_movdfcc = 476,
  CODE_FOR_sse_movdfcc_eq = 477,
  CODE_FOR_allocate_stack_worker_1 = 486,

  CODE_FOR_trap = 492,
  CODE_FOR_movv4sf_internal = 494,
  CODE_FOR_movv4si_internal = 495,
  CODE_FOR_movv2di_internal = 496,
  CODE_FOR_movv8qi_internal = 497,
  CODE_FOR_movv4hi_internal = 498,
  CODE_FOR_movv2si_internal = 499,
  CODE_FOR_movv2sf_internal = 500,
  CODE_FOR_movv2df_internal = 501,
  CODE_FOR_movv8hi_internal = 502,
  CODE_FOR_movv16qi_internal = 503,
  CODE_FOR_movti_internal = 515,
  CODE_FOR_sse_movmskps = 518,
  CODE_FOR_mmx_pmovmskb = 519,
  CODE_FOR_mmx_maskmovq = 520,

  CODE_FOR_sse_movntv4sf = 521,
  CODE_FOR_sse_movntdi = 522,
  CODE_FOR_sse_movhlps = 523,
  CODE_FOR_sse_movlhps = 524,
  CODE_FOR_sse_movhps = 525,
  CODE_FOR_sse_movlps = 526,
  CODE_FOR_sse_loadss_1 = 527,
  CODE_FOR_sse_movss = 528,
  CODE_FOR_sse_storess = 529,
  CODE_FOR_sse_shufps = 530,
  CODE_FOR_addv4sf3 = 531,
  CODE_FOR_vmaddv4sf3 = 532,
  CODE_FOR_subv4sf3 = 533,
  CODE_FOR_vmsubv4sf3 = 534,
  CODE_FOR_mulv4sf3 = 535,
  CODE_FOR_vmmulv4sf3 = 536,
  CODE_FOR_divv4sf3 = 537,
  CODE_FOR_vmdivv4sf3 = 538,
  CODE_FOR_rcpv4sf2 = 539,
  CODE_FOR_vmrcpv4sf2 = 540,
  CODE_FOR_rsqrtv4sf2 = 541,
  CODE_FOR_vmrsqrtv4sf2 = 542,
  CODE_FOR_sqrtv4sf2 = 543,
  CODE_FOR_vmsqrtv4sf2 = 544,
  CODE_FOR_sse2_andv2di3 = 562,
  CODE_FOR_sse2_nandv2di3 = 564,
  CODE_FOR_sse2_iorv2di3 = 566,
  CODE_FOR_sse2_xorv2di3 = 568,
  CODE_FOR_sse_clrv4sf = 569,
  CODE_FOR_sse_clrv2df = 570,
  CODE_FOR_maskcmpv4sf3 = 571,
  CODE_FOR_maskncmpv4sf3 = 572,
  CODE_FOR_vmmaskcmpv4sf3 = 573,
  CODE_FOR_vmmaskncmpv4sf3 = 574,
  CODE_FOR_sse_comi = 575,
  CODE_FOR_sse_ucomi = 576,
  CODE_FOR_sse_unpckhps = 577,
  CODE_FOR_sse_unpcklps = 578,
  CODE_FOR_smaxv4sf3 = 579,
  CODE_FOR_vmsmaxv4sf3 = 580,
  CODE_FOR_sminv4sf3 = 581,
  CODE_FOR_vmsminv4sf3 = 582,
  CODE_FOR_cvtpi2ps = 583,
  CODE_FOR_cvtps2pi = 584,
  CODE_FOR_cvttps2pi = 585,
  CODE_FOR_cvtsi2ss = 586,

  CODE_FOR_cvtss2si = 587,
  CODE_FOR_cvtss2siq = 588,
  CODE_FOR_cvttss2si = 589,

  CODE_FOR_addv8qi3 = 590,
  CODE_FOR_addv4hi3 = 591,
  CODE_FOR_addv2si3 = 592,
  CODE_FOR_mmx_adddi3 = 593,
  CODE_FOR_ssaddv8qi3 = 594,
  CODE_FOR_ssaddv4hi3 = 595,
  CODE_FOR_usaddv8qi3 = 596,
  CODE_FOR_usaddv4hi3 = 597,
  CODE_FOR_subv8qi3 = 598,
  CODE_FOR_subv4hi3 = 599,
  CODE_FOR_subv2si3 = 600,
  CODE_FOR_mmx_subdi3 = 601,
  CODE_FOR_sssubv8qi3 = 602,
  CODE_FOR_sssubv4hi3 = 603,
  CODE_FOR_ussubv8qi3 = 604,
  CODE_FOR_ussubv4hi3 = 605,
  CODE_FOR_mulv4hi3 = 606,
  CODE_FOR_smulv4hi3_highpart = 607,
  CODE_FOR_umulv4hi3_highpart = 608,
  CODE_FOR_mmx_pmaddwd = 609,
  CODE_FOR_mmx_iordi3 = 610,
  CODE_FOR_mmx_xordi3 = 611,
  CODE_FOR_mmx_clrdi = 612,
  CODE_FOR_mmx_anddi3 = 613,
  CODE_FOR_mmx_nanddi3 = 614,
  CODE_FOR_mmx_uavgv8qi3 = 615,
  CODE_FOR_mmx_uavgv4hi3 = 616,
  CODE_FOR_mmx_psadbw = 617,
  CODE_FOR_mmx_pinsrw = 618,
  CODE_FOR_mmx_pextrw = 619,
  CODE_FOR_mmx_pshufw = 620,
  CODE_FOR_eqv8qi3 = 621,
  CODE_FOR_eqv4hi3 = 622,
  CODE_FOR_eqv2si3 = 623,
  CODE_FOR_gtv8qi3 = 624,
  CODE_FOR_gtv4hi3 = 625,
  CODE_FOR_gtv2si3 = 626,
  CODE_FOR_umaxv8qi3 = 627,
  CODE_FOR_smaxv4hi3 = 628,
  CODE_FOR_uminv8qi3 = 629,
  CODE_FOR_sminv4hi3 = 630,
  CODE_FOR_ashrv4hi3 = 631,
  CODE_FOR_ashrv2si3 = 632,
  CODE_FOR_lshrv4hi3 = 633,
  CODE_FOR_lshrv2si3 = 634,
  CODE_FOR_mmx_lshrdi3 = 635,
  CODE_FOR_ashlv4hi3 = 636,
  CODE_FOR_ashlv2si3 = 637,
  CODE_FOR_mmx_ashldi3 = 638,
  CODE_FOR_mmx_packsswb = 639,
  CODE_FOR_mmx_packssdw = 640,
  CODE_FOR_mmx_packuswb = 641,
  CODE_FOR_mmx_punpckhbw = 642,
  CODE_FOR_mmx_punpckhwd = 643,
  CODE_FOR_mmx_punpckhdq = 644,
  CODE_FOR_mmx_punpcklbw = 645,
  CODE_FOR_mmx_punpcklwd = 646,
  CODE_FOR_mmx_punpckldq = 647,
  CODE_FOR_emms = 648,
  CODE_FOR_ldmxcsr = 649,
  CODE_FOR_stmxcsr = 650,
  CODE_FOR_addv2sf3 = 652,
  CODE_FOR_subv2sf3 = 653,
  CODE_FOR_subrv2sf3 = 654,
  CODE_FOR_gtv2sf3 = 655,
  CODE_FOR_gev2sf3 = 656,
  CODE_FOR_eqv2sf3 = 657,
  CODE_FOR_pfmaxv2sf3 = 658,
  CODE_FOR_pfminv2sf3 = 659,
  CODE_FOR_mulv2sf3 = 660,
  CODE_FOR_femms = 661,
  CODE_FOR_pf2id = 662,
  CODE_FOR_pf2iw = 663,
  CODE_FOR_pfacc = 664,
  CODE_FOR_pfnacc = 665,
  CODE_FOR_pfpnacc = 666,
  CODE_FOR_pi2fw = 667,
  CODE_FOR_floatv2si2 = 668,
  CODE_FOR_pavgusb = 669,
  CODE_FOR_pfrcpv2sf2 = 670,
  CODE_FOR_pfrcpit1v2sf3 = 671,
  CODE_FOR_pfrcpit2v2sf3 = 672,
  CODE_FOR_pfrsqrtv2sf2 = 673,
  CODE_FOR_pfrsqit1v2sf3 = 674,
  CODE_FOR_pmulhrwv4hi3 = 675,
  CODE_FOR_pswapdv2si2 = 676,
  CODE_FOR_pswapdv2sf2 = 677,
  CODE_FOR_addv2df3 = 680,
  CODE_FOR_vmaddv2df3 = 681,
  CODE_FOR_subv2df3 = 682,
  CODE_FOR_vmsubv2df3 = 683,
  CODE_FOR_mulv2df3 = 684,
  CODE_FOR_vmmulv2df3 = 685,
  CODE_FOR_divv2df3 = 686,
  CODE_FOR_vmdivv2df3 = 687,
  CODE_FOR_smaxv2df3 = 688,
  CODE_FOR_vmsmaxv2df3 = 689,
  CODE_FOR_sminv2df3 = 690,
  CODE_FOR_vmsminv2df3 = 691,
  CODE_FOR_sqrtv2df2 = 692,
  CODE_FOR_vmsqrtv2df2 = 693,
  CODE_FOR_maskcmpv2df3 = 694,
  CODE_FOR_maskncmpv2df3 = 695,
  CODE_FOR_vmmaskcmpv2df3 = 696,
  CODE_FOR_vmmaskncmpv2df3 = 697,
  CODE_FOR_sse2_comi = 698,
  CODE_FOR_sse2_ucomi = 699,
  CODE_FOR_sse2_movmskpd = 700,
  CODE_FOR_sse2_pmovmskb = 701,
  CODE_FOR_sse2_maskmovdqu = 702,
  CODE_FOR_sse2_maskmovdqu_rex64 = 703,
  CODE_FOR_sse2_movntv2df = 704,
  CODE_FOR_sse2_movntv2di = 705,
  CODE_FOR_sse2_movntsi = 706,
  CODE_FOR_cvtdq2ps = 707,
  CODE_FOR_cvtps2dq = 708,
  CODE_FOR_cvttps2dq = 709,
  CODE_FOR_cvtdq2pd = 710,
  CODE_FOR_cvtpd2dq = 711,
  CODE_FOR_cvttpd2dq = 712,
  CODE_FOR_cvtpd2pi = 713,
  CODE_FOR_cvttpd2pi = 714,
  CODE_FOR_cvtpi2pd = 715,
  CODE_FOR_cvtsd2si = 716,

  CODE_FOR_cvttsd2si = 717,

  CODE_FOR_cvtsi2sd = 718,

  CODE_FOR_cvtsd2ss = 719,
  CODE_FOR_cvtss2sd = 720,
  CODE_FOR_cvtpd2ps = 721,
  CODE_FOR_cvtps2pd = 722,
  CODE_FOR_addv16qi3 = 723,
  CODE_FOR_addv8hi3 = 724,
  CODE_FOR_addv4si3 = 725,
  CODE_FOR_addv2di3 = 726,
  CODE_FOR_ssaddv16qi3 = 727,
  CODE_FOR_ssaddv8hi3 = 728,
  CODE_FOR_usaddv16qi3 = 729,
  CODE_FOR_usaddv8hi3 = 730,
  CODE_FOR_subv16qi3 = 731,
  CODE_FOR_subv8hi3 = 732,
  CODE_FOR_subv4si3 = 733,
  CODE_FOR_subv2di3 = 734,
  CODE_FOR_sssubv16qi3 = 735,
  CODE_FOR_sssubv8hi3 = 736,
  CODE_FOR_ussubv16qi3 = 737,
  CODE_FOR_ussubv8hi3 = 738,
  CODE_FOR_mulv8hi3 = 739,
  CODE_FOR_smulv8hi3_highpart = 740,
  CODE_FOR_umulv8hi3_highpart = 741,
  CODE_FOR_sse2_umulsidi3 = 742,
  CODE_FOR_sse2_umulv2siv2di3 = 743,
  CODE_FOR_sse2_pmaddwd = 744,
  CODE_FOR_sse2_clrti = 745,
  CODE_FOR_sse2_uavgv16qi3 = 746,
  CODE_FOR_sse2_uavgv8hi3 = 747,
  CODE_FOR_sse2_psadbw = 748,
  CODE_FOR_sse2_pinsrw = 749,
  CODE_FOR_sse2_pextrw = 750,
  CODE_FOR_sse2_pshufd = 751,
  CODE_FOR_sse2_pshuflw = 752,
  CODE_FOR_sse2_pshufhw = 753,
  CODE_FOR_eqv16qi3 = 754,
  CODE_FOR_eqv8hi3 = 755,
  CODE_FOR_eqv4si3 = 756,
  CODE_FOR_gtv16qi3 = 757,
  CODE_FOR_gtv8hi3 = 758,
  CODE_FOR_gtv4si3 = 759,
  CODE_FOR_umaxv16qi3 = 760,
  CODE_FOR_smaxv8hi3 = 761,
  CODE_FOR_uminv16qi3 = 762,
  CODE_FOR_sminv8hi3 = 763,
  CODE_FOR_ashrv8hi3 = 764,
  CODE_FOR_ashrv4si3 = 765,
  CODE_FOR_lshrv8hi3 = 766,
  CODE_FOR_lshrv4si3 = 767,
  CODE_FOR_lshrv2di3 = 768,
  CODE_FOR_ashlv8hi3 = 769,
  CODE_FOR_ashlv4si3 = 770,
  CODE_FOR_ashlv2di3 = 771,
  CODE_FOR_ashrv8hi3_ti = 772,
  CODE_FOR_ashrv4si3_ti = 773,
  CODE_FOR_lshrv8hi3_ti = 774,
  CODE_FOR_lshrv4si3_ti = 775,
  CODE_FOR_lshrv2di3_ti = 776,
  CODE_FOR_ashlv8hi3_ti = 777,
  CODE_FOR_ashlv4si3_ti = 778,
  CODE_FOR_ashlv2di3_ti = 779,
  CODE_FOR_sse2_ashlti3 = 780,
  CODE_FOR_sse2_lshrti3 = 781,
  CODE_FOR_sse2_unpckhpd = 782,
  CODE_FOR_sse2_unpcklpd = 783,
  CODE_FOR_sse2_packsswb = 784,
  CODE_FOR_sse2_packssdw = 785,
  CODE_FOR_sse2_packuswb = 786,
  CODE_FOR_sse2_punpckhbw = 787,
  CODE_FOR_sse2_punpckhwd = 788,
  CODE_FOR_sse2_punpckhdq = 789,
  CODE_FOR_sse2_punpcklbw = 790,
  CODE_FOR_sse2_punpcklwd = 791,
  CODE_FOR_sse2_punpckldq = 792,
  CODE_FOR_sse2_punpcklqdq = 793,
  CODE_FOR_sse2_punpckhqdq = 794,
  CODE_FOR_sse2_movapd = 795,
  CODE_FOR_sse2_movupd = 796,
  CODE_FOR_sse2_movdqa = 797,
  CODE_FOR_sse2_movdqu = 798,
  CODE_FOR_sse2_movdq2q = 799,

  CODE_FOR_sse2_movq2dq = 800,

  CODE_FOR_sse2_movq = 801,
  CODE_FOR_sse2_loadd = 802,
  CODE_FOR_sse2_stored = 803,
  CODE_FOR_sse2_movhpd = 804,
  CODE_FOR_sse2_loadsd_1 = 805,
  CODE_FOR_sse2_movsd = 806,
  CODE_FOR_sse2_storesd = 807,
  CODE_FOR_sse2_shufpd = 808,
  CODE_FOR_sse2_clflush = 809,
  CODE_FOR_mwait = 812,
  CODE_FOR_monitor = 813,
  CODE_FOR_addsubv4sf3 = 814,
  CODE_FOR_addsubv2df3 = 815,
  CODE_FOR_haddv4sf3 = 816,
  CODE_FOR_haddv2df3 = 817,
  CODE_FOR_hsubv4sf3 = 818,
  CODE_FOR_hsubv2df3 = 819,
  CODE_FOR_movshdup = 820,
  CODE_FOR_movsldup = 821,
  CODE_FOR_lddqu = 822,
  CODE_FOR_loadddup = 823,
  CODE_FOR_movddup = 824,
  CODE_FOR_cmpdi = 825,
  CODE_FOR_cmpsi = 826,
  CODE_FOR_cmphi = 827,
  CODE_FOR_cmpqi = 828,

  CODE_FOR_cmpsi_1 = 829,
  CODE_FOR_cmpqi_ext_3 = 830,
  CODE_FOR_cmpxf = 831,
  CODE_FOR_cmpdf = 832,
  CODE_FOR_cmpsf = 833,
  CODE_FOR_movsi = 834,
  CODE_FOR_movhi = 835,
  CODE_FOR_movstricthi = 836,
  CODE_FOR_movqi = 837,
  CODE_FOR_reload_outqi = 838,
  CODE_FOR_movstrictqi = 839,
  CODE_FOR_movdi = 840,
  CODE_FOR_movsf = 843,
  CODE_FOR_movdf = 846,
  CODE_FOR_movxf = 850,
  CODE_FOR_zero_extendhisi2 = 855,
  CODE_FOR_zero_extendqihi2 = 857,
  CODE_FOR_zero_extendqisi2 = 861,
  CODE_FOR_zero_extendsidi2 = 865,
  CODE_FOR_extendsidi2 = 868,
  CODE_FOR_extendsfdf2 = 875,
  CODE_FOR_extendsfxf2 = 876,
  CODE_FOR_extenddfxf2 = 877,
  CODE_FOR_truncdfsf2 = 878,
  CODE_FOR_truncxfsf2 = 883,
  CODE_FOR_truncxfdf2 = 886,
  CODE_FOR_fix_truncxfdi2 = 889,
  CODE_FOR_fix_truncdfdi2 = 890,
  CODE_FOR_fix_truncsfdi2 = 891,
  CODE_FOR_fix_truncxfsi2 = 897,
  CODE_FOR_fix_truncdfsi2 = 898,
  CODE_FOR_fix_truncsfsi2 = 899,
  CODE_FOR_fix_truncxfhi2 = 905,
  CODE_FOR_fix_truncdfhi2 = 906,
  CODE_FOR_fix_truncsfhi2 = 907,
  CODE_FOR_floathisf2 = 911,
  CODE_FOR_floatsisf2 = 912,
  CODE_FOR_floatdisf2 = 914,
  CODE_FOR_floathidf2 = 916,
  CODE_FOR_floatsidf2 = 917,
  CODE_FOR_floatdidf2 = 918,
  CODE_FOR_floatunssisf2 = 920,


  CODE_FOR_vec_setv2df = 921,
  CODE_FOR_vec_extractv2df = 922,
  CODE_FOR_vec_initv2df = 923,
  CODE_FOR_vec_setv4sf = 924,
  CODE_FOR_vec_extractv4sf = 925,
  CODE_FOR_vec_initv4sf = 926,
  CODE_FOR_adddi3 = 927,
  CODE_FOR_addsi3 = 929,
  CODE_FOR_addhi3 = 934,
  CODE_FOR_addqi3 = 935,
  CODE_FOR_addxf3 = 936,
  CODE_FOR_adddf3 = 937,
  CODE_FOR_addsf3 = 938,
  CODE_FOR_subdi3 = 939,
  CODE_FOR_subsi3 = 941,
  CODE_FOR_subhi3 = 942,
  CODE_FOR_subqi3 = 943,
  CODE_FOR_subxf3 = 944,
  CODE_FOR_subdf3 = 945,
  CODE_FOR_subsf3 = 946,

  CODE_FOR_mulsi3 = 947,
  CODE_FOR_mulhi3 = 948,
  CODE_FOR_mulqi3 = 949,
  CODE_FOR_umulqihi3 = 950,
  CODE_FOR_mulqihi3 = 951,

  CODE_FOR_umulsidi3 = 952,

  CODE_FOR_mulsidi3 = 953,

  CODE_FOR_umulsi3_highpart = 954,

  CODE_FOR_smulsi3_highpart = 955,
  CODE_FOR_mulxf3 = 956,
  CODE_FOR_muldf3 = 957,
  CODE_FOR_mulsf3 = 958,
  CODE_FOR_divxf3 = 959,
  CODE_FOR_divdf3 = 960,
  CODE_FOR_divsf3 = 961,

  CODE_FOR_divmodsi4 = 962,
  CODE_FOR_udivmodhi4 = 965,
  CODE_FOR_testsi_ccno_1 = 966,
  CODE_FOR_testqi_ccz_1 = 967,
  CODE_FOR_testqi_ext_ccno_0 = 968,

  CODE_FOR_andsi3 = 972,
  CODE_FOR_andhi3 = 976,
  CODE_FOR_andqi3 = 977,

  CODE_FOR_iorsi3 = 980,
  CODE_FOR_iorhi3 = 981,
  CODE_FOR_iorqi3 = 982,

  CODE_FOR_xorsi3 = 985,
  CODE_FOR_xorhi3 = 986,
  CODE_FOR_xorqi3 = 987,
  CODE_FOR_xorqi_cc_ext_1 = 988,
  CODE_FOR_negdi2 = 991,
  CODE_FOR_negsi2 = 993,
  CODE_FOR_neghi2 = 994,
  CODE_FOR_negqi2 = 995,
  CODE_FOR_negsf2 = 996,
  CODE_FOR_negdf2 = 1003,
  CODE_FOR_negxf2 = 1009,
  CODE_FOR_abssf2 = 1012,
  CODE_FOR_absdf2 = 1019,
  CODE_FOR_absxf2 = 1025,

  CODE_FOR_one_cmplsi2 = 1028,
  CODE_FOR_one_cmplhi2 = 1031,
  CODE_FOR_one_cmplqi2 = 1033,
  CODE_FOR_ashldi3 = 1035,
  CODE_FOR_x86_shift_adj_1 = 1038,
  CODE_FOR_x86_shift_adj_2 = 1039,
  CODE_FOR_ashlsi3 = 1040,
  CODE_FOR_ashlhi3 = 1043,
  CODE_FOR_ashlqi3 = 1044,
  CODE_FOR_ashrdi3 = 1045,
  CODE_FOR_x86_shift_adj_3 = 1048,
  CODE_FOR_ashrsi3 = 1049,
  CODE_FOR_ashrhi3 = 1050,
  CODE_FOR_ashrqi3 = 1051,
  CODE_FOR_lshrdi3 = 1052,
  CODE_FOR_lshrsi3 = 1055,
  CODE_FOR_lshrhi3 = 1056,
  CODE_FOR_lshrqi3 = 1057,

  CODE_FOR_rotlsi3 = 1058,
  CODE_FOR_rotlhi3 = 1059,
  CODE_FOR_rotlqi3 = 1060,

  CODE_FOR_rotrsi3 = 1061,
  CODE_FOR_rotrhi3 = 1062,
  CODE_FOR_rotrqi3 = 1063,
  CODE_FOR_extv = 1064,
  CODE_FOR_extzv = 1065,
  CODE_FOR_insv = 1066,
  CODE_FOR_seq = 1067,
  CODE_FOR_sne = 1068,
  CODE_FOR_sgt = 1069,
  CODE_FOR_sgtu = 1070,
  CODE_FOR_slt = 1071,
  CODE_FOR_sltu = 1072,
  CODE_FOR_sge = 1073,
  CODE_FOR_sgeu = 1074,
  CODE_FOR_sle = 1075,
  CODE_FOR_sleu = 1076,
  CODE_FOR_sunordered = 1077,
  CODE_FOR_sordered = 1078,
  CODE_FOR_suneq = 1079,
  CODE_FOR_sunge = 1080,
  CODE_FOR_sungt = 1081,
  CODE_FOR_sunle = 1082,
  CODE_FOR_sunlt = 1083,
  CODE_FOR_sltgt = 1084,
  CODE_FOR_beq = 1089,
  CODE_FOR_bne = 1090,
  CODE_FOR_bgt = 1091,
  CODE_FOR_bgtu = 1092,
  CODE_FOR_blt = 1093,
  CODE_FOR_bltu = 1094,
  CODE_FOR_bge = 1095,
  CODE_FOR_bgeu = 1096,
  CODE_FOR_ble = 1097,
  CODE_FOR_bleu = 1098,
  CODE_FOR_bunordered = 1099,
  CODE_FOR_bordered = 1100,
  CODE_FOR_buneq = 1101,
  CODE_FOR_bunge = 1102,
  CODE_FOR_bungt = 1103,
  CODE_FOR_bunle = 1104,
  CODE_FOR_bunlt = 1105,
  CODE_FOR_bltgt = 1106,
  CODE_FOR_indirect_jump = 1111,
  CODE_FOR_tablejump = 1112,
  CODE_FOR_doloop_end = 1113,
  CODE_FOR_call_pop = 1118,
  CODE_FOR_call = 1119,
  CODE_FOR_sibcall = 1120,
  CODE_FOR_call_value_pop = 1121,
  CODE_FOR_call_value = 1122,
  CODE_FOR_sibcall_value = 1123,
  CODE_FOR_untyped_call = 1124,
  CODE_FOR_return = 1125,
  CODE_FOR_prologue = 1126,
  CODE_FOR_epilogue = 1127,
  CODE_FOR_sibcall_epilogue = 1128,
  CODE_FOR_eh_return = 1129,
  CODE_FOR_ffssi2 = 1132,
  CODE_FOR_clzsi2 = 1135,
  CODE_FOR_tls_global_dynamic_32 = 1136,
  CODE_FOR_tls_global_dynamic_64 = 1137,
  CODE_FOR_tls_local_dynamic_base_32 = 1138,
  CODE_FOR_tls_local_dynamic_base_64 = 1139,
  CODE_FOR_sqrtsf2 = 1143,
  CODE_FOR_sqrtdf2 = 1144,
  CODE_FOR_atan2df3 = 1145,
  CODE_FOR_atan2sf3 = 1146,
  CODE_FOR_atan2xf3 = 1147,
  CODE_FOR_logsf2 = 1148,
  CODE_FOR_logdf2 = 1149,
  CODE_FOR_logxf2 = 1150,
  CODE_FOR_expsf2 = 1151,
  CODE_FOR_expdf2 = 1152,
  CODE_FOR_expxf2 = 1153,
  CODE_FOR_atansf2 = 1154,
  CODE_FOR_atandf2 = 1155,
  CODE_FOR_atanxf2 = 1156,
  CODE_FOR_movstrsi = 1157,

  CODE_FOR_strmov = 1158,
  CODE_FOR_strmov_singleop = 1159,
  CODE_FOR_rep_mov = 1160,
  CODE_FOR_clrstrsi = 1161,

  CODE_FOR_strset = 1162,
  CODE_FOR_strset_singleop = 1163,
  CODE_FOR_rep_stos = 1164,
  CODE_FOR_cmpstrsi = 1165,
  CODE_FOR_cmpintqi = 1166,
  CODE_FOR_cmpstrqi_nz_1 = 1167,
  CODE_FOR_cmpstrqi_1 = 1168,
  CODE_FOR_strlensi = 1169,
  CODE_FOR_strlendi = 1170,
  CODE_FOR_strlenqi_1 = 1171,

  CODE_FOR_movsicc = 1174,
  CODE_FOR_movhicc = 1175,
  CODE_FOR_movqicc = 1176,
  CODE_FOR_movsfcc = 1178,
  CODE_FOR_movdfcc = 1179,
  CODE_FOR_movxfcc = 1181,
  CODE_FOR_minsf3 = 1182,
  CODE_FOR_addqicc = 1184,
  CODE_FOR_addhicc = 1185,
  CODE_FOR_addsicc = 1186,

  CODE_FOR_mindf3 = 1188,
  CODE_FOR_maxsf3 = 1191,
  CODE_FOR_maxdf3 = 1194,
  CODE_FOR_allocate_stack_worker = 1200,
  CODE_FOR_allocate_stack_worker_postreload = 1201,
  CODE_FOR_allocate_stack_worker_rex64_postreload = 1202,
  CODE_FOR_allocate_stack = 1203,
  CODE_FOR_builtin_setjmp_receiver = 1204,
  CODE_FOR_conditional_trap = 1273,
  CODE_FOR_movti = 1276,

  CODE_FOR_movv2df = 1277,
  CODE_FOR_movv8hi = 1278,
  CODE_FOR_movv16qi = 1279,
  CODE_FOR_movv4sf = 1280,
  CODE_FOR_movv4si = 1281,
  CODE_FOR_movv2di = 1282,
  CODE_FOR_movv2si = 1283,
  CODE_FOR_movv4hi = 1284,
  CODE_FOR_movv8qi = 1285,
  CODE_FOR_movv2sf = 1286,
  CODE_FOR_sse_movaps = 1290,
  CODE_FOR_sse_movups = 1291,
  CODE_FOR_sse_loadss = 1292,
  CODE_FOR_sse_andv4sf3 = 1293,
  CODE_FOR_sse_nandv4sf3 = 1294,
  CODE_FOR_sse_iorv4sf3 = 1295,
  CODE_FOR_sse_xorv4sf3 = 1296,
  CODE_FOR_sse2_andv2df3 = 1297,
  CODE_FOR_sse2_nandv2df3 = 1298,
  CODE_FOR_sse2_iorv2df3 = 1299,
  CODE_FOR_sse2_xorv2df3 = 1300,
  CODE_FOR_sfence = 1301,

  CODE_FOR_prefetch = 1302,
  CODE_FOR_sse2_loadsd = 1303,
  CODE_FOR_sse2_mfence = 1304,
  CODE_FOR_sse2_lfence = 1305,
  CODE_FOR_nothing
};
# 25 "optabs.h" 2
# 41 "optabs.h"
struct optab_handlers
{
  enum insn_code insn_code;
  rtx libfunc;
};

struct optab
{
  enum rtx_code code;
  struct optab_handlers handlers[NUM_MACHINE_MODES];
};
typedef struct optab * optab;




struct convert_optab
{
  enum rtx_code code;
  struct optab_handlers handlers[NUM_MACHINE_MODES][NUM_MACHINE_MODES];
};
typedef struct convert_optab *convert_optab;






enum optab_index
{
  OTI_add,
  OTI_addv,
  OTI_sub,
  OTI_subv,


  OTI_smul,
  OTI_smulv,

  OTI_smul_highpart,
  OTI_umul_highpart,

  OTI_smul_widen,
  OTI_umul_widen,


  OTI_sdiv,
  OTI_sdivv,

  OTI_sdivmod,
  OTI_udiv,
  OTI_udivmod,

  OTI_smod,
  OTI_umod,

  OTI_ftrunc,


  OTI_and,

  OTI_ior,

  OTI_xor,


  OTI_ashl,

  OTI_lshr,

  OTI_ashr,

  OTI_rotl,

  OTI_rotr,

  OTI_smin,

  OTI_smax,

  OTI_umin,

  OTI_umax,

  OTI_pow,

  OTI_atan2,


  OTI_mov,

  OTI_movstrict,



  OTI_neg,
  OTI_negv,

  OTI_abs,
  OTI_absv,

  OTI_one_cmpl,

  OTI_ffs,
  OTI_clz,
  OTI_ctz,
  OTI_popcount,
  OTI_parity,

  OTI_sqrt,

  OTI_sin,

  OTI_cos,

  OTI_exp,

  OTI_log,

  OTI_floor,
  OTI_ceil,
  OTI_trunc,
  OTI_round,
  OTI_nearbyint,

  OTI_tan,

  OTI_atan,


  OTI_cmp,

  OTI_ucmp,

  OTI_tst,


  OTI_eq,
  OTI_ne,
  OTI_gt,
  OTI_ge,
  OTI_lt,
  OTI_le,
  OTI_unord,


  OTI_strlen,


  OTI_cbranch,
  OTI_cmov,
  OTI_cstore,


  OTI_push,


  OTI_addcc,


  OTI_vec_set,

  OTI_vec_extract,

  OTI_vec_init,

  OTI_MAX
};

extern optab optab_table[OTI_MAX];
# 296 "optabs.h"
enum convert_optab_index
{
  CTI_sext,
  CTI_zext,
  CTI_trunc,

  CTI_sfix,
  CTI_ufix,

  CTI_sfixtrunc,
  CTI_ufixtrunc,

  CTI_sfloat,
  CTI_ufloat,

  CTI_MAX
};

extern convert_optab convert_optab_table[CTI_MAX];
# 329 "optabs.h"
extern enum insn_code reload_in_optab[NUM_MACHINE_MODES];
extern enum insn_code reload_out_optab[NUM_MACHINE_MODES];


extern optab code_to_optab[((int) LAST_AND_UNUSED_RTX_CODE) + 1];


typedef rtx (*rtxfun) (rtx);




extern rtxfun bcc_gen_fctn[((int) LAST_AND_UNUSED_RTX_CODE)];





extern enum insn_code setcc_gen_code[((int) LAST_AND_UNUSED_RTX_CODE)];





extern enum insn_code movcc_gen_code[NUM_MACHINE_MODES];



extern enum insn_code movstr_optab[NUM_MACHINE_MODES];


extern enum insn_code clrstr_optab[NUM_MACHINE_MODES];



extern enum insn_code cmpstr_optab[NUM_MACHINE_MODES];
extern enum insn_code cmpmem_optab[NUM_MACHINE_MODES];




extern rtx expand_binop (enum machine_mode, optab, rtx, rtx, rtx, int,
    enum optab_methods);


extern rtx sign_expand_binop (enum machine_mode, optab, optab, rtx, rtx,
         rtx, int, enum optab_methods);


extern int expand_twoval_binop (optab, rtx, rtx, rtx, rtx, int);


extern rtx expand_unop (enum machine_mode, optab, rtx, rtx, int);


extern rtx expand_abs_nojump (enum machine_mode, rtx, rtx, int);
extern rtx expand_abs (enum machine_mode, rtx, rtx, int, int);


extern rtx expand_complex_abs (enum machine_mode, rtx, rtx, int);



extern void emit_unop_insn (int, rtx, rtx, enum rtx_code);



extern rtx emit_no_conflict_block (rtx, rtx, rtx, rtx, rtx);


extern void emit_clr_insn (rtx);


extern void emit_0_to_1_insn (rtx);


extern void emit_cmp_insn (rtx, rtx, enum rtx_code, rtx, enum machine_mode,
      int);



enum can_compare_purpose
{
  ccp_jump,
  ccp_cmov,
  ccp_store_flag
};



extern int can_compare_p (enum rtx_code, enum machine_mode,
     enum can_compare_purpose);

extern rtx prepare_operand (int, rtx, int, enum machine_mode,
       enum machine_mode, int);


extern enum insn_code can_extend_p (enum machine_mode, enum machine_mode, int);



extern rtx gen_extend_insn (rtx, rtx, enum machine_mode,
       enum machine_mode, int);



extern void init_fixtab (void);
extern void init_floattab (void);


extern void set_optab_libfunc (optab, enum machine_mode, const char *);
extern void set_conv_libfunc (convert_optab, enum machine_mode,
         enum machine_mode, const char *);


extern void expand_float (rtx, rtx, int);


extern void expand_fix (rtx, rtx, int);
# 98 "reload.c" 2
# 1 "recog.h" 1
# 28 "recog.h"
enum op_type {
  OP_IN,
  OP_OUT,
  OP_INOUT
};

struct operand_alternative
{


  const char *constraint;


  enum reg_class class;



  unsigned int reject;


  int matches;



  int matched;


  unsigned int earlyclobber:1;

  unsigned int memory_ok:1;

  unsigned int offmem_ok:1;

  unsigned int nonoffmem_ok:1;

  unsigned int decmem_ok:1;

  unsigned int incmem_ok:1;

  unsigned int is_address:1;


  unsigned int anything_ok:1;
};


extern void init_recog (void);
extern void init_recog_no_volatile (void);
extern int recog_memoized_1 (rtx);
extern int check_asm_operands (rtx);
extern int asm_operand_ok (rtx, const char *);
extern int validate_change (rtx, rtx *, rtx, int);
extern int insn_invalid_p (rtx);
extern int apply_change_group (void);
extern int num_validated_changes (void);
extern void cancel_changes (int);
extern int constrain_operands (int);
extern int constrain_operands_cached (int);
extern int memory_address_p (enum machine_mode, rtx);
extern int strict_memory_address_p (enum machine_mode, rtx);
extern int validate_replace_rtx_subexp (rtx, rtx, rtx, rtx *);
extern int validate_replace_rtx (rtx, rtx, rtx);
extern void validate_replace_rtx_group (rtx, rtx, rtx);
extern int validate_replace_src (rtx, rtx, rtx);
extern void validate_replace_src_group (rtx, rtx, rtx);
extern int num_changes_pending (void);



extern int reg_fits_class_p (rtx, enum reg_class, int, enum machine_mode);
extern rtx *find_single_use (rtx, rtx, rtx *);

extern int general_operand (rtx, enum machine_mode);
extern int address_operand (rtx, enum machine_mode);
extern int register_operand (rtx, enum machine_mode);
extern int pmode_register_operand (rtx, enum machine_mode);
extern int scratch_operand (rtx, enum machine_mode);
extern int immediate_operand (rtx, enum machine_mode);
extern int const_int_operand (rtx, enum machine_mode);
extern int const_double_operand (rtx, enum machine_mode);
extern int nonimmediate_operand (rtx, enum machine_mode);
extern int nonmemory_operand (rtx, enum machine_mode);
extern int push_operand (rtx, enum machine_mode);
extern int pop_operand (rtx, enum machine_mode);
extern int memory_operand (rtx, enum machine_mode);
extern int indirect_operand (rtx, enum machine_mode);
extern int comparison_operator (rtx, enum machine_mode);

extern int offsettable_memref_p (rtx);
extern int offsettable_nonstrict_memref_p (rtx);
extern int offsettable_address_p (int, enum machine_mode, rtx);
extern int mode_dependent_address_p (rtx);

extern int recog (rtx, rtx, int *);
extern void add_clobbers (rtx, int);
extern int added_clobbers_hard_reg_p (int);
extern void insn_extract (rtx);
extern void extract_insn (rtx);
extern void extract_constrain_insn_cached (rtx);
extern void extract_insn_cached (rtx);
extern void preprocess_constraints (void);
extern rtx peep2_next_insn (int);
extern int peep2_regno_dead_p (int, int);
extern int peep2_reg_dead_p (int, rtx);




extern void peephole2_optimize (FILE *);
extern rtx peephole2_insns (rtx, rtx, int *);

extern int store_data_bypass_p (rtx, rtx);
extern int if_test_bypass_p (rtx, rtx);


extern int volatile_ok;



extern int which_alternative;



struct recog_data
{







  rtx operand[30];


  rtx *operand_loc[30];


  const char *constraints[30];


  enum machine_mode operand_mode[30];


  enum op_type operand_type[30];



  rtx *dup_loc[4];



  char dup_num[4];
# 193 "recog.h"
  char n_operands;


  char n_dups;


  char n_alternatives;


  rtx insn;
};

extern struct recog_data recog_data;



extern struct operand_alternative recog_op_alt[30][30];




typedef int (*insn_operand_predicate_fn) (rtx, enum machine_mode);
typedef const char * (*insn_output_fn) (rtx *, rtx);
typedef rtx (*insn_gen_fn) (rtx, ...);

struct insn_operand_data
{
  const insn_operand_predicate_fn predicate;

  const char *const constraint;

  __extension__ enum machine_mode const mode : 16;

  const char strict_low;

  const char eliminable;
};
# 238 "recog.h"
struct insn_data
{
  const char *const name;

  union {
    const char *single;
    const char *const *multi;
    insn_output_fn function;
  } output;







  const insn_gen_fn genfun;
  const struct insn_operand_data *const operand;

  const char n_operands;
  const char n_dups;
  const char n_alternatives;
  const char output_format;
};

extern const struct insn_data insn_data[];
# 99 "reload.c" 2
# 1 "reload.h" 1
# 47 "reload.h"
extern int memory_move_secondary_cost (enum machine_mode, enum reg_class, int);
# 76 "reload.h"
enum reload_type
{
  RELOAD_FOR_INPUT, RELOAD_FOR_OUTPUT, RELOAD_FOR_INSN,
  RELOAD_FOR_INPUT_ADDRESS, RELOAD_FOR_INPADDR_ADDRESS,
  RELOAD_FOR_OUTPUT_ADDRESS, RELOAD_FOR_OUTADDR_ADDRESS,
  RELOAD_FOR_OPERAND_ADDRESS, RELOAD_FOR_OPADDR_ADDR,
  RELOAD_OTHER, RELOAD_FOR_OTHER_ADDRESS
};



struct reload
{

  rtx in;


  rtx out;


  enum reg_class class;


  enum machine_mode inmode;

  enum machine_mode outmode;


  enum machine_mode mode;


  unsigned int nregs;




  int inc;




  rtx in_reg;
  rtx out_reg;


  int regno;




  rtx reg_rtx;




  int opnum;



  int secondary_in_reload;


  int secondary_out_reload;



  enum insn_code secondary_in_icode;

  enum insn_code secondary_out_icode;




  enum reload_type when_needed;



  unsigned int optional:1;

  unsigned int nocombine:1;

  unsigned int secondary_p:1;


  unsigned int nongroup:1;
};

extern struct reload rld[(2 * 30 * (2 + 1))];
extern int n_reloads;


extern rtx *reg_equiv_constant;
extern rtx *reg_equiv_memory_loc;
extern rtx *reg_equiv_address;
extern rtx *reg_equiv_mem;



extern int n_earlyclobbers;
extern rtx reload_earlyclobbers[30];


extern int reload_n_operands;



extern int reload_first_uid;





extern char indirect_symref_ok;


extern char double_reg_address_ok;

extern int num_not_at_initial_offset;

struct needs
{

  short regs[2][((int) LIM_REG_CLASSES)];
  short groups[((int) LIM_REG_CLASSES)];
};
# 260 "reload.h"
extern rtx get_secondary_mem (rtx, enum machine_mode, int, enum reload_type);


extern void clear_secondary_mem (void);



extern void transfer_replacements (int, int);





extern int remove_address_replacements (rtx in_rtx);




extern int operands_match_p (rtx, rtx);


extern int safe_from_earlyclobber (rtx, rtx);




extern int find_reloads (rtx, int, int, int, short *);





extern rtx form_sum (rtx, rtx);



extern void subst_reloads (rtx);




extern void copy_replacements (rtx, rtx);


extern void move_replacements (rtx *x, rtx *y);



extern rtx find_replacement (rtx *);




extern int refers_to_regno_for_reload_p (unsigned int, unsigned int,
      rtx, rtx *);


extern int reg_overlap_mentioned_for_reload_p (rtx, rtx);



extern int refers_to_mem_for_reload_p (rtx);



extern rtx find_equiv_reg (rtx, rtx, enum reg_class, int, short *,
      int, enum machine_mode);


extern int regno_clobbered_p (unsigned int, rtx, enum machine_mode, int);


extern int earlyclobber_operand_p (rtx);


extern int push_reload (rtx, rtx, rtx *, rtx *, enum reg_class,
   enum machine_mode, enum machine_mode,
   int, int, int, enum reload_type);


extern void reload_cse_regs (rtx);


extern int reloads_conflict (int, int);


extern void init_reload (void);


extern int reload (rtx, int);



extern void mark_home_live (int);



extern rtx eliminate_regs (rtx, enum machine_mode, rtx);




extern rtx gen_reload (rtx, rtx, int, enum reload_type);


extern void deallocate_reload_reg (int r);




extern void init_caller_save (void);


extern void init_save_areas (void);


extern void setup_save_areas (void);


extern void save_call_clobbered_regs (void);


extern void cleanup_subreg_operands (rtx);


extern void debug_reload_to_stream (FILE *);
extern void debug_reload (void);



extern rtx reload_adjust_reg_for_mode (rtx, enum machine_mode);
# 100 "reload.c" 2
# 1 "regs.h" 1
# 23 "regs.h"
# 1 "varray.h" 1
# 39 "varray.h"
struct const_equiv_data {
# 53 "varray.h"
  rtx rtx;



  unsigned age;
};




enum varray_data_enum {
  VARRAY_DATA_C,
  VARRAY_DATA_UC,
  VARRAY_DATA_S,
  VARRAY_DATA_US,
  VARRAY_DATA_I,
  VARRAY_DATA_U,
  VARRAY_DATA_L,
  VARRAY_DATA_UL,
  VARRAY_DATA_HINT,
  VARRAY_DATA_UHINT,
  VARRAY_DATA_GENERIC,
  VARRAY_DATA_CPTR,
  VARRAY_DATA_RTX,
  VARRAY_DATA_RTVEC,
  VARRAY_DATA_TREE,
  VARRAY_DATA_BITMAP,
  VARRAY_DATA_REG,
  VARRAY_DATA_CONST_EQUIV,
  VARRAY_DATA_BB,
  VARRAY_DATA_TE,
  NUM_VARRAY_DATA
};


typedef union varray_data_tag {
  char c[1];

  unsigned char uc[1];

  short s[1];

  unsigned short us[1];

  int i[1];

  unsigned int u[1];

  long l[1];

  unsigned long ul[1];

  long hint[1];

  unsigned long uhint[1];

  void * generic[1];

  char * cptr[1];

  rtx rtx[1];

  rtvec rtvec[1];

  tree tree[1];

  struct bitmap_head_def * bitmap[1];

  struct reg_info_def * reg[1];

  struct const_equiv_data const_equiv[1];

  struct basic_block_def * bb[1];

  struct elt_list * te[1];

} varray_data;


struct varray_head_tag {
  size_t num_elements;
  size_t elements_used;

  enum varray_data_enum type;
  const char *name;
  varray_data data;

};
typedef struct varray_head_tag *varray_type;



extern varray_type varray_init (size_t, enum varray_data_enum, const char *);
# 213 "varray.h"
extern varray_type varray_grow (varray_type, size_t);
# 224 "varray.h"
extern void varray_clear (varray_type);

extern void dump_varray_statistics (void);
# 24 "regs.h" 2
# 1 "hard-reg-set.h" 1
# 41 "hard-reg-set.h"
typedef unsigned long HARD_REG_ELT_TYPE;
# 52 "hard-reg-set.h"
typedef HARD_REG_ELT_TYPE HARD_REG_SET[((53 + (8 * 4) - 1) / (8 * 4))];
# 395 "hard-reg-set.h"
extern char fixed_regs[53];



extern HARD_REG_SET fixed_reg_set;






extern char call_used_regs[53];







extern HARD_REG_SET call_used_reg_set;


extern HARD_REG_SET losing_caller_save_reg_set;







extern char call_fixed_regs[53];



extern HARD_REG_SET call_fixed_reg_set;






extern char global_regs[53];
# 445 "hard-reg-set.h"
extern HARD_REG_SET regs_invalidated_by_call;




extern int reg_alloc_order[53];



extern int inv_reg_alloc_order[53];




extern HARD_REG_SET reg_class_contents[((int) LIM_REG_CLASSES)];



extern unsigned int reg_class_size[((int) LIM_REG_CLASSES)];



extern enum reg_class reg_class_superclasses[((int) LIM_REG_CLASSES)][((int) LIM_REG_CLASSES)];



extern enum reg_class reg_class_subclasses[((int) LIM_REG_CLASSES)][((int) LIM_REG_CLASSES)];




extern enum reg_class reg_class_subunion[((int) LIM_REG_CLASSES)][((int) LIM_REG_CLASSES)];




extern enum reg_class reg_class_superunion[((int) LIM_REG_CLASSES)][((int) LIM_REG_CLASSES)];



extern int n_non_fixed_regs;



extern const char * reg_names[53];
# 25 "regs.h" 2
# 1 "basic-block.h" 1
# 25 "basic-block.h"
# 1 "bitmap.h" 1
# 29 "bitmap.h"
typedef unsigned long BITMAP_WORD;
# 51 "bitmap.h"
typedef struct bitmap_element_def
{
  struct bitmap_element_def *next;
  struct bitmap_element_def *prev;
  unsigned int indx;
  BITMAP_WORD bits[((128 + (8 * 4) - 1) / (8 * 4))];
} bitmap_element;


typedef struct bitmap_head_def {
  bitmap_element *first;
  bitmap_element *current;
  unsigned int indx;
  int using_obstack;

} bitmap_head;
typedef struct bitmap_head_def *bitmap;


enum bitmap_bits {
  BITMAP_AND,
  BITMAP_AND_COMPL,
  BITMAP_IOR,
  BITMAP_XOR,
  BITMAP_IOR_COMPL
};


extern bitmap_element bitmap_zero_bits;


extern void bitmap_clear (bitmap);


extern void bitmap_copy (bitmap, bitmap);


extern int bitmap_equal_p (bitmap, bitmap);


extern int bitmap_operation (bitmap, bitmap, bitmap, enum bitmap_bits);



extern void bitmap_ior_and_compl (bitmap, bitmap, bitmap);


extern void bitmap_clear_bit (bitmap, int);


extern void bitmap_set_bit (bitmap, int);


extern int bitmap_bit_p (bitmap, int);


extern void debug_bitmap (bitmap);
extern void debug_bitmap_file (FILE *, bitmap);


extern void bitmap_print (FILE *, bitmap, const char *, const char *);



extern bitmap bitmap_initialize (bitmap head, int using_obstack);


extern void bitmap_release_memory (void);






extern int bitmap_union_of_diff (bitmap, bitmap, bitmap, bitmap);
extern int bitmap_first_set_bit (bitmap);
extern int bitmap_last_set_bit (bitmap);
# 26 "basic-block.h" 2
# 1 "sbitmap.h" 1
# 31 "sbitmap.h"
typedef struct simple_bitmap_def
{
  unsigned int n_bits;
  unsigned int size;
  unsigned int bytes;
  unsigned long elms[1];
} *sbitmap;

typedef unsigned long *sbitmap_ptr;
# 119 "sbitmap.h"
struct int_list;

extern void dump_sbitmap (FILE *, sbitmap);
extern void dump_sbitmap_file (FILE *, sbitmap);
extern void dump_sbitmap_vector (FILE *, const char *, const char *, sbitmap *,
     int);
extern sbitmap sbitmap_alloc (unsigned int);
extern sbitmap *sbitmap_vector_alloc (unsigned int, unsigned int);
extern sbitmap sbitmap_resize (sbitmap, unsigned int, int);
extern void sbitmap_copy (sbitmap, sbitmap);
extern int sbitmap_equal (sbitmap, sbitmap);
extern void sbitmap_zero (sbitmap);
extern void sbitmap_ones (sbitmap);
extern void sbitmap_vector_zero (sbitmap *, unsigned int);
extern void sbitmap_vector_ones (sbitmap *, unsigned int);

extern void sbitmap_union_of_diff (sbitmap, sbitmap, sbitmap, sbitmap);
extern _Bool sbitmap_union_of_diff_cg (sbitmap, sbitmap, sbitmap, sbitmap);
extern void sbitmap_difference (sbitmap, sbitmap, sbitmap);
extern void sbitmap_not (sbitmap, sbitmap);
extern void sbitmap_a_or_b_and_c (sbitmap, sbitmap, sbitmap, sbitmap);
extern _Bool sbitmap_a_or_b_and_c_cg (sbitmap, sbitmap, sbitmap, sbitmap);
extern void sbitmap_a_and_b_or_c (sbitmap, sbitmap, sbitmap, sbitmap);
extern _Bool sbitmap_a_and_b_or_c_cg (sbitmap, sbitmap, sbitmap, sbitmap);
extern void sbitmap_a_and_b (sbitmap, sbitmap, sbitmap);
extern _Bool sbitmap_a_and_b_cg (sbitmap, sbitmap, sbitmap);
extern void sbitmap_a_or_b (sbitmap, sbitmap, sbitmap);
extern _Bool sbitmap_a_or_b_cg (sbitmap, sbitmap, sbitmap);
extern void sbitmap_a_xor_b (sbitmap, sbitmap, sbitmap);
extern _Bool sbitmap_a_xor_b_cg (sbitmap, sbitmap, sbitmap);
extern _Bool sbitmap_a_subset_b_p (sbitmap, sbitmap);

extern int sbitmap_first_set_bit (sbitmap);
extern int sbitmap_last_set_bit (sbitmap);

extern void sbitmap_intersect_of_predsucc (sbitmap, sbitmap *, int,
        struct int_list **);



extern void sbitmap_union_of_predsucc (sbitmap, sbitmap *, int,
           struct int_list **);






extern void sbitmap_intersection_of_succs (sbitmap, sbitmap *, int);
extern void sbitmap_intersection_of_preds (sbitmap, sbitmap *, int);
extern void sbitmap_union_of_succs (sbitmap, sbitmap *, int);
extern void sbitmap_union_of_preds (sbitmap, sbitmap *, int);

extern void debug_sbitmap (sbitmap);
# 27 "basic-block.h" 2

# 1 "./../include/partition.h" 1
# 46 "./../include/partition.h"
struct partition_elem
{


  int class_element;


  struct partition_elem* next;


  unsigned class_count;
};

typedef struct partition_def
{

  int num_elements;

  struct partition_elem elements[1];
} *partition;

extern partition partition_new (int);
extern void partition_delete (partition);
extern int partition_union (partition, int, int);


extern void partition_print (partition, FILE*);
# 29 "basic-block.h" 2



typedef bitmap_head regset_head;

typedef bitmap regset;
# 75 "basic-block.h"
extern void reg_set_to_hard_reg_set (HARD_REG_SET *, bitmap);
# 121 "basic-block.h"
typedef long long gcov_type;


typedef struct edge_def {

  struct edge_def *pred_next, *succ_next;


  struct basic_block_def *src, *dest;


  rtx insns;


  void *aux;

  int flags;
  int probability;
  gcov_type count;

} *edge;
# 162 "basic-block.h"
extern const struct gcov_ctr_summary *profile_info;


struct loop;
struct loops;
# 194 "basic-block.h"
typedef struct basic_block_def {

  rtx head_, end_;


  tree head_tree;
  tree end_tree;


  edge pred, succ;




  regset local_set;



  regset cond_local_set;





  regset global_live_at_start;

  regset global_live_at_end;


  void *aux;


  int index;


  struct basic_block_def *prev_bb, *next_bb;


  int loop_depth;


  struct loop *loop_father;


  struct et_node *dom[2];


  gcov_type count;


  int frequency;


  int flags;


  struct reorder_block_def *rbi;
} *basic_block;
# 265 "basic-block.h"
extern int n_basic_blocks;



extern int last_basic_block;



extern int n_edges;



extern varray_type basic_block_info;
# 299 "basic-block.h"
extern regset regs_live_at_setjmp;



extern rtx label_value_list;
extern rtx tail_recursion_label_list;

extern struct obstack flow_obstack;
# 333 "basic-block.h"
extern struct basic_block_def entry_exit_blocks[2];






extern void compute_bb_for_insn (void);
extern void free_bb_for_insn (void);
extern void update_bb_for_insn (basic_block);

extern void free_basic_block_vars (int);

extern void insert_insn_on_edge (rtx, edge);
_Bool safe_insert_insn_on_edge (rtx, edge);

extern void commit_edge_insertions (void);
extern void commit_edge_insertions_watch_calls (void);

extern void remove_fake_edges (void);
extern void add_noreturn_fake_exit_edges (void);
extern void connect_infinite_loops_to_exit (void);
extern int flow_call_edges_add (sbitmap);
extern edge unchecked_make_edge (basic_block, basic_block, int);
extern edge cached_make_edge (sbitmap *, basic_block, basic_block, int);
extern edge make_edge (basic_block, basic_block, int);
extern edge make_single_succ_edge (basic_block, basic_block, int);
extern void remove_edge (edge);
extern void redirect_edge_succ (edge, basic_block);
extern edge redirect_edge_succ_nodup (edge, basic_block);
extern void redirect_edge_pred (edge, basic_block);
extern basic_block create_basic_block_structure (rtx, rtx, rtx, basic_block);
extern void clear_bb_flags (void);
extern void tidy_fallthru_edge (edge, basic_block, basic_block);
extern void tidy_fallthru_edges (void);
extern void flow_reverse_top_sort_order_compute (int *);
extern int flow_depth_first_order_compute (int *, int *);
extern void flow_preorder_transversal_compute (int *);
extern int dfs_enumerate_from (basic_block, int,
          _Bool (*)(basic_block, void *),
          basic_block *, int, void *);
extern void dump_edge_info (FILE *, edge, int);
extern void clear_edges (void);
extern void mark_critical_edges (void);
extern rtx first_insn_after_basic_block_note (basic_block);






typedef struct ce_if_block
{
  basic_block test_bb;
  basic_block then_bb;
  basic_block else_bb;
  basic_block join_bb;
  basic_block last_test_bb;
  int num_multiple_test_blocks;
  int num_and_and_blocks;
  int num_or_or_blocks;
  int num_multiple_test_insns;
  int and_and_p;
  int num_then_insns;
  int num_else_insns;
  int pass;





} ce_if_block_t;


struct edge_list
{
  int num_blocks;
  int num_edges;
  edge *index_to_edge;
};
# 450 "basic-block.h"
struct edge_list * create_edge_list (void);
void free_edge_list (struct edge_list *);
void print_edge_list (FILE *, struct edge_list *);
void verify_edge_list (FILE *, struct edge_list *);
int find_edge_index (struct edge_list *, basic_block, basic_block);


enum update_life_extent
{
  UPDATE_LIFE_LOCAL = 0,
  UPDATE_LIFE_GLOBAL = 1,
  UPDATE_LIFE_GLOBAL_RM_NOTES = 2
};
# 503 "basic-block.h"
extern void life_analysis (rtx, FILE *, int);
extern int update_life_info (sbitmap, enum update_life_extent, int);
extern int update_life_info_in_dirty_blocks (enum update_life_extent, int);
extern int count_or_remove_death_notes (sbitmap, int);
extern int propagate_block (basic_block, regset, regset, regset, int);

struct propagate_block_info;
extern rtx propagate_one_insn (struct propagate_block_info *, rtx);
extern struct propagate_block_info *init_propagate_block_info
 (basic_block, regset, regset, regset, int);
extern void free_propagate_block_info (struct propagate_block_info *);


extern struct edge_list *pre_edge_lcm (FILE *, int, sbitmap *, sbitmap *,
           sbitmap *, sbitmap *, sbitmap **,
           sbitmap **);
extern struct edge_list *pre_edge_rev_lcm (FILE *, int, sbitmap *,
        sbitmap *, sbitmap *,
        sbitmap *, sbitmap **,
        sbitmap **);
extern void compute_available (sbitmap *, sbitmap *, sbitmap *, sbitmap *);
extern int optimize_mode_switching (FILE *);


extern rtx emit_block_insn_after (rtx, rtx, basic_block);
extern rtx emit_block_insn_before (rtx, rtx, basic_block);


extern void estimate_probability (struct loops *);
extern void note_prediction_to_br_prob (void);
extern void expected_value_to_br_prob (void);
extern _Bool maybe_hot_bb_p (basic_block);
extern _Bool probably_cold_bb_p (basic_block);
extern _Bool probably_never_executed_bb_p (basic_block);


extern void init_flow (void);
extern void dump_bb (basic_block, FILE *);
extern void debug_bb (basic_block);
extern basic_block debug_bb_n (int);
extern void dump_regset (regset, FILE *);
extern void debug_regset (regset);
extern void allocate_reg_life_data (void);
extern void allocate_bb_life_data (void);
extern void expunge_block (basic_block);
extern void link_block (basic_block, basic_block);
extern void unlink_block (basic_block);
extern void compact_blocks (void);
extern basic_block alloc_block (void);
extern void find_unreachable_blocks (void);
extern int delete_noop_moves (rtx);
extern basic_block force_nonfallthru (edge);
extern rtx block_label (basic_block);
extern _Bool forwarder_block_p (basic_block);
extern _Bool purge_all_dead_edges (int);
extern _Bool purge_dead_edges (basic_block);
extern void find_sub_basic_blocks (basic_block);
extern void find_many_sub_basic_blocks (sbitmap);
extern _Bool can_fallthru (basic_block, basic_block);
extern void flow_nodes_print (const char *, const sbitmap, FILE *);
extern void flow_edge_list_print (const char *, const edge *, int, FILE *);
extern void alloc_aux_for_block (basic_block, int);
extern void alloc_aux_for_blocks (int);
extern void clear_aux_for_blocks (void);
extern void free_aux_for_blocks (void);
extern void alloc_aux_for_edge (edge, int);
extern void alloc_aux_for_edges (int);
extern void clear_aux_for_edges (void);
extern void free_aux_for_edges (void);




extern void verify_flow_info (void);

typedef struct conflict_graph_def *conflict_graph;




typedef int (*conflict_graph_enum_fn) (int, int, void *);




extern conflict_graph conflict_graph_new
 (int);
extern void conflict_graph_delete (conflict_graph);
extern int conflict_graph_add (conflict_graph, int, int);
extern int conflict_graph_conflict_p (conflict_graph, int, int);
extern void conflict_graph_enum (conflict_graph, int, conflict_graph_enum_fn,
     void *);
extern void conflict_graph_merge_regs (conflict_graph, int, int);
extern void conflict_graph_print (conflict_graph, FILE*);
extern conflict_graph conflict_graph_compute (regset, partition);
extern _Bool mark_dfs_back_edges (void);
extern void set_edge_can_fallthru_flag (void);
extern void update_br_prob_note (basic_block);
extern void fixup_abnormal_edges (void);
extern _Bool can_hoist_insn_p (rtx, rtx, regset);
extern rtx hoist_insn_after (rtx, rtx, rtx, rtx);
extern rtx hoist_insn_to_edge (rtx, edge, rtx, rtx);
extern _Bool inside_basic_block_p (rtx);
extern _Bool control_flow_insn_p (rtx);


extern void reorder_basic_blocks (void);



enum cdi_direction
{
  CDI_DOMINATORS,
  CDI_POST_DOMINATORS
};

enum dom_state
{
  DOM_NONE,
  DOM_CONS_OK,

  DOM_NO_FAST_QUERY,
  DOM_OK
};

extern enum dom_state dom_computed[2];

extern void calculate_dominance_info (enum cdi_direction);
extern void free_dominance_info (enum cdi_direction);
extern basic_block nearest_common_dominator (enum cdi_direction,
          basic_block, basic_block);
extern void set_immediate_dominator (enum cdi_direction, basic_block,
         basic_block);
extern basic_block get_immediate_dominator (enum cdi_direction, basic_block);
extern _Bool dominated_by_p (enum cdi_direction, basic_block, basic_block);
extern int get_dominated_by (enum cdi_direction, basic_block, basic_block **);
extern void add_to_dominance_info (enum cdi_direction, basic_block);
extern void delete_from_dominance_info (enum cdi_direction, basic_block);
basic_block recount_dominator (enum cdi_direction, basic_block);
extern void redirect_immediate_dominators (enum cdi_direction, basic_block,
        basic_block);
extern void iterate_fix_dominators (enum cdi_direction, basic_block *, int);
extern void verify_dominators (enum cdi_direction);
extern basic_block first_dom_son (enum cdi_direction, basic_block);
extern basic_block next_dom_son (enum cdi_direction, basic_block);
extern _Bool try_redirect_by_replacing_jump (edge, basic_block, _Bool);

# 1 "cfghooks.h" 1
# 25 "cfghooks.h"
struct cfg_hooks
{


  int (*cfgh_verify_flow_info) (void);
  void (*dump_bb) (basic_block, FILE *);




  basic_block (*create_basic_block) (void *head, void *end, basic_block after);




  _Bool (*redirect_edge_and_branch) (edge e, basic_block b);




  basic_block (*redirect_edge_and_branch_force) (edge, basic_block);


  void (*delete_block) (basic_block);


  edge (*split_block) (basic_block b, void * i);


  _Bool (*can_merge_blocks_p) (basic_block a, basic_block b);


  void (*merge_blocks) (basic_block a, basic_block b);



  basic_block (*cfgh_split_edge) (edge);
};
# 74 "cfghooks.h"
extern struct cfg_hooks rtl_cfg_hooks;


extern struct cfg_hooks *cfg_hooks;


extern void rtl_register_cfg_hooks (void);
extern void cfg_layout_rtl_register_cfg_hooks (void);
# 651 "basic-block.h" 2
# 26 "regs.h" 2
# 44 "regs.h"
extern int max_regno;


typedef struct reg_info_def
{
  int first_uid;
  int last_uid;
  int last_note_uid;


  int sets;


  int refs;
  int freq;
  int deaths;
  int live_length;
  int calls_crossed;
  int basic_block;
  char changes_mode;

} reg_info;

extern varray_type reg_n_info;

extern bitmap_head subregs_of_mode;
# 154 "regs.h"
extern short *reg_renumber;



extern char regs_ever_live[53];



extern char regs_asm_clobbered[53];






extern enum machine_mode reg_raw_mode[53];
# 192 "regs.h"
extern rtx regs_may_share;




extern int caller_save_needed;
# 226 "regs.h"
extern void allocate_reg_info (size_t, int, int);
# 101 "reload.c" 2

# 1 "flags.h" 1
# 26 "flags.h"
enum debug_info_type
{
  NO_DEBUG,
  DBX_DEBUG,
  SDB_DEBUG,
  DWARF_DEBUG,
  DWARF2_DEBUG,
  XCOFF_DEBUG,
  VMS_DEBUG,
  VMS_AND_DWARF2_DEBUG

};


extern enum debug_info_type write_symbols;


extern const char *const debug_type_names[];

enum debug_info_level
{
  DINFO_LEVEL_NONE,
  DINFO_LEVEL_TERSE,
  DINFO_LEVEL_NORMAL,
  DINFO_LEVEL_VERBOSE
};


extern enum debug_info_level debug_info_level;



extern _Bool use_gnu_debug_info_extensions;


extern int flag_debug_only_used_symbols;



extern int optimize;



extern int optimize_size;




extern int quiet_flag;




extern int mem_report;



extern _Bool inhibit_warnings;



extern _Bool warn_system_headers;




extern _Bool extra_warnings;



extern _Bool warnings_are_errors;





extern void set_Wunused (int setting);

extern _Bool warn_unused_function;
extern _Bool warn_unused_label;
extern _Bool warn_unused_parameter;
extern _Bool warn_unused_variable;
extern _Bool warn_unused_value;



extern _Bool warn_notreached;



extern _Bool warn_inline;



extern int warn_uninitialized;



extern _Bool warn_shadow;




extern _Bool warn_switch;



extern _Bool warn_switch_default;




extern _Bool warn_switch_enum;




extern int warn_return_type;



extern _Bool warn_missing_noreturn;





extern _Bool warn_cast_align;





extern _Bool warn_larger_than;
extern long larger_than_size;




extern _Bool warn_aggregate_return;



extern _Bool warn_packed;



extern _Bool warn_padded;



extern _Bool warn_disabled_optimization;




extern _Bool warn_deprecated_decl;




extern _Bool warn_strict_aliasing;



extern int profile_flag;



extern int profile_arc_flag;



extern int flag_profile_values;



extern int flag_test_coverage;



extern int flag_branch_probabilities;



extern int flag_reorder_blocks;



extern int flag_reorder_functions;



extern int flag_rename_registers;




extern int pedantic;




extern int in_system_header;




extern int flag_print_asm_name;





extern int flag_signed_char;



extern int flag_short_enums;





extern int flag_caller_saves;



extern int flag_pcc_struct_return;




extern int flag_force_mem;




extern int flag_force_addr;




extern int flag_defer_pop;




extern int flag_float_store;



extern int flag_strength_reduce;






extern int flag_old_unroll_loops;




extern int flag_old_unroll_all_loops;




extern int flag_move_all_movables;



extern int flag_prefetch_loop_arrays;




extern int flag_reduce_all_givs;




extern int flag_cse_follow_jumps;




extern int flag_cse_skip_blocks;



extern int flag_expensive_optimizations;




extern int flag_writable_strings;





extern int flag_no_function_cse;




extern int flag_omit_frame_pointer;



extern int flag_no_peephole;



extern int flag_optimize_sibling_calls;




extern int flag_errno_math;






extern int flag_unsafe_math_optimizations;



extern int flag_finite_math_only;





extern int flag_trapping_math;




extern int flag_rounding_math;





extern int flag_complex_divide_method;



extern int flag_rerun_loop_opt;




extern int flag_inline_functions;





extern int flag_keep_inline_functions;







extern int flag_no_inline;




extern int flag_really_no_inline;



extern int flag_syntax_only;



extern int flag_gen_aux_info;



extern int flag_shared_data;






extern int flag_schedule_insns;
extern int flag_schedule_insns_after_reload;
extern int flag_sched2_use_superblocks;
extern int flag_sched2_use_traces;
# 437 "flags.h"
extern int flag_schedule_interblock;
extern int flag_schedule_speculative;
extern int flag_schedule_speculative_load;
extern int flag_schedule_speculative_load_dangerous;
# 453 "flags.h"
extern int flag_sched_stalled_insns;
extern int flag_sched_stalled_insns_dep;



extern int flag_branch_on_count_reg;





extern int flag_single_precision_constant;



extern int flag_delayed_branch;




extern int flag_dump_unnumbered;




extern int flag_pedantic_errors;




extern int flag_pic;




extern int flag_pie;




extern int flag_shlib;




extern int flag_exceptions;



extern int flag_unwind_tables;



extern int flag_asynchronous_unwind_tables;




extern int flag_no_common;





extern int flag_inhibit_size_directive;




extern int flag_function_sections;



extern int flag_data_sections;
# 535 "flags.h"
extern int flag_verbose_asm;
# 544 "flags.h"
extern int flag_debug_asm;

extern int flag_dump_rtl_in_asm;



extern int flag_leading_underscore;


extern int flag_pack_struct;
# 562 "flags.h"
extern int flag_argument_noalias;





extern int flag_strict_aliasing;



extern int flag_stack_check;


extern int flag_regmove;


extern int flag_instrument_function_entry_exit;


extern int flag_peephole2;


extern int flag_guess_branch_prob;





extern int flag_bounds_check;




extern int flag_merge_constants;




extern int flag_renumber_insns;







extern int frame_pointer_needed;



extern int flag_trapv;


extern int flag_wrapv;


extern int flag_evaluation_order;


extern unsigned long g_switch_value;
extern _Bool g_switch_set;






extern int align_loops;
extern int align_loops_log;
extern int align_loops_max_skip;
extern int align_jumps;
extern int align_jumps_log;
extern int align_jumps_max_skip;
extern int align_labels;
extern int align_labels_log;
extern int align_labels_max_skip;
extern int align_functions;
extern int align_functions_log;



extern int force_align_functions_log;


extern int dump_for_graph;


enum graph_dump_types
{
  no_graph = 0,
  vcg
};
extern enum graph_dump_types graph_dump_format;





extern int flag_no_ident;



extern int flag_gcse;



extern int flag_gcse_lm;



extern int flag_gcse_sm;




extern int flag_gcse_las;


extern int flag_value_profile_transformations;




extern int flag_branch_target_load_optimize;




extern int flag_branch_target_load_optimize2;




extern int flag_eliminate_dwarf2_dups;



extern int flag_eliminate_unused_debug_types;



extern int flag_detailed_statistics;


extern int flag_non_call_exceptions;


extern int flag_zero_initialized_in_bss;


extern int flag_signaling_nans;

extern int flag_unit_at_a_time;

extern int flag_web;



extern int flag_remove_unreachable_functions;




extern const char *flag_random_seed;
# 740 "flags.h"
extern int flag_abi_version;
# 103 "reload.c" 2
# 1 "real.h" 1
# 30 "real.h"
enum real_value_class {
  rvc_zero,
  rvc_normal,
  rvc_inf,
  rvc_nan
};







struct real_value
{
  __extension__ enum real_value_class class : 2;
  unsigned int sign : 1;
  unsigned int signalling : 1;
  unsigned int canonical : 1;
  signed int exp : (32 - 5);
  unsigned long sig[((128 + (8 * 4)) / (8 * 4))];
};
# 68 "real.h"
extern char test_real_width
  [sizeof(struct real_value) <= (((128 + (8 * 4)) + 32)/(8 * 4) + (((128 + (8 * 4)) + 32)%(8 * 4) ? 1 : 0))*sizeof(long) ? 1 : -1];
# 106 "real.h"
struct real_format
{

  void (*encode) (const struct real_format *, long *,
    const struct real_value *);
  void (*decode) (const struct real_format *, struct real_value *,
    const long *);


  int b;


  int log2_b;


  int p;


  int pnan;


  int emin;


  int emax;


  int signbit;


  _Bool has_nans;
  _Bool has_inf;
  _Bool has_denorm;
  _Bool has_signed_zero;
  _Bool qnan_msb_set;
};




extern const struct real_format *
  real_format_for_mode[MAX_MODE_FLOAT - MIN_MODE_FLOAT + 1];






extern void real_arithmetic (struct real_value *, int, const struct real_value *,
        const struct real_value *);


extern _Bool real_compare (int, const struct real_value *, const struct real_value *);


extern _Bool real_isinf (const struct real_value *);


extern _Bool real_isnan (const struct real_value *);


extern _Bool real_isneg (const struct real_value *);


extern _Bool real_isnegzero (const struct real_value *);


extern _Bool real_identical (const struct real_value *, const struct real_value *);


extern void real_convert (struct real_value *, enum machine_mode,
     const struct real_value *);


extern _Bool exact_real_truncate (enum machine_mode, const struct real_value *);


extern void real_to_decimal (char *, const struct real_value *, size_t,
        size_t, int);


extern void real_to_hexadecimal (char *, const struct real_value *,
     size_t, size_t, int);


extern long real_to_integer (const struct real_value *);
extern void real_to_integer2 (long *, long *,
         const struct real_value *);


extern void real_from_string (struct real_value *, const char *);


extern void real_from_integer (struct real_value *, enum machine_mode,
          unsigned long, long, int);

extern long real_to_target_fmt (long *, const struct real_value *,
    const struct real_format *);
extern long real_to_target (long *, const struct real_value *, enum machine_mode);

extern void real_from_target_fmt (struct real_value *, const long *,
      const struct real_format *);
extern void real_from_target (struct real_value *, const long *,
         enum machine_mode);

extern void real_inf (struct real_value *);

extern _Bool real_nan (struct real_value *, const char *, int, enum machine_mode);

extern void real_maxval (struct real_value *, int, enum machine_mode);

extern void real_2expN (struct real_value *, int);

extern unsigned int real_hash (const struct real_value *);



extern const struct real_format ieee_single_format;
extern const struct real_format mips_single_format;
extern const struct real_format ieee_double_format;
extern const struct real_format mips_double_format;
extern const struct real_format ieee_extended_motorola_format;
extern const struct real_format ieee_extended_intel_96_format;
extern const struct real_format ieee_extended_intel_96_round_53_format;
extern const struct real_format ieee_extended_intel_128_format;
extern const struct real_format ibm_extended_format;
extern const struct real_format mips_extended_format;
extern const struct real_format ieee_quad_format;
extern const struct real_format mips_quad_format;
extern const struct real_format vax_f_format;
extern const struct real_format vax_d_format;
extern const struct real_format vax_g_format;
extern const struct real_format i370_single_format;
extern const struct real_format i370_double_format;
extern const struct real_format c4x_single_format;
extern const struct real_format c4x_extended_format;
extern const struct real_format real_internal_format;
# 285 "real.h"
extern struct real_value real_value_truncate (enum machine_mode,
         struct real_value);




extern struct real_value real_arithmetic2 (int, const struct real_value *,
      const struct real_value *);







extern int significand_size (enum machine_mode);

extern struct real_value real_from_string2 (const char *, enum machine_mode);
# 320 "real.h"
extern int real_exponent (const struct real_value *);


extern void real_ldexp (struct real_value *, const struct real_value *, int);





extern struct real_value dconst0;
extern struct real_value dconst1;
extern struct real_value dconst2;
extern struct real_value dconst3;
extern struct real_value dconst10;
extern struct real_value dconstm1;
extern struct real_value dconstm2;
extern struct real_value dconsthalf;
extern struct real_value dconstthird;
extern struct real_value dconstpi;
extern struct real_value dconste;



struct real_value real_value_from_int_cst (tree, tree);
# 352 "real.h"
extern rtx const_double_from_real_value (struct real_value, enum machine_mode);


extern _Bool exact_real_inverse (enum machine_mode, struct real_value *);


extern tree build_real (tree, struct real_value);


extern _Bool real_sqrt (struct real_value *, enum machine_mode,
         const struct real_value *);


extern _Bool real_powi (struct real_value *, enum machine_mode,
         const struct real_value *, long);


extern void real_trunc (struct real_value *, enum machine_mode,
   const struct real_value *);
extern void real_floor (struct real_value *, enum machine_mode,
   const struct real_value *);
extern void real_ceil (struct real_value *, enum machine_mode,
         const struct real_value *);
# 104 "reload.c" 2
# 1 "output.h" 1
# 27 "output.h"
extern void compute_alignments (void);


extern void init_final (const char *);



extern void app_enable (void);



extern void app_disable (void);




extern int dbr_sequence_length (void);


extern void init_insn_lengths (void);



extern int get_attr_length (rtx);



extern void shorten_branches (rtx);






extern void final_start_function (rtx, FILE *, int);




extern void final_end_function (void);


extern void final (rtx, FILE *, int, int);




extern rtx final_scan_insn (rtx, FILE *, int, int, int, int *);



extern rtx alter_subreg (rtx *);



extern void output_operand_lossage (const char *, ...) __attribute__ ((__format__ (__printf__, 1, 2))) __attribute__ ((__nonnull__ (1)));



extern void output_asm_insn (const char *, rtx *);




extern int insn_current_reference_address (rtx);



extern int label_to_alignment (rtx);


extern void output_asm_label (rtx);



extern void output_address (rtx);




extern void output_addr_const (FILE *, rtx);
# 116 "output.h"
typedef long __gcc_host_wide_int__;




extern void asm_fprintf (FILE *file, const char *p, ...)
     __attribute__ ((__format__ (__asm_fprintf__, 2, 3))) __attribute__ ((__nonnull__ (2)));



extern void split_double (rtx, rtx *, rtx *);


extern int leaf_function_p (void);




extern int final_forward_branch_p (rtx);



extern int only_leaf_regs_used (void);



extern void leaf_renumber_regs_insn (rtx);


extern const char *get_insn_template (int, rtx);



extern int add_weak (tree, const char *, const char *);


extern void allocate_for_life_analysis (void);
extern int regno_uninitialized (unsigned int);
extern int regno_clobbered_at_setjmp (int);
extern void find_basic_blocks (rtx, int, FILE *);
extern _Bool cleanup_cfg (int);
extern _Bool delete_unreachable_blocks (void);
extern void check_function_return_warnings (void);




extern void text_section (void);


extern void data_section (void);



extern void readonly_data_section (void);


extern int in_text_section (void);
# 184 "output.h"
extern void bss_section (void);



extern void init_section (void);



extern void fini_section (void);
# 211 "output.h"
extern void named_section (tree, const char *, int);


extern void function_section (tree);


extern void mergeable_string_section (tree, unsigned long,
          unsigned int);


extern void mergeable_constant_section (enum machine_mode,
     unsigned long, unsigned int);


extern void declare_weak (tree);

extern void merge_weak (tree, tree);


extern void weak_finish (void);
# 239 "output.h"
extern int decode_reg_name (const char *);



extern void make_var_volatile (tree);

extern void assemble_alias (tree, tree);

extern void default_assemble_visibility (tree, int);



extern void assemble_asm (tree);





extern void assemble_start_function (tree, const char *);



extern void assemble_end_function (tree, const char *);
# 272 "output.h"
extern void assemble_variable (tree, int, int, int);




extern void assemble_external (tree);


extern void assemble_zeros (unsigned long);


extern void assemble_align (int);
extern void assemble_eh_align (int);


extern void assemble_string (const char *, int);


extern void assemble_external_libcall (rtx);


extern void assemble_label (const char *);
extern void assemble_eh_label (const char *);






extern void assemble_name (FILE *, const char *);
# 310 "output.h"
extern const char *integer_asm_op (int, int);



extern void assemble_integer_with_op (const char *, rtx);


extern _Bool default_assemble_integer (rtx, unsigned int, int);





extern _Bool assemble_integer (rtx, unsigned, unsigned, int);
# 333 "output.h"
extern void assemble_real (struct real_value, enum machine_mode, unsigned);



extern int get_pool_size (void);






extern void output_constant_pool (const char *, tree);
# 355 "output.h"
extern tree initializer_constant_valid_p (tree, tree);
# 365 "output.h"
extern void output_constant (tree, unsigned long, unsigned int);







extern rtx final_sequence;
# 385 "output.h"
extern FILE *asm_out_file;



extern const char *first_global_object_name;


extern const char *weak_global_object_name;






extern int current_function_is_leaf;




extern int current_function_nothrow;





extern int current_function_sp_is_unchanging;





extern int current_function_uses_only_leaf_regs;




extern FILE *rtl_dump_file;



extern rtx current_insn_predicate;


extern rtx current_output_insn;




extern rtx this_is_asm_operands;



extern _Bool decl_readonly_section (tree, int);
extern _Bool decl_readonly_section_1 (tree, int, int);



extern int compute_reloc_for_constant (tree);


extern const char *user_label_prefix;


extern void default_function_pro_epilogue (FILE *, long);


extern void default_exception_section (void);


extern void named_section_eh_frame_section (void);
extern void collect2_eh_frame_section (void);
extern void default_eh_frame_section (void);


extern void no_asm_to_stream (FILE *);
# 478 "output.h"
extern unsigned int get_named_section_flags (const char *);
extern _Bool set_named_section_flags (const char *, unsigned int);
extern void named_section_flags (const char *, unsigned int);
extern _Bool named_section_first_declaration (const char *);
extern unsigned int default_section_type_flags (tree, const char *, int);
extern unsigned int default_section_type_flags_1 (tree, const char *, int, int);

extern void default_no_named_section (const char *, unsigned int);
extern void default_elf_asm_named_section (const char *, unsigned int);
extern void default_coff_asm_named_section (const char *, unsigned int);
extern void default_pe_asm_named_section (const char *, unsigned int);

extern void default_stabs_asm_out_destructor (rtx, int);
extern void default_named_section_asm_out_destructor (rtx, int);
extern void default_dtor_section_asm_out_destructor (rtx, int);
extern void default_stabs_asm_out_constructor (rtx, int);
extern void default_named_section_asm_out_constructor (rtx, int);
extern void default_ctor_section_asm_out_constructor (rtx, int);

extern void default_select_section (tree, int, unsigned long);
extern void default_elf_select_section (tree, int, unsigned long);
extern void default_elf_select_section_1 (tree, int,
       unsigned long, int);
extern void default_unique_section (tree, int);
extern void default_unique_section_1 (tree, int, int);
extern void default_select_rtx_section (enum machine_mode, rtx,
     unsigned long);
extern void default_elf_select_rtx_section (enum machine_mode, rtx,
         unsigned long);
extern void default_encode_section_info (tree, rtx, int);
extern const char *default_strip_name_encoding (const char *);
extern _Bool default_binds_local_p (tree);
extern _Bool default_binds_local_p_1 (tree, int);
extern void default_globalize_label (FILE *, const char *);
extern void default_internal_label (FILE *, const char *, unsigned long);
extern void default_file_start (void);
extern void file_end_indicate_exec_stack (void);
extern _Bool default_valid_pointer_mode (enum machine_mode);

extern int default_address_cost (rtx);
# 105 "reload.c" 2
# 1 "function.h" 1
# 25 "function.h"
struct var_refs_queue
{
  rtx modified;
  enum machine_mode promoted_mode;
  int unsignedp;
  struct var_refs_queue *next;
};






struct sequence_stack
{

  rtx first;
  rtx last;
  tree sequence_rtl_expr;
  struct sequence_stack *next;
};

extern struct sequence_stack *sequence_stack;



struct simple_obstack_stack
{
  struct obstack *obstack;
  struct simple_obstack_stack *next;
};

struct emit_status
{


  int x_reg_rtx_no;


  int x_first_label_num;






  rtx x_first_insn;
  rtx x_last_insn;




  tree sequence_rtl_expr;





  struct sequence_stack *sequence_stack;



  int x_cur_insn_uid;



  location_t x_last_location;





  int regno_pointer_align_length;




  unsigned char *
    regno_pointer_align;






  rtx * x_regno_reg_rtx;
};
# 121 "function.h"
struct expr_status
{


  int x_pending_stack_adjust;
# 142 "function.h"
  int x_inhibit_defer_pop;





  int x_stack_pointer_delta;




  rtx x_saveregs_value;


  rtx x_apply_args_value;


  rtx x_forced_labels;


  rtx x_pending_chain;
};
# 176 "function.h"
struct function
{
  struct eh_status *eh;
  struct stmt_status *stmt;
  struct expr_status *expr;
  struct emit_status *emit;
  struct varasm_status *varasm;




  tree decl;


  struct function *outer;




  int pops_args;




  int args_size;




  int pretend_args_size;



  int outgoing_args_size;



  rtx arg_offset_rtx;



  CUMULATIVE_ARGS args_info;





  rtx return_rtx;


  rtx internal_arg_pointer;



  const char *cannot_inline;



  struct initial_value_struct *hard_reg_initial_vals;


  int x_function_call_count;




  tree x_nonlocal_labels;





  rtx x_nonlocal_goto_handler_slots;



  rtx x_nonlocal_goto_handler_labels;




  rtx x_nonlocal_goto_stack_level;





  rtx x_cleanup_label;




  rtx x_return_label;




  rtx x_naked_return_label;


  rtx computed_goto_common_label;
  rtx computed_goto_common_reg;



  rtx x_save_expr_regs;



  rtx x_stack_slot_list;


  tree x_rtl_expr_chain;



  rtx x_tail_recursion_label;


  rtx x_tail_recursion_reentry;





  rtx x_arg_pointer_save_area;




  rtx x_clobber_return_insn;




  long x_frame_offset;




  tree x_context_display;
# 325 "function.h"
  tree x_trampoline_list;


  rtx x_parm_birth_insn;



  rtx x_last_parm_insn;



  unsigned int x_max_parm_reg;





  rtx * x_parm_reg_stack_loc;


  struct temp_slot *x_temp_slots;


  int x_temp_slot_level;


  int x_var_temp_slot_level;





  int x_target_temp_slot_level;



  struct var_refs_queue *fixup_var_refs_queue;


  int inlinable;
  int no_debugging_symbols;
  rtvec original_arg_vector;
  tree original_decl_initial;


  rtx inl_last_parm_insn;

  int inl_max_label_num;


  int funcdef_no;




  struct machine_function * machine;

  int stack_alignment_needed;

  int preferred_stack_boundary;

  _Bool recursive_call_emit;


  struct language_function * language;





  rtx epilogue_delay_list;



  enum function_frequency {


    FUNCTION_FREQUENCY_UNLIKELY_EXECUTED,

    FUNCTION_FREQUENCY_NORMAL,


    FUNCTION_FREQUENCY_HOT
  } function_frequency;



  int max_jumptable_ents;





  unsigned int returns_struct : 1;



  unsigned int returns_pcc_struct : 1;


  unsigned int returns_pointer : 1;


  unsigned int needs_context : 1;


  unsigned int calls_setjmp : 1;


  unsigned int calls_longjmp : 1;



  unsigned int calls_alloca : 1;


  unsigned int calls_eh_return : 1;


  unsigned int calls_constant_p : 1;



  unsigned int has_nonlocal_label : 1;



  unsigned int has_nonlocal_goto : 1;


  unsigned int contains_functions : 1;


  unsigned int has_computed_jump : 1;





  unsigned int is_thunk : 1;






  unsigned int all_throwers_are_sibcalls : 1;



  unsigned int instrument_entry_exit : 1;


  unsigned int profile : 1;



  unsigned int limit_stack : 1;


  unsigned int stdarg : 1;





  unsigned int x_whole_function_mode_p : 1;
# 500 "function.h"
  unsigned int x_dont_save_pending_sizes_p : 1;


  unsigned int uses_const_pool : 1;


  unsigned int uses_pic_offset_table : 1;


  unsigned int uses_eh_lsda : 1;


  unsigned int arg_pointer_save_area_init : 1;



  unsigned int rtl_inline_init : 1;


  unsigned int saved_for_inline : 1;
};


extern struct function *cfun;


extern struct function *outer_function_chain;


extern int virtuals_instantiated;


extern int trampolines_created;
# 594 "function.h"
extern tree inline_function_decl;



struct function *find_function_data (tree);


extern void identify_blocks (void);



extern void reorder_blocks (void);


extern void number_blocks (tree);




extern long get_frame_size (void);

extern long get_func_frame_size (struct function *);



extern struct machine_function * (*init_machine_status) (void);


extern void restore_emit_status (struct function *);
extern void free_after_parsing (struct function *);
extern void free_after_compilation (struct function *);

extern void init_varasm_status (struct function *);


extern void diddle_return_value (void (*)(rtx, void*), void*);
extern void clobber_return_register (void);
extern void use_return_register (void);


extern rtx get_arg_pointer_save_area (struct function *);

extern void init_virtual_regs (struct emit_status *);


extern const char *current_function_name (void);


extern void init_function_once (void);
# 106 "reload.c" 2
# 1 "toplev.h" 1
# 30 "toplev.h"
extern int toplev_main (unsigned int, const char **);
extern int read_integral_parameter (const char *, const char *, const int);
extern void strip_off_ending (char *, int);
extern const char *trim_filename (const char *);
extern void _fatal_insn_not_found (rtx, const char *, int, const char *)
     __attribute__ ((__noreturn__));
extern void _fatal_insn (const char *, rtx, const char *, int, const char *)
     __attribute__ ((__noreturn__));
# 57 "toplev.h"
extern void internal_error (const char *, ...) __attribute__ ((__format__ (__gcc_diag__, 1, 2))) __attribute__ ((__nonnull__ (1)))
     __attribute__ ((__noreturn__));
extern void warning (const char *, ...);
extern void error (const char *, ...);
extern void fatal_error (const char *, ...) __attribute__ ((__format__ (__gcc_diag__, 1, 2))) __attribute__ ((__nonnull__ (1)))
     __attribute__ ((__noreturn__));
extern void pedwarn (const char *, ...);
extern void sorry (const char *, ...);
extern void inform (const char *, ...) __attribute__ ((__format__ (__gcc_diag__, 1, 2))) __attribute__ ((__nonnull__ (1)));

extern void rest_of_decl_compilation (tree, const char *, int, int);
extern void rest_of_type_compilation (tree, int);
extern void rest_of_compilation (tree);
extern void tree_rest_of_compilation (tree, _Bool);

extern void announce_function (tree);

extern void error_for_asm (rtx, const char *, ...) __attribute__ ((__format__ (__gcc_diag__, 2, 3))) __attribute__ ((__nonnull__ (2)));
extern void warning_for_asm (rtx, const char *, ...) __attribute__ ((__format__ (__gcc_diag__, 2, 3))) __attribute__ ((__nonnull__ (2)));
extern void warn_deprecated_use (tree);


extern void output_quoted_string (FILE *, const char *);
extern void output_file_directive (FILE *, const char *);





extern void fnotice (FILE *, const char *, ...)
     __attribute__ ((__format__ (__printf__, 2, 3))) __attribute__ ((__nonnull__ (2)));


extern int wrapup_global_declarations (tree *, int);
extern void check_global_declarations (tree *, int);
extern void write_global_declarations (void);


extern unsigned local_tick;

extern const char *progname;
extern const char *dump_base_name;
extern const char *aux_base_name;
extern const char *aux_info_file_name;
extern const char *asm_file_name;
extern _Bool exit_after_options;
extern _Bool version_flag;

extern int target_flags_explicit;


extern int flag_loop_optimize;
extern int flag_crossjumping;
extern int flag_if_conversion;
extern int flag_if_conversion2;
extern int flag_delete_null_pointer_checks;
extern int flag_keep_static_consts;
extern int flag_peel_loops;
extern int flag_rerun_cse_after_loop;
extern int flag_thread_jumps;
extern int flag_tracer;
extern int flag_unroll_loops;
extern int flag_unroll_all_loops;
extern int flag_unswitch_loops;
extern int flag_cprop_registers;
extern int time_report;
extern int flag_new_regalloc;


extern void display_target_options (void);
extern void print_version (FILE *, const char *);
extern void set_target_switch (const char *);
extern void * default_get_pch_validity (size_t *);
extern const char * default_pch_valid_p (const void *, size_t);


extern struct ht *ident_hash;




extern void set_fast_math_flags (int);


extern void decode_d_option (const char *);


extern _Bool fast_math_flags_set_p (void);
# 153 "toplev.h"
extern int exact_log2_wide (unsigned long);
extern int floor_log2_wide (unsigned long);




extern const char *get_src_pwd (void);
extern _Bool set_src_pwd (const char *);
# 107 "reload.c" 2
# 1 "params.h" 1
# 44 "params.h"
typedef struct param_info
{


  const char *const option;

  int value;

  const char *const help;
} param_info;




extern param_info *compiler_params;



extern void add_params (const param_info params[], size_t n);



extern void set_param_value (const char *name, int value);




typedef enum compiler_param
{


# 1 "params.def" 1
# 51 "params.def"
PARAM_MAX_INLINE_INSNS_SINGLE,
# 63 "params.def"
PARAM_MAX_INLINE_INSNS_AUTO,
# 73 "params.def"
PARAM_MAX_INLINE_INSNS_RTL,
# 84 "params.def"
PARAM_MAX_DELAY_SLOT_INSN_SEARCH,
# 95 "params.def"
PARAM_MAX_DELAY_SLOT_LIVE_SEARCH,
# 105 "params.def"
PARAM_MAX_PENDING_LIST_LENGTH,




PARAM_LARGE_FUNCTION_INSNS,



PARAM_LARGE_FUNCTION_GROWTH,



PARAM_INLINE_UNIT_GROWTH,






PARAM_MAX_GCSE_MEMORY,




PARAM_MAX_GCSE_PASSES,
# 142 "params.def"
PARAM_MAX_UNROLLED_INSNS,





PARAM_MAX_AVERAGE_UNROLLED_INSNS,




PARAM_MAX_UNROLL_TIMES,




PARAM_MAX_PEELED_INSNS,




PARAM_MAX_PEEL_TIMES,




PARAM_MAX_COMPLETELY_PEELED_INSNS,




PARAM_MAX_COMPLETELY_PEEL_TIMES,




PARAM_MAX_ONCE_PEELED_INSNS,





PARAM_MAX_UNSWITCH_INSNS,




PARAM_MAX_UNSWITCH_LEVEL,




HOT_BB_COUNT_FRACTION,




HOT_BB_FREQUENCY_FRACTION,




TRACER_DYNAMIC_COVERAGE_FEEDBACK,




TRACER_DYNAMIC_COVERAGE,




TRACER_MAX_CODE_GROWTH,



TRACER_MIN_BRANCH_RATIO,




TRACER_MIN_BRANCH_PROBABILITY_FEEDBACK,




TRACER_MIN_BRANCH_PROBABILITY,






PARAM_MAX_CROSSJUMP_EDGES,





PARAM_MAX_CSE_PATH_LENGTH,




PARAM_MAX_CSELIB_MEMORY_LOCATIONS,
# 259 "params.def"
GGC_MIN_EXPAND,





GGC_MIN_HEAPSIZE,







PARAM_MAX_RELOAD_SEARCH_INSNS,
# 76 "params.h" 2

  LAST_PARAM
} compiler_param;
# 108 "reload.c" 2
# 119 "reload.c"
int n_reloads;
struct reload rld[(2 * 30 * (2 + 1))];



int n_earlyclobbers;
rtx reload_earlyclobbers[30];

int reload_n_operands;
# 137 "reload.c"
static int replace_reloads;


struct replacement
{
  rtx *where;
  rtx *subreg_loc;

  int what;
  enum machine_mode mode;
};

static struct replacement replacements[30 * ((2 * 2) + 1)];


static int n_replacements;


struct decomposition
{
  int reg_flag;
  int safe;
  rtx base;
  long start;
  long end;
};
# 174 "reload.c"
static rtx secondary_memlocs[NUM_MACHINE_MODES];
static rtx secondary_memlocs_elim[NUM_MACHINE_MODES][30];
static int secondary_memlocs_elim_used = 0;




static rtx this_insn;


static int this_insn_is_asm;




static int hard_regs_live_known;





static short *static_reload_reg_p;


static int subst_reg_equivs_changed;



static int output_reloadnum;
# 239 "reload.c"
static int push_secondary_reload (int, rtx, int, int, enum reg_class,
      enum machine_mode, enum reload_type,
      enum insn_code *);

static enum reg_class find_valid_class (enum machine_mode, int, unsigned int);
static int reload_inner_reg_of_subreg (rtx, enum machine_mode, int);
static void push_replacement (rtx *, int, enum machine_mode);
static void dup_replacements (rtx *, rtx *);
static void combine_reloads (void);
static int find_reusable_reload (rtx *, rtx, enum reg_class,
     enum reload_type, int, int);
static rtx find_dummy_reload (rtx, rtx, rtx *, rtx *, enum machine_mode,
         enum machine_mode, enum reg_class, int, int);
static int hard_reg_set_here_p (unsigned int, unsigned int, rtx);
static struct decomposition decompose (rtx);
static int immune_p (rtx, rtx, struct decomposition);
static int alternative_allows_memconst (const char *, int);
static rtx find_reloads_toplev (rtx, int, enum reload_type, int, int, rtx,
    int *);
static rtx make_memloc (rtx, int);
static int maybe_memory_address_p (enum machine_mode, rtx, rtx *);
static int find_reloads_address (enum machine_mode, rtx *, rtx, rtx *,
     int, enum reload_type, int, rtx);
static rtx subst_reg_equivs (rtx, rtx);
static rtx subst_indexed_address (rtx);
static void update_auto_inc_notes (rtx, int, int);
static int find_reloads_address_1 (enum machine_mode, rtx, int, rtx *,
       int, enum reload_type,int, rtx);
static void find_reloads_address_part (rtx, rtx *, enum reg_class,
           enum machine_mode, int,
           enum reload_type, int);
static rtx find_reloads_subreg_address (rtx, int, int, enum reload_type,
     int, rtx);
static void copy_replacements_1 (rtx *, rtx *, int);
static int find_inc_amount (rtx, rtx);
# 286 "reload.c"
static int
push_secondary_reload (int in_p, rtx x, int opnum, int optional,
         enum reg_class reload_class,
         enum machine_mode reload_mode, enum reload_type type,
         enum insn_code *picode)
{
  enum reg_class class = NO_REGS;
  enum machine_mode mode = reload_mode;
  enum insn_code icode = CODE_FOR_nothing;
  enum reg_class t_class = NO_REGS;
  enum machine_mode t_mode = VOIDmode;
  enum insn_code t_icode = CODE_FOR_nothing;
  enum reload_type secondary_type;
  int s_reload, t_reload = -1;

  if (type == RELOAD_FOR_INPUT_ADDRESS
      || type == RELOAD_FOR_OUTPUT_ADDRESS
      || type == RELOAD_FOR_INPADDR_ADDRESS
      || type == RELOAD_FOR_OUTADDR_ADDRESS)
    secondary_type = type;
  else
    secondary_type = in_p ? RELOAD_FOR_INPUT_ADDRESS : RELOAD_FOR_OUTPUT_ADDRESS;

  *picode = CODE_FOR_nothing;



  if (((enum rtx_code) (x)->code) == SUBREG
      && (((unsigned short) mode_size[((enum machine_mode) (x)->mode)])
   > ((unsigned short) mode_size[((enum machine_mode) ((((x)->u.fld[0]).rtx))->mode)])))
    {
      x = (((x)->u.fld[0]).rtx);
      reload_mode = ((enum machine_mode) (x)->mode);
    }







  if (((enum rtx_code) (x)->code) == REG && (((x)->u.fld[0]).rtuint) >= 53
      && reg_equiv_mem[(((x)->u.fld[0]).rtuint)] != 0)
    x = reg_equiv_mem[(((x)->u.fld[0]).rtuint)];







  if (! in_p)
    class = (((reload_class) == GENERAL_REGS || (reload_class) == LEGACY_REGS || (reload_class) == INDEX_REGS) && !0 && (reload_mode) == QImode ? Q_REGS : NO_REGS);



  if (class == NO_REGS)
    return -1;




  icode = (in_p ? reload_in_optab[(int) reload_mode]
    : reload_out_optab[(int) reload_mode]);

  if (icode != CODE_FOR_nothing
      && insn_data[(int) icode].operand[in_p].predicate
      && (! (insn_data[(int) icode].operand[in_p].predicate) (x, reload_mode)))
    icode = CODE_FOR_nothing;







  if (icode != CODE_FOR_nothing)
    {





      enum reg_class insn_class;

      if (insn_data[(int) icode].operand[!in_p].constraint[0] == 0)
 insn_class = ALL_REGS;
      else
 {
   const char *insn_constraint
     = &insn_data[(int) icode].operand[!in_p].constraint[in_p];
   char insn_letter = *insn_constraint;
   insn_class
     = (insn_letter == 'r' ? GENERAL_REGS
        : (((unsigned char) insn_letter) == 'r' ? GENERAL_REGS : ((unsigned char) insn_letter) == 'R' ? LEGACY_REGS : ((unsigned char) insn_letter) == 'q' ? 0 ? GENERAL_REGS : Q_REGS : ((unsigned char) insn_letter) == 'Q' ? Q_REGS : ((unsigned char) insn_letter) == 'f' ? ((target_flags & 0x00000001) || (target_flags & 0x00000020) ? FLOAT_REGS : NO_REGS) : ((unsigned char) insn_letter) == 't' ? ((target_flags & 0x00000001) || (target_flags & 0x00000020) ? FP_TOP_REG : NO_REGS) : ((unsigned char) insn_letter) == 'u' ? ((target_flags & 0x00000001) || (target_flags & 0x00000020) ? FP_SECOND_REG : NO_REGS) : ((unsigned char) insn_letter) == 'a' ? AREG : ((unsigned char) insn_letter) == 'b' ? BREG : ((unsigned char) insn_letter) == 'c' ? CREG : ((unsigned char) insn_letter) == 'd' ? DREG : ((unsigned char) insn_letter) == 'x' ? ((target_flags & 0x00004000) != 0) ? SSE_REGS : NO_REGS : ((unsigned char) insn_letter) == 'Y' ? ((target_flags & 0x00008000) != 0)? SSE_REGS : NO_REGS : ((unsigned char) insn_letter) == 'y' ? ((target_flags & 0x00002000) != 0) ? MMX_REGS : NO_REGS : ((unsigned char) insn_letter) == 'A' ? AD_REGS : ((unsigned char) insn_letter) == 'D' ? DIREG : ((unsigned char) insn_letter) == 'S' ? SIREG : NO_REGS));


          if (insn_class == NO_REGS)
     fancy_abort ("reload.c", 384, __FUNCTION__);
   if (in_p
       && insn_data[(int) icode].operand[!in_p].constraint[0] != '=')
     fancy_abort ("reload.c", 387, __FUNCTION__);
 }


      if (insn_data[(int) icode].operand[2].constraint[0] != '='
   || insn_data[(int) icode].operand[2].constraint[1] != '&')
 fancy_abort ("reload.c", 393, __FUNCTION__);

      if (reg_class_subset_p (reload_class, insn_class))
 mode = insn_data[(int) icode].operand[2].mode;
      else
 {
   const char *t_constraint
     = &insn_data[(int) icode].operand[2].constraint[2];
   char t_letter = *t_constraint;
   class = insn_class;
   t_mode = insn_data[(int) icode].operand[2].mode;
   t_class = (t_letter == 'r' ? GENERAL_REGS
       : (((unsigned char) t_letter) == 'r' ? GENERAL_REGS : ((unsigned char) t_letter) == 'R' ? LEGACY_REGS : ((unsigned char) t_letter) == 'q' ? 0 ? GENERAL_REGS : Q_REGS : ((unsigned char) t_letter) == 'Q' ? Q_REGS : ((unsigned char) t_letter) == 'f' ? ((target_flags & 0x00000001) || (target_flags & 0x00000020) ? FLOAT_REGS : NO_REGS) : ((unsigned char) t_letter) == 't' ? ((target_flags & 0x00000001) || (target_flags & 0x00000020) ? FP_TOP_REG : NO_REGS) : ((unsigned char) t_letter) == 'u' ? ((target_flags & 0x00000001) || (target_flags & 0x00000020) ? FP_SECOND_REG : NO_REGS) : ((unsigned char) t_letter) == 'a' ? AREG : ((unsigned char) t_letter) == 'b' ? BREG : ((unsigned char) t_letter) == 'c' ? CREG : ((unsigned char) t_letter) == 'd' ? DREG : ((unsigned char) t_letter) == 'x' ? ((target_flags & 0x00004000) != 0) ? SSE_REGS : NO_REGS : ((unsigned char) t_letter) == 'Y' ? ((target_flags & 0x00008000) != 0)? SSE_REGS : NO_REGS : ((unsigned char) t_letter) == 'y' ? ((target_flags & 0x00002000) != 0) ? MMX_REGS : NO_REGS : ((unsigned char) t_letter) == 'A' ? AD_REGS : ((unsigned char) t_letter) == 'D' ? DIREG : ((unsigned char) t_letter) == 'S' ? SIREG : NO_REGS));

   t_icode = icode;
   icode = CODE_FOR_nothing;
 }
    }
# 426 "reload.c"
  if (in_p && class == reload_class && icode == CODE_FOR_nothing
      && t_icode == CODE_FOR_nothing)
    fancy_abort ("reload.c", 428, __FUNCTION__);




  if (t_class != NO_REGS)
    {
      for (t_reload = 0; t_reload < n_reloads; t_reload++)
 if (rld[t_reload].secondary_p
     && (reg_class_subset_p (t_class, rld[t_reload].class)
  || reg_class_subset_p (rld[t_reload].class, t_class))
     && ((in_p && rld[t_reload].inmode == t_mode)
  || (! in_p && rld[t_reload].outmode == t_mode))
     && ((in_p && (rld[t_reload].secondary_in_icode
     == CODE_FOR_nothing))
  || (! in_p &&(rld[t_reload].secondary_out_icode
         == CODE_FOR_nothing)))
     && (reg_class_size[(int) t_class] == 1 || 1)
     && ((secondary_type) == RELOAD_OTHER || (rld[t_reload].when_needed) == RELOAD_OTHER || ((secondary_type) == (rld[t_reload].when_needed) && (opnum) == (rld[t_reload].opnum)) || ((secondary_type) == RELOAD_FOR_INPUT && (rld[t_reload].when_needed) == RELOAD_FOR_INPUT) || ((secondary_type) == RELOAD_FOR_OPERAND_ADDRESS && (rld[t_reload].when_needed) == RELOAD_FOR_OPERAND_ADDRESS) || ((secondary_type) == RELOAD_FOR_OTHER_ADDRESS && (rld[t_reload].when_needed) == RELOAD_FOR_OTHER_ADDRESS)))


   {
     if (in_p)
       rld[t_reload].inmode = t_mode;
     if (! in_p)
       rld[t_reload].outmode = t_mode;

     if (reg_class_subset_p (t_class, rld[t_reload].class))
       rld[t_reload].class = t_class;

     rld[t_reload].opnum = ((rld[t_reload].opnum) < (opnum) ? (rld[t_reload].opnum) : (opnum));
     rld[t_reload].optional &= optional;
     rld[t_reload].secondary_p = 1;
     if (((secondary_type) != (rld[t_reload].when_needed) || ! ((opnum) == (rld[t_reload].opnum) || (secondary_type) == RELOAD_FOR_INPUT || (secondary_type) == RELOAD_FOR_OPERAND_ADDRESS || (secondary_type) == RELOAD_FOR_OTHER_ADDRESS)))

       rld[t_reload].when_needed = RELOAD_OTHER;
   }

      if (t_reload == n_reloads)
 {

   rld[t_reload].in = rld[t_reload].out = 0;
   rld[t_reload].class = t_class;
   rld[t_reload].inmode = in_p ? t_mode : VOIDmode;
   rld[t_reload].outmode = ! in_p ? t_mode : VOIDmode;
   rld[t_reload].reg_rtx = 0;
   rld[t_reload].optional = optional;
   rld[t_reload].inc = 0;

   rld[t_reload].nocombine = 1;
   rld[t_reload].in_reg = 0;
   rld[t_reload].out_reg = 0;
   rld[t_reload].opnum = opnum;
   rld[t_reload].when_needed = secondary_type;
   rld[t_reload].secondary_in_reload = -1;
   rld[t_reload].secondary_out_reload = -1;
   rld[t_reload].secondary_in_icode = CODE_FOR_nothing;
   rld[t_reload].secondary_out_icode = CODE_FOR_nothing;
   rld[t_reload].secondary_p = 1;

   n_reloads++;
 }
    }


  for (s_reload = 0; s_reload < n_reloads; s_reload++)
    if (rld[s_reload].secondary_p
 && (reg_class_subset_p (class, rld[s_reload].class)
     || reg_class_subset_p (rld[s_reload].class, class))
 && ((in_p && rld[s_reload].inmode == mode)
     || (! in_p && rld[s_reload].outmode == mode))
 && ((in_p && rld[s_reload].secondary_in_reload == t_reload)
     || (! in_p && rld[s_reload].secondary_out_reload == t_reload))
 && ((in_p && rld[s_reload].secondary_in_icode == t_icode)
     || (! in_p && rld[s_reload].secondary_out_icode == t_icode))
 && (reg_class_size[(int) class] == 1 || 1)
 && ((secondary_type) == RELOAD_OTHER || (rld[s_reload].when_needed) == RELOAD_OTHER || ((secondary_type) == (rld[s_reload].when_needed) && (opnum) == (rld[s_reload].opnum)) || ((secondary_type) == RELOAD_FOR_INPUT && (rld[s_reload].when_needed) == RELOAD_FOR_INPUT) || ((secondary_type) == RELOAD_FOR_OPERAND_ADDRESS && (rld[s_reload].when_needed) == RELOAD_FOR_OPERAND_ADDRESS) || ((secondary_type) == RELOAD_FOR_OTHER_ADDRESS && (rld[s_reload].when_needed) == RELOAD_FOR_OTHER_ADDRESS)))

      {
 if (in_p)
   rld[s_reload].inmode = mode;
 if (! in_p)
   rld[s_reload].outmode = mode;

 if (reg_class_subset_p (class, rld[s_reload].class))
   rld[s_reload].class = class;

 rld[s_reload].opnum = ((rld[s_reload].opnum) < (opnum) ? (rld[s_reload].opnum) : (opnum));
 rld[s_reload].optional &= optional;
 rld[s_reload].secondary_p = 1;
 if (((secondary_type) != (rld[s_reload].when_needed) || ! ((opnum) == (rld[s_reload].opnum) || (secondary_type) == RELOAD_FOR_INPUT || (secondary_type) == RELOAD_FOR_OPERAND_ADDRESS || (secondary_type) == RELOAD_FOR_OTHER_ADDRESS)))

   rld[s_reload].when_needed = RELOAD_OTHER;
      }

  if (s_reload == n_reloads)
    {






      if (in_p && icode == CODE_FOR_nothing
   && ix86_secondary_memory_needed ((class), (reload_class), (mode), 1))
 {
   get_secondary_mem (x, reload_mode, opnum, type);



   s_reload = n_reloads;
 }



      rld[s_reload].in = rld[s_reload].out = 0;
      rld[s_reload].class = class;

      rld[s_reload].inmode = in_p ? mode : VOIDmode;
      rld[s_reload].outmode = ! in_p ? mode : VOIDmode;
      rld[s_reload].reg_rtx = 0;
      rld[s_reload].optional = optional;
      rld[s_reload].inc = 0;

      rld[s_reload].nocombine = 1;
      rld[s_reload].in_reg = 0;
      rld[s_reload].out_reg = 0;
      rld[s_reload].opnum = opnum;
      rld[s_reload].when_needed = secondary_type;
      rld[s_reload].secondary_in_reload = in_p ? t_reload : -1;
      rld[s_reload].secondary_out_reload = ! in_p ? t_reload : -1;
      rld[s_reload].secondary_in_icode = in_p ? t_icode : CODE_FOR_nothing;
      rld[s_reload].secondary_out_icode
 = ! in_p ? t_icode : CODE_FOR_nothing;
      rld[s_reload].secondary_p = 1;

      n_reloads++;


      if (! in_p && icode == CODE_FOR_nothing
   && ix86_secondary_memory_needed ((reload_class), (class), (mode), 1))
 get_secondary_mem (x, mode, opnum, type);

    }

  *picode = icode;
  return s_reload;
}
# 584 "reload.c"
rtx
get_secondary_mem (rtx x __attribute__ ((__unused__)), enum machine_mode mode,
     int opnum, enum reload_type type)
{
  rtx loc;
  int mem_valid;
# 599 "reload.c"
  if (((unsigned short) (((unsigned short) mode_size[mode]) * 8)) < (8 * (0 ? 8 : 4)) && (mode_class[mode] == MODE_INT || mode_class[mode] == MODE_PARTIAL_INT || mode_class[mode] == MODE_COMPLEX_INT || mode_class[mode] == MODE_VECTOR_INT))
    mode = mode_for_size ((8 * (0 ? 8 : 4)), mode_class[mode], 0);



  if (secondary_memlocs_elim[(int) mode][opnum] != 0)
    return secondary_memlocs_elim[(int) mode][opnum];





  if (secondary_memlocs[(int) mode] == 0)
    {



      secondary_memlocs[(int) mode]
 = assign_stack_local (mode, ((unsigned short) mode_size[mode]), 0);

    }




  loc = eliminate_regs (secondary_memlocs[(int) mode], VOIDmode, (rtx) 0);
  mem_valid = strict_memory_address_p (mode, (((loc)->u.fld[0]).rtx));

  if (! mem_valid && loc == secondary_memlocs[(int) mode])
    loc = copy_rtx (loc);
# 637 "reload.c"
  if (! mem_valid)
    {
      type = (type == RELOAD_FOR_INPUT ? RELOAD_FOR_INPUT_ADDRESS
        : type == RELOAD_FOR_OUTPUT ? RELOAD_FOR_OUTPUT_ADDRESS
        : RELOAD_OTHER);

      find_reloads_address (mode, &loc, (((loc)->u.fld[0]).rtx), &(((loc)->u.fld[0]).rtx),
       opnum, type, 0, 0);
    }

  secondary_memlocs_elim[(int) mode][opnum] = loc;
  if (secondary_memlocs_elim_used <= (int)mode)
    secondary_memlocs_elim_used = (int)mode + 1;
  return loc;
}



void
clear_secondary_mem (void)
{
  memset (secondary_memlocs, 0, sizeof secondary_memlocs);
}






static enum reg_class
find_valid_class (enum machine_mode m1 __attribute__ ((__unused__)), int n,
    unsigned int dest_regno __attribute__ ((__unused__)))
{
  int best_cost = -1;
  int class;
  int regno;
  enum reg_class best_class = NO_REGS;
  enum reg_class dest_class __attribute__ ((__unused__)) = (regclass_map[dest_regno]);
  unsigned int best_size = 0;
  int cost;

  for (class = 1; class < ((int) LIM_REG_CLASSES); class++)
    {
      int bad = 0;
      for (regno = 0; regno < 53 && ! bad; regno++)
 if ((!!((reg_class_contents[class])[(regno) / ((unsigned) (8 * 4))] & (((HARD_REG_ELT_TYPE) (1)) << ((regno) % ((unsigned) (8 * 4))))))
     && (!!((reg_class_contents[class])[(regno + n) / ((unsigned) (8 * 4))] & (((HARD_REG_ELT_TYPE) (1)) << ((regno + n) % ((unsigned) (8 * 4))))))
     && ! ix86_hard_regno_mode_ok ((regno + n), (m1)))
   bad = 1;

      if (bad)
 continue;
      cost = ix86_register_move_cost ((m1), (class), (dest_class));

      if ((reg_class_size[class] > best_size
    && (best_cost < 0 || best_cost >= cost))
   || best_cost > cost)
 {
   best_class = class;
   best_size = reg_class_size[class];
   best_cost = ix86_register_move_cost ((m1), (class), (dest_class));
 }
    }

  if (best_size == 0)
    fancy_abort ("reload.c", 702, __FUNCTION__);

  return best_class;
}
# 715 "reload.c"
static int
find_reusable_reload (rtx *p_in, rtx out, enum reg_class class,
        enum reload_type type, int opnum, int dont_share)
{
  rtx in = *p_in;
  int i;



  if (earlyclobber_operand_p (out))
    return n_reloads;
# 736 "reload.c"
  for (i = 0; i < n_reloads; i++)
    if ((reg_class_subset_p (class, rld[i].class)
  || reg_class_subset_p (rld[i].class, class))

 && (rld[i].reg_rtx == 0
     || (!!((reg_class_contents[(int) class])[(true_regnum (rld[i].reg_rtx)) / ((unsigned) (8 * 4))] & (((HARD_REG_ELT_TYPE) (1)) << ((true_regnum (rld[i].reg_rtx)) % ((unsigned) (8 * 4)))))))

 && ((in != 0 && (rld[i].in == in || (rld[i].in != 0 && (((enum rtx_code) (rld[i].in)->code) == REG ? ((enum rtx_code) (in)->code) == REG && (((rld[i].in)->u.fld[0]).rtuint) == (((in)->u.fld[0]).rtuint) : rtx_equal_p (rld[i].in, in) && ! side_effects_p (rld[i].in)))) && ! dont_share
      && (out == 0 || rld[i].out == 0 || (rld[i].out == out || (rld[i].out != 0 && (((enum rtx_code) (rld[i].out)->code) == REG ? ((enum rtx_code) (out)->code) == REG && (((rld[i].out)->u.fld[0]).rtuint) == (((out)->u.fld[0]).rtuint) : rtx_equal_p (rld[i].out, out) && ! side_effects_p (rld[i].out))))))
     || (out != 0 && (rld[i].out == out || (rld[i].out != 0 && (((enum rtx_code) (rld[i].out)->code) == REG ? ((enum rtx_code) (out)->code) == REG && (((rld[i].out)->u.fld[0]).rtuint) == (((out)->u.fld[0]).rtuint) : rtx_equal_p (rld[i].out, out) && ! side_effects_p (rld[i].out))))
  && (in == 0 || rld[i].in == 0 || (rld[i].in == in || (rld[i].in != 0 && (((enum rtx_code) (rld[i].in)->code) == REG ? ((enum rtx_code) (in)->code) == REG && (((rld[i].in)->u.fld[0]).rtuint) == (((in)->u.fld[0]).rtuint) : rtx_equal_p (rld[i].in, in) && ! side_effects_p (rld[i].in)))))))
 && (rld[i].out == 0 || ! earlyclobber_operand_p (rld[i].out))
 && (reg_class_size[(int) class] == 1 || 1)
 && ((type) == RELOAD_OTHER || (rld[i].when_needed) == RELOAD_OTHER || ((type) == (rld[i].when_needed) && (opnum) == (rld[i].opnum)) || ((type) == RELOAD_FOR_INPUT && (rld[i].when_needed) == RELOAD_FOR_INPUT) || ((type) == RELOAD_FOR_OPERAND_ADDRESS && (rld[i].when_needed) == RELOAD_FOR_OPERAND_ADDRESS) || ((type) == RELOAD_FOR_OTHER_ADDRESS && (rld[i].when_needed) == RELOAD_FOR_OTHER_ADDRESS)))
      return i;






  for (i = 0; i < n_reloads; i++)
    if ((reg_class_subset_p (class, rld[i].class)
  || reg_class_subset_p (rld[i].class, class))


 && (rld[i].reg_rtx == 0
     || (!!((reg_class_contents[(int) class])[(true_regnum (rld[i].reg_rtx)) / ((unsigned) (8 * 4))] & (((HARD_REG_ELT_TYPE) (1)) << ((true_regnum (rld[i].reg_rtx)) % ((unsigned) (8 * 4)))))))

 && out == 0 && rld[i].out == 0 && rld[i].in != 0
 && ((((enum rtx_code) (in)->code) == REG
      && (rtx_class[(int) (((enum rtx_code) (rld[i].in)->code))]) == 'a'
      && ((((rld[i].in)->u.fld[0]).rtx) == in || ((((rld[i].in)->u.fld[0]).rtx) != 0 && (((enum rtx_code) ((((rld[i].in)->u.fld[0]).rtx))->code) == REG ? ((enum rtx_code) (in)->code) == REG && ((((((rld[i].in)->u.fld[0]).rtx))->u.fld[0]).rtuint) == (((in)->u.fld[0]).rtuint) : rtx_equal_p ((((rld[i].in)->u.fld[0]).rtx), in) && ! side_effects_p ((((rld[i].in)->u.fld[0]).rtx))))))
     || (((enum rtx_code) (rld[i].in)->code) == REG
  && (rtx_class[(int) (((enum rtx_code) (in)->code))]) == 'a'
  && ((((in)->u.fld[0]).rtx) == rld[i].in || ((((in)->u.fld[0]).rtx) != 0 && (((enum rtx_code) ((((in)->u.fld[0]).rtx))->code) == REG ? ((enum rtx_code) (rld[i].in)->code) == REG && ((((((in)->u.fld[0]).rtx))->u.fld[0]).rtuint) == (((rld[i].in)->u.fld[0]).rtuint) : rtx_equal_p ((((in)->u.fld[0]).rtx), rld[i].in) && ! side_effects_p ((((in)->u.fld[0]).rtx)))))))
 && (rld[i].out == 0 || ! earlyclobber_operand_p (rld[i].out))
 && (reg_class_size[(int) class] == 1 || 1)
 && ((type) == RELOAD_OTHER || (rld[i].when_needed) == RELOAD_OTHER || ((type) == (rld[i].when_needed) && (opnum) == (rld[i].opnum)) || ((type) == RELOAD_FOR_INPUT && (rld[i].when_needed) == RELOAD_FOR_INPUT) || ((type) == RELOAD_FOR_OPERAND_ADDRESS && (rld[i].when_needed) == RELOAD_FOR_OPERAND_ADDRESS) || ((type) == RELOAD_FOR_OTHER_ADDRESS && (rld[i].when_needed) == RELOAD_FOR_OTHER_ADDRESS)))

      {


 if (((enum rtx_code) (in)->code) == REG)
   *p_in = rld[i].in;
 return i;
      }
  return n_reloads;
}




static int
reload_inner_reg_of_subreg (rtx x, enum machine_mode mode, int output)
{
  rtx inner;


  if (((enum rtx_code) (x)->code) != SUBREG)
    return 0;

  inner = (((x)->u.fld[0]).rtx);


  if ((((enum rtx_code) (inner)->code) == LABEL_REF || ((enum rtx_code) (inner)->code) == SYMBOL_REF || ((enum rtx_code) (inner)->code) == CONST_INT || ((enum rtx_code) (inner)->code) == CONST_DOUBLE || ((enum rtx_code) (inner)->code) == CONST || ((enum rtx_code) (inner)->code) == HIGH || ((enum rtx_code) (inner)->code) == CONST_VECTOR || ((enum rtx_code) (inner)->code) == CONSTANT_P_RTX) || ((enum rtx_code) (inner)->code) == PLUS)
    return 1;



  if (((enum rtx_code) (inner)->code) != REG
      || (((inner)->u.fld[0]).rtuint) >= 53)
    return 0;


  if (! ix86_hard_regno_mode_ok ((subreg_regno (x)), (mode)))
    return 1;




  return (((unsigned short) mode_size[mode]) <= (0 ? 8 : 4)
   && output
   && ((unsigned short) mode_size[((enum machine_mode) (inner)->mode)]) > (0 ? 8 : 4)
   && ((((unsigned short) mode_size[((enum machine_mode) (inner)->mode)]) / (0 ? 8 : 4))
       != (int) ((((((inner)->u.fld[0]).rtuint)) >= 8 && ((((inner)->u.fld[0]).rtuint)) <= (8 + 7)) || ((((((inner)->u.fld[0]).rtuint)) >= (20 + 1) && ((((inner)->u.fld[0]).rtuint)) <= ((20 + 1) + 7)) || (((((inner)->u.fld[0]).rtuint)) >= (((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) && ((((inner)->u.fld[0]).rtuint)) <= ((((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) + 7))) || (((((inner)->u.fld[0]).rtuint)) >= (((20 + 1) + 7) + 1) && ((((inner)->u.fld[0]).rtuint)) <= ((((20 + 1) + 7) + 1) + 7)) ? ((mode_class[((enum machine_mode) (inner)->mode)] == MODE_COMPLEX_INT || mode_class[((enum machine_mode) (inner)->mode)] == MODE_COMPLEX_FLOAT) ? 2 : 1) : ((((enum machine_mode) (inner)->mode)) == XFmode ? (0 ? 2 : 3) : (((enum machine_mode) (inner)->mode)) == XCmode ? (0 ? 4 : 6) : ((((unsigned short) mode_size[((enum machine_mode) (inner)->mode)]) + (0 ? 8 : 4) - 1) / (0 ? 8 : 4))))));
}
# 838 "reload.c"
static int
can_reload_into (rtx in, int regno, enum machine_mode mode)
{
  rtx dst, test_insn;
  int r = 0;
  struct recog_data save_recog_data;






  if (((enum rtx_code) (in)->code) == REG)
    return 1;





  if (((enum rtx_code) (in)->code) == MEM)
    return 1;



  dst = gen_rtx_REG (mode, regno);
  test_insn = make_insn_raw (gen_rtx_fmt_ee (SET, (VOIDmode), (dst), (in)));
  save_recog_data = recog_data;
  if (((((test_insn)->u.fld[6]).rtint) >= 0 ? (((test_insn)->u.fld[6]).rtint) : recog_memoized_1 (test_insn)) >= 0)
    {
      extract_insn (test_insn);
      r = constrain_operands (1);
    }
  recog_data = save_recog_data;
  return r;
}
# 907 "reload.c"
int
push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,
      enum reg_class class, enum machine_mode inmode,
      enum machine_mode outmode, int strict_low, int optional,
      int opnum, enum reload_type type)
{
  int i;
  int dont_share = 0;
  int dont_remove_subreg = 0;
  rtx *in_subreg_loc = 0, *out_subreg_loc = 0;
  int secondary_in_reload = -1, secondary_out_reload = -1;
  enum insn_code secondary_in_icode = CODE_FOR_nothing;
  enum insn_code secondary_out_icode = CODE_FOR_nothing;




  if (inmode == VOIDmode && in != 0)
    inmode = ((enum machine_mode) (in)->mode);
  if (outmode == VOIDmode && out != 0)
    outmode = ((enum machine_mode) (out)->mode);





  if (in != 0 && ((enum rtx_code) (in)->code) == REG)
    {
      int regno = (((in)->u.fld[0]).rtuint);

      if (regno >= 53 && reg_renumber[regno] < 0
   && reg_equiv_constant[regno] != 0)
 in = reg_equiv_constant[regno];
    }




  if (out != 0 && ((enum rtx_code) (out)->code) == REG)
    {
      int regno = (((out)->u.fld[0]).rtuint);

      if (regno >= 53 && reg_renumber[regno] < 0
   && reg_equiv_constant[regno] != 0)
 out = reg_equiv_constant[regno];
    }



  if (in != 0 && out != 0 && ((enum rtx_code) (in)->code) == MEM && rtx_equal_p (in, out))
    switch (((enum rtx_code) ((((in)->u.fld[0]).rtx))->code))
      {
      case POST_INC: case POST_DEC: case POST_MODIFY:
 in = replace_equiv_address_nv (in, ((((((in)->u.fld[0]).rtx))->u.fld[0]).rtx));
 break;

      case PRE_INC: case PRE_DEC: case PRE_MODIFY:
 out = replace_equiv_address_nv (out, ((((((out)->u.fld[0]).rtx))->u.fld[0]).rtx));
 break;

      default:
 break;
      }
# 1001 "reload.c"
  if (in != 0 && ((enum rtx_code) (in)->code) == SUBREG
      && (subreg_lowpart_p (in) || strict_low)

      && !(((unsigned short) mode_size[inmode]) < ((unsigned short) mode_size[((enum machine_mode) ((((in)->u.fld[0]).rtx))->mode)]) ? reg_classes_intersect_p (FLOAT_SSE_REGS, (class)) || reg_classes_intersect_p (MMX_REGS, (class)) : ((unsigned short) mode_size[((enum machine_mode) ((((in)->u.fld[0]).rtx))->mode)]) != ((unsigned short) mode_size[inmode]) ? reg_classes_intersect_p (FLOAT_REGS, (class)) : 0)

      && ((((enum rtx_code) ((((in)->u.fld[0]).rtx))->code) == LABEL_REF || ((enum rtx_code) ((((in)->u.fld[0]).rtx))->code) == SYMBOL_REF || ((enum rtx_code) ((((in)->u.fld[0]).rtx))->code) == CONST_INT || ((enum rtx_code) ((((in)->u.fld[0]).rtx))->code) == CONST_DOUBLE || ((enum rtx_code) ((((in)->u.fld[0]).rtx))->code) == CONST || ((enum rtx_code) ((((in)->u.fld[0]).rtx))->code) == HIGH || ((enum rtx_code) ((((in)->u.fld[0]).rtx))->code) == CONST_VECTOR || ((enum rtx_code) ((((in)->u.fld[0]).rtx))->code) == CONSTANT_P_RTX)
   || ((enum rtx_code) ((((in)->u.fld[0]).rtx))->code) == PLUS
   || strict_low
   || (((((enum rtx_code) ((((in)->u.fld[0]).rtx))->code) == REG
  && ((((((in)->u.fld[0]).rtx))->u.fld[0]).rtuint) >= 53)
        || ((enum rtx_code) ((((in)->u.fld[0]).rtx))->code) == MEM)
       && ((((unsigned short) mode_size[inmode])
     > ((unsigned short) mode_size[((enum machine_mode) ((((in)->u.fld[0]).rtx))->mode)]))
# 1030 "reload.c"
    ))
   || (((enum rtx_code) ((((in)->u.fld[0]).rtx))->code) == REG
       && ((((((in)->u.fld[0]).rtx))->u.fld[0]).rtuint) < 53


       && (out == 0 || subreg_lowpart_p (in))
       && ((((unsigned short) mode_size[inmode]) <= (0 ? 8 : 4)
     && (((unsigned short) mode_size[((enum machine_mode) ((((in)->u.fld[0]).rtx))->mode)])
         > (0 ? 8 : 4))
     && ((((unsigned short) mode_size[((enum machine_mode) ((((in)->u.fld[0]).rtx))->mode)])
   / (0 ? 8 : 4))
         != (int) (((((((((in)->u.fld[0]).rtx))->u.fld[0]).rtuint)) >= 8 && (((((((in)->u.fld[0]).rtx))->u.fld[0]).rtuint)) <= (8 + 7)) || (((((((((in)->u.fld[0]).rtx))->u.fld[0]).rtuint)) >= (20 + 1) && (((((((in)->u.fld[0]).rtx))->u.fld[0]).rtuint)) <= ((20 + 1) + 7)) || ((((((((in)->u.fld[0]).rtx))->u.fld[0]).rtuint)) >= (((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) && (((((((in)->u.fld[0]).rtx))->u.fld[0]).rtuint)) <= ((((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) + 7))) || ((((((((in)->u.fld[0]).rtx))->u.fld[0]).rtuint)) >= (((20 + 1) + 7) + 1) && (((((((in)->u.fld[0]).rtx))->u.fld[0]).rtuint)) <= ((((20 + 1) + 7) + 1) + 7)) ? ((mode_class[((enum machine_mode) ((((in)->u.fld[0]).rtx))->mode)] == MODE_COMPLEX_INT || mode_class[((enum machine_mode) ((((in)->u.fld[0]).rtx))->mode)] == MODE_COMPLEX_FLOAT) ? 2 : 1) : ((((enum machine_mode) ((((in)->u.fld[0]).rtx))->mode)) == XFmode ? (0 ? 2 : 3) : (((enum machine_mode) ((((in)->u.fld[0]).rtx))->mode)) == XCmode ? (0 ? 4 : 6) : ((((unsigned short) mode_size[((enum machine_mode) ((((in)->u.fld[0]).rtx))->mode)]) + (0 ? 8 : 4) - 1) / (0 ? 8 : 4))))))

    || ! ix86_hard_regno_mode_ok ((subreg_regno (in)), (inmode))))
# 1052 "reload.c"
   || (((enum rtx_code) ((((in)->u.fld[0]).rtx))->code) == REG
       && ((((((in)->u.fld[0]).rtx))->u.fld[0]).rtuint) < 53
       && (((unsigned short) mode_size[inmode]) < ((unsigned short) mode_size[((enum machine_mode) ((((in)->u.fld[0]).rtx))->mode)]) ? reg_classes_intersect_p (FLOAT_SSE_REGS, ((regclass_map[((((((in)->u.fld[0]).rtx))->u.fld[0]).rtuint)]))) || reg_classes_intersect_p (MMX_REGS, ((regclass_map[((((((in)->u.fld[0]).rtx))->u.fld[0]).rtuint)]))) : ((unsigned short) mode_size[((enum machine_mode) ((((in)->u.fld[0]).rtx))->mode)]) != ((unsigned short) mode_size[inmode]) ? reg_classes_intersect_p (FLOAT_REGS, ((regclass_map[((((((in)->u.fld[0]).rtx))->u.fld[0]).rtuint)]))) : 0))


   ))
    {
      in_subreg_loc = inloc;
      inloc = &(((in)->u.fld[0]).rtx);
      in = *inloc;

      if (((enum rtx_code) (in)->code) == MEM)


 if (((unsigned short) mode_size[((enum machine_mode) (in)->mode)]) > ((unsigned short) mode_size[inmode]))
   fancy_abort ("reload.c", 1067, __FUNCTION__);

      inmode = ((enum machine_mode) (in)->mode);
    }
# 1082 "reload.c"
  if (in != 0 && reload_inner_reg_of_subreg (in, inmode, 0))
    {
      enum reg_class in_class = class;

      if (((enum rtx_code) ((((in)->u.fld[0]).rtx))->code) == REG)
 in_class
   = find_valid_class (inmode,
         subreg_regno_offset (((((((in)->u.fld[0]).rtx))->u.fld[0]).rtuint),
         ((enum machine_mode) ((((in)->u.fld[0]).rtx))->mode),
         (((in)->u.fld[1]).rtuint),
         ((enum machine_mode) (in)->mode)),
         ((((((in)->u.fld[0]).rtx))->u.fld[0]).rtuint));






      push_reload ((((in)->u.fld[0]).rtx), (rtx) 0, &(((in)->u.fld[0]).rtx), (rtx *) 0,
     in_class, VOIDmode, VOIDmode, 0, 0, opnum, type);
      dont_remove_subreg = 1;
    }







  if (out != 0 && ((enum rtx_code) (out)->code) == SUBREG
      && (subreg_lowpart_p (out) || strict_low)

      && !(((unsigned short) mode_size[outmode]) < ((unsigned short) mode_size[((enum machine_mode) ((((out)->u.fld[0]).rtx))->mode)]) ? reg_classes_intersect_p (FLOAT_SSE_REGS, (class)) || reg_classes_intersect_p (MMX_REGS, (class)) : ((unsigned short) mode_size[((enum machine_mode) ((((out)->u.fld[0]).rtx))->mode)]) != ((unsigned short) mode_size[outmode]) ? reg_classes_intersect_p (FLOAT_REGS, (class)) : 0)

      && ((((enum rtx_code) ((((out)->u.fld[0]).rtx))->code) == LABEL_REF || ((enum rtx_code) ((((out)->u.fld[0]).rtx))->code) == SYMBOL_REF || ((enum rtx_code) ((((out)->u.fld[0]).rtx))->code) == CONST_INT || ((enum rtx_code) ((((out)->u.fld[0]).rtx))->code) == CONST_DOUBLE || ((enum rtx_code) ((((out)->u.fld[0]).rtx))->code) == CONST || ((enum rtx_code) ((((out)->u.fld[0]).rtx))->code) == HIGH || ((enum rtx_code) ((((out)->u.fld[0]).rtx))->code) == CONST_VECTOR || ((enum rtx_code) ((((out)->u.fld[0]).rtx))->code) == CONSTANT_P_RTX)
   || strict_low
   || (((((enum rtx_code) ((((out)->u.fld[0]).rtx))->code) == REG
  && ((((((out)->u.fld[0]).rtx))->u.fld[0]).rtuint) >= 53)
        || ((enum rtx_code) ((((out)->u.fld[0]).rtx))->code) == MEM)
       && ((((unsigned short) mode_size[outmode])
     > ((unsigned short) mode_size[((enum machine_mode) ((((out)->u.fld[0]).rtx))->mode)]))







    ))
   || (((enum rtx_code) ((((out)->u.fld[0]).rtx))->code) == REG
       && ((((((out)->u.fld[0]).rtx))->u.fld[0]).rtuint) < 53
       && ((((unsigned short) mode_size[outmode]) <= (0 ? 8 : 4)
     && (((unsigned short) mode_size[((enum machine_mode) ((((out)->u.fld[0]).rtx))->mode)])
         > (0 ? 8 : 4))
     && ((((unsigned short) mode_size[((enum machine_mode) ((((out)->u.fld[0]).rtx))->mode)])
   / (0 ? 8 : 4))
         != (int) (((((((((out)->u.fld[0]).rtx))->u.fld[0]).rtuint)) >= 8 && (((((((out)->u.fld[0]).rtx))->u.fld[0]).rtuint)) <= (8 + 7)) || (((((((((out)->u.fld[0]).rtx))->u.fld[0]).rtuint)) >= (20 + 1) && (((((((out)->u.fld[0]).rtx))->u.fld[0]).rtuint)) <= ((20 + 1) + 7)) || ((((((((out)->u.fld[0]).rtx))->u.fld[0]).rtuint)) >= (((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) && (((((((out)->u.fld[0]).rtx))->u.fld[0]).rtuint)) <= ((((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) + 7))) || ((((((((out)->u.fld[0]).rtx))->u.fld[0]).rtuint)) >= (((20 + 1) + 7) + 1) && (((((((out)->u.fld[0]).rtx))->u.fld[0]).rtuint)) <= ((((20 + 1) + 7) + 1) + 7)) ? ((mode_class[((enum machine_mode) ((((out)->u.fld[0]).rtx))->mode)] == MODE_COMPLEX_INT || mode_class[((enum machine_mode) ((((out)->u.fld[0]).rtx))->mode)] == MODE_COMPLEX_FLOAT) ? 2 : 1) : ((((enum machine_mode) ((((out)->u.fld[0]).rtx))->mode)) == XFmode ? (0 ? 2 : 3) : (((enum machine_mode) ((((out)->u.fld[0]).rtx))->mode)) == XCmode ? (0 ? 4 : 6) : ((((unsigned short) mode_size[((enum machine_mode) ((((out)->u.fld[0]).rtx))->mode)]) + (0 ? 8 : 4) - 1) / (0 ? 8 : 4))))))

    || ! ix86_hard_regno_mode_ok ((subreg_regno (out)), (outmode))))

   || ((((class) == GENERAL_REGS || (class) == LEGACY_REGS || (class) == INDEX_REGS) && !0 && (outmode) == QImode ? Q_REGS : NO_REGS) != NO_REGS
       && ((((class) == GENERAL_REGS || (class) == LEGACY_REGS || (class) == INDEX_REGS) && !0 && (((enum machine_mode) ((((out)->u.fld[0]).rtx))->mode)) == QImode ? Q_REGS : NO_REGS)


    == NO_REGS))


   || (((enum rtx_code) ((((out)->u.fld[0]).rtx))->code) == REG
       && ((((((out)->u.fld[0]).rtx))->u.fld[0]).rtuint) < 53
       && (((unsigned short) mode_size[outmode]) < ((unsigned short) mode_size[((enum machine_mode) ((((out)->u.fld[0]).rtx))->mode)]) ? reg_classes_intersect_p (FLOAT_SSE_REGS, ((regclass_map[((((((out)->u.fld[0]).rtx))->u.fld[0]).rtuint)]))) || reg_classes_intersect_p (MMX_REGS, ((regclass_map[((((((out)->u.fld[0]).rtx))->u.fld[0]).rtuint)]))) : ((unsigned short) mode_size[((enum machine_mode) ((((out)->u.fld[0]).rtx))->mode)]) != ((unsigned short) mode_size[outmode]) ? reg_classes_intersect_p (FLOAT_REGS, ((regclass_map[((((((out)->u.fld[0]).rtx))->u.fld[0]).rtuint)]))) : 0))



   ))
    {
      out_subreg_loc = outloc;
      outloc = &(((out)->u.fld[0]).rtx);
      out = *outloc;

      if (((enum rtx_code) (out)->code) == MEM
   && ((unsigned short) mode_size[((enum machine_mode) (out)->mode)]) > ((unsigned short) mode_size[outmode]))
 fancy_abort ("reload.c", 1163, __FUNCTION__);

      outmode = ((enum machine_mode) (out)->mode);
    }
# 1175 "reload.c"
  if (out != 0 && reload_inner_reg_of_subreg (out, outmode, 1))
    {





      dont_remove_subreg = 1;
      push_reload ((((out)->u.fld[0]).rtx), (((out)->u.fld[0]).rtx), &(((out)->u.fld[0]).rtx),
     &(((out)->u.fld[0]).rtx),
     find_valid_class (outmode,
         subreg_regno_offset (((((((out)->u.fld[0]).rtx))->u.fld[0]).rtuint),
         ((enum machine_mode) ((((out)->u.fld[0]).rtx))->mode),
         (((out)->u.fld[1]).rtuint),
         ((enum machine_mode) (out)->mode)),
         ((((((out)->u.fld[0]).rtx))->u.fld[0]).rtuint)),
     VOIDmode, VOIDmode, 0, 0,
     opnum, RELOAD_OTHER);
    }


  if (in != 0 && out != 0 && ((enum rtx_code) (out)->code) == MEM
      && (((enum rtx_code) (in)->code) == REG || ((enum rtx_code) (in)->code) == MEM)
      && reg_overlap_mentioned_for_reload_p (in, (((out)->u.fld[0]).rtx)))
    dont_share = 1;




  if (in != 0 && ((enum rtx_code) (in)->code) == SUBREG && ((enum rtx_code) ((((in)->u.fld[0]).rtx))->code) == REG
      && ((((((in)->u.fld[0]).rtx))->u.fld[0]).rtuint) < 53
      && ! dont_remove_subreg)
    in = gen_rtx_REG (((enum machine_mode) (in)->mode), subreg_regno (in));


  if (out != 0 && ((enum rtx_code) (out)->code) == SUBREG
      && ((enum rtx_code) ((((out)->u.fld[0]).rtx))->code) == REG
      && ((((((out)->u.fld[0]).rtx))->u.fld[0]).rtuint) < 53
      && ! dont_remove_subreg)
    out = gen_rtx_REG (((enum machine_mode) (out)->mode), subreg_regno (out));



  if (in != 0)
    class = ix86_preferred_reload_class ((in), (class));
# 1232 "reload.c"
  if (in_subreg_loc)
    class = ((inmode) == QImode && !0 && ((class) == ALL_REGS || (class) == GENERAL_REGS || (class) == LEGACY_REGS || (class) == INDEX_REGS) ? Q_REGS : (class));
  else if (in != 0 && ((enum rtx_code) (in)->code) == SUBREG)
    class = ((((enum machine_mode) ((((in)->u.fld[0]).rtx))->mode)) == QImode && !0 && ((class) == ALL_REGS || (class) == GENERAL_REGS || (class) == LEGACY_REGS || (class) == INDEX_REGS) ? Q_REGS : (class));

  if (out_subreg_loc)
    class = ((outmode) == QImode && !0 && ((class) == ALL_REGS || (class) == GENERAL_REGS || (class) == LEGACY_REGS || (class) == INDEX_REGS) ? Q_REGS : (class));
  if (out != 0 && ((enum rtx_code) (out)->code) == SUBREG)
    class = ((((enum machine_mode) ((((out)->u.fld[0]).rtx))->mode)) == QImode && !0 && ((class) == ALL_REGS || (class) == GENERAL_REGS || (class) == LEGACY_REGS || (class) == INDEX_REGS) ? Q_REGS : (class));




  if (this_insn_is_asm)
    {
      enum machine_mode mode;
      if (((unsigned short) mode_size[inmode]) > ((unsigned short) mode_size[outmode]))
 mode = inmode;
      else
 mode = outmode;
      if (mode == VOIDmode)
 {
   error_for_asm (this_insn, "cannot reload integer constant operand in `asm'");
   mode = word_mode;
   if (in != 0)
     inmode = word_mode;
   if (out != 0)
     outmode = word_mode;
 }
      for (i = 0; i < 53; i++)
 if (ix86_hard_regno_mode_ok ((i), (mode))
     && (!!((reg_class_contents[(int) class])[(i) / ((unsigned) (8 * 4))] & (((HARD_REG_ELT_TYPE) (1)) << ((i) % ((unsigned) (8 * 4)))))))
   {
     int nregs = (((i) >= 8 && (i) <= (8 + 7)) || (((i) >= (20 + 1) && (i) <= ((20 + 1) + 7)) || ((i) >= (((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) && (i) <= ((((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) + 7))) || ((i) >= (((20 + 1) + 7) + 1) && (i) <= ((((20 + 1) + 7) + 1) + 7)) ? ((mode_class[mode] == MODE_COMPLEX_INT || mode_class[mode] == MODE_COMPLEX_FLOAT) ? 2 : 1) : ((mode) == XFmode ? (0 ? 2 : 3) : (mode) == XCmode ? (0 ? 4 : 6) : ((((unsigned short) mode_size[mode]) + (0 ? 8 : 4) - 1) / (0 ? 8 : 4))));

     int j;
     for (j = 1; j < nregs; j++)
       if (! (!!((reg_class_contents[(int) class])[(i + j) / ((unsigned) (8 * 4))] & (((HARD_REG_ELT_TYPE) (1)) << ((i + j) % ((unsigned) (8 * 4)))))))
  break;
     if (j == nregs)
       break;
   }
      if (i == 53)
 {
   error_for_asm (this_insn, "impossible register constraint in `asm'");
   class = ALL_REGS;
 }
    }




  if (class == NO_REGS
      && (optional == 0 || type != RELOAD_FOR_OUTPUT))
    fancy_abort ("reload.c", 1286, __FUNCTION__);

  i = find_reusable_reload (&in, out, class, type, opnum, dont_share);

  if (i == n_reloads)
    {
# 1304 "reload.c"
      if (out != 0 && ((enum rtx_code) (out)->code) != SCRATCH)
 secondary_out_reload
   = push_secondary_reload (0, out, opnum, optional, class, outmode,
       type, &secondary_out_icode);







      if (in != 0 && (((enum rtx_code) (in)->code) == REG || ((enum rtx_code) (in)->code) == SUBREG)
   && reg_or_subregno (in) < 53
   && ix86_secondary_memory_needed (((regclass_map[reg_or_subregno (in)])), (class), (inmode), 1))

 get_secondary_mem (in, inmode, opnum, type);


      i = n_reloads;
      rld[i].in = in;
      rld[i].out = out;
      rld[i].class = class;
      rld[i].inmode = inmode;
      rld[i].outmode = outmode;
      rld[i].reg_rtx = 0;
      rld[i].optional = optional;
      rld[i].inc = 0;
      rld[i].nocombine = 0;
      rld[i].in_reg = inloc ? *inloc : 0;
      rld[i].out_reg = outloc ? *outloc : 0;
      rld[i].opnum = opnum;
      rld[i].when_needed = type;
      rld[i].secondary_in_reload = secondary_in_reload;
      rld[i].secondary_out_reload = secondary_out_reload;
      rld[i].secondary_in_icode = secondary_in_icode;
      rld[i].secondary_out_icode = secondary_out_icode;
      rld[i].secondary_p = 0;

      n_reloads++;


      if (out != 0 && (((enum rtx_code) (out)->code) == REG || ((enum rtx_code) (out)->code) == SUBREG)
   && reg_or_subregno (out) < 53
   && ix86_secondary_memory_needed ((class), ((regclass_map[reg_or_subregno (out)])), (outmode), 1))


 get_secondary_mem (out, outmode, opnum, type);

    }
  else
    {







      if (inmode != VOIDmode
   && ((unsigned short) mode_size[inmode]) > ((unsigned short) mode_size[rld[i].inmode]))
 rld[i].inmode = inmode;
      if (outmode != VOIDmode
   && ((unsigned short) mode_size[outmode]) > ((unsigned short) mode_size[rld[i].outmode]))
 rld[i].outmode = outmode;
      if (in != 0)
 {
   rtx in_reg = inloc ? *inloc : 0;
# 1385 "reload.c"
   if (rld[i].in != in && rtx_equal_p (in, rld[i].in)
       && ! (rld[i].optional && optional))
     {


       if (opnum > rld[i].opnum)
  {
    remove_address_replacements (in);
    in = rld[i].in;
    in_reg = rld[i].in_reg;
  }
       else
  remove_address_replacements (rld[i].in);
     }
   rld[i].in = in;
   rld[i].in_reg = in_reg;
 }
      if (out != 0)
 {
   rld[i].out = out;
   rld[i].out_reg = outloc ? *outloc : 0;
 }
      if (reg_class_subset_p (class, rld[i].class))
 rld[i].class = class;
      rld[i].optional &= optional;
      if (((type) != (rld[i].when_needed) || ! ((opnum) == (rld[i].opnum) || (type) == RELOAD_FOR_INPUT || (type) == RELOAD_FOR_OPERAND_ADDRESS || (type) == RELOAD_FOR_OTHER_ADDRESS)))

 rld[i].when_needed = RELOAD_OTHER;
      rld[i].opnum = ((rld[i].opnum) < (opnum) ? (rld[i].opnum) : (opnum));
    }





  if (in != 0 && in != *inloc)
    rld[i].nocombine = 1;
# 1449 "reload.c"
  if (replace_reloads)
    {
      if (inloc != 0)
 {
   struct replacement *r = &replacements[n_replacements++];
   r->what = i;
   r->subreg_loc = in_subreg_loc;
   r->where = inloc;
   r->mode = inmode;
 }
      if (outloc != 0 && outloc != inloc)
 {
   struct replacement *r = &replacements[n_replacements++];
   r->what = i;
   r->where = outloc;
   r->subreg_loc = out_subreg_loc;
   r->mode = outmode;
 }
    }
# 1477 "reload.c"
  if (in != 0 && out != 0 && in != out && rld[i].reg_rtx == 0)
    {
      rld[i].reg_rtx = find_dummy_reload (in, out, inloc, outloc,
       inmode, outmode,
       rld[i].class, i,
       earlyclobber_operand_p (out));





      if (rld[i].reg_rtx == out
   && (((enum rtx_code) (in)->code) == REG || (((enum rtx_code) (in)->code) == LABEL_REF || ((enum rtx_code) (in)->code) == SYMBOL_REF || ((enum rtx_code) (in)->code) == CONST_INT || ((enum rtx_code) (in)->code) == CONST_DOUBLE || ((enum rtx_code) (in)->code) == CONST || ((enum rtx_code) (in)->code) == HIGH || ((enum rtx_code) (in)->code) == CONST_VECTOR || ((enum rtx_code) (in)->code) == CONSTANT_P_RTX))
   && 0 != find_equiv_reg (in, this_insn, 0, (((out)->u.fld[0]).rtuint),
      static_reload_reg_p, i, inmode))
 rld[i].in = out;
    }
# 1507 "reload.c"
  if (rld[i].reg_rtx == 0 && in != 0)
    {
      rtx note;
      int regno;
      enum machine_mode rel_mode = inmode;

      if (out && ((unsigned short) mode_size[outmode]) > ((unsigned short) mode_size[inmode]))
 rel_mode = outmode;

      for (note = (((this_insn)->u.fld[8]).rtx); note; note = (((note)->u.fld[1]).rtx))
 if (((enum reg_note) ((enum machine_mode) (note)->mode)) == REG_DEAD
     && ((enum rtx_code) ((((note)->u.fld[0]).rtx))->code) == REG
     && (regno = ((((((note)->u.fld[0]).rtx))->u.fld[0]).rtuint)) < 53
     && reg_mentioned_p ((((note)->u.fld[0]).rtx), in)
     && ! refers_to_regno_for_reload_p (regno,
            (regno
      + (((regno) >= 8 && (regno) <= (8 + 7)) || (((regno) >= (20 + 1) && (regno) <= ((20 + 1) + 7)) || ((regno) >= (((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) && (regno) <= ((((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) + 7))) || ((regno) >= (((20 + 1) + 7) + 1) && (regno) <= ((((20 + 1) + 7) + 1) + 7)) ? ((mode_class[rel_mode] == MODE_COMPLEX_INT || mode_class[rel_mode] == MODE_COMPLEX_FLOAT) ? 2 : 1) : ((rel_mode) == XFmode ? (0 ? 2 : 3) : (rel_mode) == XCmode ? (0 ? 4 : 6) : ((((unsigned short) mode_size[rel_mode]) + (0 ? 8 : 4) - 1) / (0 ? 8 : 4))))),

            (((this_insn)->u.fld[5]).rtx), inloc)



     && (out == 0 || in == out
  || ! hard_reg_set_here_p (regno,
       (regno
        + (((regno) >= 8 && (regno) <= (8 + 7)) || (((regno) >= (20 + 1) && (regno) <= ((20 + 1) + 7)) || ((regno) >= (((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) && (regno) <= ((((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) + 7))) || ((regno) >= (((20 + 1) + 7) + 1) && (regno) <= ((((20 + 1) + 7) + 1) + 7)) ? ((mode_class[rel_mode] == MODE_COMPLEX_INT || mode_class[rel_mode] == MODE_COMPLEX_FLOAT) ? 2 : 1) : ((rel_mode) == XFmode ? (0 ? 2 : 3) : (rel_mode) == XCmode ? (0 ? 4 : 6) : ((((unsigned short) mode_size[rel_mode]) + (0 ? 8 : 4) - 1) / (0 ? 8 : 4))))),

       (((this_insn)->u.fld[5]).rtx)))



     && (in != out
  || (((enum rtx_code) (in)->code) == SUBREG
      && (((((unsigned short) mode_size[((enum machine_mode) (in)->mode)]) + ((0 ? 8 : 4) - 1))
    / (0 ? 8 : 4))
   == ((((unsigned short) mode_size[((enum machine_mode) ((((in)->u.fld[0]).rtx))->mode)])
        + ((0 ? 8 : 4) - 1)) / (0 ? 8 : 4)))))

     && (((unsigned short) mode_size[rel_mode])
  <= ((unsigned short) mode_size[((enum machine_mode) ((((note)->u.fld[0]).rtx))->mode)]))
     && ix86_hard_regno_mode_ok ((regno), (inmode))
     && ix86_hard_regno_mode_ok ((regno), (outmode)))
   {
     unsigned int offs;
     unsigned int nregs = (((((regno) >= 8 && (regno) <= (8 + 7)) || (((regno) >= (20 + 1) && (regno) <= ((20 + 1) + 7)) || ((regno) >= (((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) && (regno) <= ((((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) + 7))) || ((regno) >= (((20 + 1) + 7) + 1) && (regno) <= ((((20 + 1) + 7) + 1) + 7)) ? ((mode_class[inmode] == MODE_COMPLEX_INT || mode_class[inmode] == MODE_COMPLEX_FLOAT) ? 2 : 1) : ((inmode) == XFmode ? (0 ? 2 : 3) : (inmode) == XCmode ? (0 ? 4 : 6) : ((((unsigned short) mode_size[inmode]) + (0 ? 8 : 4) - 1) / (0 ? 8 : 4))))) > ((((regno) >= 8 && (regno) <= (8 + 7)) || (((regno) >= (20 + 1) && (regno) <= ((20 + 1) + 7)) || ((regno) >= (((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) && (regno) <= ((((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) + 7))) || ((regno) >= (((20 + 1) + 7) + 1) && (regno) <= ((((20 + 1) + 7) + 1) + 7)) ? ((mode_class[outmode] == MODE_COMPLEX_INT || mode_class[outmode] == MODE_COMPLEX_FLOAT) ? 2 : 1) : ((outmode) == XFmode ? (0 ? 2 : 3) : (outmode) == XCmode ? (0 ? 4 : 6) : ((((unsigned short) mode_size[outmode]) + (0 ? 8 : 4) - 1) / (0 ? 8 : 4))))) ? ((((regno) >= 8 && (regno) <= (8 + 7)) || (((regno) >= (20 + 1) && (regno) <= ((20 + 1) + 7)) || ((regno) >= (((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) && (regno) <= ((((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) + 7))) || ((regno) >= (((20 + 1) + 7) + 1) && (regno) <= ((((20 + 1) + 7) + 1) + 7)) ? ((mode_class[inmode] == MODE_COMPLEX_INT || mode_class[inmode] == MODE_COMPLEX_FLOAT) ? 2 : 1) : ((inmode) == XFmode ? (0 ? 2 : 3) : (inmode) == XCmode ? (0 ? 4 : 6) : ((((unsigned short) mode_size[inmode]) + (0 ? 8 : 4) - 1) / (0 ? 8 : 4))))) : ((((regno) >= 8 && (regno) <= (8 + 7)) || (((regno) >= (20 + 1) && (regno) <= ((20 + 1) + 7)) || ((regno) >= (((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) && (regno) <= ((((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) + 7))) || ((regno) >= (((20 + 1) + 7) + 1) && (regno) <= ((((20 + 1) + 7) + 1) + 7)) ? ((mode_class[outmode] == MODE_COMPLEX_INT || mode_class[outmode] == MODE_COMPLEX_FLOAT) ? 2 : 1) : ((outmode) == XFmode ? (0 ? 2 : 3) : (outmode) == XCmode ? (0 ? 4 : 6) : ((((unsigned short) mode_size[outmode]) + (0 ? 8 : 4) - 1) / (0 ? 8 : 4))))));


     for (offs = 0; offs < nregs; offs++)
       if (fixed_regs[regno + offs]
    || ! (!!((reg_class_contents[(int) class])[(regno + offs) / ((unsigned) (8 * 4))] & (((HARD_REG_ELT_TYPE) (1)) << ((regno + offs) % ((unsigned) (8 * 4)))))))

  break;

     if (offs == nregs
  && (! (refers_to_regno_for_reload_p
         (regno, (regno + (((regno) >= 8 && (regno) <= (8 + 7)) || (((regno) >= (20 + 1) && (regno) <= ((20 + 1) + 7)) || ((regno) >= (((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) && (regno) <= ((((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) + 7))) || ((regno) >= (((20 + 1) + 7) + 1) && (regno) <= ((((20 + 1) + 7) + 1) + 7)) ? ((mode_class[inmode] == MODE_COMPLEX_INT || mode_class[inmode] == MODE_COMPLEX_FLOAT) ? 2 : 1) : ((inmode) == XFmode ? (0 ? 2 : 3) : (inmode) == XCmode ? (0 ? 4 : 6) : ((((unsigned short) mode_size[inmode]) + (0 ? 8 : 4) - 1) / (0 ? 8 : 4))))),
    in, (rtx *)0))
      || can_reload_into (in, regno, inmode)))
       {
  rld[i].reg_rtx = gen_rtx_REG (rel_mode, regno);
  break;
       }
   }
    }

  if (out)
    output_reloadnum = i;

  return i;
}







static void
push_replacement (rtx *loc, int reloadnum, enum machine_mode mode)
{
  if (replace_reloads)
    {
      struct replacement *r = &replacements[n_replacements++];
      r->what = reloadnum;
      r->where = loc;
      r->subreg_loc = 0;
      r->mode = mode;
    }
}





static void
dup_replacements (rtx *dup_loc, rtx *orig_loc)
{
  int i, n = n_replacements;

  for (i = 0; i < n; i++)
    {
      struct replacement *r = &replacements[i];
      if (r->where == orig_loc)
 push_replacement (dup_loc, r->what, r->mode);
    }
}




void
transfer_replacements (int to, int from)
{
  int i;

  for (i = 0; i < n_replacements; i++)
    if (replacements[i].what == from)
      replacements[i].what = to;
}





int
remove_address_replacements (rtx in_rtx)
{
  int i, j;
  char reload_flags[(2 * 30 * (2 + 1))];
  int something_changed = 0;

  memset (reload_flags, 0, sizeof reload_flags);
  for (i = 0, j = 0; i < n_replacements; i++)
    {
      if (loc_mentioned_in_p (replacements[i].where, in_rtx))
 reload_flags[replacements[i].what] |= 1;
      else
 {
   replacements[j++] = replacements[i];
   reload_flags[replacements[i].what] |= 2;
 }
    }

  n_replacements = j;

  for (i = n_reloads - 1; i >= 0; i--)
    {
      if (reload_flags[i] == 1)
 {
   deallocate_reload_reg (i);
   remove_address_replacements (rld[i].in);
   rld[i].in = 0;
   something_changed = 1;
 }
    }
  return something_changed;
}
# 1677 "reload.c"
static void
combine_reloads (void)
{
  int i;
  int output_reload = -1;
  int secondary_out = -1;
  rtx note;




  for (i = 0; i < n_reloads; i++)
    if (rld[i].out != 0)
      {
 if (output_reload >= 0)
   return;
 output_reload = i;
      }

  if (output_reload < 0 || rld[output_reload].optional)
    return;



  if (rld[output_reload].in != 0)
    return;


  if (earlyclobber_operand_p (rld[output_reload].out))
    return;





  for (i = 0; i < n_reloads; i++)
    if ((rld[i].when_needed == RELOAD_FOR_OUTPUT_ADDRESS
  || rld[i].when_needed == RELOAD_FOR_OUTADDR_ADDRESS)
 && rld[i].opnum == rld[output_reload].opnum)
      return;



  for (i = 0; i < n_reloads; i++)
    if (rld[i].in && ! rld[i].optional && ! rld[i].nocombine

 && rld[i].when_needed != RELOAD_FOR_OUTPUT_ADDRESS
 && rld[i].when_needed != RELOAD_FOR_OUTADDR_ADDRESS
 && rld[i].when_needed != RELOAD_OTHER
 && ((!reg_classes_intersect_p ((rld[i].class), GENERAL_REGS) ? ((mode_class[rld[i].inmode] == MODE_COMPLEX_INT || mode_class[rld[i].inmode] == MODE_COMPLEX_FLOAT) ? 2 : 1) : (((((rld[i].inmode) == XFmode ? 12 : ((unsigned short) mode_size[rld[i].inmode]))) + (0 ? 8 : 4) - 1) / (0 ? 8 : 4)))
     == (!reg_classes_intersect_p ((rld[output_reload].class), GENERAL_REGS) ? ((mode_class[rld[output_reload].outmode] == MODE_COMPLEX_INT || mode_class[rld[output_reload].outmode] == MODE_COMPLEX_FLOAT) ? 2 : 1) : (((((rld[output_reload].outmode) == XFmode ? 12 : ((unsigned short) mode_size[rld[output_reload].outmode]))) + (0 ? 8 : 4) - 1) / (0 ? 8 : 4))))

 && rld[i].inc == 0
 && rld[i].reg_rtx == 0



 && (secondary_memlocs_elim[(int) rld[output_reload].outmode][rld[i].opnum] == 0
     || secondary_memlocs_elim[(int) rld[output_reload].outmode][rld[output_reload].opnum] == 0
     || rtx_equal_p (secondary_memlocs_elim[(int) rld[output_reload].outmode][rld[i].opnum],
       secondary_memlocs_elim[(int) rld[output_reload].outmode][rld[output_reload].opnum]))

 && (1
     ? (rld[i].class == rld[output_reload].class)
     : (reg_class_subset_p (rld[i].class,
       rld[output_reload].class)
        || reg_class_subset_p (rld[output_reload].class,
          rld[i].class)))
 && ((rld[i].in == rld[output_reload].out || (rld[i].in != 0 && (((enum rtx_code) (rld[i].in)->code) == REG ? ((enum rtx_code) (rld[output_reload].out)->code) == REG && (((rld[i].in)->u.fld[0]).rtuint) == (((rld[output_reload].out)->u.fld[0]).rtuint) : rtx_equal_p (rld[i].in, rld[output_reload].out) && ! side_effects_p (rld[i].in))))



     || (! reg_overlap_mentioned_for_reload_p (rld[output_reload].out,
            rld[i].in)






  && ! (((enum rtx_code) (rld[i].in)->code) == REG
        && reg_overlap_mentioned_for_reload_p (rld[i].in,
            rld[output_reload].out))))
 && ! reload_inner_reg_of_subreg (rld[i].in, rld[i].inmode,
      rld[i].when_needed != RELOAD_FOR_INPUT)
 && (reg_class_size[(int) rld[i].class]
     || 1)


 && (rld[i].when_needed == RELOAD_FOR_INPUT
     || rld[i].when_needed == RELOAD_FOR_OUTPUT))
      {
 int j;


 rld[i].out = rld[output_reload].out;
 rld[i].out_reg = rld[output_reload].out_reg;
 rld[i].outmode = rld[output_reload].outmode;

 rld[output_reload].out = 0;

 rld[i].when_needed = RELOAD_OTHER;

 if (rld[output_reload].secondary_out_reload != -1)
   {
     rld[i].secondary_out_reload
       = rld[output_reload].secondary_out_reload;
     rld[i].secondary_out_icode
       = rld[output_reload].secondary_out_icode;
   }



 if (secondary_memlocs_elim[(int) rld[output_reload].outmode][rld[output_reload].opnum] != 0)
   secondary_memlocs_elim[(int) rld[output_reload].outmode][rld[i].opnum]
     = secondary_memlocs_elim[(int) rld[output_reload].outmode][rld[output_reload].opnum];


 if (reg_class_subset_p (rld[output_reload].class,
    rld[i].class))
   rld[i].class = rld[output_reload].class;


 for (j = 0; j < n_replacements; j++)
   if (replacements[j].what == output_reload)
     replacements[j].what = i;

 return;
      }







  if ((((this_insn)->u.fld[6]).rtint) == -1)
    return;

  for (i = 1; i < insn_data[(((this_insn)->u.fld[6]).rtint)].n_operands; i++)
    if (insn_data[(((this_insn)->u.fld[6]).rtint)].operand[i].constraint[0] == '='
 || insn_data[(((this_insn)->u.fld[6]).rtint)].operand[i].constraint[0] == '+')
      return;




  for (note = (((this_insn)->u.fld[8]).rtx); note; note = (((note)->u.fld[1]).rtx))
    if (((enum reg_note) ((enum machine_mode) (note)->mode)) == REG_DEAD
 && ((enum rtx_code) ((((note)->u.fld[0]).rtx))->code) == REG
 && ! reg_overlap_mentioned_for_reload_p ((((note)->u.fld[0]).rtx),
       rld[output_reload].out)
 && ((((((note)->u.fld[0]).rtx))->u.fld[0]).rtuint) < 53
 && ix86_hard_regno_mode_ok ((((((((note)->u.fld[0]).rtx))->u.fld[0]).rtuint)), (rld[output_reload].outmode))
 && (!!((reg_class_contents[(int) rld[output_reload].class])[(((((((note)->u.fld[0]).rtx))->u.fld[0]).rtuint)) / ((unsigned) (8 * 4))] & (((HARD_REG_ELT_TYPE) (1)) << ((((((((note)->u.fld[0]).rtx))->u.fld[0]).rtuint)) % ((unsigned) (8 * 4))))))

 && ((((((((((note)->u.fld[0]).rtx))->u.fld[0]).rtuint)) >= 8 && (((((((note)->u.fld[0]).rtx))->u.fld[0]).rtuint)) <= (8 + 7)) || (((((((((note)->u.fld[0]).rtx))->u.fld[0]).rtuint)) >= (20 + 1) && (((((((note)->u.fld[0]).rtx))->u.fld[0]).rtuint)) <= ((20 + 1) + 7)) || ((((((((note)->u.fld[0]).rtx))->u.fld[0]).rtuint)) >= (((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) && (((((((note)->u.fld[0]).rtx))->u.fld[0]).rtuint)) <= ((((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) + 7))) || ((((((((note)->u.fld[0]).rtx))->u.fld[0]).rtuint)) >= (((20 + 1) + 7) + 1) && (((((((note)->u.fld[0]).rtx))->u.fld[0]).rtuint)) <= ((((20 + 1) + 7) + 1) + 7)) ? ((mode_class[rld[output_reload].outmode] == MODE_COMPLEX_INT || mode_class[rld[output_reload].outmode] == MODE_COMPLEX_FLOAT) ? 2 : 1) : ((rld[output_reload].outmode) == XFmode ? (0 ? 2 : 3) : (rld[output_reload].outmode) == XCmode ? (0 ? 4 : 6) : ((((unsigned short) mode_size[rld[output_reload].outmode]) + (0 ? 8 : 4) - 1) / (0 ? 8 : 4))))
     <= (((((((((note)->u.fld[0]).rtx))->u.fld[0]).rtuint)) >= 8 && (((((((note)->u.fld[0]).rtx))->u.fld[0]).rtuint)) <= (8 + 7)) || (((((((((note)->u.fld[0]).rtx))->u.fld[0]).rtuint)) >= (20 + 1) && (((((((note)->u.fld[0]).rtx))->u.fld[0]).rtuint)) <= ((20 + 1) + 7)) || ((((((((note)->u.fld[0]).rtx))->u.fld[0]).rtuint)) >= (((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) && (((((((note)->u.fld[0]).rtx))->u.fld[0]).rtuint)) <= ((((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) + 7))) || ((((((((note)->u.fld[0]).rtx))->u.fld[0]).rtuint)) >= (((20 + 1) + 7) + 1) && (((((((note)->u.fld[0]).rtx))->u.fld[0]).rtuint)) <= ((((20 + 1) + 7) + 1) + 7)) ? ((mode_class[((enum machine_mode) ((((note)->u.fld[0]).rtx))->mode)] == MODE_COMPLEX_INT || mode_class[((enum machine_mode) ((((note)->u.fld[0]).rtx))->mode)] == MODE_COMPLEX_FLOAT) ? 2 : 1) : ((((enum machine_mode) ((((note)->u.fld[0]).rtx))->mode)) == XFmode ? (0 ? 2 : 3) : (((enum machine_mode) ((((note)->u.fld[0]).rtx))->mode)) == XCmode ? (0 ? 4 : 6) : ((((unsigned short) mode_size[((enum machine_mode) ((((note)->u.fld[0]).rtx))->mode)]) + (0 ? 8 : 4) - 1) / (0 ? 8 : 4)))))


 && ((secondary_out = rld[output_reload].secondary_out_reload) == -1
     || (! ((!!((reg_class_contents[(int) rld[secondary_out].class])[(((((((note)->u.fld[0]).rtx))->u.fld[0]).rtuint)) / ((unsigned) (8 * 4))] & (((HARD_REG_ELT_TYPE) (1)) << ((((((((note)->u.fld[0]).rtx))->u.fld[0]).rtuint)) % ((unsigned) (8 * 4)))))))


  && ((secondary_out = rld[secondary_out].secondary_out_reload) == -1
      || ! ((!!((reg_class_contents[(int) rld[secondary_out].class])[(((((((note)->u.fld[0]).rtx))->u.fld[0]).rtuint)) / ((unsigned) (8 * 4))] & (((HARD_REG_ELT_TYPE) (1)) << ((((((((note)->u.fld[0]).rtx))->u.fld[0]).rtuint)) % ((unsigned) (8 * 4))))))))))


 && ! fixed_regs[((((((note)->u.fld[0]).rtx))->u.fld[0]).rtuint)])
      {
 rld[output_reload].reg_rtx
   = gen_rtx_REG (rld[output_reload].outmode,
    ((((((note)->u.fld[0]).rtx))->u.fld[0]).rtuint));
 return;
      }
}
# 1874 "reload.c"
static rtx
find_dummy_reload (rtx real_in, rtx real_out, rtx *inloc, rtx *outloc,
     enum machine_mode inmode, enum machine_mode outmode,
     enum reg_class class, int for_real, int earlyclobber)
{
  rtx in = real_in;
  rtx out = real_out;
  int in_offset = 0;
  int out_offset = 0;
  rtx value = 0;



  if (((unsigned short) mode_size[outmode]) != ((unsigned short) mode_size[inmode])
      && (((unsigned short) mode_size[outmode]) > (0 ? 8 : 4)
   || ((unsigned short) mode_size[inmode]) > (0 ? 8 : 4)))
    return 0;





  while (((enum rtx_code) (out)->code) == SUBREG)
    {
      if (((enum rtx_code) ((((out)->u.fld[0]).rtx))->code) == REG
   && ((((((out)->u.fld[0]).rtx))->u.fld[0]).rtuint) < 53)
 out_offset += subreg_regno_offset (((((((out)->u.fld[0]).rtx))->u.fld[0]).rtuint),
        ((enum machine_mode) ((((out)->u.fld[0]).rtx))->mode),
        (((out)->u.fld[1]).rtuint),
        ((enum machine_mode) (out)->mode));
      out = (((out)->u.fld[0]).rtx);
    }
  while (((enum rtx_code) (in)->code) == SUBREG)
    {
      if (((enum rtx_code) ((((in)->u.fld[0]).rtx))->code) == REG
   && ((((((in)->u.fld[0]).rtx))->u.fld[0]).rtuint) < 53)
 in_offset += subreg_regno_offset (((((((in)->u.fld[0]).rtx))->u.fld[0]).rtuint),
       ((enum machine_mode) ((((in)->u.fld[0]).rtx))->mode),
       (((in)->u.fld[1]).rtuint),
       ((enum machine_mode) (in)->mode));
      in = (((in)->u.fld[0]).rtx);
    }



  class = ix86_preferred_reload_class ((in), (class));


  if (((enum rtx_code) (out)->code) == REG
      && (((out)->u.fld[0]).rtuint) < 53)
    {
      unsigned int regno = (((out)->u.fld[0]).rtuint) + out_offset;
      unsigned int nwords = (((regno) >= 8 && (regno) <= (8 + 7)) || (((regno) >= (20 + 1) && (regno) <= ((20 + 1) + 7)) || ((regno) >= (((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) && (regno) <= ((((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) + 7))) || ((regno) >= (((20 + 1) + 7) + 1) && (regno) <= ((((20 + 1) + 7) + 1) + 7)) ? ((mode_class[outmode] == MODE_COMPLEX_INT || mode_class[outmode] == MODE_COMPLEX_FLOAT) ? 2 : 1) : ((outmode) == XFmode ? (0 ? 2 : 3) : (outmode) == XCmode ? (0 ? 4 : 6) : ((((unsigned short) mode_size[outmode]) + (0 ? 8 : 4) - 1) / (0 ? 8 : 4))));
      rtx saved_rtx;
# 1938 "reload.c"
      saved_rtx = *inloc;
      *inloc = (const_int_rtx[64]);

      if (regno < 53
   && ix86_hard_regno_mode_ok ((regno), (outmode))
   && ! refers_to_regno_for_reload_p (regno, regno + nwords,
          (((this_insn)->u.fld[5]).rtx), outloc))
 {
   unsigned int i;

   for (i = 0; i < nwords; i++)
     if (! (!!((reg_class_contents[(int) class])[(regno + i) / ((unsigned) (8 * 4))] & (((HARD_REG_ELT_TYPE) (1)) << ((regno + i) % ((unsigned) (8 * 4)))))))

       break;

   if (i == nwords)
     {
       if (((enum rtx_code) (real_out)->code) == REG)
  value = real_out;
       else
  value = gen_rtx_REG (outmode, regno);
     }
 }

      *inloc = saved_rtx;
    }







  if (hard_regs_live_known
      && ((enum rtx_code) (in)->code) == REG
      && (((in)->u.fld[0]).rtuint) < 53
      && (value == 0
   || find_reg_note (this_insn, REG_UNUSED, real_out))
      && find_reg_note (this_insn, REG_DEAD, real_in)
      && !fixed_regs[(((in)->u.fld[0]).rtuint)]
      && ix86_hard_regno_mode_ok (((((in)->u.fld[0]).rtuint)), ((((enum machine_mode) (out)->mode) != VOIDmode ? ((enum machine_mode) (out)->mode) : outmode))))






    {
      unsigned int regno = (((in)->u.fld[0]).rtuint) + in_offset;
      unsigned int nwords = (((regno) >= 8 && (regno) <= (8 + 7)) || (((regno) >= (20 + 1) && (regno) <= ((20 + 1) + 7)) || ((regno) >= (((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) && (regno) <= ((((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) + 7))) || ((regno) >= (((20 + 1) + 7) + 1) && (regno) <= ((((20 + 1) + 7) + 1) + 7)) ? ((mode_class[inmode] == MODE_COMPLEX_INT || mode_class[inmode] == MODE_COMPLEX_FLOAT) ? 2 : 1) : ((inmode) == XFmode ? (0 ? 2 : 3) : (inmode) == XCmode ? (0 ? 4 : 6) : ((((unsigned short) mode_size[inmode]) + (0 ? 8 : 4) - 1) / (0 ? 8 : 4))));

      if (! refers_to_regno_for_reload_p (regno, regno + nwords, out, (rtx*) 0)
   && ! hard_reg_set_here_p (regno, regno + nwords,
        (((this_insn)->u.fld[5]).rtx))
   && (! earlyclobber
       || ! refers_to_regno_for_reload_p (regno, regno + nwords,
       (((this_insn)->u.fld[5]).rtx), inloc)))
 {
   unsigned int i;

   for (i = 0; i < nwords; i++)
     if (! (!!((reg_class_contents[(int) class])[(regno + i) / ((unsigned) (8 * 4))] & (((HARD_REG_ELT_TYPE) (1)) << ((regno + i) % ((unsigned) (8 * 4)))))))

       break;

   if (i == nwords)
     {



       if (for_real >= 0 && value == real_out)
  rld[for_real].out = 0;
       if (((enum rtx_code) (real_in)->code) == REG)
  value = real_in;
       else
  value = gen_rtx_REG (inmode, regno);
     }
 }
    }

  return value;
}







int
earlyclobber_operand_p (rtx x)
{
  int i;

  for (i = 0; i < n_earlyclobbers; i++)
    if (reload_earlyclobbers[i] == x)
      return 1;

  return 0;
}






static int
hard_reg_set_here_p (unsigned int beg_regno, unsigned int end_regno, rtx x)
{
  if (((enum rtx_code) (x)->code) == SET || ((enum rtx_code) (x)->code) == CLOBBER)
    {
      rtx op0 = (((x)->u.fld[0]).rtx);

      while (((enum rtx_code) (op0)->code) == SUBREG)
 op0 = (((op0)->u.fld[0]).rtx);
      if (((enum rtx_code) (op0)->code) == REG)
 {
   unsigned int r = (((op0)->u.fld[0]).rtuint);


   if (r < end_regno
       && r + (((r) >= 8 && (r) <= (8 + 7)) || (((r) >= (20 + 1) && (r) <= ((20 + 1) + 7)) || ((r) >= (((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) && (r) <= ((((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) + 7))) || ((r) >= (((20 + 1) + 7) + 1) && (r) <= ((((20 + 1) + 7) + 1) + 7)) ? ((mode_class[((enum machine_mode) (op0)->mode)] == MODE_COMPLEX_INT || mode_class[((enum machine_mode) (op0)->mode)] == MODE_COMPLEX_FLOAT) ? 2 : 1) : ((((enum machine_mode) (op0)->mode)) == XFmode ? (0 ? 2 : 3) : (((enum machine_mode) (op0)->mode)) == XCmode ? (0 ? 4 : 6) : ((((unsigned short) mode_size[((enum machine_mode) (op0)->mode)]) + (0 ? 8 : 4) - 1) / (0 ? 8 : 4)))) > beg_regno)
     return 1;
 }
    }
  else if (((enum rtx_code) (x)->code) == PARALLEL)
    {
      int i = (((((x)->u.fld[0]).rtvec))->num_elem) - 1;

      for (; i >= 0; i--)
 if (hard_reg_set_here_p (beg_regno, end_regno, (((((x)->u.fld[0]).rtvec))->elem[i])))
   return 1;
    }

  return 0;
}





int
strict_memory_address_p (enum machine_mode mode __attribute__ ((__unused__)), rtx addr)
{
  do { if (legitimate_address_p ((mode), (addr), 1)) goto win; } while (0);
  return 0;

 win:
  return 1;
}
# 2104 "reload.c"
int
operands_match_p (rtx x, rtx y)
{
  int i;
  enum rtx_code code = ((enum rtx_code) (x)->code);
  const char *fmt;
  int success_2;

  if (x == y)
    return 1;
  if ((code == REG || (code == SUBREG && ((enum rtx_code) ((((x)->u.fld[0]).rtx))->code) == REG))
      && (((enum rtx_code) (y)->code) == REG || (((enum rtx_code) (y)->code) == SUBREG
      && ((enum rtx_code) ((((y)->u.fld[0]).rtx))->code) == REG)))
    {
      int j;

      if (code == SUBREG)
 {
   i = ((((((x)->u.fld[0]).rtx))->u.fld[0]).rtuint);
   if (i >= 53)
     goto slow;
   i += subreg_regno_offset (((((((x)->u.fld[0]).rtx))->u.fld[0]).rtuint),
        ((enum machine_mode) ((((x)->u.fld[0]).rtx))->mode),
        (((x)->u.fld[1]).rtuint),
        ((enum machine_mode) (x)->mode));
 }
      else
 i = (((x)->u.fld[0]).rtuint);

      if (((enum rtx_code) (y)->code) == SUBREG)
 {
   j = ((((((y)->u.fld[0]).rtx))->u.fld[0]).rtuint);
   if (j >= 53)
     goto slow;
   j += subreg_regno_offset (((((((y)->u.fld[0]).rtx))->u.fld[0]).rtuint),
        ((enum machine_mode) ((((y)->u.fld[0]).rtx))->mode),
        (((y)->u.fld[1]).rtuint),
        ((enum machine_mode) (y)->mode));
 }
      else
 j = (((y)->u.fld[0]).rtuint);




      if (0 && ((unsigned short) mode_size[((enum machine_mode) (x)->mode)]) > (0 ? 8 : 4)
   && i < 53)
 i += (((i) >= 8 && (i) <= (8 + 7)) || (((i) >= (20 + 1) && (i) <= ((20 + 1) + 7)) || ((i) >= (((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) && (i) <= ((((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) + 7))) || ((i) >= (((20 + 1) + 7) + 1) && (i) <= ((((20 + 1) + 7) + 1) + 7)) ? ((mode_class[((enum machine_mode) (x)->mode)] == MODE_COMPLEX_INT || mode_class[((enum machine_mode) (x)->mode)] == MODE_COMPLEX_FLOAT) ? 2 : 1) : ((((enum machine_mode) (x)->mode)) == XFmode ? (0 ? 2 : 3) : (((enum machine_mode) (x)->mode)) == XCmode ? (0 ? 4 : 6) : ((((unsigned short) mode_size[((enum machine_mode) (x)->mode)]) + (0 ? 8 : 4) - 1) / (0 ? 8 : 4)))) - 1;
      if (0 && ((unsigned short) mode_size[((enum machine_mode) (y)->mode)]) > (0 ? 8 : 4)
   && j < 53)
 j += (((j) >= 8 && (j) <= (8 + 7)) || (((j) >= (20 + 1) && (j) <= ((20 + 1) + 7)) || ((j) >= (((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) && (j) <= ((((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) + 7))) || ((j) >= (((20 + 1) + 7) + 1) && (j) <= ((((20 + 1) + 7) + 1) + 7)) ? ((mode_class[((enum machine_mode) (y)->mode)] == MODE_COMPLEX_INT || mode_class[((enum machine_mode) (y)->mode)] == MODE_COMPLEX_FLOAT) ? 2 : 1) : ((((enum machine_mode) (y)->mode)) == XFmode ? (0 ? 2 : 3) : (((enum machine_mode) (y)->mode)) == XCmode ? (0 ? 4 : 6) : ((((unsigned short) mode_size[((enum machine_mode) (y)->mode)]) + (0 ? 8 : 4) - 1) / (0 ? 8 : 4)))) - 1;

      return i == j;
    }





  if (code == POST_DEC || code == POST_INC || code == POST_MODIFY)
    return operands_match_p ((((x)->u.fld[0]).rtx), y);






  if (((enum rtx_code) (y)->code) == PRE_DEC || ((enum rtx_code) (y)->code) == PRE_INC
      || ((enum rtx_code) (y)->code) == PRE_MODIFY)
    return operands_match_p (x, (((y)->u.fld[0]).rtx)) ? 2 : 0;

 slow:



  if (code != ((enum rtx_code) (y)->code))
    return 0;
  if (code == LABEL_REF)
    return (((x)->u.fld[0]).rtx) == (((y)->u.fld[0]).rtx);
  if (code == SYMBOL_REF)
    return (((x)->u.fld[0]).rtstr) == (((y)->u.fld[0]).rtstr);



  if (((enum machine_mode) (x)->mode) != ((enum machine_mode) (y)->mode))
    return 0;




  success_2 = 0;
  fmt = (rtx_format[(int) (code)]);
  for (i = (rtx_length[(int) (code)]) - 1; i >= 0; i--)
    {
      int val, j;
      switch (fmt[i])
 {
 case 'w':
   if (((x)->u.hwint[i]) != ((y)->u.hwint[i]))
     return 0;
   break;

 case 'i':
   if ((((x)->u.fld[i]).rtint) != (((y)->u.fld[i]).rtint))
     return 0;
   break;

 case 'e':
   val = operands_match_p ((((x)->u.fld[i]).rtx), (((y)->u.fld[i]).rtx));
   if (val == 0)
     return 0;


   if (val == 2)
     success_2 = 1;
   break;

 case '0':
   break;

 case 'E':
   if ((((((x)->u.fld[i]).rtvec))->num_elem) != (((((y)->u.fld[i]).rtvec))->num_elem))
     return 0;
   for (j = (((((x)->u.fld[i]).rtvec))->num_elem) - 1; j >= 0; --j)
     {
       val = operands_match_p ((((((x)->u.fld[i]).rtvec))->elem[j]), (((((y)->u.fld[i]).rtvec))->elem[j]));
       if (val == 0)
  return 0;
       if (val == 2)
  success_2 = 1;
     }
   break;




 default:
   fancy_abort ("reload.c", 2241, __FUNCTION__);
 }
    }
  return 1 + success_2;
}
# 2255 "reload.c"
static struct decomposition
decompose (rtx x)
{
  struct decomposition val;
  int all_const = 0;

  val.reg_flag = 0;
  val.safe = 0;
  val.base = 0;
  if (((enum rtx_code) (x)->code) == MEM)
    {
      rtx base = (rtx) 0, offset = 0;
      rtx addr = (((x)->u.fld[0]).rtx);

      if (((enum rtx_code) (addr)->code) == PRE_DEC || ((enum rtx_code) (addr)->code) == PRE_INC
   || ((enum rtx_code) (addr)->code) == POST_DEC || ((enum rtx_code) (addr)->code) == POST_INC)
 {
   val.base = (((addr)->u.fld[0]).rtx);
   val.start = -((unsigned short) mode_size[((enum machine_mode) (x)->mode)]);
   val.end = ((unsigned short) mode_size[((enum machine_mode) (x)->mode)]);
   val.safe = (((val.base)->u.fld[0]).rtuint) == 7;
   return val;
 }

      if (((enum rtx_code) (addr)->code) == PRE_MODIFY || ((enum rtx_code) (addr)->code) == POST_MODIFY)
 {
   if (((enum rtx_code) ((((addr)->u.fld[1]).rtx))->code) == PLUS
       && (((addr)->u.fld[0]).rtx) == ((((((addr)->u.fld[1]).rtx))->u.fld[0]).rtx)
       && (((enum rtx_code) (((((((addr)->u.fld[1]).rtx))->u.fld[1]).rtx))->code) == LABEL_REF || ((enum rtx_code) (((((((addr)->u.fld[1]).rtx))->u.fld[1]).rtx))->code) == SYMBOL_REF || ((enum rtx_code) (((((((addr)->u.fld[1]).rtx))->u.fld[1]).rtx))->code) == CONST_INT || ((enum rtx_code) (((((((addr)->u.fld[1]).rtx))->u.fld[1]).rtx))->code) == CONST_DOUBLE || ((enum rtx_code) (((((((addr)->u.fld[1]).rtx))->u.fld[1]).rtx))->code) == CONST || ((enum rtx_code) (((((((addr)->u.fld[1]).rtx))->u.fld[1]).rtx))->code) == HIGH || ((enum rtx_code) (((((((addr)->u.fld[1]).rtx))->u.fld[1]).rtx))->code) == CONST_VECTOR || ((enum rtx_code) (((((((addr)->u.fld[1]).rtx))->u.fld[1]).rtx))->code) == CONSTANT_P_RTX))
     {
       val.base = (((addr)->u.fld[0]).rtx);
       val.start = -((((((((addr)->u.fld[1]).rtx))->u.fld[1]).rtx))->u.hwint[0]);
       val.end = ((((((((addr)->u.fld[1]).rtx))->u.fld[1]).rtx))->u.hwint[0]);
       val.safe = (((val.base)->u.fld[0]).rtuint) == 7;
       return val;
     }
 }

      if (((enum rtx_code) (addr)->code) == CONST)
 {
   addr = (((addr)->u.fld[0]).rtx);
   all_const = 1;
 }
      if (((enum rtx_code) (addr)->code) == PLUS)
 {
   if ((((enum rtx_code) ((((addr)->u.fld[0]).rtx))->code) == LABEL_REF || ((enum rtx_code) ((((addr)->u.fld[0]).rtx))->code) == SYMBOL_REF || ((enum rtx_code) ((((addr)->u.fld[0]).rtx))->code) == CONST_INT || ((enum rtx_code) ((((addr)->u.fld[0]).rtx))->code) == CONST_DOUBLE || ((enum rtx_code) ((((addr)->u.fld[0]).rtx))->code) == CONST || ((enum rtx_code) ((((addr)->u.fld[0]).rtx))->code) == HIGH || ((enum rtx_code) ((((addr)->u.fld[0]).rtx))->code) == CONST_VECTOR || ((enum rtx_code) ((((addr)->u.fld[0]).rtx))->code) == CONSTANT_P_RTX))
     {
       base = (((addr)->u.fld[1]).rtx);
       offset = (((addr)->u.fld[0]).rtx);
     }
   else if ((((enum rtx_code) ((((addr)->u.fld[1]).rtx))->code) == LABEL_REF || ((enum rtx_code) ((((addr)->u.fld[1]).rtx))->code) == SYMBOL_REF || ((enum rtx_code) ((((addr)->u.fld[1]).rtx))->code) == CONST_INT || ((enum rtx_code) ((((addr)->u.fld[1]).rtx))->code) == CONST_DOUBLE || ((enum rtx_code) ((((addr)->u.fld[1]).rtx))->code) == CONST || ((enum rtx_code) ((((addr)->u.fld[1]).rtx))->code) == HIGH || ((enum rtx_code) ((((addr)->u.fld[1]).rtx))->code) == CONST_VECTOR || ((enum rtx_code) ((((addr)->u.fld[1]).rtx))->code) == CONSTANT_P_RTX))
     {
       base = (((addr)->u.fld[0]).rtx);
       offset = (((addr)->u.fld[1]).rtx);
     }
 }

      if (offset == 0)
 {
   base = addr;
   offset = (const_int_rtx[64]);
 }
      if (((enum rtx_code) (offset)->code) == CONST)
 offset = (((offset)->u.fld[0]).rtx);
      if (((enum rtx_code) (offset)->code) == PLUS)
 {
   if (((enum rtx_code) ((((offset)->u.fld[0]).rtx))->code) == CONST_INT)
     {
       base = gen_rtx_fmt_ee (PLUS, (((enum machine_mode) (base)->mode)), (base), ((((offset)->u.fld[1]).rtx)));
       offset = (((offset)->u.fld[0]).rtx);
     }
   else if (((enum rtx_code) ((((offset)->u.fld[1]).rtx))->code) == CONST_INT)
     {
       base = gen_rtx_fmt_ee (PLUS, (((enum machine_mode) (base)->mode)), (base), ((((offset)->u.fld[0]).rtx)));
       offset = (((offset)->u.fld[1]).rtx);
     }
   else
     {
       base = gen_rtx_fmt_ee (PLUS, (((enum machine_mode) (base)->mode)), (base), (offset));
       offset = (const_int_rtx[64]);
     }
 }
      else if (((enum rtx_code) (offset)->code) != CONST_INT)
 {
   base = gen_rtx_fmt_ee (PLUS, (((enum machine_mode) (base)->mode)), (base), (offset));
   offset = (const_int_rtx[64]);
 }

      if (all_const && ((enum rtx_code) (base)->code) == PLUS)
 base = gen_rtx_fmt_e (CONST, (((enum machine_mode) (base)->mode)), (base));

      if (((enum rtx_code) (offset)->code) != CONST_INT)
 fancy_abort ("reload.c", 2347, __FUNCTION__);

      val.start = ((offset)->u.hwint[0]);
      val.end = val.start + ((unsigned short) mode_size[((enum machine_mode) (x)->mode)]);
      val.base = base;
      return val;
    }
  else if (((enum rtx_code) (x)->code) == REG)
    {
      val.reg_flag = 1;
      val.start = true_regnum (x);
      if (val.start < 0)
 {

   val.start = (((x)->u.fld[0]).rtuint);
   val.end = val.start + 1;
 }
      else

 val.end = val.start + (((val.start) >= 8 && (val.start) <= (8 + 7)) || (((val.start) >= (20 + 1) && (val.start) <= ((20 + 1) + 7)) || ((val.start) >= (((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) && (val.start) <= ((((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) + 7))) || ((val.start) >= (((20 + 1) + 7) + 1) && (val.start) <= ((((20 + 1) + 7) + 1) + 7)) ? ((mode_class[((enum machine_mode) (x)->mode)] == MODE_COMPLEX_INT || mode_class[((enum machine_mode) (x)->mode)] == MODE_COMPLEX_FLOAT) ? 2 : 1) : ((((enum machine_mode) (x)->mode)) == XFmode ? (0 ? 2 : 3) : (((enum machine_mode) (x)->mode)) == XCmode ? (0 ? 4 : 6) : ((((unsigned short) mode_size[((enum machine_mode) (x)->mode)]) + (0 ? 8 : 4) - 1) / (0 ? 8 : 4))));
    }
  else if (((enum rtx_code) (x)->code) == SUBREG)
    {
      if (((enum rtx_code) ((((x)->u.fld[0]).rtx))->code) != REG)

 return decompose ((((x)->u.fld[0]).rtx));
      val.reg_flag = 1;
      val.start = true_regnum (x);
      if (val.start < 0)
 return decompose ((((x)->u.fld[0]).rtx));
      else

 val.end = val.start + (((val.start) >= 8 && (val.start) <= (8 + 7)) || (((val.start) >= (20 + 1) && (val.start) <= ((20 + 1) + 7)) || ((val.start) >= (((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) && (val.start) <= ((((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) + 7))) || ((val.start) >= (((20 + 1) + 7) + 1) && (val.start) <= ((((20 + 1) + 7) + 1) + 7)) ? ((mode_class[((enum machine_mode) (x)->mode)] == MODE_COMPLEX_INT || mode_class[((enum machine_mode) (x)->mode)] == MODE_COMPLEX_FLOAT) ? 2 : 1) : ((((enum machine_mode) (x)->mode)) == XFmode ? (0 ? 2 : 3) : (((enum machine_mode) (x)->mode)) == XCmode ? (0 ? 4 : 6) : ((((unsigned short) mode_size[((enum machine_mode) (x)->mode)]) + (0 ? 8 : 4) - 1) / (0 ? 8 : 4))));
    }
  else if ((((enum rtx_code) (x)->code) == LABEL_REF || ((enum rtx_code) (x)->code) == SYMBOL_REF || ((enum rtx_code) (x)->code) == CONST_INT || ((enum rtx_code) (x)->code) == CONST_DOUBLE || ((enum rtx_code) (x)->code) == CONST || ((enum rtx_code) (x)->code) == HIGH || ((enum rtx_code) (x)->code) == CONST_VECTOR || ((enum rtx_code) (x)->code) == CONSTANT_P_RTX)

    || ((enum rtx_code) (x)->code) == SCRATCH)
    val.safe = 1;
  else
    fancy_abort ("reload.c", 2386, __FUNCTION__);
  return val;
}




static int
immune_p (rtx x, rtx y, struct decomposition ydata)
{
  struct decomposition xdata;

  if (ydata.reg_flag)
    return !refers_to_regno_for_reload_p (ydata.start, ydata.end, x, (rtx*) 0);
  if (ydata.safe)
    return 1;

  if (((enum rtx_code) (y)->code) != MEM)
    fancy_abort ("reload.c", 2404, __FUNCTION__);

  if (((enum rtx_code) (x)->code) != MEM)
    return 1;

  xdata = decompose (x);

  if (! rtx_equal_p (xdata.base, ydata.base))
    {

      if ((((enum rtx_code) (xdata.base)->code) == LABEL_REF || ((enum rtx_code) (xdata.base)->code) == SYMBOL_REF || ((enum rtx_code) (xdata.base)->code) == CONST_INT || ((enum rtx_code) (xdata.base)->code) == CONST_DOUBLE || ((enum rtx_code) (xdata.base)->code) == CONST || ((enum rtx_code) (xdata.base)->code) == HIGH || ((enum rtx_code) (xdata.base)->code) == CONST_VECTOR || ((enum rtx_code) (xdata.base)->code) == CONSTANT_P_RTX) && (((enum rtx_code) (ydata.base)->code) == LABEL_REF || ((enum rtx_code) (ydata.base)->code) == SYMBOL_REF || ((enum rtx_code) (ydata.base)->code) == CONST_INT || ((enum rtx_code) (ydata.base)->code) == CONST_DOUBLE || ((enum rtx_code) (ydata.base)->code) == CONST || ((enum rtx_code) (ydata.base)->code) == HIGH || ((enum rtx_code) (ydata.base)->code) == CONST_VECTOR || ((enum rtx_code) (ydata.base)->code) == CONSTANT_P_RTX))
 return 1;

      if ((((enum rtx_code) (xdata.base)->code) == LABEL_REF || ((enum rtx_code) (xdata.base)->code) == SYMBOL_REF || ((enum rtx_code) (xdata.base)->code) == CONST_INT || ((enum rtx_code) (xdata.base)->code) == CONST_DOUBLE || ((enum rtx_code) (xdata.base)->code) == CONST || ((enum rtx_code) (xdata.base)->code) == HIGH || ((enum rtx_code) (xdata.base)->code) == CONST_VECTOR || ((enum rtx_code) (xdata.base)->code) == CONSTANT_P_RTX)
   && (ydata.base == (global_rtl[GR_FRAME_POINTER])
       || ydata.base == (global_rtl[GR_HARD_FRAME_POINTER])
       || ydata.base == (global_rtl[GR_STACK_POINTER])))
 return 1;
      if ((((enum rtx_code) (ydata.base)->code) == LABEL_REF || ((enum rtx_code) (ydata.base)->code) == SYMBOL_REF || ((enum rtx_code) (ydata.base)->code) == CONST_INT || ((enum rtx_code) (ydata.base)->code) == CONST_DOUBLE || ((enum rtx_code) (ydata.base)->code) == CONST || ((enum rtx_code) (ydata.base)->code) == HIGH || ((enum rtx_code) (ydata.base)->code) == CONST_VECTOR || ((enum rtx_code) (ydata.base)->code) == CONSTANT_P_RTX)
   && (xdata.base == (global_rtl[GR_FRAME_POINTER])
       || xdata.base == (global_rtl[GR_HARD_FRAME_POINTER])
       || xdata.base == (global_rtl[GR_STACK_POINTER])))
 return 1;

      return 0;
    }

  return (xdata.start >= ydata.end || ydata.start >= xdata.end);
}



int
safe_from_earlyclobber (rtx op, rtx clobber)
{
  struct decomposition early_data;

  early_data = decompose (clobber);
  return immune_p (op, clobber, early_data);
}
# 2467 "reload.c"
int
find_reloads (rtx insn, int replace, int ind_levels, int live_known,
       short *reload_reg_p)
{
  int insn_code_number;
  int i, j;
  int noperands;


  char *constraints[30];


  enum reg_class preferred_class[30];
  char pref_or_nothing[30];

  int address_reloaded[30];

  int address_operand_reloaded[30];

  enum reload_type operand_type[30];

  enum reload_type address_type[30];

  enum reload_usage { RELOAD_READ, RELOAD_READ_WRITE, RELOAD_WRITE } modified[30];
  int no_input_reloads = 0, no_output_reloads = 0;
  int n_alternatives;
  int this_alternative[30];
  char this_alternative_match_win[30];
  char this_alternative_win[30];
  char this_alternative_offmemok[30];
  char this_alternative_earlyclobber[30];
  int this_alternative_matches[30];
  int swapped;
  int goal_alternative[30];
  int this_alternative_number;
  int goal_alternative_number = 0;
  int operand_reloadnum[30];
  int goal_alternative_matches[30];
  int goal_alternative_matched[30];
  char goal_alternative_match_win[30];
  char goal_alternative_win[30];
  char goal_alternative_offmemok[30];
  char goal_alternative_earlyclobber[30];
  int goal_alternative_swapped;
  int best;
  int commutative;
  char operands_match[30][30];
  rtx substed_operand[30];
  rtx body = (((insn)->u.fld[5]).rtx);
  rtx set = (((rtx_class[(int) (((enum rtx_code) (insn)->code))]) == 'i') ? (((enum rtx_code) ((((insn)->u.fld[5]).rtx))->code) == SET ? (((insn)->u.fld[5]).rtx) : single_set_2 (insn, (((insn)->u.fld[5]).rtx))) : (rtx) 0);
  int goal_earlyclobber = 0, this_earlyclobber;
  enum machine_mode operand_mode[30];
  int retval = 0;

  this_insn = insn;
  n_reloads = 0;
  n_replacements = 0;
  n_earlyclobbers = 0;
  replace_reloads = replace;
  hard_regs_live_known = live_known;
  static_reload_reg_p = reload_reg_p;




  if (((enum rtx_code) (insn)->code) == JUMP_INSN || ((enum rtx_code) (insn)->code) == CALL_INSN)
    no_output_reloads = 1;
# 2546 "reload.c"
  if (secondary_memlocs_elim_used)
    {
      memset (secondary_memlocs_elim, 0,
       sizeof (secondary_memlocs_elim[0]) * secondary_memlocs_elim_used);
      secondary_memlocs_elim_used = 0;
    }





  if (((enum rtx_code) (body)->code) == SET
      && ((enum rtx_code) ((((body)->u.fld[0]).rtx))->code) == REG
      && ((((((body)->u.fld[0]).rtx))->u.fld[0]).rtuint) < 53
      && ((enum rtx_code) ((((body)->u.fld[1]).rtx))->code) == REG
      && ((((((body)->u.fld[1]).rtx))->u.fld[0]).rtuint) < 53
      && ix86_register_move_cost ((((enum machine_mode) ((((body)->u.fld[1]).rtx))->mode)), ((regclass_map[((((((body)->u.fld[1]).rtx))->u.fld[0]).rtuint)])), ((regclass_map[((((((body)->u.fld[0]).rtx))->u.fld[0]).rtuint)]))) == 2)


    return 0;

  extract_insn (insn);

  noperands = reload_n_operands = recog_data.n_operands;
  n_alternatives = recog_data.n_alternatives;


  if (noperands == 0 || n_alternatives == 0)
    return 0;

  insn_code_number = (((insn)->u.fld[6]).rtint);
  this_insn_is_asm = insn_code_number < 0;

  memcpy (operand_mode, recog_data.operand_mode,
   noperands * sizeof (enum machine_mode));
  memcpy (constraints, recog_data.constraints, noperands * sizeof (char *));

  commutative = -1;






  for (i = 0; i < noperands; i++)
    {
      char *p;
      int c;

      substed_operand[i] = recog_data.operand[i];
      p = constraints[i];

      modified[i] = RELOAD_READ;




      while ((c = *p))
 {
   p += 1;
   if (c == '=')
     modified[i] = RELOAD_WRITE;
   else if (c == '+')
     modified[i] = RELOAD_READ_WRITE;
   else if (c == '%')
     {

       if (i == noperands - 1)
  fancy_abort ("reload.c", 2614, __FUNCTION__);
# 2623 "reload.c"
       if (commutative < 0)
  commutative = i;
       else if (!this_insn_is_asm)
  fancy_abort ("reload.c", 2626, __FUNCTION__);
     }
   else if ((_sch_istable[(c) & 0xff] & (unsigned short)(_sch_isdigit)))
     {
       c = strtoul (p - 1, &p, 10);

       operands_match[c][i]
  = operands_match_p (recog_data.operand[c],
        recog_data.operand[i]);


       if (c == i)
  fancy_abort ("reload.c", 2638, __FUNCTION__);



       if (commutative >= 0)
  {
    if (c == commutative || c == commutative + 1)
      {
        int other = c + (c == commutative ? 1 : -1);
        operands_match[other][i]
   = operands_match_p (recog_data.operand[other],
         recog_data.operand[i]);
      }
    if (i == commutative || i == commutative + 1)
      {
        int other = i + (i == commutative ? 1 : -1);
        operands_match[c][other]
   = operands_match_p (recog_data.operand[c],
         recog_data.operand[other]);
      }



  }
     }
 }
    }
# 2674 "reload.c"
  for (i = 0; i < noperands; i++)
    {
      enum rtx_code code = ((enum rtx_code) (recog_data.operand[i])->code);

      address_reloaded[i] = 0;
      address_operand_reloaded[i] = 0;
      operand_type[i] = (modified[i] == RELOAD_READ ? RELOAD_FOR_INPUT
    : modified[i] == RELOAD_WRITE ? RELOAD_FOR_OUTPUT
    : RELOAD_OTHER);
      address_type[i]
 = (modified[i] == RELOAD_READ ? RELOAD_FOR_INPUT_ADDRESS
    : modified[i] == RELOAD_WRITE ? RELOAD_FOR_OUTPUT_ADDRESS
    : RELOAD_OTHER);

      if (*constraints[i] == 0)

 ;
      else if (constraints[i][0] == 'p'
        || 0)
 {
   address_operand_reloaded[i]
     = find_reloads_address (recog_data.operand_mode[i], (rtx*) 0,
        recog_data.operand[i],
        recog_data.operand_loc[i],
        i, operand_type[i], ind_levels, insn);



   if (((rtx_class[(int) (((enum rtx_code) (*recog_data.operand_loc[i])->code))]) == 'o'
        || ((enum rtx_code) (*recog_data.operand_loc[i])->code) == SUBREG)
       && (((enum rtx_code) (recog_data.operand[i])->code) == MULT
    || ((enum rtx_code) (recog_data.operand[i])->code) == PLUS))
     {
       (((insn)->u.fld[6]).rtint) = -1;
       retval = find_reloads (insn, replace, ind_levels, live_known,
         reload_reg_p);
       return retval;
     }

   recog_data.operand[i] = *recog_data.operand_loc[i];
   substed_operand[i] = recog_data.operand[i];



   operand_mode[i] = ((enum machine_mode) (recog_data.operand[i])->mode);
 }
      else if (code == MEM)
 {
   address_reloaded[i]
     = find_reloads_address (((enum machine_mode) (recog_data.operand[i])->mode),
        recog_data.operand_loc[i],
        (((recog_data.operand[i])->u.fld[0]).rtx),
        &(((recog_data.operand[i])->u.fld[0]).rtx),
        i, address_type[i], ind_levels, insn);
   recog_data.operand[i] = *recog_data.operand_loc[i];
   substed_operand[i] = recog_data.operand[i];
 }
      else if (code == SUBREG)
 {
   rtx reg = (((recog_data.operand[i])->u.fld[0]).rtx);
   rtx op
     = find_reloads_toplev (recog_data.operand[i], i, address_type[i],
       ind_levels,
       set != 0
       && &(((set)->u.fld[0]).rtx) == recog_data.operand_loc[i],
       insn,
       &address_reloaded[i]);






   if (replace
       && ((enum rtx_code) (op)->code) == MEM
       && ((enum rtx_code) (reg)->code) == REG
       && (((unsigned short) mode_size[((enum machine_mode) (reg)->mode)])
    >= ((unsigned short) mode_size[((enum machine_mode) (op)->mode)])))
     set_unique_reg_note (emit_insn_before (gen_rtx_fmt_e (USE, (VOIDmode), (reg)),
         insn),
     REG_EQUAL, reg_equiv_memory_loc[(((reg)->u.fld[0]).rtuint)]);

   substed_operand[i] = recog_data.operand[i] = op;
 }
      else if (code == PLUS || (rtx_class[(int) (code)]) == '1')



 substed_operand[i] = recog_data.operand[i]
   = find_reloads_toplev (recog_data.operand[i], i, address_type[i],
     ind_levels, 0, insn,
     &address_reloaded[i]);
      else if (code == REG)
 {






   int regno = (((recog_data.operand[i])->u.fld[0]).rtuint);
   if (reg_equiv_constant[regno] != 0
       && (set == 0 || &(((set)->u.fld[0]).rtx) != recog_data.operand_loc[i]))
     {



       if (operand_mode[i] == VOIDmode)
  operand_mode[i] = ((enum machine_mode) (recog_data.operand[i])->mode);

       substed_operand[i] = recog_data.operand[i]
  = reg_equiv_constant[regno];
     }
   if (reg_equiv_memory_loc[regno] != 0
       && (reg_equiv_address[regno] != 0 || num_not_at_initial_offset))


     substed_operand[i] = recog_data.operand[i]
       = find_reloads_toplev (recog_data.operand[i], i, address_type[i],
         ind_levels, 0, insn,
         &address_reloaded[i]);
 }


      code = ((enum rtx_code) (recog_data.operand[i])->code);
      preferred_class[i]
 = ((code == REG && (((recog_data.operand[i])->u.fld[0]).rtuint)
     >= 53)
    ? reg_preferred_class ((((recog_data.operand[i])->u.fld[0]).rtuint))
    : NO_REGS);
      pref_or_nothing[i]
 = (code == REG
    && (((recog_data.operand[i])->u.fld[0]).rtuint) >= 53
    && reg_alternate_class ((((recog_data.operand[i])->u.fld[0]).rtuint)) == NO_REGS);
    }



  if (set != 0 && noperands >= 2 && recog_data.operand[0] == (((set)->u.fld[0]).rtx)
      && recog_data.operand[1] == (((set)->u.fld[1]).rtx))
    {
      preferred_class[0] = preferred_class[1]
 = reg_class_subunion[(int) preferred_class[0]][(int) preferred_class[1]];
      pref_or_nothing[0] |= pref_or_nothing[1];
      pref_or_nothing[1] |= pref_or_nothing[0];
    }





  best = 30 * 2 + 600;

  swapped = 0;
  goal_alternative_swapped = 0;
 try_swapped:
# 2838 "reload.c"
  for (this_alternative_number = 0;
       this_alternative_number < n_alternatives;
       this_alternative_number++)
    {



      int losers = 0;


      int bad = 0;






      int reject = 0;

      this_earlyclobber = 0;

      for (i = 0; i < noperands; i++)
 {
   char *p = constraints[i];
   char *end;
   int len;
   int win = 0;
   int did_match = 0;

   int badop = 1;

   int winreg = 0;
   int c;
   int m;
   rtx operand = recog_data.operand[i];
   int offset = 0;


   int force_reload = 0;
   int offmemok = 0;


   int constmemok = 0;
   int earlyclobber = 0;




   if ((rtx_class[(int) (((enum rtx_code) (operand)->code))]) == '1' && *p != 0)
     operand = (((operand)->u.fld[0]).rtx);





   while (((enum rtx_code) (operand)->code) == SUBREG)
     {




       if (((enum rtx_code) ((((operand)->u.fld[0]).rtx))->code) == REG
    && ((((((operand)->u.fld[0]).rtx))->u.fld[0]).rtuint) < 53)
  {
    if (!subreg_offset_representable_p
   (((((((operand)->u.fld[0]).rtx))->u.fld[0]).rtuint),
    ((enum machine_mode) ((((operand)->u.fld[0]).rtx))->mode),
    (((operand)->u.fld[1]).rtuint),
    ((enum machine_mode) (operand)->mode)))
       force_reload = 1;
    offset += subreg_regno_offset (((((((operand)->u.fld[0]).rtx))->u.fld[0]).rtuint),
       ((enum machine_mode) ((((operand)->u.fld[0]).rtx))->mode),
       (((operand)->u.fld[1]).rtuint),
       ((enum machine_mode) (operand)->mode));
  }
       operand = (((operand)->u.fld[0]).rtx);


       if ((((enum rtx_code) (operand)->code) == LABEL_REF || ((enum rtx_code) (operand)->code) == SYMBOL_REF || ((enum rtx_code) (operand)->code) == CONST_INT || ((enum rtx_code) (operand)->code) == CONST_DOUBLE || ((enum rtx_code) (operand)->code) == CONST || ((enum rtx_code) (operand)->code) == HIGH || ((enum rtx_code) (operand)->code) == CONST_VECTOR || ((enum rtx_code) (operand)->code) == CONSTANT_P_RTX)
    || ((enum rtx_code) (operand)->code) == PLUS
# 2942 "reload.c"
    || ((((enum rtx_code) (operand)->code) == MEM
         || (((enum rtx_code) (operand)->code)== REG
      && (((operand)->u.fld[0]).rtuint) >= 53))

        && (((((unsigned short) (((unsigned short) mode_size[((enum machine_mode) (operand)->mode)]) * 8))
       < 128)
      && (((unsigned short) mode_size[operand_mode[i]])
          > ((unsigned short) mode_size[((enum machine_mode) (operand)->mode)])))
     || (((enum rtx_code) (operand)->code) == MEM && 0)
# 2960 "reload.c"
     )

        )
    )
  force_reload = 1;
     }

   this_alternative[i] = (int) NO_REGS;
   this_alternative_win[i] = 0;
   this_alternative_match_win[i] = 0;
   this_alternative_offmemok[i] = 0;
   this_alternative_earlyclobber[i] = 0;
   this_alternative_matches[i] = -1;



   if (*p == 0 || *p == ',')
     win = 1, badop = 0;
# 2986 "reload.c"
   do
     switch ((c = *p, len = 1), c)
       {
       case '\0':
  len = 0;
  break;
       case ',':
  c = '\0';
  break;

       case '=': case '+': case '*':
  break;

       case '%':


  break;

       case '?':
  reject += 6;
  break;

       case '!':
  reject = 600;
  break;

       case '#':


  do
    p++;
  while (*p && *p != ',');
  len = 0;
  break;

       case '0': case '1': case '2': case '3': case '4':
       case '5': case '6': case '7': case '8': case '9':
  m = strtoul (p, &end, 10);
  p = end;
  len = 0;

  this_alternative_matches[i] = m;







  if ((swapped && (m != commutative || i != commutative + 1))






      ? (operands_match
         [(m == commutative || m == commutative + 1)
         ? 2 * commutative + 1 - m : m]
         [(i == commutative || i == commutative + 1)
         ? 2 * commutative + 1 - i : i])
      : operands_match[m][i])
    {



      if (this_alternative_offmemok[m]
   && ((enum rtx_code) (recog_data.operand[m])->code) == MEM
   && this_alternative[m] == (int) NO_REGS
   && ! this_alternative_win[m])
        bad = 1;

      did_match = this_alternative_win[m];
    }
  else
    {

      rtx value;


      if (this_alternative_win[m])
        losers++;
      this_alternative_win[m] = 0;
      if (this_alternative[m] == (int) NO_REGS)
        bad = 1;


      value
        = find_dummy_reload (recog_data.operand[i],
        recog_data.operand[m],
        recog_data.operand_loc[i],
        recog_data.operand_loc[m],
        operand_mode[i], operand_mode[m],
        this_alternative[m], -1,
        this_alternative_earlyclobber[m]);

      if (value != 0)
        losers--;
    }


  badop = 0;
  this_alternative[i] = this_alternative[m];





  if (! did_match || force_reload)
    for (j = 0; j < i; j++)
      if (this_alternative_matches[j]
   == this_alternative_matches[i])
        badop = 1;
  break;

       case 'p':


  this_alternative[i] = (int) GENERAL_REGS;
  win = 1;
  badop = 0;
  break;

       case 'm':
  if (force_reload)
    break;
  if (((enum rtx_code) (operand)->code) == MEM
      || (((enum rtx_code) (operand)->code) == REG
   && (((operand)->u.fld[0]).rtuint) >= 53
   && reg_renumber[(((operand)->u.fld[0]).rtuint)] < 0))
    win = 1;
  if ((((enum rtx_code) (operand)->code) == LABEL_REF || ((enum rtx_code) (operand)->code) == SYMBOL_REF || ((enum rtx_code) (operand)->code) == CONST_INT || ((enum rtx_code) (operand)->code) == CONST_DOUBLE || ((enum rtx_code) (operand)->code) == CONST || ((enum rtx_code) (operand)->code) == HIGH || ((enum rtx_code) (operand)->code) == CONST_VECTOR || ((enum rtx_code) (operand)->code) == CONSTANT_P_RTX)

      && ((enum rtx_code) (operand)->code) != HIGH)
    badop = 0;
  constmemok = 1;
  break;

       case '<':
  if (((enum rtx_code) (operand)->code) == MEM
      && ! address_reloaded[i]
      && (((enum rtx_code) ((((operand)->u.fld[0]).rtx))->code) == PRE_DEC
   || ((enum rtx_code) ((((operand)->u.fld[0]).rtx))->code) == POST_DEC))
    win = 1;
  break;

       case '>':
  if (((enum rtx_code) (operand)->code) == MEM
      && ! address_reloaded[i]
      && (((enum rtx_code) ((((operand)->u.fld[0]).rtx))->code) == PRE_INC
   || ((enum rtx_code) ((((operand)->u.fld[0]).rtx))->code) == POST_INC))
    win = 1;
  break;


       case 'V':
  if (force_reload)
    break;
  if (((enum rtx_code) (operand)->code) == MEM
      && ! (ind_levels ? offsettable_memref_p (operand)
     : offsettable_nonstrict_memref_p (operand))




      && !(((enum rtx_code) ((((operand)->u.fld[0]).rtx))->code) == REG
    && (ind_levels == 0
        || reg_equiv_address[((((((operand)->u.fld[0]).rtx))->u.fld[0]).rtuint)] != 0)))
    win = 1;
  break;


       case 'o':
  if (force_reload)
    break;
  if ((((enum rtx_code) (operand)->code) == MEM



       && ((ind_levels ? offsettable_memref_p (operand)
     : offsettable_nonstrict_memref_p (operand))


    || address_reloaded[i]))
      || (((enum rtx_code) (operand)->code) == REG
   && (((operand)->u.fld[0]).rtuint) >= 53
   && reg_renumber[(((operand)->u.fld[0]).rtuint)] < 0




   && ((reg_equiv_mem[(((operand)->u.fld[0]).rtuint)] != 0
        && offsettable_memref_p (reg_equiv_mem[(((operand)->u.fld[0]).rtuint)]))
       || (reg_equiv_address[(((operand)->u.fld[0]).rtuint)] != 0))))
    win = 1;

  if (((((enum rtx_code) (operand)->code) == LABEL_REF || ((enum rtx_code) (operand)->code) == SYMBOL_REF || ((enum rtx_code) (operand)->code) == CONST_INT || ((enum rtx_code) (operand)->code) == CONST_DOUBLE || ((enum rtx_code) (operand)->code) == CONST || ((enum rtx_code) (operand)->code) == HIGH || ((enum rtx_code) (operand)->code) == CONST_VECTOR || ((enum rtx_code) (operand)->code) == CONSTANT_P_RTX) && ((enum rtx_code) (operand)->code) != HIGH)
      || ((enum rtx_code) (operand)->code) == MEM)
    badop = 0;
  constmemok = 1;
  offmemok = 1;
  break;

       case '&':


  earlyclobber = 1, this_earlyclobber = 1;
  break;

       case 'E':
       case 'F':
  if (((enum rtx_code) (operand)->code) == CONST_DOUBLE
      || (((enum rtx_code) (operand)->code) == CONST_VECTOR
   && (mode_class[((enum machine_mode) (operand)->mode)]
       == MODE_VECTOR_FLOAT)))
    win = 1;
  break;

       case 'G':
       case 'H':
  if (((enum rtx_code) (operand)->code) == CONST_DOUBLE
      && ((c) == 'G' ? standard_80387_constant_p (operand) : 0))
    win = 1;
  break;

       case 's':
  if (((enum rtx_code) (operand)->code) == CONST_INT
      || (((enum rtx_code) (operand)->code) == CONST_DOUBLE
   && ((enum machine_mode) (operand)->mode) == VOIDmode))
    break;
       case 'i':
  if ((((enum rtx_code) (operand)->code) == LABEL_REF || ((enum rtx_code) (operand)->code) == SYMBOL_REF || ((enum rtx_code) (operand)->code) == CONST_INT || ((enum rtx_code) (operand)->code) == CONST_DOUBLE || ((enum rtx_code) (operand)->code) == CONST || ((enum rtx_code) (operand)->code) == HIGH || ((enum rtx_code) (operand)->code) == CONST_VECTOR || ((enum rtx_code) (operand)->code) == CONSTANT_P_RTX)

      && (! flag_pic || legitimate_pic_operand_p (operand))

      )
    win = 1;
  break;

       case 'n':
  if (((enum rtx_code) (operand)->code) == CONST_INT
      || (((enum rtx_code) (operand)->code) == CONST_DOUBLE
   && ((enum machine_mode) (operand)->mode) == VOIDmode))
    win = 1;
  break;

       case 'I':
       case 'J':
       case 'K':
       case 'L':
       case 'M':
       case 'N':
       case 'O':
       case 'P':
  if (((enum rtx_code) (operand)->code) == CONST_INT
      && ((c) == 'I' ? (((operand)->u.hwint[0])) >= 0 && (((operand)->u.hwint[0])) <= 31 : (c) == 'J' ? (((operand)->u.hwint[0])) >= 0 && (((operand)->u.hwint[0])) <= 63 : (c) == 'K' ? (((operand)->u.hwint[0])) >= -128 && (((operand)->u.hwint[0])) <= 127 : (c) == 'L' ? (((operand)->u.hwint[0])) == 0xff || (((operand)->u.hwint[0])) == 0xffff : (c) == 'M' ? (((operand)->u.hwint[0])) >= 0 && (((operand)->u.hwint[0])) <= 3 : (c) == 'N' ? (((operand)->u.hwint[0])) >= 0 && (((operand)->u.hwint[0])) <= 255 : 0))
    win = 1;
  break;

       case 'X':
  win = 1;
  break;

       case 'g':
  if (! force_reload


      && ((enum rtx_code) (operand)->code) != PLUS

      && ((enum rtx_code) (operand)->code) != SCRATCH

      && (! (((enum rtx_code) (operand)->code) == LABEL_REF || ((enum rtx_code) (operand)->code) == SYMBOL_REF || ((enum rtx_code) (operand)->code) == CONST_INT || ((enum rtx_code) (operand)->code) == CONST_DOUBLE || ((enum rtx_code) (operand)->code) == CONST || ((enum rtx_code) (operand)->code) == HIGH || ((enum rtx_code) (operand)->code) == CONST_VECTOR || ((enum rtx_code) (operand)->code) == CONSTANT_P_RTX)
   || ! flag_pic
   || legitimate_pic_operand_p (operand))

      && (GENERAL_REGS == ALL_REGS
   || ((enum rtx_code) (operand)->code) != REG
   || ((((operand)->u.fld[0]).rtuint) >= 53
       && reg_renumber[(((operand)->u.fld[0]).rtuint)] < 0)))
    win = 1;


       case 'r':
  this_alternative[i]
    = (int) reg_class_subunion[this_alternative[i]][(int) GENERAL_REGS];
  goto reg;

       default:
  if (((c) == 'r' ? GENERAL_REGS : (c) == 'R' ? LEGACY_REGS : (c) == 'q' ? 0 ? GENERAL_REGS : Q_REGS : (c) == 'Q' ? Q_REGS : (c) == 'f' ? ((target_flags & 0x00000001) || (target_flags & 0x00000020) ? FLOAT_REGS : NO_REGS) : (c) == 't' ? ((target_flags & 0x00000001) || (target_flags & 0x00000020) ? FP_TOP_REG : NO_REGS) : (c) == 'u' ? ((target_flags & 0x00000001) || (target_flags & 0x00000020) ? FP_SECOND_REG : NO_REGS) : (c) == 'a' ? AREG : (c) == 'b' ? BREG : (c) == 'c' ? CREG : (c) == 'd' ? DREG : (c) == 'x' ? ((target_flags & 0x00004000) != 0) ? SSE_REGS : NO_REGS : (c) == 'Y' ? ((target_flags & 0x00008000) != 0)? SSE_REGS : NO_REGS : (c) == 'y' ? ((target_flags & 0x00002000) != 0) ? MMX_REGS : NO_REGS : (c) == 'A' ? AD_REGS : (c) == 'D' ? DIREG : (c) == 'S' ? SIREG : NO_REGS) == NO_REGS)
    {

      if (0)
        {
   if (force_reload)
     break;
          if (((c) == 'e' ? x86_64_sign_extended_value (operand) : (c) == 'Z' ? x86_64_zero_extended_value (operand) : (c) == 'C' ? standard_sse_constant_p (operand) : 0))
            win = 1;


   else if (((enum rtx_code) (operand)->code) == MEM
     && address_reloaded[i])
     win = 1;



          else if (((enum rtx_code) (operand)->code) == REG
     && (((operand)->u.fld[0]).rtuint) >= 53
     && reg_renumber[(((operand)->u.fld[0]).rtuint)] < 0
     && ((reg_equiv_mem[(((operand)->u.fld[0]).rtuint)] != 0
          && ((c) == 'e' ? x86_64_sign_extended_value (reg_equiv_mem[(((operand)->u.fld[0]).rtuint)]) : (c) == 'Z' ? x86_64_zero_extended_value (reg_equiv_mem[(((operand)->u.fld[0]).rtuint)]) : (c) == 'C' ? standard_sse_constant_p (reg_equiv_mem[(((operand)->u.fld[0]).rtuint)]) : 0))
         || (reg_equiv_address[(((operand)->u.fld[0]).rtuint)] != 0)))
     win = 1;




   if (((((enum rtx_code) (operand)->code) == LABEL_REF || ((enum rtx_code) (operand)->code) == SYMBOL_REF || ((enum rtx_code) (operand)->code) == CONST_INT || ((enum rtx_code) (operand)->code) == CONST_DOUBLE || ((enum rtx_code) (operand)->code) == CONST || ((enum rtx_code) (operand)->code) == HIGH || ((enum rtx_code) (operand)->code) == CONST_VECTOR || ((enum rtx_code) (operand)->code) == CONSTANT_P_RTX) && ((enum rtx_code) (operand)->code) != HIGH)
       || ((enum rtx_code) (operand)->code) == MEM)
     badop = 0;
   constmemok = 1;
   offmemok = 1;
   break;
        }
      if (0)
        {
          if (((c) == 'e' ? x86_64_sign_extended_value (operand) : (c) == 'Z' ? x86_64_zero_extended_value (operand) : (c) == 'C' ? standard_sse_constant_p (operand) : 0))
            win = 1;



   this_alternative[i] = (int) GENERAL_REGS;
   badop = 0;
   break;
        }

      if (((c) == 'e' ? x86_64_sign_extended_value (operand) : (c) == 'Z' ? x86_64_zero_extended_value (operand) : (c) == 'C' ? standard_sse_constant_p (operand) : 0))
        win = 1;

      break;
    }

  this_alternative[i]
    = (int) (reg_class_subunion
      [this_alternative[i]]
      [(int) ((c) == 'r' ? GENERAL_REGS : (c) == 'R' ? LEGACY_REGS : (c) == 'q' ? 0 ? GENERAL_REGS : Q_REGS : (c) == 'Q' ? Q_REGS : (c) == 'f' ? ((target_flags & 0x00000001) || (target_flags & 0x00000020) ? FLOAT_REGS : NO_REGS) : (c) == 't' ? ((target_flags & 0x00000001) || (target_flags & 0x00000020) ? FP_TOP_REG : NO_REGS) : (c) == 'u' ? ((target_flags & 0x00000001) || (target_flags & 0x00000020) ? FP_SECOND_REG : NO_REGS) : (c) == 'a' ? AREG : (c) == 'b' ? BREG : (c) == 'c' ? CREG : (c) == 'd' ? DREG : (c) == 'x' ? ((target_flags & 0x00004000) != 0) ? SSE_REGS : NO_REGS : (c) == 'Y' ? ((target_flags & 0x00008000) != 0)? SSE_REGS : NO_REGS : (c) == 'y' ? ((target_flags & 0x00002000) != 0) ? MMX_REGS : NO_REGS : (c) == 'A' ? AD_REGS : (c) == 'D' ? DIREG : (c) == 'S' ? SIREG : NO_REGS)]);
       reg:
  if (((enum machine_mode) (operand)->mode) == BLKmode)
    break;
  winreg = 1;
  if (((enum rtx_code) (operand)->code) == REG
      && reg_fits_class_p (operand, this_alternative[i],
      offset, ((enum machine_mode) (recog_data.operand[i])->mode)))
    win = 1;
  break;
       }
   while ((p += len), c);

   constraints[i] = p;



   if (winreg && this_alternative[i] != (int) NO_REGS)
     badop = 0;


   this_alternative_earlyclobber[i] = earlyclobber;
   if (win && ! force_reload)
     this_alternative_win[i] = 1;
   else if (did_match && ! force_reload)
     this_alternative_match_win[i] = 1;
   else
     {
       int const_to_mem = 0;

       this_alternative_offmemok[i] = offmemok;
       losers++;
       if (badop)
  bad = 1;

       if (((enum rtx_code) (operand)->code) == REG
    && this_alternative[i] == (int) NO_REGS
    && this_alternative_matches[i] < 0)
  bad = 1;
# 3378 "reload.c"
       if ((((enum rtx_code) (operand)->code) == LABEL_REF || ((enum rtx_code) (operand)->code) == SYMBOL_REF || ((enum rtx_code) (operand)->code) == CONST_INT || ((enum rtx_code) (operand)->code) == CONST_DOUBLE || ((enum rtx_code) (operand)->code) == CONST || ((enum rtx_code) (operand)->code) == HIGH || ((enum rtx_code) (operand)->code) == CONST_VECTOR || ((enum rtx_code) (operand)->code) == CONSTANT_P_RTX)

    && ((enum rtx_code) (operand)->code) != HIGH
    && ((ix86_preferred_reload_class ((operand), ((enum reg_class) this_alternative[i]))

         == NO_REGS)
        || no_input_reloads)
    && operand_mode[i] != VOIDmode)
  {
    const_to_mem = 1;
    if (this_alternative[i] != (int) NO_REGS)
      losers++;
  }






       if (! (((enum rtx_code) (operand)->code) == LABEL_REF || ((enum rtx_code) (operand)->code) == SYMBOL_REF || ((enum rtx_code) (operand)->code) == CONST_INT || ((enum rtx_code) (operand)->code) == CONST_DOUBLE || ((enum rtx_code) (operand)->code) == CONST || ((enum rtx_code) (operand)->code) == HIGH || ((enum rtx_code) (operand)->code) == CONST_VECTOR || ((enum rtx_code) (operand)->code) == CONSTANT_P_RTX)
    && (enum reg_class) this_alternative[i] != NO_REGS
    && (ix86_preferred_reload_class ((operand), ((enum reg_class) this_alternative[i]))

        == NO_REGS))
  bad = 1;




       else if (((enum rtx_code) (operand)->code) != SCRATCH
         && modified[i] != RELOAD_READ && no_output_reloads
         && ! find_reg_note (insn, REG_UNUSED, operand))
  bad = 1;
       else if (modified[i] != RELOAD_WRITE && no_input_reloads
         && ! const_to_mem)
  bad = 1;
# 3429 "reload.c"
       if (! (((enum rtx_code) (operand)->code) == REG
       && (((operand)->u.fld[0]).rtuint) >= 53)
    && ((enum rtx_code) (operand)->code) != SCRATCH
    && ! (const_to_mem && constmemok))
  reject += 2;



       if (operand_type[i] != RELOAD_FOR_INPUT
    && ((enum rtx_code) (operand)->code) != SCRATCH)
  reject++;
     }
# 3463 "reload.c"
   if (! win && ! did_match
       && this_alternative[i] != (int) NO_REGS
       && ((unsigned short) mode_size[operand_mode[i]]) <= (0 ? 8 : 4)
       && reg_class_size[(int) preferred_class[i]] > 1)
     {
       if (! reg_class_subset_p (this_alternative[i],
     preferred_class[i]))
  {




    if (reg_class_subset_p (preferred_class[i],
       this_alternative[i]))
      this_alternative[i] = (int) preferred_class[i];
    else
      reject += (2 + 2 * pref_or_nothing[i]);
  }
     }
 }





      for (i = 0; i < noperands; i++)
 if (this_alternative_earlyclobber[i]
     && (this_alternative_win[i] || this_alternative_match_win[i]))
   {
     struct decomposition early_data;

     early_data = decompose (recog_data.operand[i]);

     if (modified[i] == RELOAD_READ)
       fancy_abort ("reload.c", 3497, __FUNCTION__);

     if (this_alternative[i] == NO_REGS)
       {
  this_alternative_earlyclobber[i] = 0;
  if (this_insn_is_asm)
    error_for_asm (this_insn,
     "`&' constraint used with no register class");
  else
    fancy_abort ("reload.c", 3506, __FUNCTION__);
       }

     for (j = 0; j < noperands; j++)

       if ((((enum rtx_code) (recog_data.operand[j])->code) == MEM
     || modified[j] != RELOAD_WRITE)
    && j != i

    && *recog_data.constraints[j] != 0


    && ! (this_alternative_matches[j] == i
   && rtx_equal_p (recog_data.operand[i],
     recog_data.operand[j]))

    && !immune_p (recog_data.operand[j], recog_data.operand[i],
    early_data))
  {


    if (reg_class_size[this_alternative[i]] == 1
        && (((enum rtx_code) (recog_data.operand[j])->code) == REG
     || ((enum rtx_code) (recog_data.operand[j])->code) == SUBREG))
      {
        losers++;
        this_alternative_win[j] = 0;
        this_alternative_match_win[j] = 0;
      }
    else
      break;
  }


     if (j != noperands)
       {
  losers++;
  this_alternative_win[i] = 0;
  this_alternative_match_win[j] = 0;
  for (j = 0; j < noperands; j++)
    if (this_alternative_matches[j] == i
        && this_alternative_match_win[j])
      {
        this_alternative_win[j] = 0;
        this_alternative_match_win[j] = 0;
        losers++;
      }
       }
   }



      if (losers == 0)
 {

   if (commutative >= 0)
     {
       recog_data.operand[commutative] = substed_operand[commutative];
       recog_data.operand[commutative + 1]
  = substed_operand[commutative + 1];
     }
   for (i = 0; i < noperands; i++)
     {
       goal_alternative_win[i] = this_alternative_win[i];
       goal_alternative_match_win[i] = this_alternative_match_win[i];
       goal_alternative[i] = this_alternative[i];
       goal_alternative_offmemok[i] = this_alternative_offmemok[i];
       goal_alternative_matches[i] = this_alternative_matches[i];
       goal_alternative_earlyclobber[i]
  = this_alternative_earlyclobber[i];
     }
   goal_alternative_number = this_alternative_number;
   goal_alternative_swapped = swapped;
   goal_earlyclobber = this_earlyclobber;
   goto finish;
 }





      losers = losers * 6 + reject;




      if (! bad && best > losers)
 {
   for (i = 0; i < noperands; i++)
     {
       goal_alternative[i] = this_alternative[i];
       goal_alternative_win[i] = this_alternative_win[i];
       goal_alternative_match_win[i] = this_alternative_match_win[i];
       goal_alternative_offmemok[i] = this_alternative_offmemok[i];
       goal_alternative_matches[i] = this_alternative_matches[i];
       goal_alternative_earlyclobber[i]
  = this_alternative_earlyclobber[i];
     }
   goal_alternative_swapped = swapped;
   best = losers;
   goal_alternative_number = this_alternative_number;
   goal_earlyclobber = this_earlyclobber;
 }
    }
# 3620 "reload.c"
  if (commutative >= 0)
    {
      swapped = !swapped;
      if (swapped)
 {
   enum reg_class tclass;
   int t;

   recog_data.operand[commutative] = substed_operand[commutative + 1];
   recog_data.operand[commutative + 1] = substed_operand[commutative];

   for (i = 0; i < recog_data.n_dups; i++)
     if (recog_data.dup_num[i] == commutative
  || recog_data.dup_num[i] == commutative + 1)
       *recog_data.dup_loc[i]
   = recog_data.operand[(int) recog_data.dup_num[i]];

   tclass = preferred_class[commutative];
   preferred_class[commutative] = preferred_class[commutative + 1];
   preferred_class[commutative + 1] = tclass;

   t = pref_or_nothing[commutative];
   pref_or_nothing[commutative] = pref_or_nothing[commutative + 1];
   pref_or_nothing[commutative + 1] = t;

   memcpy (constraints, recog_data.constraints,
    noperands * sizeof (char *));
   goto try_swapped;
 }
      else
 {
   recog_data.operand[commutative] = substed_operand[commutative];
   recog_data.operand[commutative + 1]
     = substed_operand[commutative + 1];

   for (i = 0; i < recog_data.n_dups; i++)
     if (recog_data.dup_num[i] == commutative
  || recog_data.dup_num[i] == commutative + 1)
       *recog_data.dup_loc[i]
   = recog_data.operand[(int) recog_data.dup_num[i]];
 }
    }






  if (best == 30 * 2 + 600)
    {

      if (insn_code_number >= 0)
 _fatal_insn ("unable to generate reloads for:", insn, "reload.c", 3672, __FUNCTION__);
      error_for_asm (insn, "inconsistent operand constraints in an `asm'");

      (((insn)->u.fld[5]).rtx) = gen_rtx_fmt_e (USE, (VOIDmode), ((const_int_rtx[64])));
      n_reloads = 0;
      return 0;
    }



 finish:







  for (i = 0; i < noperands; i++)
    goal_alternative_matched[i] = -1;

  for (i = 0; i < noperands; i++)
    if (! goal_alternative_win[i]
 && goal_alternative_matches[i] >= 0)
      goal_alternative_matched[goal_alternative_matches[i]] = i;

  for (i = 0; i < noperands; i++)
    goal_alternative_win[i] |= goal_alternative_match_win[i];





  if (goal_alternative_swapped)
    {
      rtx tem;

      tem = substed_operand[commutative];
      substed_operand[commutative] = substed_operand[commutative + 1];
      substed_operand[commutative + 1] = tem;
      tem = recog_data.operand[commutative];
      recog_data.operand[commutative] = recog_data.operand[commutative + 1];
      recog_data.operand[commutative + 1] = tem;
      tem = *recog_data.operand_loc[commutative];
      *recog_data.operand_loc[commutative]
 = *recog_data.operand_loc[commutative + 1];
      *recog_data.operand_loc[commutative + 1] = tem;

      for (i = 0; i < n_reloads; i++)
 {
   if (rld[i].opnum == commutative)
     rld[i].opnum = commutative + 1;
   else if (rld[i].opnum == commutative + 1)
     rld[i].opnum = commutative;
 }
    }

  for (i = 0; i < noperands; i++)
    {
      operand_reloadnum[i] = -1;
# 3750 "reload.c"
      if (goal_alternative_earlyclobber[i] && operand_type[i] != RELOAD_OTHER)
 operand_type[i]
   = (find_reg_note (insn, REG_UNUSED, recog_data.operand[i])
      ? RELOAD_FOR_INSN : RELOAD_OTHER);
    }



  for (i = 0; i < noperands; i++)
    if (! goal_alternative_win[i]
 && (((enum rtx_code) (recog_data.operand[i])->code) == LABEL_REF || ((enum rtx_code) (recog_data.operand[i])->code) == SYMBOL_REF || ((enum rtx_code) (recog_data.operand[i])->code) == CONST_INT || ((enum rtx_code) (recog_data.operand[i])->code) == CONST_DOUBLE || ((enum rtx_code) (recog_data.operand[i])->code) == CONST || ((enum rtx_code) (recog_data.operand[i])->code) == HIGH || ((enum rtx_code) (recog_data.operand[i])->code) == CONST_VECTOR || ((enum rtx_code) (recog_data.operand[i])->code) == CONSTANT_P_RTX)

 && ((enum rtx_code) (recog_data.operand[i])->code) != HIGH
 && ((ix86_preferred_reload_class ((recog_data.operand[i]), ((enum reg_class) goal_alternative[i]))

      == NO_REGS)
     || no_input_reloads)
 && operand_mode[i] != VOIDmode)
      {
 substed_operand[i] = recog_data.operand[i]
   = find_reloads_toplev (force_const_mem (operand_mode[i],
        recog_data.operand[i]),
     i, address_type[i], ind_levels, 0, insn,
     ((void *)0));
 if (alternative_allows_memconst (recog_data.constraints[i],
      goal_alternative_number))
   goal_alternative_win[i] = 1;
      }


  if (goal_earlyclobber)
    for (i = 0; i < noperands; i++)
      if (goal_alternative_earlyclobber[i])
 reload_earlyclobbers[n_earlyclobbers++] = recog_data.operand[i];


  for (i = 0; i < noperands; i++)
    if (! goal_alternative_win[i])
      {

 if (goal_alternative_matches[i] >= 0)
   ;







 else if (goal_alternative_matched[i] == -1
   && goal_alternative_offmemok[i]
   && ((enum rtx_code) (recog_data.operand[i])->code) == MEM)
   {
     operand_reloadnum[i]
       = push_reload ((((recog_data.operand[i])->u.fld[0]).rtx), (rtx) 0,
        &(((recog_data.operand[i])->u.fld[0]).rtx), (rtx*) 0,
        GENERAL_REGS,
        ((enum machine_mode) ((((recog_data.operand[i])->u.fld[0]).rtx))->mode),
        VOIDmode, 0, 0, i, RELOAD_FOR_INPUT);
     rld[operand_reloadnum[i]].inc
       = ((unsigned short) mode_size[((enum machine_mode) (recog_data.operand[i])->mode)]);






     if (modified[i] == RELOAD_WRITE)
       {
  for (j = 0; j < n_reloads; j++)
    {
      if (rld[j].opnum == i)
        {
   if (rld[j].when_needed == RELOAD_FOR_OUTPUT_ADDRESS)
     rld[j].when_needed = RELOAD_FOR_INPUT_ADDRESS;
   else if (rld[j].when_needed
     == RELOAD_FOR_OUTADDR_ADDRESS)
     rld[j].when_needed = RELOAD_FOR_INPADDR_ADDRESS;
        }
    }
       }
   }
 else if (goal_alternative_matched[i] == -1)
   {
     operand_reloadnum[i]
       = push_reload ((modified[i] != RELOAD_WRITE
         ? recog_data.operand[i] : 0),
        (modified[i] != RELOAD_READ
         ? recog_data.operand[i] : 0),
        (modified[i] != RELOAD_WRITE
         ? recog_data.operand_loc[i] : 0),
        (modified[i] != RELOAD_READ
         ? recog_data.operand_loc[i] : 0),
        (enum reg_class) goal_alternative[i],
        (modified[i] == RELOAD_WRITE
         ? VOIDmode : operand_mode[i]),
        (modified[i] == RELOAD_READ
         ? VOIDmode : operand_mode[i]),
        (insn_code_number < 0 ? 0
         : insn_data[insn_code_number].operand[i].strict_low),
        0, i, operand_type[i]);
   }



 else if (modified[i] == RELOAD_READ
   && modified[goal_alternative_matched[i]] == RELOAD_WRITE)
   {
     operand_reloadnum[i]
       = push_reload (recog_data.operand[i],
        recog_data.operand[goal_alternative_matched[i]],
        recog_data.operand_loc[i],
        recog_data.operand_loc[goal_alternative_matched[i]],
        (enum reg_class) goal_alternative[i],
        operand_mode[i],
        operand_mode[goal_alternative_matched[i]],
        0, 0, i, RELOAD_OTHER);
     operand_reloadnum[goal_alternative_matched[i]] = output_reloadnum;
   }
 else if (modified[i] == RELOAD_WRITE
   && modified[goal_alternative_matched[i]] == RELOAD_READ)
   {
     operand_reloadnum[goal_alternative_matched[i]]
       = push_reload (recog_data.operand[goal_alternative_matched[i]],
        recog_data.operand[i],
        recog_data.operand_loc[goal_alternative_matched[i]],
        recog_data.operand_loc[i],
        (enum reg_class) goal_alternative[i],
        operand_mode[goal_alternative_matched[i]],
        operand_mode[i],
        0, 0, i, RELOAD_OTHER);
     operand_reloadnum[i] = output_reloadnum;
   }
 else if (insn_code_number >= 0)
   fancy_abort ("reload.c", 3884, __FUNCTION__);
 else
   {
     error_for_asm (insn, "inconsistent operand constraints in an `asm'");

     (((insn)->u.fld[5]).rtx) = gen_rtx_fmt_e (USE, (VOIDmode), ((const_int_rtx[64])));
     n_reloads = 0;
     return 0;
   }
      }
    else if (goal_alternative_matched[i] < 0
      && goal_alternative_matches[i] < 0
      && !address_operand_reloaded[i]
      && optimize)
      {




 rtx operand = recog_data.operand[i];

 while (((enum rtx_code) (operand)->code) == SUBREG)
   operand = (((operand)->u.fld[0]).rtx);
 if ((((enum rtx_code) (operand)->code) == MEM
      || (((enum rtx_code) (operand)->code) == REG
   && (((operand)->u.fld[0]).rtuint) >= 53))



     && ((enum reg_class) goal_alternative[i] != NO_REGS
  || modified[i] == RELOAD_WRITE)
     && ! no_input_reloads







     && (modified[i] == RELOAD_READ
  || (! no_output_reloads && ! this_insn_is_asm)))
   operand_reloadnum[i]
     = push_reload ((modified[i] != RELOAD_WRITE
       ? recog_data.operand[i] : 0),
      (modified[i] != RELOAD_READ
       ? recog_data.operand[i] : 0),
      (modified[i] != RELOAD_WRITE
       ? recog_data.operand_loc[i] : 0),
      (modified[i] != RELOAD_READ
       ? recog_data.operand_loc[i] : 0),
      (enum reg_class) goal_alternative[i],
      (modified[i] == RELOAD_WRITE
       ? VOIDmode : operand_mode[i]),
      (modified[i] == RELOAD_READ
       ? VOIDmode : operand_mode[i]),
      (insn_code_number < 0 ? 0
       : insn_data[insn_code_number].operand[i].strict_low),
      1, i, operand_type[i]);





 else if (replace
   && (((enum rtx_code) (operand)->code) == MEM
       || (((enum rtx_code) (operand)->code) == REG
    && (((operand)->u.fld[0]).rtuint) >= 53
    && reg_renumber [(((operand)->u.fld[0]).rtuint)] < 0)))
   {
     operand = *recog_data.operand_loc[i];

     while (((enum rtx_code) (operand)->code) == SUBREG)
       operand = (((operand)->u.fld[0]).rtx);
     if (((enum rtx_code) (operand)->code) == REG)
       {
  if (modified[i] != RELOAD_WRITE)



    ((emit_insn_before (gen_rtx_fmt_e (USE, (VOIDmode), (operand)), insn))->mode = (QImode));

  if (modified[i] != RELOAD_READ)
    emit_insn_after (gen_rtx_fmt_e (CLOBBER, (VOIDmode), (operand)), insn);
       }
   }
      }
    else if (goal_alternative_matches[i] >= 0
      && goal_alternative_win[goal_alternative_matches[i]]
      && modified[i] == RELOAD_READ
      && modified[goal_alternative_matches[i]] == RELOAD_WRITE
      && ! no_input_reloads && ! no_output_reloads
      && optimize)
      {



 rtx operand = recog_data.operand[i];

 while (((enum rtx_code) (operand)->code) == SUBREG)
   operand = (((operand)->u.fld[0]).rtx);
 if ((((enum rtx_code) (operand)->code) == MEM
      || (((enum rtx_code) (operand)->code) == REG
   && (((operand)->u.fld[0]).rtuint) >= 53))
     && ((enum reg_class) goal_alternative[goal_alternative_matches[i]]
  != NO_REGS))
   operand_reloadnum[i] = operand_reloadnum[goal_alternative_matches[i]]
     = push_reload (recog_data.operand[goal_alternative_matches[i]],
      recog_data.operand[i],
      recog_data.operand_loc[goal_alternative_matches[i]],
      recog_data.operand_loc[i],
      (enum reg_class) goal_alternative[goal_alternative_matches[i]],
      operand_mode[goal_alternative_matches[i]],
      operand_mode[i],
      0, 1, goal_alternative_matches[i], RELOAD_OTHER);
      }





  for (i = 0; i < noperands; i++)
    {





      if (replace)
 {
   rtx substitution = substed_operand[i];

   *recog_data.operand_loc[i] = substitution;




   if (((enum rtx_code) (insn)->code) != JUMP_INSN
       && ((enum rtx_code) (substitution)->code) == LABEL_REF
       && !find_reg_note (insn, REG_LABEL, (((substitution)->u.fld[0]).rtx)))
     (((insn)->u.fld[8]).rtx) = gen_rtx_fmt_ue (INSN_LIST, (REG_LABEL), ((((substitution)->u.fld[0]).rtx)), ((((insn)->u.fld[8]).rtx)));


 }
      else
 retval |= (substed_operand[i] != *recog_data.operand_loc[i]);
    }
# 4039 "reload.c"
  if (insn_code_number >= 0 && replace)
    for (i = insn_data[insn_code_number].n_dups - 1; i >= 0; i--)
      {
 int opno = recog_data.dup_num[i];
 *recog_data.dup_loc[i] = *recog_data.operand_loc[opno];
 dup_replacements (recog_data.dup_loc[i], recog_data.operand_loc[opno]);
      }
# 4075 "reload.c"
  if (!goal_earlyclobber)
    combine_reloads ();






  for (i = 0; i < n_reloads; i++)
    {
      int k;

      for (j = i + 1; j < n_reloads; j++)
 if ((rld[i].when_needed == RELOAD_FOR_INPUT_ADDRESS
      || rld[i].when_needed == RELOAD_FOR_OUTPUT_ADDRESS
      || rld[i].when_needed == RELOAD_FOR_INPADDR_ADDRESS
      || rld[i].when_needed == RELOAD_FOR_OUTADDR_ADDRESS)
     && (rld[j].when_needed == RELOAD_FOR_INPUT_ADDRESS
  || rld[j].when_needed == RELOAD_FOR_OUTPUT_ADDRESS
  || rld[j].when_needed == RELOAD_FOR_INPADDR_ADDRESS
  || rld[j].when_needed == RELOAD_FOR_OUTADDR_ADDRESS)
     && rtx_equal_p (rld[i].in, rld[j].in)
     && (operand_reloadnum[rld[i].opnum] < 0
  || rld[operand_reloadnum[rld[i].opnum]].optional)
     && (operand_reloadnum[rld[j].opnum] < 0
  || rld[operand_reloadnum[rld[j].opnum]].optional)
     && (goal_alternative_matches[rld[i].opnum] == rld[j].opnum
  || (goal_alternative_matches[rld[j].opnum]
      == rld[i].opnum)))
   {
     for (k = 0; k < n_replacements; k++)
       if (replacements[k].what == j)
  replacements[k].what = i;

     if (rld[i].when_needed == RELOAD_FOR_INPADDR_ADDRESS
  || rld[i].when_needed == RELOAD_FOR_OUTADDR_ADDRESS)
       rld[i].when_needed = RELOAD_FOR_OPADDR_ADDR;
     else
       rld[i].when_needed = RELOAD_FOR_OPERAND_ADDRESS;
     rld[j].in = 0;
   }
    }
# 4135 "reload.c"
  for (i = 0; i < n_reloads; i++)
    {
      if (rld[i].secondary_p
   && rld[i].when_needed == operand_type[rld[i].opnum])
 rld[i].when_needed = address_type[rld[i].opnum];

      if ((rld[i].when_needed == RELOAD_FOR_INPUT_ADDRESS
    || rld[i].when_needed == RELOAD_FOR_OUTPUT_ADDRESS
    || rld[i].when_needed == RELOAD_FOR_INPADDR_ADDRESS
    || rld[i].when_needed == RELOAD_FOR_OUTADDR_ADDRESS)
   && (operand_reloadnum[rld[i].opnum] < 0
       || rld[operand_reloadnum[rld[i].opnum]].optional))
 {



   if ((rld[i].when_needed == RELOAD_FOR_INPUT_ADDRESS
        || rld[i].when_needed == RELOAD_FOR_INPADDR_ADDRESS)
       && rld[i].secondary_in_reload != -1)
     {
       int secondary_in_reload = rld[i].secondary_in_reload;

       rld[secondary_in_reload].when_needed = RELOAD_FOR_OPADDR_ADDR;


       if (secondary_in_reload > 0
    && rld[secondary_in_reload].secondary_in_reload != -1)
  rld[rld[secondary_in_reload].secondary_in_reload].when_needed
    = RELOAD_FOR_OPADDR_ADDR;
     }

   if ((rld[i].when_needed == RELOAD_FOR_OUTPUT_ADDRESS
        || rld[i].when_needed == RELOAD_FOR_OUTADDR_ADDRESS)
       && rld[i].secondary_out_reload != -1)
     {
       int secondary_out_reload = rld[i].secondary_out_reload;

       rld[secondary_out_reload].when_needed = RELOAD_FOR_OPADDR_ADDR;


       if (secondary_out_reload
    && rld[secondary_out_reload].secondary_out_reload != -1)
  rld[rld[secondary_out_reload].secondary_out_reload].when_needed
    = RELOAD_FOR_OPADDR_ADDR;
     }

   if (rld[i].when_needed == RELOAD_FOR_INPADDR_ADDRESS
       || rld[i].when_needed == RELOAD_FOR_OUTADDR_ADDRESS)
     rld[i].when_needed = RELOAD_FOR_OPADDR_ADDR;
   else
     rld[i].when_needed = RELOAD_FOR_OPERAND_ADDRESS;
 }

      if ((rld[i].when_needed == RELOAD_FOR_INPUT_ADDRESS
    || rld[i].when_needed == RELOAD_FOR_INPADDR_ADDRESS)
   && operand_reloadnum[rld[i].opnum] >= 0
   && (rld[operand_reloadnum[rld[i].opnum]].when_needed
       == RELOAD_OTHER))
 rld[i].when_needed = RELOAD_FOR_OTHER_ADDRESS;

      if (goal_alternative_matches[rld[i].opnum] >= 0)
 rld[i].opnum = goal_alternative_matches[rld[i].opnum];
    }
# 4222 "reload.c"
  {
    int first_op_addr_num = -2;
    int first_inpaddr_num[30];
    int first_outpaddr_num[30];
    int need_change = 0;






    for (i = 0; i < noperands; i++)
      first_inpaddr_num[i] = first_outpaddr_num[i] = -2;
    for (i = n_reloads - 1; i >= 0; i--)
      {
 switch (rld[i].when_needed)
   {
   case RELOAD_FOR_OPERAND_ADDRESS:
     if (++first_op_addr_num >= 0)
       {
  first_op_addr_num = i;
  need_change = 1;
       }
     break;
   case RELOAD_FOR_INPUT_ADDRESS:
     if (++first_inpaddr_num[rld[i].opnum] >= 0)
       {
  first_inpaddr_num[rld[i].opnum] = i;
  need_change = 1;
       }
     break;
   case RELOAD_FOR_OUTPUT_ADDRESS:
     if (++first_outpaddr_num[rld[i].opnum] >= 0)
       {
  first_outpaddr_num[rld[i].opnum] = i;
  need_change = 1;
       }
     break;
   default:
     break;
   }
      }

    if (need_change)
      {
 for (i = 0; i < n_reloads; i++)
   {
     int first_num;
     enum reload_type type;

     switch (rld[i].when_needed)
       {
       case RELOAD_FOR_OPADDR_ADDR:
  first_num = first_op_addr_num;
  type = RELOAD_FOR_OPERAND_ADDRESS;
  break;
       case RELOAD_FOR_INPADDR_ADDRESS:
  first_num = first_inpaddr_num[rld[i].opnum];
  type = RELOAD_FOR_INPUT_ADDRESS;
  break;
       case RELOAD_FOR_OUTADDR_ADDRESS:
  first_num = first_outpaddr_num[rld[i].opnum];
  type = RELOAD_FOR_OUTPUT_ADDRESS;
  break;
       default:
  continue;
       }
     if (first_num < 0)
       continue;
     else if (i > first_num)
       rld[i].when_needed = type;
     else
       {


  for (j = n_reloads - 1; j > first_num; j--)
    {
      if (rld[j].when_needed == type
   && (rld[i].secondary_p
       ? rld[j].secondary_in_reload == i
       : reg_mentioned_p (rld[i].in, rld[j].in)))
        {
   rld[i].when_needed = type;
   break;
        }
    }
       }
   }
      }
  }






  for (i = 0; i < n_reloads; i++)
    if (rld[i].in != 0 && rld[i].out == 0
 && (rld[i].when_needed == RELOAD_FOR_OPERAND_ADDRESS
     || rld[i].when_needed == RELOAD_FOR_OPADDR_ADDR
     || rld[i].when_needed == RELOAD_FOR_OTHER_ADDRESS))
      for (j = 0; j < n_reloads; j++)
 if (i != j && rld[j].in != 0 && rld[j].out == 0
     && rld[j].when_needed == rld[i].when_needed
     && (rld[i].in == rld[j].in || (rld[i].in != 0 && (((enum rtx_code) (rld[i].in)->code) == REG ? ((enum rtx_code) (rld[j].in)->code) == REG && (((rld[i].in)->u.fld[0]).rtuint) == (((rld[j].in)->u.fld[0]).rtuint) : rtx_equal_p (rld[i].in, rld[j].in) && ! side_effects_p (rld[i].in))))
     && rld[i].class == rld[j].class
     && !rld[i].nocombine && !rld[j].nocombine
     && rld[i].reg_rtx == rld[j].reg_rtx)
   {
     rld[i].opnum = ((rld[i].opnum) < (rld[j].opnum) ? (rld[i].opnum) : (rld[j].opnum));
     transfer_replacements (i, j);
     rld[j].in = 0;
   }
# 4349 "reload.c"
  for (i = 0; i < n_reloads; i++)
    {
      rld[i].mode
 = (rld[i].inmode == VOIDmode
    || (((unsigned short) mode_size[rld[i].outmode])
        > ((unsigned short) mode_size[rld[i].inmode])))
   ? rld[i].outmode : rld[i].inmode;

      rld[i].nregs = (!reg_classes_intersect_p ((rld[i].class), GENERAL_REGS) ? ((mode_class[rld[i].mode] == MODE_COMPLEX_INT || mode_class[rld[i].mode] == MODE_COMPLEX_FLOAT) ? 2 : 1) : (((((rld[i].mode) == XFmode ? 12 : ((unsigned short) mode_size[rld[i].mode]))) + (0 ? 8 : 4) - 1) / (0 ? 8 : 4)));
    }



  for (i = 0; i < n_reloads; i++)
    if (rld[i].when_needed == RELOAD_FOR_INPUT
 && ((enum rtx_code) ((((insn)->u.fld[5]).rtx))->code) == SET
 && ((enum rtx_code) (((((((insn)->u.fld[5]).rtx))->u.fld[0]).rtx))->code) == REG
 && ((((((insn)->u.fld[5]).rtx))->u.fld[1]).rtx) == rld[i].in)
      {
 rtx dest = ((((((insn)->u.fld[5]).rtx))->u.fld[0]).rtx);
 unsigned int regno = (((dest)->u.fld[0]).rtuint);

 if (regno < 53
     && (!!((reg_class_contents[rld[i].class])[(regno) / ((unsigned) (8 * 4))] & (((HARD_REG_ELT_TYPE) (1)) << ((regno) % ((unsigned) (8 * 4))))))
     && ix86_hard_regno_mode_ok ((regno), (rld[i].mode)))
   {
     int nr = (((regno) >= 8 && (regno) <= (8 + 7)) || (((regno) >= (20 + 1) && (regno) <= ((20 + 1) + 7)) || ((regno) >= (((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) && (regno) <= ((((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) + 7))) || ((regno) >= (((20 + 1) + 7) + 1) && (regno) <= ((((20 + 1) + 7) + 1) + 7)) ? ((mode_class[rld[i].mode] == MODE_COMPLEX_INT || mode_class[rld[i].mode] == MODE_COMPLEX_FLOAT) ? 2 : 1) : ((rld[i].mode) == XFmode ? (0 ? 2 : 3) : (rld[i].mode) == XCmode ? (0 ? 4 : 6) : ((((unsigned short) mode_size[rld[i].mode]) + (0 ? 8 : 4) - 1) / (0 ? 8 : 4))));
     int ok = 1, nri;

     for (nri = 1; nri < nr; nri ++)
       if (! (!!((reg_class_contents[rld[i].class])[(regno + nri) / ((unsigned) (8 * 4))] & (((HARD_REG_ELT_TYPE) (1)) << ((regno + nri) % ((unsigned) (8 * 4)))))))
  ok = 0;

     if (ok)
       rld[i].reg_rtx = dest;
   }
      }

  return retval;
}




static int
alternative_allows_memconst (const char *constraint, int altnum)
{
  int c;

  while (altnum > 0)
    {
      while (*constraint++ != ',');
      altnum--;
    }


  for (; (c = *constraint) && c != ',' && c != '#';
       constraint += 1)
    if (c == 'm' || c == 'o' || 0)
      return 1;
  return 0;
}
# 4434 "reload.c"
static rtx
find_reloads_toplev (rtx x, int opnum, enum reload_type type,
       int ind_levels, int is_set_dest, rtx insn,
       int *address_reloaded)
{
  enum rtx_code code = ((enum rtx_code) (x)->code);

  const char *fmt = (rtx_format[(int) (code)]);
  int i;
  int copied;

  if (code == REG)
    {

      int regno = (((x)->u.fld[0]).rtuint);
      if (reg_equiv_constant[regno] != 0 && !is_set_dest)
 x = reg_equiv_constant[regno];






      else if (reg_equiv_memory_loc[regno]
        && (reg_equiv_address[regno] != 0 || num_not_at_initial_offset))
 {
   rtx mem = make_memloc (x, regno);
   if (reg_equiv_address[regno]
       || ! rtx_equal_p (mem, reg_equiv_mem[regno]))
     {



       if (replace_reloads && recog_data.operand[opnum] != x)



  ((emit_insn_before (gen_rtx_fmt_e (USE, (VOIDmode), (x)), insn))->mode = (QImode));

       x = mem;
       i = find_reloads_address (((enum machine_mode) (x)->mode), &x, (((x)->u.fld[0]).rtx), &(((x)->u.fld[0]).rtx),
     opnum, type, ind_levels, insn);
       if (address_reloaded)
  *address_reloaded = i;
     }
 }
      return x;
    }
  if (code == MEM)
    {
      rtx tem = x;

      i = find_reloads_address (((enum machine_mode) (x)->mode), &tem, (((x)->u.fld[0]).rtx), &(((x)->u.fld[0]).rtx),
    opnum, type, ind_levels, insn);
      if (address_reloaded)
 *address_reloaded = i;

      return tem;
    }

  if (code == SUBREG && ((enum rtx_code) ((((x)->u.fld[0]).rtx))->code) == REG)
    {
# 4505 "reload.c"
      int regno = ((((((x)->u.fld[0]).rtx))->u.fld[0]).rtuint);
      rtx tem;

      if (subreg_lowpart_p (x)
   && regno >= 53 && reg_renumber[regno] < 0
   && reg_equiv_constant[regno] != 0
   && (tem = gen_lowpart_common (((enum machine_mode) (x)->mode),
     reg_equiv_constant[regno])) != 0)
 return tem;

      if (regno >= 53 && reg_renumber[regno] < 0
   && reg_equiv_constant[regno] != 0)
 {
   tem =
     simplify_gen_subreg (((enum machine_mode) (x)->mode), reg_equiv_constant[regno],
     ((enum machine_mode) ((((x)->u.fld[0]).rtx))->mode), (((x)->u.fld[1]).rtuint));
   if (!tem)
     fancy_abort ("reload.c", 4522, __FUNCTION__);
   return tem;
 }
# 4539 "reload.c"
      else if (regno >= 53




        && (reg_equiv_address[regno] != 0
     || (reg_equiv_mem[regno] != 0
         && (! strict_memory_address_p (((enum machine_mode) (x)->mode),
            (((reg_equiv_mem[regno])->u.fld[0]).rtx))
      || ! offsettable_memref_p (reg_equiv_mem[regno])
      || num_not_at_initial_offset))))
 x = find_reloads_subreg_address (x, 1, opnum, type, ind_levels,
      insn);
    }

  for (copied = 0, i = (rtx_length[(int) (code)]) - 1; i >= 0; i--)
    {
      if (fmt[i] == 'e')
 {
   rtx new_part = find_reloads_toplev ((((x)->u.fld[i]).rtx), opnum, type,
           ind_levels, is_set_dest, insn,
           address_reloaded);





   if (new_part != (((x)->u.fld[i]).rtx) && ! (((enum rtx_code) (new_part)->code) == LABEL_REF || ((enum rtx_code) (new_part)->code) == SYMBOL_REF || ((enum rtx_code) (new_part)->code) == CONST_INT || ((enum rtx_code) (new_part)->code) == CONST_DOUBLE || ((enum rtx_code) (new_part)->code) == CONST || ((enum rtx_code) (new_part)->code) == HIGH || ((enum rtx_code) (new_part)->code) == CONST_VECTOR || ((enum rtx_code) (new_part)->code) == CONSTANT_P_RTX) && ! copied)
     {
       x = shallow_copy_rtx (x);
       copied = 1;
     }
   (((x)->u.fld[i]).rtx) = new_part;
 }
    }
  return x;
}




static rtx
make_memloc (rtx ad, int regno)
{


  rtx tem
    = (((eliminate_regs (reg_equiv_memory_loc[regno], 0, (rtx) 0))->u.fld[0]).rtx);



  if (rtx_varies_p (tem, 0))
    tem = copy_rtx (tem);

  tem = replace_equiv_address_nv (reg_equiv_memory_loc[regno], tem);
  tem = adjust_address_1 (tem, ((enum machine_mode) (ad)->mode), 0, 0, 1);



  if (tem == reg_equiv_memory_loc[regno])
    tem = copy_rtx (tem);
  return tem;
}





static int
maybe_memory_address_p (enum machine_mode mode, rtx ad, rtx *part)
{
  int retv;
  rtx tem = *part;
  rtx reg = gen_rtx_REG (((enum machine_mode) (tem)->mode), max_reg_num ());

  *part = reg;
  retv = memory_address_p (mode, ad);
  *part = tem;

  return retv;
}
# 4645 "reload.c"
static int
find_reloads_address (enum machine_mode mode, rtx *memrefloc, rtx ad,
        rtx *loc, int opnum, enum reload_type type,
        int ind_levels, rtx insn)
{
  int regno;
  int removed_and = 0;
  rtx tem;





  if (((enum rtx_code) (ad)->code) == REG)
    {
      regno = (((ad)->u.fld[0]).rtuint);



      tem = reg_equiv_constant[regno];
      if (tem != 0
   && (tem = eliminate_regs (tem, mode, insn))
   && strict_memory_address_p (mode, tem))
 {
   *loc = ad = tem;
   return 0;
 }

      tem = reg_equiv_memory_loc[regno];
      if (tem != 0)
 {
   if (reg_equiv_address[regno] != 0 || num_not_at_initial_offset)
     {
       tem = make_memloc (ad, regno);
       if (! strict_memory_address_p (((enum machine_mode) (tem)->mode), (((tem)->u.fld[0]).rtx)))
  {
    find_reloads_address (((enum machine_mode) (tem)->mode), &tem, (((tem)->u.fld[0]).rtx),
     &(((tem)->u.fld[0]).rtx), opnum,
     ((type) == RELOAD_FOR_INPUT_ADDRESS ? RELOAD_FOR_INPADDR_ADDRESS : ((type) == RELOAD_FOR_OUTPUT_ADDRESS ? RELOAD_FOR_OUTADDR_ADDRESS : (type))), ind_levels, insn);
  }





       if (ind_levels > 0
    && strict_memory_address_p (mode, tem)
    && (((enum rtx_code) ((((tem)->u.fld[0]).rtx))->code) == REG
        || (((enum rtx_code) ((((tem)->u.fld[0]).rtx))->code) == PLUS
     && ((enum rtx_code) (((((((tem)->u.fld[0]).rtx))->u.fld[0]).rtx))->code) == REG
     && (((enum rtx_code) (((((((tem)->u.fld[0]).rtx))->u.fld[1]).rtx))->code) == LABEL_REF || ((enum rtx_code) (((((((tem)->u.fld[0]).rtx))->u.fld[1]).rtx))->code) == SYMBOL_REF || ((enum rtx_code) (((((((tem)->u.fld[0]).rtx))->u.fld[1]).rtx))->code) == CONST_INT || ((enum rtx_code) (((((((tem)->u.fld[0]).rtx))->u.fld[1]).rtx))->code) == CONST_DOUBLE || ((enum rtx_code) (((((((tem)->u.fld[0]).rtx))->u.fld[1]).rtx))->code) == CONST || ((enum rtx_code) (((((((tem)->u.fld[0]).rtx))->u.fld[1]).rtx))->code) == HIGH || ((enum rtx_code) (((((((tem)->u.fld[0]).rtx))->u.fld[1]).rtx))->code) == CONST_VECTOR || ((enum rtx_code) (((((((tem)->u.fld[0]).rtx))->u.fld[1]).rtx))->code) == CONSTANT_P_RTX))))
  {



    if (replace_reloads
        && num_not_at_initial_offset
        && ! rtx_equal_p (tem, reg_equiv_mem[regno]))
      {
        *loc = tem;



        ((emit_insn_before (gen_rtx_fmt_e (USE, (VOIDmode), (ad)), insn))->mode = (QImode));




      }
    return 0;
  }
       ad = tem;
     }
 }





      else if (regno < 53
        && ((regno) <= 7 || (regno) == 16 || (regno) == 20 || (regno >= (((((20 + 1) + 7) + 1) + 7) + 1) && (regno) <= ((((((20 + 1) + 7) + 1) + 7) + 1) + 7)) || ((unsigned) reg_renumber[(regno)] >= (((((20 + 1) + 7) + 1) + 7) + 1) && (unsigned) reg_renumber[(regno)] <= ((((((20 + 1) + 7) + 1) + 7) + 1) + 7)) || (unsigned) reg_renumber[(regno)] <= 7)
        && ! regno_clobbered_p (regno, this_insn, mode, 0))
 return 0;


      push_reload (ad, (rtx) 0, loc, (rtx*) 0, GENERAL_REGS,
     ((enum machine_mode) (ad)->mode), VOIDmode, 0, 0, opnum, type);
      return 1;
    }

  if (strict_memory_address_p (mode, ad))
    {
# 4745 "reload.c"
      if (((enum rtx_code) (ad)->code) == PLUS
   && ((enum rtx_code) ((((ad)->u.fld[1]).rtx))->code) == CONST_INT
   && ((enum rtx_code) ((((ad)->u.fld[0]).rtx))->code) == REG
   && reg_equiv_constant[((((((ad)->u.fld[0]).rtx))->u.fld[0]).rtuint)] == 0)
 return 0;

      subst_reg_equivs_changed = 0;
      *loc = subst_reg_equivs (ad, insn);

      if (! subst_reg_equivs_changed)
 return 0;


      if (strict_memory_address_p (mode, ad))
 return 0;
    }
# 4783 "reload.c"
  if (((enum rtx_code) (ad)->code) == AND)
    {
      removed_and = 1;
      loc = &(((ad)->u.fld[0]).rtx);
      ad = *loc;
    }







  if (((enum rtx_code) (ad)->code) == MEM)
    {


      tem = ad;
      find_reloads_address (((enum machine_mode) (ad)->mode), &tem, (((ad)->u.fld[0]).rtx), &(((ad)->u.fld[0]).rtx),
       opnum, ((type) == RELOAD_FOR_INPUT_ADDRESS ? RELOAD_FOR_INPADDR_ADDRESS : ((type) == RELOAD_FOR_OUTPUT_ADDRESS ? RELOAD_FOR_OUTADDR_ADDRESS : (type))),
       ind_levels == 0 ? 0 : ind_levels - 1, insn);



      if (tem != ad && memrefloc)
 {
   *memrefloc = copy_rtx (*memrefloc);
   copy_replacements (tem, (((*memrefloc)->u.fld[0]).rtx));
   loc = &(((*memrefloc)->u.fld[0]).rtx);
   if (removed_and)
     loc = &(((*loc)->u.fld[0]).rtx);
 }





      if (ind_levels == 0
   || (((enum rtx_code) ((((tem)->u.fld[0]).rtx))->code) == SYMBOL_REF && ! indirect_symref_ok)
   || ((enum rtx_code) ((((tem)->u.fld[0]).rtx))->code) == MEM
   || ! (((enum rtx_code) ((((tem)->u.fld[0]).rtx))->code) == REG
  || (((enum rtx_code) ((((tem)->u.fld[0]).rtx))->code) == PLUS
      && ((enum rtx_code) (((((((tem)->u.fld[0]).rtx))->u.fld[0]).rtx))->code) == REG
      && ((enum rtx_code) (((((((tem)->u.fld[0]).rtx))->u.fld[1]).rtx))->code) == CONST_INT)))
 {


   push_reload (tem, (rtx) 0, loc, (rtx*) 0,
         GENERAL_REGS, ((enum machine_mode) (tem)->mode),
         VOIDmode, 0,
         0, opnum, type);
   return ! removed_and;
 }
      else
 return 0;
    }






  else if (((enum rtx_code) (ad)->code) == PLUS
    && ((enum rtx_code) ((((ad)->u.fld[0]).rtx))->code) == REG
    && ((((((ad)->u.fld[0]).rtx))->u.fld[0]).rtuint) < 53
    && ((((((((ad)->u.fld[0]).rtx))->u.fld[0]).rtuint)) <= 7 || (((((((ad)->u.fld[0]).rtx))->u.fld[0]).rtuint)) == 16 || (((((((ad)->u.fld[0]).rtx))->u.fld[0]).rtuint)) == 20 || (((((((ad)->u.fld[0]).rtx))->u.fld[0]).rtuint) >= (((((20 + 1) + 7) + 1) + 7) + 1) && (((((((ad)->u.fld[0]).rtx))->u.fld[0]).rtuint)) <= ((((((20 + 1) + 7) + 1) + 7) + 1) + 7)) || ((unsigned) reg_renumber[(((((((ad)->u.fld[0]).rtx))->u.fld[0]).rtuint))] >= (((((20 + 1) + 7) + 1) + 7) + 1) && (unsigned) reg_renumber[(((((((ad)->u.fld[0]).rtx))->u.fld[0]).rtuint))] <= ((((((20 + 1) + 7) + 1) + 7) + 1) + 7)) || (unsigned) reg_renumber[(((((((ad)->u.fld[0]).rtx))->u.fld[0]).rtuint))] <= 7)
    && ((enum rtx_code) ((((ad)->u.fld[1]).rtx))->code) == CONST_INT)
    {

      if (memrefloc)
 {
   *memrefloc = copy_rtx (*memrefloc);
   loc = &(((*memrefloc)->u.fld[0]).rtx);
   if (removed_and)
     loc = &(((*loc)->u.fld[0]).rtx);
 }

      if (double_reg_address_ok)
 {

   *loc = ad = copy_rtx (ad);



   find_reloads_address_part ((((ad)->u.fld[1]).rtx), &(((ad)->u.fld[1]).rtx),
         INDEX_REGS, ((enum machine_mode) (ad)->mode), opnum,
         type, ind_levels);
   return 0;
 }
      else
 {



   find_reloads_address_part (ad, loc, GENERAL_REGS,
         (0 ? DImode : SImode), opnum, type, ind_levels);
 }
      return ! removed_and;
    }
# 4907 "reload.c"
  else if (((enum rtx_code) (ad)->code) == PLUS && ((enum rtx_code) ((((ad)->u.fld[1]).rtx))->code) == CONST_INT
    && ((enum rtx_code) ((((ad)->u.fld[0]).rtx))->code) == PLUS
    && ((enum rtx_code) (((((((ad)->u.fld[0]).rtx))->u.fld[0]).rtx))->code) == REG
    && (((((((((ad)->u.fld[0]).rtx))->u.fld[0]).rtx))->u.fld[0]).rtuint) < 53
    && ((((((((((((ad)->u.fld[0]).rtx))->u.fld[0]).rtx))->u.fld[0]).rtuint)) <= 7 || ((((((((((ad)->u.fld[0]).rtx))->u.fld[0]).rtx))->u.fld[0]).rtuint)) == 16 || ((((((((((ad)->u.fld[0]).rtx))->u.fld[0]).rtx))->u.fld[0]).rtuint)) == 20 || ((((((((((ad)->u.fld[0]).rtx))->u.fld[0]).rtx))->u.fld[0]).rtuint) >= (((((20 + 1) + 7) + 1) + 7) + 1) && ((((((((((ad)->u.fld[0]).rtx))->u.fld[0]).rtx))->u.fld[0]).rtuint)) <= ((((((20 + 1) + 7) + 1) + 7) + 1) + 7)) || ((unsigned) reg_renumber[((((((((((ad)->u.fld[0]).rtx))->u.fld[0]).rtx))->u.fld[0]).rtuint))] >= (((((20 + 1) + 7) + 1) + 7) + 1) && (unsigned) reg_renumber[((((((((((ad)->u.fld[0]).rtx))->u.fld[0]).rtx))->u.fld[0]).rtuint))] <= ((((((20 + 1) + 7) + 1) + 7) + 1) + 7)) || (unsigned) reg_renumber[((((((((((ad)->u.fld[0]).rtx))->u.fld[0]).rtx))->u.fld[0]).rtuint))] <= 7)
        || ((((((ad)->u.fld[0]).rtx))->u.fld[0]).rtx) == (global_rtl[GR_FRAME_POINTER])

        || ((((((ad)->u.fld[0]).rtx))->u.fld[0]).rtx) == (global_rtl[GR_HARD_FRAME_POINTER])


        || ((((((ad)->u.fld[0]).rtx))->u.fld[0]).rtx) == (global_rtl[GR_ARG_POINTER])

        || ((((((ad)->u.fld[0]).rtx))->u.fld[0]).rtx) == (global_rtl[GR_STACK_POINTER]))
    && ! maybe_memory_address_p (mode, ad, &((((((ad)->u.fld[0]).rtx))->u.fld[1]).rtx)))
    {
      *loc = ad = gen_rtx_fmt_ee (PLUS, (((enum machine_mode) (ad)->mode)), (plus_constant_wide ((((((((ad)->u.fld[0]).rtx))->u.fld[0]).rtx)), (long) ((((((ad)->u.fld[1]).rtx))->u.hwint[0])))), (((((((ad)->u.fld[0]).rtx))->u.fld[1]).rtx)));



      find_reloads_address_part ((((ad)->u.fld[0]).rtx), &(((ad)->u.fld[0]).rtx),
     GENERAL_REGS,
     ((enum machine_mode) (ad)->mode), opnum, type, ind_levels);
      find_reloads_address_1 (mode, (((ad)->u.fld[1]).rtx), 1, &(((ad)->u.fld[1]).rtx), opnum,
         type, 0, insn);

      return 0;
    }

  else if (((enum rtx_code) (ad)->code) == PLUS && ((enum rtx_code) ((((ad)->u.fld[1]).rtx))->code) == CONST_INT
    && ((enum rtx_code) ((((ad)->u.fld[0]).rtx))->code) == PLUS
    && ((enum rtx_code) (((((((ad)->u.fld[0]).rtx))->u.fld[1]).rtx))->code) == REG
    && (((((((((ad)->u.fld[0]).rtx))->u.fld[1]).rtx))->u.fld[0]).rtuint) < 53
    && ((((((((((((ad)->u.fld[0]).rtx))->u.fld[1]).rtx))->u.fld[0]).rtuint)) <= 7 || ((((((((((ad)->u.fld[0]).rtx))->u.fld[1]).rtx))->u.fld[0]).rtuint)) == 16 || ((((((((((ad)->u.fld[0]).rtx))->u.fld[1]).rtx))->u.fld[0]).rtuint)) == 20 || ((((((((((ad)->u.fld[0]).rtx))->u.fld[1]).rtx))->u.fld[0]).rtuint) >= (((((20 + 1) + 7) + 1) + 7) + 1) && ((((((((((ad)->u.fld[0]).rtx))->u.fld[1]).rtx))->u.fld[0]).rtuint)) <= ((((((20 + 1) + 7) + 1) + 7) + 1) + 7)) || ((unsigned) reg_renumber[((((((((((ad)->u.fld[0]).rtx))->u.fld[1]).rtx))->u.fld[0]).rtuint))] >= (((((20 + 1) + 7) + 1) + 7) + 1) && (unsigned) reg_renumber[((((((((((ad)->u.fld[0]).rtx))->u.fld[1]).rtx))->u.fld[0]).rtuint))] <= ((((((20 + 1) + 7) + 1) + 7) + 1) + 7)) || (unsigned) reg_renumber[((((((((((ad)->u.fld[0]).rtx))->u.fld[1]).rtx))->u.fld[0]).rtuint))] <= 7)
        || ((((((ad)->u.fld[0]).rtx))->u.fld[1]).rtx) == (global_rtl[GR_FRAME_POINTER])

        || ((((((ad)->u.fld[0]).rtx))->u.fld[1]).rtx) == (global_rtl[GR_HARD_FRAME_POINTER])


        || ((((((ad)->u.fld[0]).rtx))->u.fld[1]).rtx) == (global_rtl[GR_ARG_POINTER])

        || ((((((ad)->u.fld[0]).rtx))->u.fld[1]).rtx) == (global_rtl[GR_STACK_POINTER]))
    && ! maybe_memory_address_p (mode, ad, &((((((ad)->u.fld[0]).rtx))->u.fld[0]).rtx)))
    {
      *loc = ad = gen_rtx_fmt_ee (PLUS, (((enum machine_mode) (ad)->mode)), (((((((ad)->u.fld[0]).rtx))->u.fld[0]).rtx)), (plus_constant_wide ((((((((ad)->u.fld[0]).rtx))->u.fld[1]).rtx)), (long) ((((((ad)->u.fld[1]).rtx))->u.hwint[0])))));



      find_reloads_address_part ((((ad)->u.fld[1]).rtx), &(((ad)->u.fld[1]).rtx),
     GENERAL_REGS,
     ((enum machine_mode) (ad)->mode), opnum, type, ind_levels);
      find_reloads_address_1 (mode, (((ad)->u.fld[0]).rtx), 1, &(((ad)->u.fld[0]).rtx), opnum,
         type, 0, insn);

      return 0;
    }




  tem = ad;
  if (((enum rtx_code) (ad)->code) == PLUS)
    tem = subst_indexed_address (ad);
  if (tem != ad && strict_memory_address_p (mode, tem))
    {



      subst_reg_equivs_changed = 0;
      tem = subst_reg_equivs (tem, insn);



      if (! subst_reg_equivs_changed || strict_memory_address_p (mode, tem))
 {
   *loc = tem;
   return 0;
 }
    }



  if ((((enum rtx_code) (ad)->code) == LABEL_REF || ((enum rtx_code) (ad)->code) == SYMBOL_REF || ((enum rtx_code) (ad)->code) == CONST_INT || ((enum rtx_code) (ad)->code) == CONST_DOUBLE || ((enum rtx_code) (ad)->code) == CONST || ((enum rtx_code) (ad)->code) == HIGH || ((enum rtx_code) (ad)->code) == CONST_VECTOR || ((enum rtx_code) (ad)->code) == CONSTANT_P_RTX) && ! strict_memory_address_p (mode, ad))
    {


      if (memrefloc && ((enum rtx_code) (ad)->code) == SYMBOL_REF
   && (((ad))->unchanging))
 {
   *memrefloc = copy_rtx (*memrefloc);
   loc = &(((*memrefloc)->u.fld[0]).rtx);
   if (removed_and)
     loc = &(((*loc)->u.fld[0]).rtx);
 }

      find_reloads_address_part (ad, loc, GENERAL_REGS,
     (0 ? DImode : SImode), opnum, type, ind_levels);
      return ! removed_and;
    }

  return find_reloads_address_1 (mode, ad, 0, loc, opnum, type, ind_levels,
     insn);
}







static rtx
subst_reg_equivs (rtx ad, rtx insn)
{
  enum rtx_code code = ((enum rtx_code) (ad)->code);
  int i;
  const char *fmt;

  switch (code)
    {
    case HIGH:
    case CONST_INT:
    case CONST:
    case CONST_DOUBLE:
    case CONST_VECTOR:
    case SYMBOL_REF:
    case LABEL_REF:
    case PC:
    case CC0:
      return ad;

    case REG:
      {
 int regno = (((ad)->u.fld[0]).rtuint);

 if (reg_equiv_constant[regno] != 0)
   {
     subst_reg_equivs_changed = 1;
     return reg_equiv_constant[regno];
   }
 if (reg_equiv_memory_loc[regno] && num_not_at_initial_offset)
   {
     rtx mem = make_memloc (ad, regno);
     if (! rtx_equal_p (mem, reg_equiv_mem[regno]))
       {
  subst_reg_equivs_changed = 1;



  ((emit_insn_before (gen_rtx_fmt_e (USE, (VOIDmode), (ad)), insn))->mode = (QImode));

  return mem;
       }
   }
      }
      return ad;

    case PLUS:

      if ((((ad)->u.fld[0]).rtx) == (global_rtl[GR_FRAME_POINTER])
   && ((enum rtx_code) ((((ad)->u.fld[1]).rtx))->code) == CONST_INT)
 return ad;
      break;

    default:
      break;
    }

  fmt = (rtx_format[(int) (code)]);
  for (i = (rtx_length[(int) (code)]) - 1; i >= 0; i--)
    if (fmt[i] == 'e')
      (((ad)->u.fld[i]).rtx) = subst_reg_equivs ((((ad)->u.fld[i]).rtx), insn);
  return ad;
}
# 5087 "reload.c"
rtx
form_sum (rtx x, rtx y)
{
  rtx tem;
  enum machine_mode mode = ((enum machine_mode) (x)->mode);

  if (mode == VOIDmode)
    mode = ((enum machine_mode) (y)->mode);

  if (mode == VOIDmode)
    mode = (0 ? DImode : SImode);

  if (((enum rtx_code) (x)->code) == CONST_INT)
    return plus_constant_wide ((y), (long) (((x)->u.hwint[0])));
  else if (((enum rtx_code) (y)->code) == CONST_INT)
    return plus_constant_wide ((x), (long) (((y)->u.hwint[0])));
  else if ((((enum rtx_code) (x)->code) == LABEL_REF || ((enum rtx_code) (x)->code) == SYMBOL_REF || ((enum rtx_code) (x)->code) == CONST_INT || ((enum rtx_code) (x)->code) == CONST_DOUBLE || ((enum rtx_code) (x)->code) == CONST || ((enum rtx_code) (x)->code) == HIGH || ((enum rtx_code) (x)->code) == CONST_VECTOR || ((enum rtx_code) (x)->code) == CONSTANT_P_RTX))
    tem = x, x = y, y = tem;

  if (((enum rtx_code) (x)->code) == PLUS && (((enum rtx_code) ((((x)->u.fld[1]).rtx))->code) == LABEL_REF || ((enum rtx_code) ((((x)->u.fld[1]).rtx))->code) == SYMBOL_REF || ((enum rtx_code) ((((x)->u.fld[1]).rtx))->code) == CONST_INT || ((enum rtx_code) ((((x)->u.fld[1]).rtx))->code) == CONST_DOUBLE || ((enum rtx_code) ((((x)->u.fld[1]).rtx))->code) == CONST || ((enum rtx_code) ((((x)->u.fld[1]).rtx))->code) == HIGH || ((enum rtx_code) ((((x)->u.fld[1]).rtx))->code) == CONST_VECTOR || ((enum rtx_code) ((((x)->u.fld[1]).rtx))->code) == CONSTANT_P_RTX))
    return form_sum ((((x)->u.fld[0]).rtx), form_sum ((((x)->u.fld[1]).rtx), y));



  if (((enum rtx_code) (y)->code) == PLUS && (((enum rtx_code) ((((y)->u.fld[1]).rtx))->code) == LABEL_REF || ((enum rtx_code) ((((y)->u.fld[1]).rtx))->code) == SYMBOL_REF || ((enum rtx_code) ((((y)->u.fld[1]).rtx))->code) == CONST_INT || ((enum rtx_code) ((((y)->u.fld[1]).rtx))->code) == CONST_DOUBLE || ((enum rtx_code) ((((y)->u.fld[1]).rtx))->code) == CONST || ((enum rtx_code) ((((y)->u.fld[1]).rtx))->code) == HIGH || ((enum rtx_code) ((((y)->u.fld[1]).rtx))->code) == CONST_VECTOR || ((enum rtx_code) ((((y)->u.fld[1]).rtx))->code) == CONSTANT_P_RTX))
    return form_sum (form_sum (x, (((y)->u.fld[0]).rtx)), (((y)->u.fld[1]).rtx));



  if ((((enum rtx_code) (x)->code) == LABEL_REF || ((enum rtx_code) (x)->code) == SYMBOL_REF || ((enum rtx_code) (x)->code) == CONST_INT || ((enum rtx_code) (x)->code) == CONST_DOUBLE || ((enum rtx_code) (x)->code) == CONST || ((enum rtx_code) (x)->code) == HIGH || ((enum rtx_code) (x)->code) == CONST_VECTOR || ((enum rtx_code) (x)->code) == CONSTANT_P_RTX) && (((enum rtx_code) (y)->code) == LABEL_REF || ((enum rtx_code) (y)->code) == SYMBOL_REF || ((enum rtx_code) (y)->code) == CONST_INT || ((enum rtx_code) (y)->code) == CONST_DOUBLE || ((enum rtx_code) (y)->code) == CONST || ((enum rtx_code) (y)->code) == HIGH || ((enum rtx_code) (y)->code) == CONST_VECTOR || ((enum rtx_code) (y)->code) == CONSTANT_P_RTX))
    {
      if (((enum rtx_code) (x)->code) == CONST)
 x = (((x)->u.fld[0]).rtx);
      if (((enum rtx_code) (y)->code) == CONST)
 y = (((y)->u.fld[0]).rtx);

      return gen_rtx_fmt_e (CONST, (VOIDmode), (gen_rtx_fmt_ee (PLUS, (mode), (x), (y))));
    }

  return gen_rtx_fmt_ee (PLUS, (mode), (x), (y));
}
# 5141 "reload.c"
static rtx
subst_indexed_address (rtx addr)
{
  rtx op0 = 0, op1 = 0, op2 = 0;
  rtx tem;
  int regno;

  if (((enum rtx_code) (addr)->code) == PLUS)
    {

      op0 = (((addr)->u.fld[0]).rtx), op1 = (((addr)->u.fld[1]).rtx), op2 = 0;
      if (((enum rtx_code) (op0)->code) == REG
   && (regno = (((op0)->u.fld[0]).rtuint)) >= 53
   && reg_renumber[regno] < 0
   && reg_equiv_constant[regno] != 0)
 op0 = reg_equiv_constant[regno];
      else if (((enum rtx_code) (op1)->code) == REG
        && (regno = (((op1)->u.fld[0]).rtuint)) >= 53
        && reg_renumber[regno] < 0
        && reg_equiv_constant[regno] != 0)
 op1 = reg_equiv_constant[regno];
      else if (((enum rtx_code) (op0)->code) == PLUS
        && (tem = subst_indexed_address (op0)) != op0)
 op0 = tem;
      else if (((enum rtx_code) (op1)->code) == PLUS
        && (tem = subst_indexed_address (op1)) != op1)
 op1 = tem;
      else
 return addr;


      if (((enum rtx_code) (op1)->code) == PLUS)
 op2 = (((op1)->u.fld[1]).rtx), op1 = (((op1)->u.fld[0]).rtx);
      else if (((enum rtx_code) (op0)->code) == PLUS)
 op2 = op1, op1 = (((op0)->u.fld[1]).rtx), op0 = (((op0)->u.fld[0]).rtx);


      if (op2 != 0)
 op1 = form_sum (op1, op2);
      if (op1 != 0)
 op0 = form_sum (op0, op1);

      return op0;
    }
  return addr;
}
# 5198 "reload.c"
static void
update_auto_inc_notes (rtx insn __attribute__ ((__unused__)), int regno __attribute__ ((__unused__)),
         int reloadnum __attribute__ ((__unused__)))
{
# 5210 "reload.c"
}
# 5236 "reload.c"
static int
find_reloads_address_1 (enum machine_mode mode, rtx x, int context,
   rtx *loc, int opnum, enum reload_type type,
   int ind_levels, rtx insn)
{
  enum rtx_code code = ((enum rtx_code) (x)->code);

  switch (code)
    {
    case PLUS:
      {
 rtx orig_op0 = (((x)->u.fld[0]).rtx);
 rtx orig_op1 = (((x)->u.fld[1]).rtx);
 enum rtx_code code0 = ((enum rtx_code) (orig_op0)->code);
 enum rtx_code code1 = ((enum rtx_code) (orig_op1)->code);
 rtx op0 = orig_op0;
 rtx op1 = orig_op1;

 if (((enum rtx_code) (op0)->code) == SUBREG)
   {
     op0 = (((op0)->u.fld[0]).rtx);
     code0 = ((enum rtx_code) (op0)->code);
     if (code0 == REG && (((op0)->u.fld[0]).rtuint) < 53)
       op0 = gen_rtx_REG (word_mode,
     ((((op0)->u.fld[0]).rtuint) +
      subreg_regno_offset (((((((orig_op0)->u.fld[0]).rtx))->u.fld[0]).rtuint),
             ((enum machine_mode) ((((orig_op0)->u.fld[0]).rtx))->mode),
             (((orig_op0)->u.fld[1]).rtuint),
             ((enum machine_mode) (orig_op0)->mode))));
   }

 if (((enum rtx_code) (op1)->code) == SUBREG)
   {
     op1 = (((op1)->u.fld[0]).rtx);
     code1 = ((enum rtx_code) (op1)->code);
     if (code1 == REG && (((op1)->u.fld[0]).rtuint) < 53)


       op1 = gen_rtx_REG (((enum machine_mode) (op1)->mode),
     ((((op1)->u.fld[0]).rtuint) +
      subreg_regno_offset (((((((orig_op1)->u.fld[0]).rtx))->u.fld[0]).rtuint),
             ((enum machine_mode) ((((orig_op1)->u.fld[0]).rtx))->mode),
             (((orig_op1)->u.fld[1]).rtuint),
             ((enum machine_mode) (orig_op1)->mode))));
   }




 if (context)
   {
     find_reloads_address (((enum machine_mode) (x)->mode), loc, (((x)->u.fld[0]).rtx), &(((x)->u.fld[0]).rtx),
      opnum, ((type) == RELOAD_FOR_INPUT_ADDRESS ? RELOAD_FOR_INPADDR_ADDRESS : ((type) == RELOAD_FOR_OUTPUT_ADDRESS ? RELOAD_FOR_OUTADDR_ADDRESS : (type))), ind_levels, insn);
     push_reload (*loc, (rtx) 0, loc, (rtx*) 0,
    (context ? INDEX_REGS : GENERAL_REGS),
    ((enum machine_mode) (x)->mode), VOIDmode, 0, 0, opnum, type);
     return 1;
   }

 if (code0 == MULT || code0 == SIGN_EXTEND || code0 == TRUNCATE
     || code0 == ZERO_EXTEND || code1 == MEM)
   {
     find_reloads_address_1 (mode, orig_op0, 1, &(((x)->u.fld[0]).rtx), opnum,
        type, ind_levels, insn);
     find_reloads_address_1 (mode, orig_op1, 0, &(((x)->u.fld[1]).rtx), opnum,
        type, ind_levels, insn);
   }

 else if (code1 == MULT || code1 == SIGN_EXTEND || code1 == TRUNCATE
   || code1 == ZERO_EXTEND || code0 == MEM)
   {
     find_reloads_address_1 (mode, orig_op0, 0, &(((x)->u.fld[0]).rtx), opnum,
        type, ind_levels, insn);
     find_reloads_address_1 (mode, orig_op1, 1, &(((x)->u.fld[1]).rtx), opnum,
        type, ind_levels, insn);
   }

 else if (code0 == CONST_INT || code0 == CONST
   || code0 == SYMBOL_REF || code0 == LABEL_REF)
   find_reloads_address_1 (mode, orig_op1, 0, &(((x)->u.fld[1]).rtx), opnum,
      type, ind_levels, insn);

 else if (code1 == CONST_INT || code1 == CONST
   || code1 == SYMBOL_REF || code1 == LABEL_REF)
   find_reloads_address_1 (mode, orig_op0, 0, &(((x)->u.fld[0]).rtx), opnum,
      type, ind_levels, insn);

 else if (code0 == REG && code1 == REG)
   {
     if ((((((op0)->u.fld[0]).rtuint)) < 7 || ((((op0)->u.fld[0]).rtuint) >= (((((20 + 1) + 7) + 1) + 7) + 1) && ((((op0)->u.fld[0]).rtuint)) <= ((((((20 + 1) + 7) + 1) + 7) + 1) + 7)) || ((unsigned) reg_renumber[((((op0)->u.fld[0]).rtuint))] >= (((((20 + 1) + 7) + 1) + 7) + 1) && (unsigned) reg_renumber[((((op0)->u.fld[0]).rtuint))] <= ((((((20 + 1) + 7) + 1) + 7) + 1) + 7)) || (unsigned) reg_renumber[((((op0)->u.fld[0]).rtuint))] < 7)
  && (((((op1)->u.fld[0]).rtuint)) <= 7 || ((((op1)->u.fld[0]).rtuint)) == 16 || ((((op1)->u.fld[0]).rtuint)) == 20 || ((((op1)->u.fld[0]).rtuint) >= (((((20 + 1) + 7) + 1) + 7) + 1) && ((((op1)->u.fld[0]).rtuint)) <= ((((((20 + 1) + 7) + 1) + 7) + 1) + 7)) || ((unsigned) reg_renumber[((((op1)->u.fld[0]).rtuint))] >= (((((20 + 1) + 7) + 1) + 7) + 1) && (unsigned) reg_renumber[((((op1)->u.fld[0]).rtuint))] <= ((((((20 + 1) + 7) + 1) + 7) + 1) + 7)) || (unsigned) reg_renumber[((((op1)->u.fld[0]).rtuint))] <= 7))
       return 0;
     else if ((((((op1)->u.fld[0]).rtuint)) < 7 || ((((op1)->u.fld[0]).rtuint) >= (((((20 + 1) + 7) + 1) + 7) + 1) && ((((op1)->u.fld[0]).rtuint)) <= ((((((20 + 1) + 7) + 1) + 7) + 1) + 7)) || ((unsigned) reg_renumber[((((op1)->u.fld[0]).rtuint))] >= (((((20 + 1) + 7) + 1) + 7) + 1) && (unsigned) reg_renumber[((((op1)->u.fld[0]).rtuint))] <= ((((((20 + 1) + 7) + 1) + 7) + 1) + 7)) || (unsigned) reg_renumber[((((op1)->u.fld[0]).rtuint))] < 7)
       && (((((op0)->u.fld[0]).rtuint)) <= 7 || ((((op0)->u.fld[0]).rtuint)) == 16 || ((((op0)->u.fld[0]).rtuint)) == 20 || ((((op0)->u.fld[0]).rtuint) >= (((((20 + 1) + 7) + 1) + 7) + 1) && ((((op0)->u.fld[0]).rtuint)) <= ((((((20 + 1) + 7) + 1) + 7) + 1) + 7)) || ((unsigned) reg_renumber[((((op0)->u.fld[0]).rtuint))] >= (((((20 + 1) + 7) + 1) + 7) + 1) && (unsigned) reg_renumber[((((op0)->u.fld[0]).rtuint))] <= ((((((20 + 1) + 7) + 1) + 7) + 1) + 7)) || (unsigned) reg_renumber[((((op0)->u.fld[0]).rtuint))] <= 7))
       return 0;
     else if ((((((op1)->u.fld[0]).rtuint)) <= 7 || ((((op1)->u.fld[0]).rtuint)) == 16 || ((((op1)->u.fld[0]).rtuint)) == 20 || ((((op1)->u.fld[0]).rtuint) >= (((((20 + 1) + 7) + 1) + 7) + 1) && ((((op1)->u.fld[0]).rtuint)) <= ((((((20 + 1) + 7) + 1) + 7) + 1) + 7)) || ((unsigned) reg_renumber[((((op1)->u.fld[0]).rtuint))] >= (((((20 + 1) + 7) + 1) + 7) + 1) && (unsigned) reg_renumber[((((op1)->u.fld[0]).rtuint))] <= ((((((20 + 1) + 7) + 1) + 7) + 1) + 7)) || (unsigned) reg_renumber[((((op1)->u.fld[0]).rtuint))] <= 7))
       find_reloads_address_1 (mode, orig_op0, 1, &(((x)->u.fld[0]).rtx), opnum,
          type, ind_levels, insn);
     else if ((((((op0)->u.fld[0]).rtuint)) <= 7 || ((((op0)->u.fld[0]).rtuint)) == 16 || ((((op0)->u.fld[0]).rtuint)) == 20 || ((((op0)->u.fld[0]).rtuint) >= (((((20 + 1) + 7) + 1) + 7) + 1) && ((((op0)->u.fld[0]).rtuint)) <= ((((((20 + 1) + 7) + 1) + 7) + 1) + 7)) || ((unsigned) reg_renumber[((((op0)->u.fld[0]).rtuint))] >= (((((20 + 1) + 7) + 1) + 7) + 1) && (unsigned) reg_renumber[((((op0)->u.fld[0]).rtuint))] <= ((((((20 + 1) + 7) + 1) + 7) + 1) + 7)) || (unsigned) reg_renumber[((((op0)->u.fld[0]).rtuint))] <= 7))
       find_reloads_address_1 (mode, orig_op1, 1, &(((x)->u.fld[1]).rtx), opnum,
          type, ind_levels, insn);
     else if ((((((op1)->u.fld[0]).rtuint)) < 7 || ((((op1)->u.fld[0]).rtuint) >= (((((20 + 1) + 7) + 1) + 7) + 1) && ((((op1)->u.fld[0]).rtuint)) <= ((((((20 + 1) + 7) + 1) + 7) + 1) + 7)) || ((unsigned) reg_renumber[((((op1)->u.fld[0]).rtuint))] >= (((((20 + 1) + 7) + 1) + 7) + 1) && (unsigned) reg_renumber[((((op1)->u.fld[0]).rtuint))] <= ((((((20 + 1) + 7) + 1) + 7) + 1) + 7)) || (unsigned) reg_renumber[((((op1)->u.fld[0]).rtuint))] < 7))
       find_reloads_address_1 (mode, orig_op0, 0, &(((x)->u.fld[0]).rtx), opnum,
          type, ind_levels, insn);
     else if ((((((op0)->u.fld[0]).rtuint)) < 7 || ((((op0)->u.fld[0]).rtuint) >= (((((20 + 1) + 7) + 1) + 7) + 1) && ((((op0)->u.fld[0]).rtuint)) <= ((((((20 + 1) + 7) + 1) + 7) + 1) + 7)) || ((unsigned) reg_renumber[((((op0)->u.fld[0]).rtuint))] >= (((((20 + 1) + 7) + 1) + 7) + 1) && (unsigned) reg_renumber[((((op0)->u.fld[0]).rtuint))] <= ((((((20 + 1) + 7) + 1) + 7) + 1) + 7)) || (unsigned) reg_renumber[((((op0)->u.fld[0]).rtuint))] < 7))
       find_reloads_address_1 (mode, orig_op1, 0, &(((x)->u.fld[1]).rtx), opnum,
          type, ind_levels, insn);
     else
       {
  find_reloads_address_1 (mode, orig_op0, 1, &(((x)->u.fld[0]).rtx), opnum,
     type, ind_levels, insn);
  find_reloads_address_1 (mode, orig_op1, 0, &(((x)->u.fld[1]).rtx), opnum,
     type, ind_levels, insn);
       }
   }

 else if (code0 == REG)
   {
     find_reloads_address_1 (mode, orig_op0, 1, &(((x)->u.fld[0]).rtx), opnum,
        type, ind_levels, insn);
     find_reloads_address_1 (mode, orig_op1, 0, &(((x)->u.fld[1]).rtx), opnum,
        type, ind_levels, insn);
   }

 else if (code1 == REG)
   {
     find_reloads_address_1 (mode, orig_op1, 1, &(((x)->u.fld[1]).rtx), opnum,
        type, ind_levels, insn);
     find_reloads_address_1 (mode, orig_op0, 0, &(((x)->u.fld[0]).rtx), opnum,
        type, ind_levels, insn);
   }
      }

      return 0;

    case POST_MODIFY:
    case PRE_MODIFY:
      {
 rtx op0 = (((x)->u.fld[0]).rtx);
 rtx op1 = (((x)->u.fld[1]).rtx);

 if (((enum rtx_code) (op1)->code) != PLUS && ((enum rtx_code) (op1)->code) != MINUS)
   return 0;





 if (op0 != (((op1)->u.fld[0]).rtx))
   fancy_abort ("reload.c", 5385, __FUNCTION__);





 if ((((enum rtx_code) ((((op1)->u.fld[1]).rtx))->code) == REG))
   if (!((((((((op1)->u.fld[1]).rtx))->u.fld[0]).rtuint)) < 7 || (((((((op1)->u.fld[1]).rtx))->u.fld[0]).rtuint) >= (((((20 + 1) + 7) + 1) + 7) + 1) && (((((((op1)->u.fld[1]).rtx))->u.fld[0]).rtuint)) <= ((((((20 + 1) + 7) + 1) + 7) + 1) + 7)) || ((unsigned) reg_renumber[(((((((op1)->u.fld[1]).rtx))->u.fld[0]).rtuint))] >= (((((20 + 1) + 7) + 1) + 7) + 1) && (unsigned) reg_renumber[(((((((op1)->u.fld[1]).rtx))->u.fld[0]).rtuint))] <= ((((((20 + 1) + 7) + 1) + 7) + 1) + 7)) || (unsigned) reg_renumber[(((((((op1)->u.fld[1]).rtx))->u.fld[0]).rtuint))] < 7))
     find_reloads_address_1 (mode, (((op1)->u.fld[1]).rtx), 1, &(((op1)->u.fld[1]).rtx),
        opnum, type, ind_levels, insn);

 if ((((enum rtx_code) ((((op1)->u.fld[0]).rtx))->code) == REG))
   {
     int regno = ((((((op1)->u.fld[0]).rtx))->u.fld[0]).rtuint);
     int reloadnum;


     if (regno >= 53
  && reg_equiv_constant[regno] != 0)
       fancy_abort ("reload.c", 5404, __FUNCTION__);



     if (reg_equiv_memory_loc[regno] != 0
  && (reg_equiv_address[regno] != 0
      || num_not_at_initial_offset))
       {
  rtx tem = make_memloc ((((x)->u.fld[0]).rtx), regno);

  if (reg_equiv_address[regno]
      || ! rtx_equal_p (tem, reg_equiv_mem[regno]))
    {




      find_reloads_address (((enum machine_mode) (tem)->mode), &tem, (((tem)->u.fld[0]).rtx),
       &(((tem)->u.fld[0]).rtx), opnum,
       RELOAD_OTHER,
       ind_levels, insn);



      reloadnum = push_reload (tem, tem, &(((x)->u.fld[0]).rtx),
          &(((op1)->u.fld[0]).rtx),
          GENERAL_REGS,
          ((enum machine_mode) (x)->mode), ((enum machine_mode) (x)->mode), 0,
          0, opnum, RELOAD_OTHER);

      update_auto_inc_notes (this_insn, regno, reloadnum);
      return 0;
    }
       }

     if (reg_renumber[regno] >= 0)
       regno = reg_renumber[regno];


     if (!((regno) <= 7 || (regno) == 16 || (regno) == 20 || (regno >= (((((20 + 1) + 7) + 1) + 7) + 1) && (regno) <= ((((((20 + 1) + 7) + 1) + 7) + 1) + 7)) || ((unsigned) reg_renumber[(regno)] >= (((((20 + 1) + 7) + 1) + 7) + 1) && (unsigned) reg_renumber[(regno)] <= ((((((20 + 1) + 7) + 1) + 7) + 1) + 7)) || (unsigned) reg_renumber[(regno)] <= 7))
       {
  reloadnum = push_reload ((((op1)->u.fld[0]).rtx), (((x)->u.fld[0]).rtx),
      &(((op1)->u.fld[0]).rtx), &(((x)->u.fld[0]).rtx),
      GENERAL_REGS,
      ((enum machine_mode) (x)->mode), ((enum machine_mode) (x)->mode), 0, 0,
      opnum, RELOAD_OTHER);

  update_auto_inc_notes (this_insn, regno, reloadnum);
  return 0;
       }
   }
 else
   fancy_abort ("reload.c", 5456, __FUNCTION__);
      }
      return 0;

    case POST_INC:
    case POST_DEC:
    case PRE_INC:
    case PRE_DEC:
      if (((enum rtx_code) ((((x)->u.fld[0]).rtx))->code) == REG)
 {
   int regno = ((((((x)->u.fld[0]).rtx))->u.fld[0]).rtuint);
   int value = 0;
   rtx x_orig = x;


   if (regno >= 53
       && reg_equiv_constant[regno] != 0)
     fancy_abort ("reload.c", 5473, __FUNCTION__);



   if (reg_equiv_memory_loc[regno] != 0
       && (reg_equiv_address[regno] != 0 || num_not_at_initial_offset))
     {
       rtx tem = make_memloc ((((x)->u.fld[0]).rtx), regno);
       if (reg_equiv_address[regno]
    || ! rtx_equal_p (tem, reg_equiv_mem[regno]))
  {




    find_reloads_address (((enum machine_mode) (tem)->mode), &tem, (((tem)->u.fld[0]).rtx),
     &(((tem)->u.fld[0]).rtx), opnum, type,
     ind_levels, insn);

    x = gen_rtx_fmt_e (((enum rtx_code) (x)->code), ((enum machine_mode) (x)->mode), tem);

  }
     }
# 5508 "reload.c"
   if (reg_renumber[regno] >= 0)
     regno = reg_renumber[regno];
   if ((regno >= 53
        || !(context ? ((regno) < 7 || (regno >= (((((20 + 1) + 7) + 1) + 7) + 1) && (regno) <= ((((((20 + 1) + 7) + 1) + 7) + 1) + 7)) || ((unsigned) reg_renumber[(regno)] >= (((((20 + 1) + 7) + 1) + 7) + 1) && (unsigned) reg_renumber[(regno)] <= ((((((20 + 1) + 7) + 1) + 7) + 1) + 7)) || (unsigned) reg_renumber[(regno)] < 7)
      : ((regno) <= 7 || (regno) == 16 || (regno) == 20 || (regno >= (((((20 + 1) + 7) + 1) + 7) + 1) && (regno) <= ((((((20 + 1) + 7) + 1) + 7) + 1) + 7)) || ((unsigned) reg_renumber[(regno)] >= (((((20 + 1) + 7) + 1) + 7) + 1) && (unsigned) reg_renumber[(regno)] <= ((((((20 + 1) + 7) + 1) + 7) + 1) + 7)) || (unsigned) reg_renumber[(regno)] <= 7))))
     {
       int reloadnum;
# 5524 "reload.c"
       rtx equiv = (((enum rtx_code) ((((x)->u.fld[0]).rtx))->code) == MEM
      ? (((x)->u.fld[0]).rtx)
      : reg_equiv_mem[regno]);
       int icode = (int) (optab_table[OTI_add])->handlers[(int) (0 ? DImode : SImode)].insn_code;
       if (insn && ((enum rtx_code) (insn)->code) == INSN && equiv
    && memory_operand (equiv, ((enum machine_mode) (equiv)->mode))



    && ! (icode != CODE_FOR_nothing
   && ((*insn_data[icode].operand[0].predicate)
       (equiv, (0 ? DImode : SImode)))
   && ((*insn_data[icode].operand[1].predicate)
       (equiv, (0 ? DImode : SImode)))))
  {





    loc = &(((x_orig)->u.fld[0]).rtx);
    x = (((x)->u.fld[0]).rtx);
    reloadnum
      = push_reload (x, x, loc, loc,
       (context ? INDEX_REGS :
        GENERAL_REGS),
       ((enum machine_mode) (x)->mode), ((enum machine_mode) (x)->mode), 0, 0,
       opnum, RELOAD_OTHER);
  }
       else
  {
    reloadnum
      = push_reload (x, (rtx) 0, loc, (rtx*) 0,
       (context ? INDEX_REGS :
        GENERAL_REGS),
       ((enum machine_mode) (x)->mode), ((enum machine_mode) (x)->mode), 0, 0,
       opnum, type);
    rld[reloadnum].inc
      = find_inc_amount ((((this_insn)->u.fld[5]).rtx), (((x_orig)->u.fld[0]).rtx));

    value = 1;
  }

       update_auto_inc_notes (this_insn, ((((((x_orig)->u.fld[0]).rtx))->u.fld[0]).rtuint),
         reloadnum);
     }
   return value;
 }

      else if (((enum rtx_code) ((((x)->u.fld[0]).rtx))->code) == MEM)
 {





   rtx tem __attribute__ ((__unused__)) = (((x)->u.fld[0]).rtx);
   rtx link;
   int reloadnum;
# 5593 "reload.c"
   find_reloads_address (((enum machine_mode) (x)->mode), &(((x)->u.fld[0]).rtx),
    ((((((x)->u.fld[0]).rtx))->u.fld[0]).rtx), &((((((x)->u.fld[0]).rtx))->u.fld[0]).rtx),
    opnum, type, ind_levels, insn);

   reloadnum = push_reload (x, (rtx) 0, loc, (rtx*) 0,
       (context ? INDEX_REGS :
        GENERAL_REGS),
       ((enum machine_mode) (x)->mode), VOIDmode, 0, 0, opnum, type);
   rld[reloadnum].inc
     = find_inc_amount ((((this_insn)->u.fld[5]).rtx), (((x)->u.fld[0]).rtx));

   link = 0;
   if (link != 0)
     push_replacement (&(((link)->u.fld[0]).rtx), reloadnum, VOIDmode);

   return 1;
 }
      return 0;

    case MEM:
# 5625 "reload.c"
      find_reloads_address (((enum machine_mode) (x)->mode), loc, (((x)->u.fld[0]).rtx), &(((x)->u.fld[0]).rtx),
       opnum, ((type) == RELOAD_FOR_INPUT_ADDRESS ? RELOAD_FOR_INPADDR_ADDRESS : ((type) == RELOAD_FOR_OUTPUT_ADDRESS ? RELOAD_FOR_OUTADDR_ADDRESS : (type))), ind_levels, insn);
      push_reload (*loc, (rtx) 0, loc, (rtx*) 0,
     (context ? INDEX_REGS : GENERAL_REGS),
     ((enum machine_mode) (x)->mode), VOIDmode, 0, 0, opnum, type);
      return 1;

    case REG:
      {
 int regno = (((x)->u.fld[0]).rtuint);

 if (reg_equiv_constant[regno] != 0)
   {
     find_reloads_address_part (reg_equiv_constant[regno], loc,
           (context ? INDEX_REGS :
     GENERAL_REGS),
           ((enum machine_mode) (x)->mode), opnum, type, ind_levels);
     return 1;
   }
# 5657 "reload.c"
 if (reg_equiv_memory_loc[regno]
     && (reg_equiv_address[regno] != 0 || num_not_at_initial_offset))
   {
     rtx tem = make_memloc (x, regno);
     if (reg_equiv_address[regno] != 0
  || ! rtx_equal_p (tem, reg_equiv_mem[regno]))
       {
  x = tem;
  find_reloads_address (((enum machine_mode) (x)->mode), &x, (((x)->u.fld[0]).rtx),
          &(((x)->u.fld[0]).rtx), opnum, ((type) == RELOAD_FOR_INPUT_ADDRESS ? RELOAD_FOR_INPADDR_ADDRESS : ((type) == RELOAD_FOR_OUTPUT_ADDRESS ? RELOAD_FOR_OUTADDR_ADDRESS : (type))),
          ind_levels, insn);
       }
   }

 if (reg_renumber[regno] >= 0)
   regno = reg_renumber[regno];

 if ((regno >= 53
      || !(context ? ((regno) < 7 || (regno >= (((((20 + 1) + 7) + 1) + 7) + 1) && (regno) <= ((((((20 + 1) + 7) + 1) + 7) + 1) + 7)) || ((unsigned) reg_renumber[(regno)] >= (((((20 + 1) + 7) + 1) + 7) + 1) && (unsigned) reg_renumber[(regno)] <= ((((((20 + 1) + 7) + 1) + 7) + 1) + 7)) || (unsigned) reg_renumber[(regno)] < 7)
    : ((regno) <= 7 || (regno) == 16 || (regno) == 20 || (regno >= (((((20 + 1) + 7) + 1) + 7) + 1) && (regno) <= ((((((20 + 1) + 7) + 1) + 7) + 1) + 7)) || ((unsigned) reg_renumber[(regno)] >= (((((20 + 1) + 7) + 1) + 7) + 1) && (unsigned) reg_renumber[(regno)] <= ((((((20 + 1) + 7) + 1) + 7) + 1) + 7)) || (unsigned) reg_renumber[(regno)] <= 7))))
   {
     push_reload (x, (rtx) 0, loc, (rtx*) 0,
    (context ? INDEX_REGS : GENERAL_REGS),
    ((enum machine_mode) (x)->mode), VOIDmode, 0, 0, opnum, type);
     return 1;
   }





 if (regno_clobbered_p (regno, this_insn, ((enum machine_mode) (x)->mode), 0))
   {
     push_reload (x, (rtx) 0, loc, (rtx*) 0,
    (context ? INDEX_REGS : GENERAL_REGS),
    ((enum machine_mode) (x)->mode), VOIDmode, 0, 0, opnum, type);
     return 1;
   }
      }
      return 0;

    case SUBREG:
      if (((enum rtx_code) ((((x)->u.fld[0]).rtx))->code) == REG)
 {



   if (((((((x)->u.fld[0]).rtx))->u.fld[0]).rtuint) < 53)
     {
       int regno __attribute__ ((__unused__)) = subreg_regno (x);

       if (! (context ? ((regno) < 7 || (regno >= (((((20 + 1) + 7) + 1) + 7) + 1) && (regno) <= ((((((20 + 1) + 7) + 1) + 7) + 1) + 7)) || ((unsigned) reg_renumber[(regno)] >= (((((20 + 1) + 7) + 1) + 7) + 1) && (unsigned) reg_renumber[(regno)] <= ((((((20 + 1) + 7) + 1) + 7) + 1) + 7)) || (unsigned) reg_renumber[(regno)] < 7)
       : ((regno) <= 7 || (regno) == 16 || (regno) == 20 || (regno >= (((((20 + 1) + 7) + 1) + 7) + 1) && (regno) <= ((((((20 + 1) + 7) + 1) + 7) + 1) + 7)) || ((unsigned) reg_renumber[(regno)] >= (((((20 + 1) + 7) + 1) + 7) + 1) && (unsigned) reg_renumber[(regno)] <= ((((((20 + 1) + 7) + 1) + 7) + 1) + 7)) || (unsigned) reg_renumber[(regno)] <= 7)))
  {
    push_reload (x, (rtx) 0, loc, (rtx*) 0,
          (context ? INDEX_REGS :
    GENERAL_REGS),
          ((enum machine_mode) (x)->mode), VOIDmode, 0, 0, opnum, type);
    return 1;
  }
     }


   else
     {
       enum reg_class class = (context ? INDEX_REGS
          : GENERAL_REGS);
       if ((unsigned) (!reg_classes_intersect_p ((class), GENERAL_REGS) ? ((mode_class[((enum machine_mode) ((((x)->u.fld[0]).rtx))->mode)] == MODE_COMPLEX_INT || mode_class[((enum machine_mode) ((((x)->u.fld[0]).rtx))->mode)] == MODE_COMPLEX_FLOAT) ? 2 : 1) : (((((((enum machine_mode) ((((x)->u.fld[0]).rtx))->mode)) == XFmode ? 12 : ((unsigned short) mode_size[((enum machine_mode) ((((x)->u.fld[0]).rtx))->mode)]))) + (0 ? 8 : 4) - 1) / (0 ? 8 : 4)))
    > reg_class_size[class])
  {
    x = find_reloads_subreg_address (x, 0, opnum, type,
         ind_levels, insn);
    push_reload (x, (rtx) 0, loc, (rtx*) 0, class,
          ((enum machine_mode) (x)->mode), VOIDmode, 0, 0, opnum, type);
    return 1;
  }
     }
 }
      break;

    default:
      break;
    }

  {
    const char *fmt = (rtx_format[(int) (code)]);
    int i;

    for (i = (rtx_length[(int) (code)]) - 1; i >= 0; i--)
      {
 if (fmt[i] == 'e')
   find_reloads_address_1 (mode, (((x)->u.fld[i]).rtx), context, &(((x)->u.fld[i]).rtx),
      opnum, type, ind_levels, insn);
      }
  }

  return 0;
}
# 5771 "reload.c"
static void
find_reloads_address_part (rtx x, rtx *loc, enum reg_class class,
      enum machine_mode mode, int opnum,
      enum reload_type type, int ind_levels)
{
  if ((((enum rtx_code) (x)->code) == LABEL_REF || ((enum rtx_code) (x)->code) == SYMBOL_REF || ((enum rtx_code) (x)->code) == CONST_INT || ((enum rtx_code) (x)->code) == CONST_DOUBLE || ((enum rtx_code) (x)->code) == CONST || ((enum rtx_code) (x)->code) == HIGH || ((enum rtx_code) (x)->code) == CONST_VECTOR || ((enum rtx_code) (x)->code) == CONSTANT_P_RTX)
      && (! legitimate_constant_p (x)
   || ix86_preferred_reload_class ((x), (class)) == NO_REGS))
    {
      rtx tem;

      tem = x = force_const_mem (mode, x);
      find_reloads_address (mode, &tem, (((tem)->u.fld[0]).rtx), &(((tem)->u.fld[0]).rtx),
       opnum, type, ind_levels, 0);
    }

  else if (((enum rtx_code) (x)->code) == PLUS
    && (((enum rtx_code) ((((x)->u.fld[1]).rtx))->code) == LABEL_REF || ((enum rtx_code) ((((x)->u.fld[1]).rtx))->code) == SYMBOL_REF || ((enum rtx_code) ((((x)->u.fld[1]).rtx))->code) == CONST_INT || ((enum rtx_code) ((((x)->u.fld[1]).rtx))->code) == CONST_DOUBLE || ((enum rtx_code) ((((x)->u.fld[1]).rtx))->code) == CONST || ((enum rtx_code) ((((x)->u.fld[1]).rtx))->code) == HIGH || ((enum rtx_code) ((((x)->u.fld[1]).rtx))->code) == CONST_VECTOR || ((enum rtx_code) ((((x)->u.fld[1]).rtx))->code) == CONSTANT_P_RTX)
    && (! legitimate_constant_p ((((x)->u.fld[1]).rtx))
        || ix86_preferred_reload_class (((((x)->u.fld[1]).rtx)), (class)) == NO_REGS))
    {
      rtx tem;

      tem = force_const_mem (((enum machine_mode) (x)->mode), (((x)->u.fld[1]).rtx));
      x = gen_rtx_fmt_ee (PLUS, (((enum machine_mode) (x)->mode)), ((((x)->u.fld[0]).rtx)), (tem));
      find_reloads_address (mode, &tem, (((tem)->u.fld[0]).rtx), &(((tem)->u.fld[0]).rtx),
       opnum, type, ind_levels, 0);
    }

  push_reload (x, (rtx) 0, loc, (rtx*) 0, class,
        mode, VOIDmode, 0, 0, opnum, type);
}
# 5826 "reload.c"
static rtx
find_reloads_subreg_address (rtx x, int force_replace, int opnum,
        enum reload_type type, int ind_levels, rtx insn)
{
  int regno = ((((((x)->u.fld[0]).rtx))->u.fld[0]).rtuint);

  if (reg_equiv_memory_loc[regno])
    {


      if (! force_replace
   && (reg_equiv_address[regno]
       || ! offsettable_memref_p (reg_equiv_mem[regno])))
 force_replace = 1;

      if (force_replace || num_not_at_initial_offset)
 {
   rtx tem = make_memloc ((((x)->u.fld[0]).rtx), regno);



   if (force_replace
       || ! rtx_equal_p (tem, reg_equiv_mem[regno]))
     {
       unsigned outer_size = ((unsigned short) mode_size[((enum machine_mode) (x)->mode)]);
       unsigned inner_size = ((unsigned short) mode_size[((enum machine_mode) ((((x)->u.fld[0]).rtx))->mode)]);
       int offset;



       if (0 && outer_size > inner_size)
  offset = inner_size - outer_size;
       else
  offset = (((x)->u.fld[1]).rtuint);

       (((tem)->u.fld[0]).rtx) = plus_constant_wide (((((tem)->u.fld[0]).rtx)), (long) (offset));
       ((tem)->mode = (((enum machine_mode) (x)->mode)));




       if (outer_size > inner_size && 0)
  {
    rtx base;

    base = (((tem)->u.fld[0]).rtx);
    if (((enum rtx_code) (base)->code) == PLUS)
      {
        if (((enum rtx_code) ((((base)->u.fld[1]).rtx))->code) == CONST_INT
     && (((((base)->u.fld[1]).rtx))->u.hwint[0]) % outer_size != 0)
   return x;
        base = (((base)->u.fld[0]).rtx);
      }
    if (((enum rtx_code) (base)->code) != REG
        || ((cfun->emit->regno_pointer_align[(((base)->u.fld[0]).rtuint)])
     < outer_size * 8))
      return x;
  }

       find_reloads_address (((enum machine_mode) (tem)->mode), &tem, (((tem)->u.fld[0]).rtx),
        &(((tem)->u.fld[0]).rtx), opnum, ((type) == RELOAD_FOR_INPUT_ADDRESS ? RELOAD_FOR_INPADDR_ADDRESS : ((type) == RELOAD_FOR_OUTPUT_ADDRESS ? RELOAD_FOR_OUTADDR_ADDRESS : (type))),
        ind_levels, insn);




       if (replace_reloads && recog_data.operand[opnum] != x)



  ((emit_insn_before (gen_rtx_fmt_e (USE, (VOIDmode), ((((x)->u.fld[0]).rtx))), insn))->mode = (QImode));


       x = tem;
     }
 }
    }
  return x;
}
# 5913 "reload.c"
void
subst_reloads (rtx insn)
{
  int i;

  for (i = 0; i < n_replacements; i++)
    {
      struct replacement *r = &replacements[i];
      rtx reloadreg = rld[r->what].reg_rtx;
      if (reloadreg)
 {
# 5953 "reload.c"
   if (((enum rtx_code) (*r->where)->code) == LABEL_REF
       && ((enum rtx_code) (insn)->code) == JUMP_INSN)
     (((insn)->u.fld[8]).rtx) = gen_rtx_fmt_ue (INSN_LIST, (REG_LABEL), ((((*r->where)->u.fld[0]).rtx)), ((((insn)->u.fld[8]).rtx)));







   if (((enum machine_mode) (reloadreg)->mode) != r->mode && r->mode != VOIDmode)
     reloadreg = reload_adjust_reg_for_mode (reloadreg, r->mode);





   if (r->subreg_loc != 0 && ((enum rtx_code) (reloadreg)->code) == SUBREG)
     {
       if (((enum machine_mode) (*r->subreg_loc)->mode)
    == ((enum machine_mode) ((((reloadreg)->u.fld[0]).rtx))->mode))
  *r->subreg_loc = (((reloadreg)->u.fld[0]).rtx);
       else
  {
    int final_offset =
      (((*r->subreg_loc)->u.fld[1]).rtuint) + (((reloadreg)->u.fld[1]).rtuint);



    final_offset = (final_offset /
      ((unsigned short) mode_size[((enum machine_mode) (*r->subreg_loc)->mode)]));
    final_offset = (final_offset *
      ((unsigned short) mode_size[((enum machine_mode) (*r->subreg_loc)->mode)]));

    *r->where = (((reloadreg)->u.fld[0]).rtx);
    (((*r->subreg_loc)->u.fld[1]).rtuint) = final_offset;
  }
     }
   else
     *r->where = reloadreg;
 }

      else if (! rld[r->what].optional)
 fancy_abort ("reload.c", 5996, __FUNCTION__);
    }
}




void
copy_replacements (rtx x, rtx y)
{


  if (((enum rtx_code) (x)->code) == SUBREG)
    fancy_abort ("reload.c", 6009, __FUNCTION__);

  copy_replacements_1 (&x, &y, n_replacements);
}

static void
copy_replacements_1 (rtx *px, rtx *py, int orig_replacements)
{
  int i, j;
  rtx x, y;
  struct replacement *r;
  enum rtx_code code;
  const char *fmt;

  for (j = 0; j < orig_replacements; j++)
    {
      if (replacements[j].subreg_loc == px)
 {
   r = &replacements[n_replacements++];
   r->where = replacements[j].where;
   r->subreg_loc = py;
   r->what = replacements[j].what;
   r->mode = replacements[j].mode;
 }
      else if (replacements[j].where == px)
 {
   r = &replacements[n_replacements++];
   r->where = py;
   r->subreg_loc = 0;
   r->what = replacements[j].what;
   r->mode = replacements[j].mode;
 }
    }

  x = *px;
  y = *py;
  code = ((enum rtx_code) (x)->code);
  fmt = (rtx_format[(int) (code)]);

  for (i = (rtx_length[(int) (code)]) - 1; i >= 0; i--)
    {
      if (fmt[i] == 'e')
 copy_replacements_1 (&(((x)->u.fld[i]).rtx), &(((y)->u.fld[i]).rtx), orig_replacements);
      else if (fmt[i] == 'E')
 for (j = (((((x)->u.fld[i]).rtvec))->num_elem); --j >= 0; )
   copy_replacements_1 (&(((((x)->u.fld[i]).rtvec))->elem[j]), &(((((y)->u.fld[i]).rtvec))->elem[j]),
          orig_replacements);
    }
}



void
move_replacements (rtx *x, rtx *y)
{
  int i;

  for (i = 0; i < n_replacements; i++)
    if (replacements[i].subreg_loc == x)
      replacements[i].subreg_loc = y;
    else if (replacements[i].where == x)
      {
 replacements[i].where = y;
 replacements[i].subreg_loc = 0;
      }
}




rtx
find_replacement (rtx *loc)
{
  struct replacement *r;

  for (r = &replacements[0]; r < &replacements[n_replacements]; r++)
    {
      rtx reloadreg = rld[r->what].reg_rtx;

      if (reloadreg && r->where == loc)
 {
   if (r->mode != VOIDmode && ((enum machine_mode) (reloadreg)->mode) != r->mode)
     reloadreg = gen_rtx_REG (r->mode, (((reloadreg)->u.fld[0]).rtuint));

   return reloadreg;
 }
      else if (reloadreg && r->subreg_loc == loc)
 {




   if (((enum rtx_code) (reloadreg)->code) == REG)
     return gen_rtx_REG (((enum machine_mode) (*loc)->mode),
    ((((reloadreg)->u.fld[0]).rtuint) +
     subreg_regno_offset (((((((*loc)->u.fld[0]).rtx))->u.fld[0]).rtuint),
            ((enum machine_mode) ((((*loc)->u.fld[0]).rtx))->mode),
            (((*loc)->u.fld[1]).rtuint),
            ((enum machine_mode) (*loc)->mode))));
   else if (((enum machine_mode) (reloadreg)->mode) == ((enum machine_mode) (*loc)->mode))
     return reloadreg;
   else
     {
       int final_offset = (((reloadreg)->u.fld[1]).rtuint) + (((*loc)->u.fld[1]).rtuint);



       final_offset = (final_offset / ((unsigned short) mode_size[((enum machine_mode) (*loc)->mode)]));
       final_offset = (final_offset * ((unsigned short) mode_size[((enum machine_mode) (*loc)->mode)]));
       return gen_rtx_SUBREG (((enum machine_mode) (*loc)->mode), (((reloadreg)->u.fld[0]).rtx),
         final_offset);
     }
 }
    }



  if (((enum rtx_code) (*loc)->code) == PLUS || ((enum rtx_code) (*loc)->code) == MINUS
      || ((enum rtx_code) (*loc)->code) == MULT)
    {
      rtx x = find_replacement (&(((*loc)->u.fld[0]).rtx));
      rtx y = find_replacement (&(((*loc)->u.fld[1]).rtx));

      if (x != (((*loc)->u.fld[0]).rtx) || y != (((*loc)->u.fld[1]).rtx))
 return gen_rtx_fmt_ee (((enum rtx_code) (*loc)->code), ((enum machine_mode) (*loc)->mode), x, y);
    }

  return *loc;
}
# 6149 "reload.c"
int
refers_to_regno_for_reload_p (unsigned int regno, unsigned int endregno,
         rtx x, rtx *loc)
{
  int i;
  unsigned int r;
  enum rtx_code code;
  const char *fmt;

  if (x == 0)
    return 0;

 repeat:
  code = ((enum rtx_code) (x)->code);

  switch (code)
    {
    case REG:
      r = (((x)->u.fld[0]).rtuint);



      if (r >= 53)
 {
   if (reg_equiv_memory_loc[r])
     return refers_to_regno_for_reload_p (regno, endregno,
       reg_equiv_memory_loc[r],
       (rtx*) 0);

   if (reg_equiv_constant[r])
     return 0;

   fancy_abort ("reload.c", 6181, __FUNCTION__);
 }

      return (endregno > r
       && regno < r + (r < 53
         ? (((r) >= 8 && (r) <= (8 + 7)) || (((r) >= (20 + 1) && (r) <= ((20 + 1) + 7)) || ((r) >= (((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) && (r) <= ((((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) + 7))) || ((r) >= (((20 + 1) + 7) + 1) && (r) <= ((((20 + 1) + 7) + 1) + 7)) ? ((mode_class[((enum machine_mode) (x)->mode)] == MODE_COMPLEX_INT || mode_class[((enum machine_mode) (x)->mode)] == MODE_COMPLEX_FLOAT) ? 2 : 1) : ((((enum machine_mode) (x)->mode)) == XFmode ? (0 ? 2 : 3) : (((enum machine_mode) (x)->mode)) == XCmode ? (0 ? 4 : 6) : ((((unsigned short) mode_size[((enum machine_mode) (x)->mode)]) + (0 ? 8 : 4) - 1) / (0 ? 8 : 4))))
         : 1));

    case SUBREG:


      if (((enum rtx_code) ((((x)->u.fld[0]).rtx))->code) == REG
   && ((((((x)->u.fld[0]).rtx))->u.fld[0]).rtuint) < 53)
 {
   unsigned int inner_regno = subreg_regno (x);
   unsigned int inner_endregno
     = inner_regno + (inner_regno < 53
        ? (((regno) >= 8 && (regno) <= (8 + 7)) || (((regno) >= (20 + 1) && (regno) <= ((20 + 1) + 7)) || ((regno) >= (((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) && (regno) <= ((((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) + 7))) || ((regno) >= (((20 + 1) + 7) + 1) && (regno) <= ((((20 + 1) + 7) + 1) + 7)) ? ((mode_class[((enum machine_mode) (x)->mode)] == MODE_COMPLEX_INT || mode_class[((enum machine_mode) (x)->mode)] == MODE_COMPLEX_FLOAT) ? 2 : 1) : ((((enum machine_mode) (x)->mode)) == XFmode ? (0 ? 2 : 3) : (((enum machine_mode) (x)->mode)) == XCmode ? (0 ? 4 : 6) : ((((unsigned short) mode_size[((enum machine_mode) (x)->mode)]) + (0 ? 8 : 4) - 1) / (0 ? 8 : 4)))) : 1);

   return endregno > inner_regno && regno < inner_endregno;
 }
      break;

    case CLOBBER:
    case SET:
      if (&(((x)->u.fld[0]).rtx) != loc



   && ((((enum rtx_code) ((((x)->u.fld[0]).rtx))->code) == SUBREG
        && loc != &((((((x)->u.fld[0]).rtx))->u.fld[0]).rtx)
        && ((enum rtx_code) (((((((x)->u.fld[0]).rtx))->u.fld[0]).rtx))->code) == REG
        && (((((((((x)->u.fld[0]).rtx))->u.fld[0]).rtx))->u.fld[0]).rtuint) >= 53
        && refers_to_regno_for_reload_p (regno, endregno,
      ((((((x)->u.fld[0]).rtx))->u.fld[0]).rtx),
      loc))


       || ((((enum rtx_code) ((((x)->u.fld[0]).rtx))->code) != REG
     || earlyclobber_operand_p ((((x)->u.fld[0]).rtx)))
    && refers_to_regno_for_reload_p (regno, endregno,
         (((x)->u.fld[0]).rtx), loc))))
 return 1;

      if (code == CLOBBER || loc == &(((x)->u.fld[1]).rtx))
 return 0;
      x = (((x)->u.fld[1]).rtx);
      goto repeat;

    default:
      break;
    }



  fmt = (rtx_format[(int) (code)]);
  for (i = (rtx_length[(int) (code)]) - 1; i >= 0; i--)
    {
      if (fmt[i] == 'e' && loc != &(((x)->u.fld[i]).rtx))
 {
   if (i == 0)
     {
       x = (((x)->u.fld[0]).rtx);
       goto repeat;
     }
   else
     if (refers_to_regno_for_reload_p (regno, endregno,
           (((x)->u.fld[i]).rtx), loc))
       return 1;
 }
      else if (fmt[i] == 'E')
 {
   int j;
   for (j = (((((x)->u.fld[i]).rtvec))->num_elem) - 1; j >= 0; j--)
     if (loc != &(((((x)->u.fld[i]).rtvec))->elem[j])
  && refers_to_regno_for_reload_p (regno, endregno,
       (((((x)->u.fld[i]).rtvec))->elem[j]), loc))
       return 1;
 }
    }
  return 0;
}
# 6273 "reload.c"
int
reg_overlap_mentioned_for_reload_p (rtx x, rtx in)
{
  int regno, endregno;


  if (((enum rtx_code) (x)->code) == STRICT_LOW_PART
      || (rtx_class[(int) (((enum rtx_code) (x)->code))]) == 'a')
    x = (((x)->u.fld[0]).rtx);


  if ((((enum rtx_code) (x)->code) == LABEL_REF || ((enum rtx_code) (x)->code) == SYMBOL_REF || ((enum rtx_code) (x)->code) == CONST_INT || ((enum rtx_code) (x)->code) == CONST_DOUBLE || ((enum rtx_code) (x)->code) == CONST || ((enum rtx_code) (x)->code) == HIGH || ((enum rtx_code) (x)->code) == CONST_VECTOR || ((enum rtx_code) (x)->code) == CONSTANT_P_RTX) || (((enum rtx_code) (in)->code) == LABEL_REF || ((enum rtx_code) (in)->code) == SYMBOL_REF || ((enum rtx_code) (in)->code) == CONST_INT || ((enum rtx_code) (in)->code) == CONST_DOUBLE || ((enum rtx_code) (in)->code) == CONST || ((enum rtx_code) (in)->code) == HIGH || ((enum rtx_code) (in)->code) == CONST_VECTOR || ((enum rtx_code) (in)->code) == CONSTANT_P_RTX))
    return 0;
  else if (((enum rtx_code) (x)->code) == SUBREG)
    {
      regno = ((((((x)->u.fld[0]).rtx))->u.fld[0]).rtuint);
      if (regno < 53)
 regno += subreg_regno_offset (((((((x)->u.fld[0]).rtx))->u.fld[0]).rtuint),
          ((enum machine_mode) ((((x)->u.fld[0]).rtx))->mode),
          (((x)->u.fld[1]).rtuint),
          ((enum machine_mode) (x)->mode));
    }
  else if (((enum rtx_code) (x)->code) == REG)
    {
      regno = (((x)->u.fld[0]).rtuint);




      if (regno >= 53)
 {
   if (reg_equiv_memory_loc[regno])
     return refers_to_mem_for_reload_p (in);
   else if (reg_equiv_constant[regno])
     return 0;
   fancy_abort ("reload.c", 6308, __FUNCTION__);
 }
    }
  else if (((enum rtx_code) (x)->code) == MEM)
    return refers_to_mem_for_reload_p (in);
  else if (((enum rtx_code) (x)->code) == SCRATCH || ((enum rtx_code) (x)->code) == PC
    || ((enum rtx_code) (x)->code) == CC0)
    return reg_mentioned_p (x, in);
  else if (((enum rtx_code) (x)->code) == PLUS)
    {





      while (((enum rtx_code) (in)->code) == MEM)
 in = (((in)->u.fld[0]).rtx);
      if (((enum rtx_code) (in)->code) == REG)
 return 0;
      else if (((enum rtx_code) (in)->code) == PLUS)
 return (reg_overlap_mentioned_for_reload_p (x, (((in)->u.fld[0]).rtx))
  || reg_overlap_mentioned_for_reload_p (x, (((in)->u.fld[1]).rtx)));
      else return (reg_overlap_mentioned_for_reload_p ((((x)->u.fld[0]).rtx), in)
     || reg_overlap_mentioned_for_reload_p ((((x)->u.fld[1]).rtx), in));
    }
  else
    fancy_abort ("reload.c", 6334, __FUNCTION__);

  endregno = regno + (regno < 53
        ? (((regno) >= 8 && (regno) <= (8 + 7)) || (((regno) >= (20 + 1) && (regno) <= ((20 + 1) + 7)) || ((regno) >= (((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) && (regno) <= ((((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) + 7))) || ((regno) >= (((20 + 1) + 7) + 1) && (regno) <= ((((20 + 1) + 7) + 1) + 7)) ? ((mode_class[((enum machine_mode) (x)->mode)] == MODE_COMPLEX_INT || mode_class[((enum machine_mode) (x)->mode)] == MODE_COMPLEX_FLOAT) ? 2 : 1) : ((((enum machine_mode) (x)->mode)) == XFmode ? (0 ? 2 : 3) : (((enum machine_mode) (x)->mode)) == XCmode ? (0 ? 4 : 6) : ((((unsigned short) mode_size[((enum machine_mode) (x)->mode)]) + (0 ? 8 : 4) - 1) / (0 ? 8 : 4)))) : 1);

  return refers_to_regno_for_reload_p (regno, endregno, in, (rtx*) 0);
}




int
refers_to_mem_for_reload_p (rtx x)
{
  const char *fmt;
  int i;

  if (((enum rtx_code) (x)->code) == MEM)
    return 1;

  if (((enum rtx_code) (x)->code) == REG)
    return ((((x)->u.fld[0]).rtuint) >= 53
     && reg_equiv_memory_loc[(((x)->u.fld[0]).rtuint)]);

  fmt = (rtx_format[(int) (((enum rtx_code) (x)->code))]);
  for (i = (rtx_length[(int) (((enum rtx_code) (x)->code))]) - 1; i >= 0; i--)
    if (fmt[i] == 'e'
 && (((enum rtx_code) ((((x)->u.fld[i]).rtx))->code) == MEM
     || refers_to_mem_for_reload_p ((((x)->u.fld[i]).rtx))))
      return 1;

  return 0;
}
# 6395 "reload.c"
rtx
find_equiv_reg (rtx goal, rtx insn, enum reg_class class, int other,
  short *reload_reg_p, int goalreg, enum machine_mode mode)
{
  rtx p = insn;
  rtx goaltry, valtry, value, where;
  rtx pat;
  int regno = -1;
  int valueno;
  int goal_mem = 0;
  int goal_const = 0;
  int goal_mem_addr_varies = 0;
  int need_stable_sp = 0;
  int nregs;
  int valuenregs;
  int num = 0;

  if (goal == 0)
    regno = goalreg;
  else if (((enum rtx_code) (goal)->code) == REG)
    regno = (((goal)->u.fld[0]).rtuint);
  else if (((enum rtx_code) (goal)->code) == MEM)
    {
      enum rtx_code code = ((enum rtx_code) ((((goal)->u.fld[0]).rtx))->code);
      if ((((goal))->volatil))
 return 0;
      if (flag_float_store && mode_class[((enum machine_mode) (goal)->mode)] == MODE_FLOAT)
 return 0;

      switch (code)
 {
 case POST_INC:
 case PRE_INC:
 case POST_DEC:
 case PRE_DEC:
 case POST_MODIFY:
 case PRE_MODIFY:
   return 0;
 default:
   break;
 }
      goal_mem = 1;
    }
  else if ((((enum rtx_code) (goal)->code) == LABEL_REF || ((enum rtx_code) (goal)->code) == SYMBOL_REF || ((enum rtx_code) (goal)->code) == CONST_INT || ((enum rtx_code) (goal)->code) == CONST_DOUBLE || ((enum rtx_code) (goal)->code) == CONST || ((enum rtx_code) (goal)->code) == HIGH || ((enum rtx_code) (goal)->code) == CONST_VECTOR || ((enum rtx_code) (goal)->code) == CONSTANT_P_RTX))
    goal_const = 1;
  else if (((enum rtx_code) (goal)->code) == PLUS
    && (((goal)->u.fld[0]).rtx) == (global_rtl[GR_STACK_POINTER])
    && (((enum rtx_code) ((((goal)->u.fld[1]).rtx))->code) == LABEL_REF || ((enum rtx_code) ((((goal)->u.fld[1]).rtx))->code) == SYMBOL_REF || ((enum rtx_code) ((((goal)->u.fld[1]).rtx))->code) == CONST_INT || ((enum rtx_code) ((((goal)->u.fld[1]).rtx))->code) == CONST_DOUBLE || ((enum rtx_code) ((((goal)->u.fld[1]).rtx))->code) == CONST || ((enum rtx_code) ((((goal)->u.fld[1]).rtx))->code) == HIGH || ((enum rtx_code) ((((goal)->u.fld[1]).rtx))->code) == CONST_VECTOR || ((enum rtx_code) ((((goal)->u.fld[1]).rtx))->code) == CONSTANT_P_RTX))
    goal_const = need_stable_sp = 1;
  else if (((enum rtx_code) (goal)->code) == PLUS
    && (((goal)->u.fld[0]).rtx) == (global_rtl[GR_FRAME_POINTER])
    && (((enum rtx_code) ((((goal)->u.fld[1]).rtx))->code) == LABEL_REF || ((enum rtx_code) ((((goal)->u.fld[1]).rtx))->code) == SYMBOL_REF || ((enum rtx_code) ((((goal)->u.fld[1]).rtx))->code) == CONST_INT || ((enum rtx_code) ((((goal)->u.fld[1]).rtx))->code) == CONST_DOUBLE || ((enum rtx_code) ((((goal)->u.fld[1]).rtx))->code) == CONST || ((enum rtx_code) ((((goal)->u.fld[1]).rtx))->code) == HIGH || ((enum rtx_code) ((((goal)->u.fld[1]).rtx))->code) == CONST_VECTOR || ((enum rtx_code) ((((goal)->u.fld[1]).rtx))->code) == CONSTANT_P_RTX))
    goal_const = 1;
  else
    return 0;

  num = 0;




  while (1)
    {
      p = (((p)->u.fld[1]).rtx);
      num++;
      if (p == 0 || ((enum rtx_code) (p)->code) == CODE_LABEL
   || num > (compiler_params[(int) PARAM_MAX_RELOAD_SEARCH_INSNS].value))
 return 0;

      if (((enum rtx_code) (p)->code) == INSN

   && (! (reload_reg_p != 0
   && reload_reg_p != (short *) (long) 1)
# 6476 "reload.c"
       || (((p)->u.fld[0]).rtint) < reload_first_uid))
 {
   rtx tem;
   pat = (((rtx_class[(int) (((enum rtx_code) (p)->code))]) == 'i') ? (((enum rtx_code) ((((p)->u.fld[5]).rtx))->code) == SET ? (((p)->u.fld[5]).rtx) : single_set_2 (p, (((p)->u.fld[5]).rtx))) : (rtx) 0);


   if (pat != 0
       && ((regno >= 0
     && true_regnum ((((pat)->u.fld[1]).rtx)) == regno
     && (valueno = true_regnum (valtry = (((pat)->u.fld[0]).rtx))) >= 0)
    ||
    (regno >= 0
     && true_regnum ((((pat)->u.fld[0]).rtx)) == regno
     && (valueno = true_regnum (valtry = (((pat)->u.fld[1]).rtx))) >= 0)
    ||
    (goal_const && rtx_equal_p ((((pat)->u.fld[1]).rtx), goal)


     && !reg_overlap_mentioned_for_reload_p ((((pat)->u.fld[0]).rtx), goal)
     && (valueno = true_regnum (valtry = (((pat)->u.fld[0]).rtx))) >= 0)
    || (goal_mem
        && (valueno = true_regnum (valtry = (((pat)->u.fld[0]).rtx))) >= 0
        && rtx_renumbered_equal_p (goal, (((pat)->u.fld[1]).rtx)))
    || (goal_mem
        && (valueno = true_regnum (valtry = (((pat)->u.fld[1]).rtx))) >= 0
        && rtx_renumbered_equal_p (goal, (((pat)->u.fld[0]).rtx)))



    || (goal_const && (((p)->u.fld[8]).rtx) != 0
        && (tem = find_reg_note (p, REG_EQUIV, (rtx) 0))
        && ((rtx_equal_p ((((tem)->u.fld[0]).rtx), goal)
      && (valueno
          = true_regnum (valtry = (((pat)->u.fld[0]).rtx))) >= 0)
     || (((enum rtx_code) ((((pat)->u.fld[0]).rtx))->code) == REG
         && ((enum rtx_code) ((((tem)->u.fld[0]).rtx))->code) == CONST_DOUBLE
         && (mode_class[((enum machine_mode) ((((tem)->u.fld[0]).rtx))->mode)]
      == MODE_FLOAT)
         && ((enum rtx_code) (goal)->code) == CONST_INT
         && 0 != (goaltry
           = operand_subword ((((tem)->u.fld[0]).rtx), 0, 0,
         VOIDmode))
         && rtx_equal_p (goal, goaltry)
         && (valtry
      = operand_subword ((((pat)->u.fld[0]).rtx), 0, 0,
           VOIDmode))
         && (valueno = true_regnum (valtry)) >= 0)))
    || (goal_const && (tem = find_reg_note (p, REG_EQUIV,
         (rtx) 0))
        && ((enum rtx_code) ((((pat)->u.fld[0]).rtx))->code) == REG
        && ((enum rtx_code) ((((tem)->u.fld[0]).rtx))->code) == CONST_DOUBLE
        && (mode_class[((enum machine_mode) ((((tem)->u.fld[0]).rtx))->mode)]
     == MODE_FLOAT)
        && ((enum rtx_code) (goal)->code) == CONST_INT
        && 0 != (goaltry = operand_subword ((((tem)->u.fld[0]).rtx), 1, 0,
         VOIDmode))
        && rtx_equal_p (goal, goaltry)
        && (valtry
     = operand_subword ((((pat)->u.fld[0]).rtx), 1, 0, VOIDmode))
        && (valueno = true_regnum (valtry)) >= 0)))
     {
       if (other >= 0)
  {
    if (valueno != other)
      continue;
  }
       else if ((unsigned) valueno >= 53)
  continue;
       else
  {
    int i;

    for (i = (((valueno) >= 8 && (valueno) <= (8 + 7)) || (((valueno) >= (20 + 1) && (valueno) <= ((20 + 1) + 7)) || ((valueno) >= (((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) && (valueno) <= ((((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) + 7))) || ((valueno) >= (((20 + 1) + 7) + 1) && (valueno) <= ((((20 + 1) + 7) + 1) + 7)) ? ((mode_class[mode] == MODE_COMPLEX_INT || mode_class[mode] == MODE_COMPLEX_FLOAT) ? 2 : 1) : ((mode) == XFmode ? (0 ? 2 : 3) : (mode) == XCmode ? (0 ? 4 : 6) : ((((unsigned short) mode_size[mode]) + (0 ? 8 : 4) - 1) / (0 ? 8 : 4)))) - 1; i >= 0; i--)
      if (! (!!((reg_class_contents[(int) class])[(valueno + i) / ((unsigned) (8 * 4))] & (((HARD_REG_ELT_TYPE) (1)) << ((valueno + i) % ((unsigned) (8 * 4)))))))

        break;
    if (i >= 0)
      continue;
  }
       value = valtry;
       where = p;
       break;
     }
 }
    }
# 6570 "reload.c"
  if ((((where)->u.fld[8]).rtx) != 0 && find_reg_note (where, REG_UNUSED, value))
    return 0;



  if (valueno == 7 || regno == 7
      || (goal_mem && reg_overlap_mentioned_for_reload_p ((global_rtl[GR_STACK_POINTER]),
         goal)))
    need_stable_sp = 1;


  if (((enum machine_mode) (value)->mode) != mode)
    return 0;




  if (goal_mem && value == ((((((rtx_class[(int) (((enum rtx_code) (where)->code))]) == 'i') ? (((enum rtx_code) ((((where)->u.fld[5]).rtx))->code) == SET ? (((where)->u.fld[5]).rtx) : single_set_2 (where, (((where)->u.fld[5]).rtx))) : (rtx) 0))->u.fld[0]).rtx)
      && refers_to_regno_for_reload_p (valueno,
           (valueno
     + (((valueno) >= 8 && (valueno) <= (8 + 7)) || (((valueno) >= (20 + 1) && (valueno) <= ((20 + 1) + 7)) || ((valueno) >= (((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) && (valueno) <= ((((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) + 7))) || ((valueno) >= (((20 + 1) + 7) + 1) && (valueno) <= ((((20 + 1) + 7) + 1) + 7)) ? ((mode_class[mode] == MODE_COMPLEX_INT || mode_class[mode] == MODE_COMPLEX_FLOAT) ? 2 : 1) : ((mode) == XFmode ? (0 ? 2 : 3) : (mode) == XCmode ? (0 ? 4 : 6) : ((((unsigned short) mode_size[mode]) + (0 ? 8 : 4) - 1) / (0 ? 8 : 4))))),
           goal, (rtx*) 0))
    return 0;



  if (!goal_mem && !goal_const
      && regno + (int) (((regno) >= 8 && (regno) <= (8 + 7)) || (((regno) >= (20 + 1) && (regno) <= ((20 + 1) + 7)) || ((regno) >= (((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) && (regno) <= ((((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) + 7))) || ((regno) >= (((20 + 1) + 7) + 1) && (regno) <= ((((20 + 1) + 7) + 1) + 7)) ? ((mode_class[mode] == MODE_COMPLEX_INT || mode_class[mode] == MODE_COMPLEX_FLOAT) ? 2 : 1) : ((mode) == XFmode ? (0 ? 2 : 3) : (mode) == XCmode ? (0 ? 4 : 6) : ((((unsigned short) mode_size[mode]) + (0 ? 8 : 4) - 1) / (0 ? 8 : 4)))) > valueno
      && regno < valueno + (int) (((valueno) >= 8 && (valueno) <= (8 + 7)) || (((valueno) >= (20 + 1) && (valueno) <= ((20 + 1) + 7)) || ((valueno) >= (((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) && (valueno) <= ((((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) + 7))) || ((valueno) >= (((20 + 1) + 7) + 1) && (valueno) <= ((((20 + 1) + 7) + 1) + 7)) ? ((mode_class[mode] == MODE_COMPLEX_INT || mode_class[mode] == MODE_COMPLEX_FLOAT) ? 2 : 1) : ((mode) == XFmode ? (0 ? 2 : 3) : (mode) == XCmode ? (0 ? 4 : 6) : ((((unsigned short) mode_size[mode]) + (0 ? 8 : 4) - 1) / (0 ? 8 : 4)))))
    return 0;

  nregs = (((regno) >= 8 && (regno) <= (8 + 7)) || (((regno) >= (20 + 1) && (regno) <= ((20 + 1) + 7)) || ((regno) >= (((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) && (regno) <= ((((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) + 7))) || ((regno) >= (((20 + 1) + 7) + 1) && (regno) <= ((((20 + 1) + 7) + 1) + 7)) ? ((mode_class[mode] == MODE_COMPLEX_INT || mode_class[mode] == MODE_COMPLEX_FLOAT) ? 2 : 1) : ((mode) == XFmode ? (0 ? 2 : 3) : (mode) == XCmode ? (0 ? 4 : 6) : ((((unsigned short) mode_size[mode]) + (0 ? 8 : 4) - 1) / (0 ? 8 : 4))));
  valuenregs = (((valueno) >= 8 && (valueno) <= (8 + 7)) || (((valueno) >= (20 + 1) && (valueno) <= ((20 + 1) + 7)) || ((valueno) >= (((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) && (valueno) <= ((((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) + 7))) || ((valueno) >= (((20 + 1) + 7) + 1) && (valueno) <= ((((20 + 1) + 7) + 1) + 7)) ? ((mode_class[mode] == MODE_COMPLEX_INT || mode_class[mode] == MODE_COMPLEX_FLOAT) ? 2 : 1) : ((mode) == XFmode ? (0 ? 2 : 3) : (mode) == XCmode ? (0 ? 4 : 6) : ((((unsigned short) mode_size[mode]) + (0 ? 8 : 4) - 1) / (0 ? 8 : 4))));







  if (reload_reg_p != 0 && reload_reg_p != (short *) (long) 1)
    {
      int i;
      for (i = 0; i < valuenregs; ++i)
 if (reload_reg_p[valueno + i] >= 0)
   return 0;
    }




  if (reload_reg_p != 0)
    {
      int i;
      for (i = 0; i < n_reloads; i++)
 if (rld[i].reg_rtx != 0 && rld[i].in)
   {
     int regno1 = (((rld[i].reg_rtx)->u.fld[0]).rtuint);
     int nregs1 = (((regno1) >= 8 && (regno1) <= (8 + 7)) || (((regno1) >= (20 + 1) && (regno1) <= ((20 + 1) + 7)) || ((regno1) >= (((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) && (regno1) <= ((((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) + 7))) || ((regno1) >= (((20 + 1) + 7) + 1) && (regno1) <= ((((20 + 1) + 7) + 1) + 7)) ? ((mode_class[((enum machine_mode) (rld[i].reg_rtx)->mode)] == MODE_COMPLEX_INT || mode_class[((enum machine_mode) (rld[i].reg_rtx)->mode)] == MODE_COMPLEX_FLOAT) ? 2 : 1) : ((((enum machine_mode) (rld[i].reg_rtx)->mode)) == XFmode ? (0 ? 2 : 3) : (((enum machine_mode) (rld[i].reg_rtx)->mode)) == XCmode ? (0 ? 4 : 6) : ((((unsigned short) mode_size[((enum machine_mode) (rld[i].reg_rtx)->mode)]) + (0 ? 8 : 4) - 1) / (0 ? 8 : 4))));

     if (regno1 < valueno + valuenregs
  && regno1 + nregs1 > valueno)
       return 0;
   }
    }

  if (goal_mem)


    goal_mem_addr_varies = !constant_address_p ((((goal)->u.fld[0]).rtx));




  p = insn;
  while (1)
    {
      p = (((p)->u.fld[1]).rtx);
      if (p == where)
 return value;



      if (((enum rtx_code) (p)->code) == CALL_INSN)
 {
   int i;

   if (goal_mem || need_stable_sp)
     return 0;

   if (regno >= 0 && regno < 53)
     for (i = 0; i < nregs; ++i)
       if (call_used_regs[regno + i])
  return 0;

   if (valueno >= 0 && valueno < 53)
     for (i = 0; i < valuenregs; ++i)
       if (call_used_regs[valueno + i])
  return 0;




 }

      if (((rtx_class[(int) (((enum rtx_code) (p)->code))]) == 'i'))
 {
   pat = (((p)->u.fld[5]).rtx);


   if (volatile_insn_p (pat))
     return 0;






   if (((enum rtx_code) (pat)->code) == COND_EXEC)
     pat = (((pat)->u.fld[1]).rtx);
   if (((enum rtx_code) (pat)->code) == SET || ((enum rtx_code) (pat)->code) == CLOBBER)
     {
       rtx dest = (((pat)->u.fld[0]).rtx);
       while (((enum rtx_code) (dest)->code) == SUBREG
       || ((enum rtx_code) (dest)->code) == ZERO_EXTRACT
       || ((enum rtx_code) (dest)->code) == SIGN_EXTRACT
       || ((enum rtx_code) (dest)->code) == STRICT_LOW_PART)
  dest = (((dest)->u.fld[0]).rtx);
       if (((enum rtx_code) (dest)->code) == REG)
  {
    int xregno = (((dest)->u.fld[0]).rtuint);
    int xnregs;
    if ((((dest)->u.fld[0]).rtuint) < 53)
      xnregs = (((xregno) >= 8 && (xregno) <= (8 + 7)) || (((xregno) >= (20 + 1) && (xregno) <= ((20 + 1) + 7)) || ((xregno) >= (((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) && (xregno) <= ((((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) + 7))) || ((xregno) >= (((20 + 1) + 7) + 1) && (xregno) <= ((((20 + 1) + 7) + 1) + 7)) ? ((mode_class[((enum machine_mode) (dest)->mode)] == MODE_COMPLEX_INT || mode_class[((enum machine_mode) (dest)->mode)] == MODE_COMPLEX_FLOAT) ? 2 : 1) : ((((enum machine_mode) (dest)->mode)) == XFmode ? (0 ? 2 : 3) : (((enum machine_mode) (dest)->mode)) == XCmode ? (0 ? 4 : 6) : ((((unsigned short) mode_size[((enum machine_mode) (dest)->mode)]) + (0 ? 8 : 4) - 1) / (0 ? 8 : 4))));
    else
      xnregs = 1;
    if (xregno < regno + nregs && xregno + xnregs > regno)
      return 0;
    if (xregno < valueno + valuenregs
        && xregno + xnregs > valueno)
      return 0;
    if (goal_mem_addr_varies
        && reg_overlap_mentioned_for_reload_p (dest, goal))
      return 0;
    if (xregno == 7 && need_stable_sp)
      return 0;
  }
       else if (goal_mem && ((enum rtx_code) (dest)->code) == MEM
         && ! push_operand (dest, ((enum machine_mode) (dest)->mode)))
  return 0;
       else if (((enum rtx_code) (dest)->code) == MEM && regno >= 53
         && reg_equiv_memory_loc[regno] != 0)
  return 0;
       else if (need_stable_sp && push_operand (dest, ((enum machine_mode) (dest)->mode)))
  return 0;
     }
   else if (((enum rtx_code) (pat)->code) == PARALLEL)
     {
       int i;
       for (i = (((((pat)->u.fld[0]).rtvec))->num_elem) - 1; i >= 0; i--)
  {
    rtx v1 = (((((pat)->u.fld[0]).rtvec))->elem[i]);
    if (((enum rtx_code) (v1)->code) == COND_EXEC)
      v1 = (((v1)->u.fld[1]).rtx);
    if (((enum rtx_code) (v1)->code) == SET || ((enum rtx_code) (v1)->code) == CLOBBER)
      {
        rtx dest = (((v1)->u.fld[0]).rtx);
        while (((enum rtx_code) (dest)->code) == SUBREG
        || ((enum rtx_code) (dest)->code) == ZERO_EXTRACT
        || ((enum rtx_code) (dest)->code) == SIGN_EXTRACT
        || ((enum rtx_code) (dest)->code) == STRICT_LOW_PART)
   dest = (((dest)->u.fld[0]).rtx);
        if (((enum rtx_code) (dest)->code) == REG)
   {
     int xregno = (((dest)->u.fld[0]).rtuint);
     int xnregs;
     if ((((dest)->u.fld[0]).rtuint) < 53)
       xnregs = (((xregno) >= 8 && (xregno) <= (8 + 7)) || (((xregno) >= (20 + 1) && (xregno) <= ((20 + 1) + 7)) || ((xregno) >= (((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) && (xregno) <= ((((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) + 7))) || ((xregno) >= (((20 + 1) + 7) + 1) && (xregno) <= ((((20 + 1) + 7) + 1) + 7)) ? ((mode_class[((enum machine_mode) (dest)->mode)] == MODE_COMPLEX_INT || mode_class[((enum machine_mode) (dest)->mode)] == MODE_COMPLEX_FLOAT) ? 2 : 1) : ((((enum machine_mode) (dest)->mode)) == XFmode ? (0 ? 2 : 3) : (((enum machine_mode) (dest)->mode)) == XCmode ? (0 ? 4 : 6) : ((((unsigned short) mode_size[((enum machine_mode) (dest)->mode)]) + (0 ? 8 : 4) - 1) / (0 ? 8 : 4))));
     else
       xnregs = 1;
     if (xregno < regno + nregs
         && xregno + xnregs > regno)
       return 0;
     if (xregno < valueno + valuenregs
         && xregno + xnregs > valueno)
       return 0;
     if (goal_mem_addr_varies
         && reg_overlap_mentioned_for_reload_p (dest,
             goal))
       return 0;
     if (xregno == 7 && need_stable_sp)
       return 0;
   }
        else if (goal_mem && ((enum rtx_code) (dest)->code) == MEM
          && ! push_operand (dest, ((enum machine_mode) (dest)->mode)))
   return 0;
        else if (((enum rtx_code) (dest)->code) == MEM && regno >= 53
          && reg_equiv_memory_loc[regno] != 0)
   return 0;
        else if (need_stable_sp
          && push_operand (dest, ((enum machine_mode) (dest)->mode)))
   return 0;
      }
  }
     }

   if (((enum rtx_code) (p)->code) == CALL_INSN && (((p)->u.fld[9]).rtx))
     {
       rtx link;

       for (link = (((p)->u.fld[9]).rtx); (((link)->u.fld[1]).rtx) != 0;
     link = (((link)->u.fld[1]).rtx))
  {
    pat = (((link)->u.fld[0]).rtx);
    if (((enum rtx_code) (pat)->code) == CLOBBER)
      {
        rtx dest = (((pat)->u.fld[0]).rtx);

        if (((enum rtx_code) (dest)->code) == REG)
   {
     int xregno = (((dest)->u.fld[0]).rtuint);
     int xnregs
       = (((xregno) >= 8 && (xregno) <= (8 + 7)) || (((xregno) >= (20 + 1) && (xregno) <= ((20 + 1) + 7)) || ((xregno) >= (((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) && (xregno) <= ((((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) + 7))) || ((xregno) >= (((20 + 1) + 7) + 1) && (xregno) <= ((((20 + 1) + 7) + 1) + 7)) ? ((mode_class[((enum machine_mode) (dest)->mode)] == MODE_COMPLEX_INT || mode_class[((enum machine_mode) (dest)->mode)] == MODE_COMPLEX_FLOAT) ? 2 : 1) : ((((enum machine_mode) (dest)->mode)) == XFmode ? (0 ? 2 : 3) : (((enum machine_mode) (dest)->mode)) == XCmode ? (0 ? 4 : 6) : ((((unsigned short) mode_size[((enum machine_mode) (dest)->mode)]) + (0 ? 8 : 4) - 1) / (0 ? 8 : 4))));

     if (xregno < regno + nregs
         && xregno + xnregs > regno)
       return 0;
     else if (xregno < valueno + valuenregs
       && xregno + xnregs > valueno)
       return 0;
     else if (goal_mem_addr_varies
       && reg_overlap_mentioned_for_reload_p (dest,
             goal))
       return 0;
   }

        else if (goal_mem && ((enum rtx_code) (dest)->code) == MEM
          && ! push_operand (dest, ((enum machine_mode) (dest)->mode)))
   return 0;
        else if (need_stable_sp
          && push_operand (dest, ((enum machine_mode) (dest)->mode)))
   return 0;
      }
  }
     }
# 6840 "reload.c"
 }
    }
}





static int
find_inc_amount (rtx x, rtx inced)
{
  enum rtx_code code = ((enum rtx_code) (x)->code);
  const char *fmt;
  int i;

  if (code == MEM)
    {
      rtx addr = (((x)->u.fld[0]).rtx);
      if ((((enum rtx_code) (addr)->code) == PRE_DEC
    || ((enum rtx_code) (addr)->code) == POST_DEC
    || ((enum rtx_code) (addr)->code) == PRE_INC
    || ((enum rtx_code) (addr)->code) == POST_INC)
   && (((addr)->u.fld[0]).rtx) == inced)
 return ((unsigned short) mode_size[((enum machine_mode) (x)->mode)]);
      else if ((((enum rtx_code) (addr)->code) == PRE_MODIFY
  || ((enum rtx_code) (addr)->code) == POST_MODIFY)
        && ((enum rtx_code) ((((addr)->u.fld[1]).rtx))->code) == PLUS
        && (((addr)->u.fld[0]).rtx) == ((((((addr)->u.fld[1]).rtx))->u.fld[0]).rtx)
        && (((addr)->u.fld[0]).rtx) == inced
        && ((enum rtx_code) (((((((addr)->u.fld[1]).rtx))->u.fld[1]).rtx))->code) == CONST_INT)
 {
   i = ((((((((addr)->u.fld[1]).rtx))->u.fld[1]).rtx))->u.hwint[0]);
   return i < 0 ? -i : i;
 }
    }

  fmt = (rtx_format[(int) (code)]);
  for (i = (rtx_length[(int) (code)]) - 1; i >= 0; i--)
    {
      if (fmt[i] == 'e')
 {
   int tem = find_inc_amount ((((x)->u.fld[i]).rtx), inced);
   if (tem != 0)
     return tem;
 }
      if (fmt[i] == 'E')
 {
   int j;
   for (j = (((((x)->u.fld[i]).rtvec))->num_elem) - 1; j >= 0; j--)
     {
       int tem = find_inc_amount ((((((x)->u.fld[i]).rtvec))->elem[j]), inced);
       if (tem != 0)
  return tem;
     }
 }
    }

  return 0;
}




int
regno_clobbered_p (unsigned int regno, rtx insn, enum machine_mode mode,
     int sets)
{
  unsigned int nregs = (((regno) >= 8 && (regno) <= (8 + 7)) || (((regno) >= (20 + 1) && (regno) <= ((20 + 1) + 7)) || ((regno) >= (((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) && (regno) <= ((((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) + 7))) || ((regno) >= (((20 + 1) + 7) + 1) && (regno) <= ((((20 + 1) + 7) + 1) + 7)) ? ((mode_class[mode] == MODE_COMPLEX_INT || mode_class[mode] == MODE_COMPLEX_FLOAT) ? 2 : 1) : ((mode) == XFmode ? (0 ? 2 : 3) : (mode) == XCmode ? (0 ? 4 : 6) : ((((unsigned short) mode_size[mode]) + (0 ? 8 : 4) - 1) / (0 ? 8 : 4))));
  unsigned int endregno = regno + nregs;

  if ((((enum rtx_code) ((((insn)->u.fld[5]).rtx))->code) == CLOBBER
       || (sets && ((enum rtx_code) ((((insn)->u.fld[5]).rtx))->code) == SET))
      && ((enum rtx_code) (((((((insn)->u.fld[5]).rtx))->u.fld[0]).rtx))->code) == REG)
    {
      unsigned int test = (((((((((insn)->u.fld[5]).rtx))->u.fld[0]).rtx))->u.fld[0]).rtuint);

      return test >= regno && test < endregno;
    }

  if (((enum rtx_code) ((((insn)->u.fld[5]).rtx))->code) == PARALLEL)
    {
      int i = ((((((((insn)->u.fld[5]).rtx))->u.fld[0]).rtvec))->num_elem) - 1;

      for (; i >= 0; i--)
 {
   rtx elt = ((((((((insn)->u.fld[5]).rtx))->u.fld[0]).rtvec))->elem[i]);
   if ((((enum rtx_code) (elt)->code) == CLOBBER
        || (sets && ((enum rtx_code) ((((insn)->u.fld[5]).rtx))->code) == SET))
       && ((enum rtx_code) ((((elt)->u.fld[0]).rtx))->code) == REG)
     {
       unsigned int test = ((((((elt)->u.fld[0]).rtx))->u.fld[0]).rtuint);

       if (test >= regno && test < endregno)
  return 1;
     }
 }
    }

  return 0;
}


rtx
reload_adjust_reg_for_mode (rtx reloadreg, enum machine_mode mode)
{
  int regno;

  if (((enum machine_mode) (reloadreg)->mode) == mode)
    return reloadreg;

  regno = (((reloadreg)->u.fld[0]).rtuint);

  if (0)
    regno += (((regno) >= 8 && (regno) <= (8 + 7)) || (((regno) >= (20 + 1) && (regno) <= ((20 + 1) + 7)) || ((regno) >= (((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) && (regno) <= ((((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) + 7))) || ((regno) >= (((20 + 1) + 7) + 1) && (regno) <= ((((20 + 1) + 7) + 1) + 7)) ? ((mode_class[((enum machine_mode) (reloadreg)->mode)] == MODE_COMPLEX_INT || mode_class[((enum machine_mode) (reloadreg)->mode)] == MODE_COMPLEX_FLOAT) ? 2 : 1) : ((((enum machine_mode) (reloadreg)->mode)) == XFmode ? (0 ? 2 : 3) : (((enum machine_mode) (reloadreg)->mode)) == XCmode ? (0 ? 4 : 6) : ((((unsigned short) mode_size[((enum machine_mode) (reloadreg)->mode)]) + (0 ? 8 : 4) - 1) / (0 ? 8 : 4))))
      - (((regno) >= 8 && (regno) <= (8 + 7)) || (((regno) >= (20 + 1) && (regno) <= ((20 + 1) + 7)) || ((regno) >= (((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) && (regno) <= ((((((((20 + 1) + 7) + 1) + 7) + 1) + 7) + 1) + 7))) || ((regno) >= (((20 + 1) + 7) + 1) && (regno) <= ((((20 + 1) + 7) + 1) + 7)) ? ((mode_class[mode] == MODE_COMPLEX_INT || mode_class[mode] == MODE_COMPLEX_FLOAT) ? 2 : 1) : ((mode) == XFmode ? (0 ? 2 : 3) : (mode) == XCmode ? (0 ? 4 : 6) : ((((unsigned short) mode_size[mode]) + (0 ? 8 : 4) - 1) / (0 ? 8 : 4))));

  return gen_rtx_REG (mode, regno);
}

static const char *const reload_when_needed_name[] =
{
  "RELOAD_FOR_INPUT",
  "RELOAD_FOR_OUTPUT",
  "RELOAD_FOR_INSN",
  "RELOAD_FOR_INPUT_ADDRESS",
  "RELOAD_FOR_INPADDR_ADDRESS",
  "RELOAD_FOR_OUTPUT_ADDRESS",
  "RELOAD_FOR_OUTADDR_ADDRESS",
  "RELOAD_FOR_OPERAND_ADDRESS",
  "RELOAD_FOR_OPADDR_ADDR",
  "RELOAD_OTHER",
  "RELOAD_FOR_OTHER_ADDRESS"
};

static const char * const reg_class_names[] = { "NO_REGS", "AREG", "DREG", "CREG", "BREG", "SIREG", "DIREG", "AD_REGS", "Q_REGS", "NON_Q_REGS", "INDEX_REGS", "LEGACY_REGS", "GENERAL_REGS", "FP_TOP_REG", "FP_SECOND_REG", "FLOAT_REGS", "SSE_REGS", "MMX_REGS", "FP_TOP_SSE_REGS", "FP_SECOND_SSE_REGS", "FLOAT_SSE_REGS", "FLOAT_INT_REGS", "INT_SSE_REGS", "FLOAT_INT_SSE_REGS", "ALL_REGS" };



void
debug_reload_to_stream (FILE *f)
{
  int r;
  const char *prefix;

  if (! f)
    f = stderr;
  for (r = 0; r < n_reloads; r++)
    {
      fprintf (f, "Reload %d: ", r);

      if (rld[r].in != 0)
 {
   fprintf (f, "reload_in (%s) = ",
     mode_name[rld[r].inmode]);
   print_inline_rtx (f, rld[r].in, 24);
   fprintf (f, "\n\t");
 }

      if (rld[r].out != 0)
 {
   fprintf (f, "reload_out (%s) = ",
     mode_name[rld[r].outmode]);
   print_inline_rtx (f, rld[r].out, 24);
   fprintf (f, "\n\t");
 }

      fprintf (f, "%s, ", reg_class_names[(int) rld[r].class]);

      fprintf (f, "%s (opnum = %d)",
        reload_when_needed_name[(int) rld[r].when_needed],
        rld[r].opnum);

      if (rld[r].optional)
 fprintf (f, ", optional");

      if (rld[r].nongroup)
 fprintf (f, ", nongroup");

      if (rld[r].inc != 0)
 fprintf (f, ", inc by %d", rld[r].inc);

      if (rld[r].nocombine)
 fprintf (f, ", can't combine");

      if (rld[r].secondary_p)
 fprintf (f, ", secondary_reload_p");

      if (rld[r].in_reg != 0)
 {
   fprintf (f, "\n\treload_in_reg: ");
   print_inline_rtx (f, rld[r].in_reg, 24);
 }

      if (rld[r].out_reg != 0)
 {
   fprintf (f, "\n\treload_out_reg: ");
   print_inline_rtx (f, rld[r].out_reg, 24);
 }

      if (rld[r].reg_rtx != 0)
 {
   fprintf (f, "\n\treload_reg_rtx: ");
   print_inline_rtx (f, rld[r].reg_rtx, 24);
 }

      prefix = "\n\t";
      if (rld[r].secondary_in_reload != -1)
 {
   fprintf (f, "%ssecondary_in_reload = %d",
     prefix, rld[r].secondary_in_reload);
   prefix = ", ";
 }

      if (rld[r].secondary_out_reload != -1)
 fprintf (f, "%ssecondary_out_reload = %d\n",
   prefix, rld[r].secondary_out_reload);

      prefix = "\n\t";
      if (rld[r].secondary_in_icode != CODE_FOR_nothing)
 {
   fprintf (f, "%ssecondary_in_icode = %s", prefix,
     insn_data[rld[r].secondary_in_icode].name);
   prefix = ", ";
 }

      if (rld[r].secondary_out_icode != CODE_FOR_nothing)
 fprintf (f, "%ssecondary_out_icode = %s", prefix,
   insn_data[rld[r].secondary_out_icode].name);

      fprintf (f, "\n");
    }
}

void
debug_reload (void)
{
  debug_reload_to_stream (stderr);
}
